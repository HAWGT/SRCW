#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: UnionRun

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Hedgehog_classes.hpp"
#include "UnionRun_structs.hpp"
#include "UnionSystem_structs.hpp"
#include "UnionSystem_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "PhysicsCore_classes.hpp"


namespace SDK
{

// Class UnionRun.AreaBoxInterface
// 0x0000 (0x0000 - 0x0000)
class IAreaBoxInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AreaBoxInterface">();
	}
	static class IAreaBoxInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAreaBoxInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAreaBoxInterface) == 0x000001, "Wrong alignment on IAreaBoxInterface");
static_assert(sizeof(IAreaBoxInterface) == 0x000001, "Wrong size on IAreaBoxInterface");

// Class UnionRun.UnionCourseObjectBase
// 0x00B0 (0x0340 - 0x0290)
class AUnionCourseObjectBase : public AActor
{
public:
	ECourseObjType                                CourseObjType;                                     // 0x0290(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VioletVoidAbsorbTargetScale;                       // 0x0298(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionSplineMoveComponent*              SplineMoveComponent;                               // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionRoundTripMoveComponent*           RoundTripMoveComponent;                            // 0x02B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0[0x10];                                     // 0x02C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsRingGateHidden;                                 // 0x02D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECourseObjColType                             ColType;                                           // 0x02D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAttachMove;                                     // 0x02D2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMove;                                           // 0x02D3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsRoundTripMove;                                  // 0x02D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D5[0x3];                                      // 0x02D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AttachOffsetLocation;                              // 0x02D8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 ParentSkeletalMeshComponent;                       // 0x02F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AttachSocketName;                                  // 0x02F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             RoundTripDataTable;                                // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EObjectPlacementType                          ObjectPlacementType;                               // 0x0310(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IgnoreGimmickCurringDataTable;                     // 0x0311(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERandomObjType                                RandomObjType;                                     // 0x0312(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_313[0x1];                                      // 0x0313(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PatternRandomId;                                   // 0x0314(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         LinkActorArray;                                    // 0x0318(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_328[0x18];                                     // 0x0328(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckIsValidParentActor();
	const EObjectPlacementType GetObjectPlacementType();
	const int32 GetPatternRandomId();
	void SetDomainIndex(EDomainIndex Index_0);
	void SetDomainNumber(EDomainNumber Number);
	void SetPatternRandomId(int32 ID);
	void SetRandomObjectType(ERandomObjType Type);

	EDomainNumber GetDomainNumber() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionCourseObjectBase">();
	}
	static class AUnionCourseObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnionCourseObjectBase>();
	}
};
static_assert(alignof(AUnionCourseObjectBase) == 0x000008, "Wrong alignment on AUnionCourseObjectBase");
static_assert(sizeof(AUnionCourseObjectBase) == 0x000340, "Wrong size on AUnionCourseObjectBase");
static_assert(offsetof(AUnionCourseObjectBase, CourseObjType) == 0x000290, "Member 'AUnionCourseObjectBase::CourseObjType' has a wrong offset!");
static_assert(offsetof(AUnionCourseObjectBase, VioletVoidAbsorbTargetScale) == 0x000298, "Member 'AUnionCourseObjectBase::VioletVoidAbsorbTargetScale' has a wrong offset!");
static_assert(offsetof(AUnionCourseObjectBase, SplineMoveComponent) == 0x0002B0, "Member 'AUnionCourseObjectBase::SplineMoveComponent' has a wrong offset!");
static_assert(offsetof(AUnionCourseObjectBase, RoundTripMoveComponent) == 0x0002B8, "Member 'AUnionCourseObjectBase::RoundTripMoveComponent' has a wrong offset!");
static_assert(offsetof(AUnionCourseObjectBase, bIsRingGateHidden) == 0x0002D0, "Member 'AUnionCourseObjectBase::bIsRingGateHidden' has a wrong offset!");
static_assert(offsetof(AUnionCourseObjectBase, ColType) == 0x0002D1, "Member 'AUnionCourseObjectBase::ColType' has a wrong offset!");
static_assert(offsetof(AUnionCourseObjectBase, bIsAttachMove) == 0x0002D2, "Member 'AUnionCourseObjectBase::bIsAttachMove' has a wrong offset!");
static_assert(offsetof(AUnionCourseObjectBase, bIsMove) == 0x0002D3, "Member 'AUnionCourseObjectBase::bIsMove' has a wrong offset!");
static_assert(offsetof(AUnionCourseObjectBase, bIsRoundTripMove) == 0x0002D4, "Member 'AUnionCourseObjectBase::bIsRoundTripMove' has a wrong offset!");
static_assert(offsetof(AUnionCourseObjectBase, AttachOffsetLocation) == 0x0002D8, "Member 'AUnionCourseObjectBase::AttachOffsetLocation' has a wrong offset!");
static_assert(offsetof(AUnionCourseObjectBase, ParentSkeletalMeshComponent) == 0x0002F0, "Member 'AUnionCourseObjectBase::ParentSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AUnionCourseObjectBase, AttachSocketName) == 0x0002F8, "Member 'AUnionCourseObjectBase::AttachSocketName' has a wrong offset!");
static_assert(offsetof(AUnionCourseObjectBase, RoundTripDataTable) == 0x000308, "Member 'AUnionCourseObjectBase::RoundTripDataTable' has a wrong offset!");
static_assert(offsetof(AUnionCourseObjectBase, ObjectPlacementType) == 0x000310, "Member 'AUnionCourseObjectBase::ObjectPlacementType' has a wrong offset!");
static_assert(offsetof(AUnionCourseObjectBase, IgnoreGimmickCurringDataTable) == 0x000311, "Member 'AUnionCourseObjectBase::IgnoreGimmickCurringDataTable' has a wrong offset!");
static_assert(offsetof(AUnionCourseObjectBase, RandomObjType) == 0x000312, "Member 'AUnionCourseObjectBase::RandomObjType' has a wrong offset!");
static_assert(offsetof(AUnionCourseObjectBase, PatternRandomId) == 0x000314, "Member 'AUnionCourseObjectBase::PatternRandomId' has a wrong offset!");
static_assert(offsetof(AUnionCourseObjectBase, LinkActorArray) == 0x000318, "Member 'AUnionCourseObjectBase::LinkActorArray' has a wrong offset!");

// Class UnionRun.UnionGimmickObjectBase
// 0x0270 (0x05B0 - 0x0340)
class AUnionGimmickObjectBase : public AUnionCourseObjectBase
{
public:
	uint8                                         Pad_340[0x220];                                    // 0x0340(0x0220)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ComAvoid;                                          // 0x0560(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_561[0x3];                                      // 0x0561(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ComAvoidWidth;                                     // 0x0564(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETimingGimmickType                            TimingGimmickType;                                 // 0x0568(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ComBeneficial;                                     // 0x0569(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_56A[0x1];                                      // 0x056A(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsVioletVoidTarget;                               // 0x056B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGimmickContactType                           GimmickContactType;                                // 0x056C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBackGroundGimmick;                              // 0x056D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_56E[0x42];                                     // 0x056E(0x0042)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionGimmickObjectBase">();
	}
	static class AUnionGimmickObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnionGimmickObjectBase>();
	}
};
static_assert(alignof(AUnionGimmickObjectBase) == 0x000008, "Wrong alignment on AUnionGimmickObjectBase");
static_assert(sizeof(AUnionGimmickObjectBase) == 0x0005B0, "Wrong size on AUnionGimmickObjectBase");
static_assert(offsetof(AUnionGimmickObjectBase, ComAvoid) == 0x000560, "Member 'AUnionGimmickObjectBase::ComAvoid' has a wrong offset!");
static_assert(offsetof(AUnionGimmickObjectBase, ComAvoidWidth) == 0x000564, "Member 'AUnionGimmickObjectBase::ComAvoidWidth' has a wrong offset!");
static_assert(offsetof(AUnionGimmickObjectBase, TimingGimmickType) == 0x000568, "Member 'AUnionGimmickObjectBase::TimingGimmickType' has a wrong offset!");
static_assert(offsetof(AUnionGimmickObjectBase, ComBeneficial) == 0x000569, "Member 'AUnionGimmickObjectBase::ComBeneficial' has a wrong offset!");
static_assert(offsetof(AUnionGimmickObjectBase, bIsVioletVoidTarget) == 0x00056B, "Member 'AUnionGimmickObjectBase::bIsVioletVoidTarget' has a wrong offset!");
static_assert(offsetof(AUnionGimmickObjectBase, GimmickContactType) == 0x00056C, "Member 'AUnionGimmickObjectBase::GimmickContactType' has a wrong offset!");
static_assert(offsetof(AUnionGimmickObjectBase, bIsBackGroundGimmick) == 0x00056D, "Member 'AUnionGimmickObjectBase::bIsBackGroundGimmick' has a wrong offset!");

// Class UnionRun.GimmickBigBakubaku
// 0x0060 (0x0610 - 0x05B0)
class alignas(0x10) AGimmickBigBakubaku final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshComponent*                         GFurComponent;                                     // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionSkeletalMeshComponent*            SkeletalMeshComponent;                             // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            ToothCenterStaticBody;                             // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            ToothLeft1StaticBody;                              // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            ToothLeft2StaticBody;                              // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            ToothRight1StaticBody;                             // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            ToothRight2StaticBody;                             // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERacerDamageType                              _DamageType;                                       // 0x05F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F1[0x7];                                      // 0x05F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          AnimSequence;                                      // 0x05F8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentDeltaTime;                                  // 0x0600(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          m_Init;                                            // 0x0604(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_605[0xB];                                      // 0x0605(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitStaticBody(const class UGimmickStaticBodyComponent* StaticBody, class FName SocketName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickBigBakubaku">();
	}
	static class AGimmickBigBakubaku* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickBigBakubaku>();
	}
};
static_assert(alignof(AGimmickBigBakubaku) == 0x000010, "Wrong alignment on AGimmickBigBakubaku");
static_assert(sizeof(AGimmickBigBakubaku) == 0x000610, "Wrong size on AGimmickBigBakubaku");
static_assert(offsetof(AGimmickBigBakubaku, GFurComponent) == 0x0005B8, "Member 'AGimmickBigBakubaku::GFurComponent' has a wrong offset!");
static_assert(offsetof(AGimmickBigBakubaku, SkeletalMeshComponent) == 0x0005C0, "Member 'AGimmickBigBakubaku::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickBigBakubaku, ToothCenterStaticBody) == 0x0005C8, "Member 'AGimmickBigBakubaku::ToothCenterStaticBody' has a wrong offset!");
static_assert(offsetof(AGimmickBigBakubaku, ToothLeft1StaticBody) == 0x0005D0, "Member 'AGimmickBigBakubaku::ToothLeft1StaticBody' has a wrong offset!");
static_assert(offsetof(AGimmickBigBakubaku, ToothLeft2StaticBody) == 0x0005D8, "Member 'AGimmickBigBakubaku::ToothLeft2StaticBody' has a wrong offset!");
static_assert(offsetof(AGimmickBigBakubaku, ToothRight1StaticBody) == 0x0005E0, "Member 'AGimmickBigBakubaku::ToothRight1StaticBody' has a wrong offset!");
static_assert(offsetof(AGimmickBigBakubaku, ToothRight2StaticBody) == 0x0005E8, "Member 'AGimmickBigBakubaku::ToothRight2StaticBody' has a wrong offset!");
static_assert(offsetof(AGimmickBigBakubaku, _DamageType) == 0x0005F0, "Member 'AGimmickBigBakubaku::_DamageType' has a wrong offset!");
static_assert(offsetof(AGimmickBigBakubaku, AnimSequence) == 0x0005F8, "Member 'AGimmickBigBakubaku::AnimSequence' has a wrong offset!");
static_assert(offsetof(AGimmickBigBakubaku, CurrentDeltaTime) == 0x000600, "Member 'AGimmickBigBakubaku::CurrentDeltaTime' has a wrong offset!");
static_assert(offsetof(AGimmickBigBakubaku, m_Init) == 0x000604, "Member 'AGimmickBigBakubaku::m_Init' has a wrong offset!");

// Class UnionRun.AreaCollisionInterface
// 0x0000 (0x0000 - 0x0000)
class IAreaCollisionInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AreaCollisionInterface">();
	}
	static class IAreaCollisionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAreaCollisionInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAreaCollisionInterface) == 0x000001, "Wrong alignment on IAreaCollisionInterface");
static_assert(sizeof(IAreaCollisionInterface) == 0x000001, "Wrong size on IAreaCollisionInterface");

// Class UnionRun.AreaDataDividedCourseCollisions
// 0x0108 (0x0130 - 0x0028)
class UAreaDataDividedCourseCollisions final : public UObject
{
public:
	uint8                                         Pad_28[0x68];                                      // 0x0028(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAreaDataCourseColSettings             Settings;                                          // 0x0090(0x0050)(NativeAccessSpecifierPublic)
	struct FAreaDataCourseColContents             Contents;                                          // 0x00E0(0x0050)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AreaDataDividedCourseCollisions">();
	}
	static class UAreaDataDividedCourseCollisions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAreaDataDividedCourseCollisions>();
	}
};
static_assert(alignof(UAreaDataDividedCourseCollisions) == 0x000008, "Wrong alignment on UAreaDataDividedCourseCollisions");
static_assert(sizeof(UAreaDataDividedCourseCollisions) == 0x000130, "Wrong size on UAreaDataDividedCourseCollisions");
static_assert(offsetof(UAreaDataDividedCourseCollisions, Settings) == 0x000090, "Member 'UAreaDataDividedCourseCollisions::Settings' has a wrong offset!");
static_assert(offsetof(UAreaDataDividedCourseCollisions, Contents) == 0x0000E0, "Member 'UAreaDataDividedCourseCollisions::Contents' has a wrong offset!");

// Class UnionRun.EnemyAnimInstance
// 0x0000 (0x0370 - 0x0370)
#pragma pack(push, 0x1)
class alignas(0x10) UEnemyAnimInstance : public UAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyAnimInstance">();
	}
	static class UEnemyAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UEnemyAnimInstance) == 0x000010, "Wrong alignment on UEnemyAnimInstance");
static_assert(sizeof(UEnemyAnimInstance) == 0x000370, "Wrong size on UEnemyAnimInstance");

// Class UnionRun.IntervalVATObject
// 0x0020 (0x02B0 - 0x0290)
class AIntervalVATObject : public AActor
{
public:
	class UUnionVATMeshComponent*                 VATMeshComponent;                                  // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IntervalTime;                                      // 0x0298(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StartTime;                                         // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EventTime;                                         // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A4[0xC];                                      // 0x02A4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IntervalVATObject">();
	}
	static class AIntervalVATObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIntervalVATObject>();
	}
};
static_assert(alignof(AIntervalVATObject) == 0x000008, "Wrong alignment on AIntervalVATObject");
static_assert(sizeof(AIntervalVATObject) == 0x0002B0, "Wrong size on AIntervalVATObject");
static_assert(offsetof(AIntervalVATObject, VATMeshComponent) == 0x000290, "Member 'AIntervalVATObject::VATMeshComponent' has a wrong offset!");
static_assert(offsetof(AIntervalVATObject, IntervalTime) == 0x000298, "Member 'AIntervalVATObject::IntervalTime' has a wrong offset!");
static_assert(offsetof(AIntervalVATObject, StartTime) == 0x00029C, "Member 'AIntervalVATObject::StartTime' has a wrong offset!");
static_assert(offsetof(AIntervalVATObject, EventTime) == 0x0002A0, "Member 'AIntervalVATObject::EventTime' has a wrong offset!");

// Class UnionRun.GimmickMechaFish
// 0x0020 (0x02D0 - 0x02B0)
class AGimmickMechaFish final : public AIntervalVATObject
{
public:
	class UNiagaraComponent*                      JumpStartEffect;                                   // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      JumpEndEffect;                                     // 0x02B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionAtomComponent*                    JumpStartSound;                                    // 0x02C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionAtomComponent*                    JumpEndSound;                                      // 0x02C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickMechaFish">();
	}
	static class AGimmickMechaFish* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickMechaFish>();
	}
};
static_assert(alignof(AGimmickMechaFish) == 0x000008, "Wrong alignment on AGimmickMechaFish");
static_assert(sizeof(AGimmickMechaFish) == 0x0002D0, "Wrong size on AGimmickMechaFish");
static_assert(offsetof(AGimmickMechaFish, JumpStartEffect) == 0x0002B0, "Member 'AGimmickMechaFish::JumpStartEffect' has a wrong offset!");
static_assert(offsetof(AGimmickMechaFish, JumpEndEffect) == 0x0002B8, "Member 'AGimmickMechaFish::JumpEndEffect' has a wrong offset!");
static_assert(offsetof(AGimmickMechaFish, JumpStartSound) == 0x0002C0, "Member 'AGimmickMechaFish::JumpStartSound' has a wrong offset!");
static_assert(offsetof(AGimmickMechaFish, JumpEndSound) == 0x0002C8, "Member 'AGimmickMechaFish::JumpEndSound' has a wrong offset!");

// Class UnionRun.AsuraAnimInstance
// 0x0000 (0x0370 - 0x0370)
class UAsuraAnimInstance final : public UEnemyAnimInstance
{
public:
	void SetAsuraState(EAsuraState State);

	bool IsAsuraState(EAsuraState State) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsuraAnimInstance">();
	}
	static class UAsuraAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsuraAnimInstance>();
	}
};
static_assert(alignof(UAsuraAnimInstance) == 0x000010, "Wrong alignment on UAsuraAnimInstance");
static_assert(sizeof(UAsuraAnimInstance) == 0x000370, "Wrong size on UAsuraAnimInstance");

// Class UnionRun.RaceLogUtil
// 0x0000 (0x0028 - 0x0028)
class URaceLogUtil final : public UBlueprintFunctionLibrary
{
public:
	static class FString GetRacerLapInfo(int32 RacerIndex);
	static class FString GetRacerStatusInfo(int32 RacerIndex);
	static void PrintRaceLog(int32 RacerIndex, const class FString& str, const class FString& at);
	static void PrintRunLog(int32 RacerIndex, const class FString& str, const class FString& at);
	static void PrintWarpLog(int32 RacerIndex, const class FString& str, const class FString& at);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceLogUtil">();
	}
	static class URaceLogUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceLogUtil>();
	}
};
static_assert(alignof(URaceLogUtil) == 0x000008, "Wrong alignment on URaceLogUtil");
static_assert(sizeof(URaceLogUtil) == 0x000028, "Wrong size on URaceLogUtil");

// Class UnionRun.AttackReplyInterface
// 0x0000 (0x0000 - 0x0000)
class IAttackReplyInterface final
{
public:
	void NotifyAttackFailed(const struct FAttackReply& Info);
	void NotifyAttackFinishOverwritten(const struct FAttackReply& Info);
	void NotifyAttackFinishSucceed(const struct FAttackReply& Info);
	void NotifyAttackMissingShot(const struct FAttackReply& Info);
	void NotifyAttackPauseEnd(const struct FAttackReply& Info);
	void NotifyAttackPauseStart(const struct FAttackReply& Info);
	void NotifyAttackSucced(const struct FAttackReply& Info);
	void NotifyAttackTimeElapsed(const struct FAttackReply& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttackReplyInterface">();
	}
	static class IAttackReplyInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAttackReplyInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAttackReplyInterface) == 0x000001, "Wrong alignment on IAttackReplyInterface");
static_assert(sizeof(IAttackReplyInterface) == 0x000001, "Wrong size on IAttackReplyInterface");

// Class UnionRun.UnionCameraBase
// 0x0048 (0x02D8 - 0x0290)
class AUnionCameraBase : public AActor
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Root;                                              // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       Camera;                                            // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoStart;                                        // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRacerCameraDomainNumber;                       // 0x02A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRacerCameraFOV;                                // 0x02AA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUnionCameraPriority                          Priority;                                          // 0x02AB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FViewTargetTransitionParams            StartBlendSetting;                                 // 0x02AC(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FViewTargetTransitionParams            EndBlendSetting;                                   // 0x02BC(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         RacerIndex;                                        // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDomainNumber                                 DomainNumber;                                      // 0x02D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D1[0x7];                                      // 0x02D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsCurrentViewTarget();
	bool IsInBlending();
	bool RequestEndCamera();
	bool RequestStartCamera();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionCameraBase">();
	}
	static class AUnionCameraBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnionCameraBase>();
	}
};
static_assert(alignof(AUnionCameraBase) == 0x000008, "Wrong alignment on AUnionCameraBase");
static_assert(sizeof(AUnionCameraBase) == 0x0002D8, "Wrong size on AUnionCameraBase");
static_assert(offsetof(AUnionCameraBase, Root) == 0x000298, "Member 'AUnionCameraBase::Root' has a wrong offset!");
static_assert(offsetof(AUnionCameraBase, Camera) == 0x0002A0, "Member 'AUnionCameraBase::Camera' has a wrong offset!");
static_assert(offsetof(AUnionCameraBase, bAutoStart) == 0x0002A8, "Member 'AUnionCameraBase::bAutoStart' has a wrong offset!");
static_assert(offsetof(AUnionCameraBase, bUseRacerCameraDomainNumber) == 0x0002A9, "Member 'AUnionCameraBase::bUseRacerCameraDomainNumber' has a wrong offset!");
static_assert(offsetof(AUnionCameraBase, bUseRacerCameraFOV) == 0x0002AA, "Member 'AUnionCameraBase::bUseRacerCameraFOV' has a wrong offset!");
static_assert(offsetof(AUnionCameraBase, Priority) == 0x0002AB, "Member 'AUnionCameraBase::Priority' has a wrong offset!");
static_assert(offsetof(AUnionCameraBase, StartBlendSetting) == 0x0002AC, "Member 'AUnionCameraBase::StartBlendSetting' has a wrong offset!");
static_assert(offsetof(AUnionCameraBase, EndBlendSetting) == 0x0002BC, "Member 'AUnionCameraBase::EndBlendSetting' has a wrong offset!");
static_assert(offsetof(AUnionCameraBase, RacerIndex) == 0x0002CC, "Member 'AUnionCameraBase::RacerIndex' has a wrong offset!");
static_assert(offsetof(AUnionCameraBase, DomainNumber) == 0x0002D0, "Member 'AUnionCameraBase::DomainNumber' has a wrong offset!");

// Class UnionRun.ReplayFixedCameraFocus
// 0x0050 (0x0328 - 0x02D8)
class AReplayFixedCameraFocus final : public AUnionCameraBase
{
public:
	class USceneComponent*                        CameraRoot;                                        // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        FocusTarget;                                       // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 FocusTargetActor;                                  // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFovBlend;                                      // 0x02F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F1[0x3];                                      // 0x02F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartFovBlend;                                     // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndFovBlend;                                       // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpTime;                                        // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   EasingFunc;                                        // 0x0300(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_301[0x3];                                      // 0x0301(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterpExp;                                         // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetOffset;                                      // 0x0308(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_320[0x8];                                      // 0x0320(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplayFixedCameraFocus">();
	}
	static class AReplayFixedCameraFocus* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReplayFixedCameraFocus>();
	}
};
static_assert(alignof(AReplayFixedCameraFocus) == 0x000008, "Wrong alignment on AReplayFixedCameraFocus");
static_assert(sizeof(AReplayFixedCameraFocus) == 0x000328, "Wrong size on AReplayFixedCameraFocus");
static_assert(offsetof(AReplayFixedCameraFocus, CameraRoot) == 0x0002D8, "Member 'AReplayFixedCameraFocus::CameraRoot' has a wrong offset!");
static_assert(offsetof(AReplayFixedCameraFocus, FocusTarget) == 0x0002E0, "Member 'AReplayFixedCameraFocus::FocusTarget' has a wrong offset!");
static_assert(offsetof(AReplayFixedCameraFocus, FocusTargetActor) == 0x0002E8, "Member 'AReplayFixedCameraFocus::FocusTargetActor' has a wrong offset!");
static_assert(offsetof(AReplayFixedCameraFocus, bUseFovBlend) == 0x0002F0, "Member 'AReplayFixedCameraFocus::bUseFovBlend' has a wrong offset!");
static_assert(offsetof(AReplayFixedCameraFocus, StartFovBlend) == 0x0002F4, "Member 'AReplayFixedCameraFocus::StartFovBlend' has a wrong offset!");
static_assert(offsetof(AReplayFixedCameraFocus, EndFovBlend) == 0x0002F8, "Member 'AReplayFixedCameraFocus::EndFovBlend' has a wrong offset!");
static_assert(offsetof(AReplayFixedCameraFocus, InterpTime) == 0x0002FC, "Member 'AReplayFixedCameraFocus::InterpTime' has a wrong offset!");
static_assert(offsetof(AReplayFixedCameraFocus, EasingFunc) == 0x000300, "Member 'AReplayFixedCameraFocus::EasingFunc' has a wrong offset!");
static_assert(offsetof(AReplayFixedCameraFocus, InterpExp) == 0x000304, "Member 'AReplayFixedCameraFocus::InterpExp' has a wrong offset!");
static_assert(offsetof(AReplayFixedCameraFocus, TargetOffset) == 0x000308, "Member 'AReplayFixedCameraFocus::TargetOffset' has a wrong offset!");

// Class UnionRun.BoostPadObject
// 0x01D0 (0x0780 - 0x05B0)
class alignas(0x10) ABoostPadObject final : public AUnionGimmickObjectBase
{
public:
	class UUnionVATMeshComponent*                 VATMeshComponent;                                  // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticBodyComponent*                   StaticBodyComponent;                               // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoostPadType                                 BoostPadType;                                      // 0x05C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C1[0x3];                                      // 0x05C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BoostGateRadius;                                   // 0x05C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInIrregular;                                      // 0x05C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C9[0x7];                                      // 0x05C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            BoostPadMeshByType[0xA];                           // 0x05D0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            SpecialBoostPadMeshByType[0xA];                    // 0x0620(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         PassThroughFX;                                     // 0x0670(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CollisionExtentsByType[0xA];                       // 0x0678(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpecificId;                                        // 0x0768(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHiddenMesh;                                     // 0x076C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_76D[0x3];                                      // 0x076D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0770(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_778[0x3];                                      // 0x0778(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          m_bIsSpecial;                                      // 0x077B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESpecialObjGroup                              m_SpecialGroup;                                    // 0x077C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_77D[0x3];                                      // 0x077D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnVATUpdate(class UUnionVATMeshComponent* VATComponent, const struct FUnionVATSequenceInfo& SequenceInfo);
	void SetBoostPadType(EBoostPadType Type, bool IsSpecial);
	void SetGateScaleRate(float Rate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoostPadObject">();
	}
	static class ABoostPadObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABoostPadObject>();
	}
};
static_assert(alignof(ABoostPadObject) == 0x000010, "Wrong alignment on ABoostPadObject");
static_assert(sizeof(ABoostPadObject) == 0x000780, "Wrong size on ABoostPadObject");
static_assert(offsetof(ABoostPadObject, VATMeshComponent) == 0x0005B0, "Member 'ABoostPadObject::VATMeshComponent' has a wrong offset!");
static_assert(offsetof(ABoostPadObject, StaticBodyComponent) == 0x0005B8, "Member 'ABoostPadObject::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(ABoostPadObject, BoostPadType) == 0x0005C0, "Member 'ABoostPadObject::BoostPadType' has a wrong offset!");
static_assert(offsetof(ABoostPadObject, BoostGateRadius) == 0x0005C4, "Member 'ABoostPadObject::BoostGateRadius' has a wrong offset!");
static_assert(offsetof(ABoostPadObject, bInIrregular) == 0x0005C8, "Member 'ABoostPadObject::bInIrregular' has a wrong offset!");
static_assert(offsetof(ABoostPadObject, BoostPadMeshByType) == 0x0005D0, "Member 'ABoostPadObject::BoostPadMeshByType' has a wrong offset!");
static_assert(offsetof(ABoostPadObject, SpecialBoostPadMeshByType) == 0x000620, "Member 'ABoostPadObject::SpecialBoostPadMeshByType' has a wrong offset!");
static_assert(offsetof(ABoostPadObject, PassThroughFX) == 0x000670, "Member 'ABoostPadObject::PassThroughFX' has a wrong offset!");
static_assert(offsetof(ABoostPadObject, CollisionExtentsByType) == 0x000678, "Member 'ABoostPadObject::CollisionExtentsByType' has a wrong offset!");
static_assert(offsetof(ABoostPadObject, SpecificId) == 0x000768, "Member 'ABoostPadObject::SpecificId' has a wrong offset!");
static_assert(offsetof(ABoostPadObject, bIsHiddenMesh) == 0x00076C, "Member 'ABoostPadObject::bIsHiddenMesh' has a wrong offset!");
static_assert(offsetof(ABoostPadObject, DefaultSceneRoot) == 0x000770, "Member 'ABoostPadObject::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(ABoostPadObject, m_bIsSpecial) == 0x00077B, "Member 'ABoostPadObject::m_bIsSpecial' has a wrong offset!");
static_assert(offsetof(ABoostPadObject, m_SpecialGroup) == 0x00077C, "Member 'ABoostPadObject::m_SpecialGroup' has a wrong offset!");

// Class UnionRun.BounceCollision
// 0x0040 (0x05F0 - 0x05B0)
class alignas(0x10) ABounceCollision final : public AUnionGimmickObjectBase
{
public:
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            StaticBodyComponent;                               // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EStaticBodyShapeType                          ShapeType;                                         // 0x05C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C1[0x7];                                      // 0x05C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CollisionSize;                                     // 0x05C8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Radius;                                            // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Height;                                            // 0x05E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ParamId;                                           // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAirImpact;                                        // 0x05EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EUnionSurfaceType                             SurfaceType;                                       // 0x05ED(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5EE[0x2];                                      // 0x05EE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BounceCollision">();
	}
	static class ABounceCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABounceCollision>();
	}
};
static_assert(alignof(ABounceCollision) == 0x000010, "Wrong alignment on ABounceCollision");
static_assert(sizeof(ABounceCollision) == 0x0005F0, "Wrong size on ABounceCollision");
static_assert(offsetof(ABounceCollision, DefaultSceneRoot) == 0x0005B0, "Member 'ABounceCollision::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(ABounceCollision, StaticBodyComponent) == 0x0005B8, "Member 'ABounceCollision::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(ABounceCollision, ShapeType) == 0x0005C0, "Member 'ABounceCollision::ShapeType' has a wrong offset!");
static_assert(offsetof(ABounceCollision, CollisionSize) == 0x0005C8, "Member 'ABounceCollision::CollisionSize' has a wrong offset!");
static_assert(offsetof(ABounceCollision, Radius) == 0x0005E0, "Member 'ABounceCollision::Radius' has a wrong offset!");
static_assert(offsetof(ABounceCollision, Height) == 0x0005E4, "Member 'ABounceCollision::Height' has a wrong offset!");
static_assert(offsetof(ABounceCollision, ParamId) == 0x0005E8, "Member 'ABounceCollision::ParamId' has a wrong offset!");
static_assert(offsetof(ABounceCollision, bAirImpact) == 0x0005EC, "Member 'ABounceCollision::bAirImpact' has a wrong offset!");
static_assert(offsetof(ABounceCollision, SurfaceType) == 0x0005ED, "Member 'ABounceCollision::SurfaceType' has a wrong offset!");

// Class UnionRun.GimmickOnlyOwnerSeeBase
// 0x0030 (0x05E0 - 0x05B0)
class alignas(0x10) AGimmickOnlyOwnerSeeBase : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGimmickOnlyOwnerSeeBase*>       CloneObjects;                                      // 0x05B8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C8[0x8];                                      // 0x05C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D8[0x8];                                      // 0x05D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickOnlyOwnerSeeBase">();
	}
	static class AGimmickOnlyOwnerSeeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickOnlyOwnerSeeBase>();
	}
};
static_assert(alignof(AGimmickOnlyOwnerSeeBase) == 0x000010, "Wrong alignment on AGimmickOnlyOwnerSeeBase");
static_assert(sizeof(AGimmickOnlyOwnerSeeBase) == 0x0005E0, "Wrong size on AGimmickOnlyOwnerSeeBase");
static_assert(offsetof(AGimmickOnlyOwnerSeeBase, CloneObjects) == 0x0005B8, "Member 'AGimmickOnlyOwnerSeeBase::CloneObjects' has a wrong offset!");
static_assert(offsetof(AGimmickOnlyOwnerSeeBase, DefaultSceneRoot) == 0x0005D0, "Member 'AGimmickOnlyOwnerSeeBase::DefaultSceneRoot' has a wrong offset!");

// Class UnionRun.RedStarRingObject
// 0x0090 (0x0670 - 0x05E0)
class ARedStarRingObject final : public AGimmickOnlyOwnerSeeBase
{
public:
	class UUnionStaticMeshComponent*              StaticMeshComponent;                               // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticBodyComponent*                   StaticBodyComponent;                               // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USuckedMovement*                        SuckedMovement;                                    // 0x05F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         RedStarRingIndex;                                  // 0x05F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5FC[0x4];                                      // 0x05FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstance*                      NormalMaterial;                                    // 0x0600(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstance*                      PickUpMaterial;                                    // 0x0608(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_610[0x60];                                     // 0x0610(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RedStarRingObject">();
	}
	static class ARedStarRingObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARedStarRingObject>();
	}
};
static_assert(alignof(ARedStarRingObject) == 0x000010, "Wrong alignment on ARedStarRingObject");
static_assert(sizeof(ARedStarRingObject) == 0x000670, "Wrong size on ARedStarRingObject");
static_assert(offsetof(ARedStarRingObject, StaticMeshComponent) == 0x0005E0, "Member 'ARedStarRingObject::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(ARedStarRingObject, StaticBodyComponent) == 0x0005E8, "Member 'ARedStarRingObject::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(ARedStarRingObject, SuckedMovement) == 0x0005F0, "Member 'ARedStarRingObject::SuckedMovement' has a wrong offset!");
static_assert(offsetof(ARedStarRingObject, RedStarRingIndex) == 0x0005F8, "Member 'ARedStarRingObject::RedStarRingIndex' has a wrong offset!");
static_assert(offsetof(ARedStarRingObject, NormalMaterial) == 0x000600, "Member 'ARedStarRingObject::NormalMaterial' has a wrong offset!");
static_assert(offsetof(ARedStarRingObject, PickUpMaterial) == 0x000608, "Member 'ARedStarRingObject::PickUpMaterial' has a wrong offset!");

// Class UnionRun.BounceMoveObject
// 0x0040 (0x05F0 - 0x05B0)
class alignas(0x10) ABounceMoveObject final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionBounceMoveComponent*              BounceComponent;                                   // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            Body;                                              // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    LoopSound;                                         // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    BounceSound;                                       // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopEffect;                                        // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AllowBounce;                                       // 0x05E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERacerDamageType                              DamageType;                                        // 0x05E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopLoopSoundOnBounce;                             // 0x05E2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopLoopEffectOnBounce;                            // 0x05E3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E4[0x4];                                      // 0x05E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnFinishedBounce();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BounceMoveObject">();
	}
	static class ABounceMoveObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABounceMoveObject>();
	}
};
static_assert(alignof(ABounceMoveObject) == 0x000010, "Wrong alignment on ABounceMoveObject");
static_assert(sizeof(ABounceMoveObject) == 0x0005F0, "Wrong size on ABounceMoveObject");
static_assert(offsetof(ABounceMoveObject, BounceComponent) == 0x0005B8, "Member 'ABounceMoveObject::BounceComponent' has a wrong offset!");
static_assert(offsetof(ABounceMoveObject, Body) == 0x0005C0, "Member 'ABounceMoveObject::Body' has a wrong offset!");
static_assert(offsetof(ABounceMoveObject, LoopSound) == 0x0005C8, "Member 'ABounceMoveObject::LoopSound' has a wrong offset!");
static_assert(offsetof(ABounceMoveObject, BounceSound) == 0x0005D0, "Member 'ABounceMoveObject::BounceSound' has a wrong offset!");
static_assert(offsetof(ABounceMoveObject, LoopEffect) == 0x0005D8, "Member 'ABounceMoveObject::LoopEffect' has a wrong offset!");
static_assert(offsetof(ABounceMoveObject, AllowBounce) == 0x0005E0, "Member 'ABounceMoveObject::AllowBounce' has a wrong offset!");
static_assert(offsetof(ABounceMoveObject, DamageType) == 0x0005E1, "Member 'ABounceMoveObject::DamageType' has a wrong offset!");
static_assert(offsetof(ABounceMoveObject, StopLoopSoundOnBounce) == 0x0005E2, "Member 'ABounceMoveObject::StopLoopSoundOnBounce' has a wrong offset!");
static_assert(offsetof(ABounceMoveObject, StopLoopEffectOnBounce) == 0x0005E3, "Member 'ABounceMoveObject::StopLoopEffectOnBounce' has a wrong offset!");
static_assert(offsetof(ABounceMoveObject, DefaultSceneRoot) == 0x0005E8, "Member 'ABounceMoveObject::DefaultSceneRoot' has a wrong offset!");

// Class UnionRun.BPFL_UnionRunTuningUtil
// 0x0000 (0x0028 - 0x0028)
class UBPFL_UnionRunTuningUtil final : public UBlueprintFunctionLibrary
{
public:
	static float GetHoverBaseHeight(EVehicleType VehicleType);
	static bool GetIsDroneDisable();
	static float GetMeshSizeRate(EVehicleDisplayMode DisplayMode);
	static void GetStartingLightPosition(const int32& SelectedPlayerNum, float* Front, float* Height, float* Right);
	static float GetYellowDrillMeshSizeRate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPFL_UnionRunTuningUtil">();
	}
	static class UBPFL_UnionRunTuningUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPFL_UnionRunTuningUtil>();
	}
};
static_assert(alignof(UBPFL_UnionRunTuningUtil) == 0x000008, "Wrong alignment on UBPFL_UnionRunTuningUtil");
static_assert(sizeof(UBPFL_UnionRunTuningUtil) == 0x000028, "Wrong size on UBPFL_UnionRunTuningUtil");

// Class UnionRun.BPFL_UnionRunVehicleUtil
// 0x0000 (0x0028 - 0x0028)
class UBPFL_UnionRunVehicleUtil final : public UBlueprintFunctionLibrary
{
public:
	static ECarStatusType GetCarStatusType(EMachineId InMachineID);
	static EMachineId GetDefaultMachineId(ECarStatusType InCarStatusType);
	static EMachineId GetFirstBasicCustomMachineId(ECarStatusType InCarStatusType);
	static bool IsHoverboard(ECarStatusType InCarStatusType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPFL_UnionRunVehicleUtil">();
	}
	static class UBPFL_UnionRunVehicleUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPFL_UnionRunVehicleUtil>();
	}
};
static_assert(alignof(UBPFL_UnionRunVehicleUtil) == 0x000008, "Wrong alignment on UBPFL_UnionRunVehicleUtil");
static_assert(sizeof(UBPFL_UnionRunVehicleUtil) == 0x000028, "Wrong size on UBPFL_UnionRunVehicleUtil");

// Class UnionRun.ItemObjectBase
// 0x02E0 (0x0570 - 0x0290)
#pragma pack(push, 0x1)
class alignas(0x10) AItemObjectBase : public AActor
{
public:
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VioletVoidAbsorbTargetScale;                       // 0x02A0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8[0x2B0];                                    // 0x02B8(0x02B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemObjectBase">();
	}
	static class AItemObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemObjectBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(AItemObjectBase) == 0x000010, "Wrong alignment on AItemObjectBase");
static_assert(sizeof(AItemObjectBase) == 0x000570, "Wrong size on AItemObjectBase");
static_assert(offsetof(AItemObjectBase, VioletVoidAbsorbTargetScale) == 0x0002A0, "Member 'AItemObjectBase::VioletVoidAbsorbTargetScale' has a wrong offset!");

// Class UnionRun.ItemCyanLaserObject
// 0x02A0 (0x0810 - 0x0570)
class AItemCyanLaserObject : public AItemObjectBase
{
public:
	class UUnionStaticMeshComponent*              m_staticMeshComponent;                             // 0x0568(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        RootScene_;                                        // 0x0570(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              playerPointerMesh00;                               // 0x0578(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              playerPointerMesh01;                               // 0x0580(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              pointerMesh00_;                                    // 0x0588(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              pointerMesh01_;                                    // 0x0590(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              pointerMesh02_;                                    // 0x0598(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              pointerMesh03_;                                    // 0x05A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              pointerMesh04_;                                    // 0x05A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              pointerMesh05_;                                    // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              laserMesh00_;                                      // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              laserMesh01_;                                      // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              laserMesh02_;                                      // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              laserMesh03_;                                      // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              laserMesh04_;                                      // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              laserMesh05_;                                      // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              laserMesh06_;                                      // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              laserMesh07_;                                      // 0x05F0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              laserMesh08_;                                      // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              laserMesh09_;                                      // 0x0600(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              laserMesh10_;                                      // 0x0608(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              laserMesh11_;                                      // 0x0610(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              laserMesh12_;                                      // 0x0618(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              laserMesh13_;                                      // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              laserMesh14_;                                      // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            laserMeshAsset_;                                   // 0x0630(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstance*                      laserMaterialAsset_;                               // 0x0638(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      bodyFX_;                                           // 0x0640(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         bodyInFXAsset_;                                    // 0x0648(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         bodyOutFXAsset_;                                   // 0x0650(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         passedFXAsset_;                                    // 0x0658(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          startSoundAsset_;                                  // 0x0660(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          endSoundAsset_;                                    // 0x0668(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          pointerSoundAsset_;                                // 0x0670(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          movingSoundAsset_;                                 // 0x0678(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          movingOwnerSoundAsset_;                            // 0x0680(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          passedSoundAsset_;                                 // 0x0688(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AUnionCameraCarCamOffset>   MovingCameraClass;                                 // 0x0690(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         rivalPointerNumMax_;                               // 0x0698(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         playerPointerHeightOffset_;                        // 0x069C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         rivalPointerHeightOffset_;                         // 0x06A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         forwardDist_;                                      // 0x06A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         playerSearchFrontDist_;                            // 0x06A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         playerSearchDist_;                                 // 0x06AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         noTargetGap_;                                      // 0x06B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         noTargetDist_;                                     // 0x06B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         toLastCount_;                                      // 0x06B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         toLastDist_;                                       // 0x06BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         toLastGap_;                                        // 0x06C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         toGroundRayUpperHeight_;                           // 0x06C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         toGroundRayLowerHeight_;                           // 0x06C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         lastLocationHeightOffset_;                         // 0x06CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         noTargetPointerNum_;                               // 0x06D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         lerpRate_;                                         // 0x06D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         waitStopSeconds_;                                  // 0x06D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         startDelaySeconds_;                                // 0x06DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         endDelaySeconds_;                                  // 0x06E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         cancelSeconds_;                                    // 0x06E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         mparamAnimationMin_;                               // 0x06E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         mparamAnimationMax_;                               // 0x06EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      tempNiagara;                                       // 0x06F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6F8[0xC0];                                     // 0x06F8(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCyanLaserParam>                laserMParamList_;                                  // 0x07B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UUnionStaticMeshComponent*>      laserMeshes_;                                      // 0x07C8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UUnionStaticMeshComponent*>      playerPointers_;                                   // 0x07D8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UUnionStaticMeshComponent*>      rivalPointers_;                                    // 0x07E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7F8[0x18];                                     // 0x07F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemCyanLaserObject">();
	}
	static class AItemCyanLaserObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemCyanLaserObject>();
	}
};
static_assert(alignof(AItemCyanLaserObject) == 0x000010, "Wrong alignment on AItemCyanLaserObject");
static_assert(sizeof(AItemCyanLaserObject) == 0x000810, "Wrong size on AItemCyanLaserObject");
static_assert(offsetof(AItemCyanLaserObject, m_staticMeshComponent) == 0x000568, "Member 'AItemCyanLaserObject::m_staticMeshComponent' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, RootScene_) == 0x000570, "Member 'AItemCyanLaserObject::RootScene_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, playerPointerMesh00) == 0x000578, "Member 'AItemCyanLaserObject::playerPointerMesh00' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, playerPointerMesh01) == 0x000580, "Member 'AItemCyanLaserObject::playerPointerMesh01' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, pointerMesh00_) == 0x000588, "Member 'AItemCyanLaserObject::pointerMesh00_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, pointerMesh01_) == 0x000590, "Member 'AItemCyanLaserObject::pointerMesh01_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, pointerMesh02_) == 0x000598, "Member 'AItemCyanLaserObject::pointerMesh02_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, pointerMesh03_) == 0x0005A0, "Member 'AItemCyanLaserObject::pointerMesh03_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, pointerMesh04_) == 0x0005A8, "Member 'AItemCyanLaserObject::pointerMesh04_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, pointerMesh05_) == 0x0005B0, "Member 'AItemCyanLaserObject::pointerMesh05_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, laserMesh00_) == 0x0005B8, "Member 'AItemCyanLaserObject::laserMesh00_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, laserMesh01_) == 0x0005C0, "Member 'AItemCyanLaserObject::laserMesh01_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, laserMesh02_) == 0x0005C8, "Member 'AItemCyanLaserObject::laserMesh02_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, laserMesh03_) == 0x0005D0, "Member 'AItemCyanLaserObject::laserMesh03_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, laserMesh04_) == 0x0005D8, "Member 'AItemCyanLaserObject::laserMesh04_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, laserMesh05_) == 0x0005E0, "Member 'AItemCyanLaserObject::laserMesh05_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, laserMesh06_) == 0x0005E8, "Member 'AItemCyanLaserObject::laserMesh06_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, laserMesh07_) == 0x0005F0, "Member 'AItemCyanLaserObject::laserMesh07_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, laserMesh08_) == 0x0005F8, "Member 'AItemCyanLaserObject::laserMesh08_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, laserMesh09_) == 0x000600, "Member 'AItemCyanLaserObject::laserMesh09_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, laserMesh10_) == 0x000608, "Member 'AItemCyanLaserObject::laserMesh10_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, laserMesh11_) == 0x000610, "Member 'AItemCyanLaserObject::laserMesh11_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, laserMesh12_) == 0x000618, "Member 'AItemCyanLaserObject::laserMesh12_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, laserMesh13_) == 0x000620, "Member 'AItemCyanLaserObject::laserMesh13_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, laserMesh14_) == 0x000628, "Member 'AItemCyanLaserObject::laserMesh14_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, laserMeshAsset_) == 0x000630, "Member 'AItemCyanLaserObject::laserMeshAsset_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, laserMaterialAsset_) == 0x000638, "Member 'AItemCyanLaserObject::laserMaterialAsset_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, bodyFX_) == 0x000640, "Member 'AItemCyanLaserObject::bodyFX_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, bodyInFXAsset_) == 0x000648, "Member 'AItemCyanLaserObject::bodyInFXAsset_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, bodyOutFXAsset_) == 0x000650, "Member 'AItemCyanLaserObject::bodyOutFXAsset_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, passedFXAsset_) == 0x000658, "Member 'AItemCyanLaserObject::passedFXAsset_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, startSoundAsset_) == 0x000660, "Member 'AItemCyanLaserObject::startSoundAsset_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, endSoundAsset_) == 0x000668, "Member 'AItemCyanLaserObject::endSoundAsset_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, pointerSoundAsset_) == 0x000670, "Member 'AItemCyanLaserObject::pointerSoundAsset_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, movingSoundAsset_) == 0x000678, "Member 'AItemCyanLaserObject::movingSoundAsset_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, movingOwnerSoundAsset_) == 0x000680, "Member 'AItemCyanLaserObject::movingOwnerSoundAsset_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, passedSoundAsset_) == 0x000688, "Member 'AItemCyanLaserObject::passedSoundAsset_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, MovingCameraClass) == 0x000690, "Member 'AItemCyanLaserObject::MovingCameraClass' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, rivalPointerNumMax_) == 0x000698, "Member 'AItemCyanLaserObject::rivalPointerNumMax_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, playerPointerHeightOffset_) == 0x00069C, "Member 'AItemCyanLaserObject::playerPointerHeightOffset_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, rivalPointerHeightOffset_) == 0x0006A0, "Member 'AItemCyanLaserObject::rivalPointerHeightOffset_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, forwardDist_) == 0x0006A4, "Member 'AItemCyanLaserObject::forwardDist_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, playerSearchFrontDist_) == 0x0006A8, "Member 'AItemCyanLaserObject::playerSearchFrontDist_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, playerSearchDist_) == 0x0006AC, "Member 'AItemCyanLaserObject::playerSearchDist_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, noTargetGap_) == 0x0006B0, "Member 'AItemCyanLaserObject::noTargetGap_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, noTargetDist_) == 0x0006B4, "Member 'AItemCyanLaserObject::noTargetDist_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, toLastCount_) == 0x0006B8, "Member 'AItemCyanLaserObject::toLastCount_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, toLastDist_) == 0x0006BC, "Member 'AItemCyanLaserObject::toLastDist_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, toLastGap_) == 0x0006C0, "Member 'AItemCyanLaserObject::toLastGap_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, toGroundRayUpperHeight_) == 0x0006C4, "Member 'AItemCyanLaserObject::toGroundRayUpperHeight_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, toGroundRayLowerHeight_) == 0x0006C8, "Member 'AItemCyanLaserObject::toGroundRayLowerHeight_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, lastLocationHeightOffset_) == 0x0006CC, "Member 'AItemCyanLaserObject::lastLocationHeightOffset_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, noTargetPointerNum_) == 0x0006D0, "Member 'AItemCyanLaserObject::noTargetPointerNum_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, lerpRate_) == 0x0006D4, "Member 'AItemCyanLaserObject::lerpRate_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, waitStopSeconds_) == 0x0006D8, "Member 'AItemCyanLaserObject::waitStopSeconds_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, startDelaySeconds_) == 0x0006DC, "Member 'AItemCyanLaserObject::startDelaySeconds_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, endDelaySeconds_) == 0x0006E0, "Member 'AItemCyanLaserObject::endDelaySeconds_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, cancelSeconds_) == 0x0006E4, "Member 'AItemCyanLaserObject::cancelSeconds_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, mparamAnimationMin_) == 0x0006E8, "Member 'AItemCyanLaserObject::mparamAnimationMin_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, mparamAnimationMax_) == 0x0006EC, "Member 'AItemCyanLaserObject::mparamAnimationMax_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, tempNiagara) == 0x0006F0, "Member 'AItemCyanLaserObject::tempNiagara' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, laserMParamList_) == 0x0007B8, "Member 'AItemCyanLaserObject::laserMParamList_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, laserMeshes_) == 0x0007C8, "Member 'AItemCyanLaserObject::laserMeshes_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, playerPointers_) == 0x0007D8, "Member 'AItemCyanLaserObject::playerPointers_' has a wrong offset!");
static_assert(offsetof(AItemCyanLaserObject, rivalPointers_) == 0x0007E8, "Member 'AItemCyanLaserObject::rivalPointers_' has a wrong offset!");

// Class UnionRun.BreakObjectAnimInstance
// 0x0000 (0x0370 - 0x0370)
class UBreakObjectAnimInstance final : public UAnimInstance
{
public:
	bool                                          bIsHit;                                            // 0x0368(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_369[0x3];                                      // 0x0369(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitSpeed;                                          // 0x036C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetHit(float Speed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BreakObjectAnimInstance">();
	}
	static class UBreakObjectAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBreakObjectAnimInstance>();
	}
};
static_assert(alignof(UBreakObjectAnimInstance) == 0x000010, "Wrong alignment on UBreakObjectAnimInstance");
static_assert(sizeof(UBreakObjectAnimInstance) == 0x000370, "Wrong size on UBreakObjectAnimInstance");
static_assert(offsetof(UBreakObjectAnimInstance, bIsHit) == 0x000368, "Member 'UBreakObjectAnimInstance::bIsHit' has a wrong offset!");
static_assert(offsetof(UBreakObjectAnimInstance, HitSpeed) == 0x00036C, "Member 'UBreakObjectAnimInstance::HitSpeed' has a wrong offset!");

// Class UnionRun.KingBoomBooAnimInstance
// 0x0000 (0x0370 - 0x0370)
class UKingBoomBooAnimInstance : public UAnimInstance
{
public:
	bool                                          bIsStart;                                          // 0x0368(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMove;                                           // 0x0369(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAttack;                                         // 0x036A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsExit;                                           // 0x036B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAttackEnd;                                      // 0x036C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsEnd;                                            // 0x036D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36E[0x2];                                      // 0x036E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetIsAttack();
	bool GetIsAttackEnd();
	bool GetIsEnd();
	bool GetIsExit();
	bool GetIsMove();
	bool GetIsStart();
	void SetIsAttack(bool flag);
	void SetIsAttackEnd(bool flag);
	void SetIsEnd(bool flag);
	void SetIsExit(bool flag);
	void SetIsMove(bool flag);
	void SetIsStart(bool flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KingBoomBooAnimInstance">();
	}
	static class UKingBoomBooAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKingBoomBooAnimInstance>();
	}
};
static_assert(alignof(UKingBoomBooAnimInstance) == 0x000010, "Wrong alignment on UKingBoomBooAnimInstance");
static_assert(sizeof(UKingBoomBooAnimInstance) == 0x000370, "Wrong size on UKingBoomBooAnimInstance");
static_assert(offsetof(UKingBoomBooAnimInstance, bIsStart) == 0x000368, "Member 'UKingBoomBooAnimInstance::bIsStart' has a wrong offset!");
static_assert(offsetof(UKingBoomBooAnimInstance, bIsMove) == 0x000369, "Member 'UKingBoomBooAnimInstance::bIsMove' has a wrong offset!");
static_assert(offsetof(UKingBoomBooAnimInstance, bIsAttack) == 0x00036A, "Member 'UKingBoomBooAnimInstance::bIsAttack' has a wrong offset!");
static_assert(offsetof(UKingBoomBooAnimInstance, bIsExit) == 0x00036B, "Member 'UKingBoomBooAnimInstance::bIsExit' has a wrong offset!");
static_assert(offsetof(UKingBoomBooAnimInstance, bIsAttackEnd) == 0x00036C, "Member 'UKingBoomBooAnimInstance::bIsAttackEnd' has a wrong offset!");
static_assert(offsetof(UKingBoomBooAnimInstance, bIsEnd) == 0x00036D, "Member 'UKingBoomBooAnimInstance::bIsEnd' has a wrong offset!");

// Class UnionRun.BreakObjectBase
// 0x00E0 (0x0690 - 0x05B0)
class alignas(0x10) ABreakObjectBase : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              StaticMeshComponent;                               // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionSkeletalMeshComponent*            SkeletalMeshComponent;                             // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            StaticBodyComponent;                               // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isBreak;                                           // 0x05D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isRelocate;                                        // 0x05D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D2[0x2];                                      // 0x05D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RelocateTimer;                                     // 0x05D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBlendSpaceValue;                                // 0x05D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinBlendSpaceValue;                                // 0x05DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrashSpeedMaxBlendSpaceValueThreshold;             // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InValidRotation;                                   // 0x05E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E5[0x3];                                      // 0x05E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CrashSoundTimer;                                   // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBreakObjType                                 BreakObjType;                                      // 0x05EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBreakConditionType                           BreakConditionType;                                // 0x05ED(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBreakDamageType                              BreakDamageType;                                   // 0x05EE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5EF[0x1];                                      // 0x05EF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UBreakObjectAnimInstance*               AnimInstance;                                      // 0x05F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_600[0x90];                                     // 0x0600(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HitRacer(int32 RacerIndex);
	void OnPlayBreakAnimation();
	void OnPlayBreakSound();
	void OnPlayClashSound();

	float GetBlendSpaceValue() const;
	bool IsBroken() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BreakObjectBase">();
	}
	static class ABreakObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABreakObjectBase>();
	}
};
static_assert(alignof(ABreakObjectBase) == 0x000010, "Wrong alignment on ABreakObjectBase");
static_assert(sizeof(ABreakObjectBase) == 0x000690, "Wrong size on ABreakObjectBase");
static_assert(offsetof(ABreakObjectBase, StaticMeshComponent) == 0x0005B8, "Member 'ABreakObjectBase::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(ABreakObjectBase, SkeletalMeshComponent) == 0x0005C0, "Member 'ABreakObjectBase::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ABreakObjectBase, StaticBodyComponent) == 0x0005C8, "Member 'ABreakObjectBase::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(ABreakObjectBase, isBreak) == 0x0005D0, "Member 'ABreakObjectBase::isBreak' has a wrong offset!");
static_assert(offsetof(ABreakObjectBase, isRelocate) == 0x0005D1, "Member 'ABreakObjectBase::isRelocate' has a wrong offset!");
static_assert(offsetof(ABreakObjectBase, RelocateTimer) == 0x0005D4, "Member 'ABreakObjectBase::RelocateTimer' has a wrong offset!");
static_assert(offsetof(ABreakObjectBase, MaxBlendSpaceValue) == 0x0005D8, "Member 'ABreakObjectBase::MaxBlendSpaceValue' has a wrong offset!");
static_assert(offsetof(ABreakObjectBase, MinBlendSpaceValue) == 0x0005DC, "Member 'ABreakObjectBase::MinBlendSpaceValue' has a wrong offset!");
static_assert(offsetof(ABreakObjectBase, CrashSpeedMaxBlendSpaceValueThreshold) == 0x0005E0, "Member 'ABreakObjectBase::CrashSpeedMaxBlendSpaceValueThreshold' has a wrong offset!");
static_assert(offsetof(ABreakObjectBase, InValidRotation) == 0x0005E4, "Member 'ABreakObjectBase::InValidRotation' has a wrong offset!");
static_assert(offsetof(ABreakObjectBase, CrashSoundTimer) == 0x0005E8, "Member 'ABreakObjectBase::CrashSoundTimer' has a wrong offset!");
static_assert(offsetof(ABreakObjectBase, BreakObjType) == 0x0005EC, "Member 'ABreakObjectBase::BreakObjType' has a wrong offset!");
static_assert(offsetof(ABreakObjectBase, BreakConditionType) == 0x0005ED, "Member 'ABreakObjectBase::BreakConditionType' has a wrong offset!");
static_assert(offsetof(ABreakObjectBase, BreakDamageType) == 0x0005EE, "Member 'ABreakObjectBase::BreakDamageType' has a wrong offset!");
static_assert(offsetof(ABreakObjectBase, AnimInstance) == 0x0005F0, "Member 'ABreakObjectBase::AnimInstance' has a wrong offset!");
static_assert(offsetof(ABreakObjectBase, DefaultSceneRoot) == 0x0005F8, "Member 'ABreakObjectBase::DefaultSceneRoot' has a wrong offset!");

// Class UnionRun.BtDebugDispActor
// 0x0100 (0x0390 - 0x0290)
class ABtDebugDispActor final : public AActor
{
public:
	uint8                                         Pad_290[0x100];                                    // 0x0290(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Execute_AreaDataBlockDisp(const TArray<class FString>& args);
	void Execute_AreaDataCourseCollisionDisp(const TArray<class FString>& args);
	void Execute_AreaDataCourseCollisionText(const TArray<class FString>& args);
	void Execute_CalcStageAABB(const TArray<class FString>& args);
	void Execute_CollisionDisp(const TArray<class FString>& args);
	void Execute_CollisionText(const TArray<class FString>& args);
	void Execute_DispStageAABB(const TArray<class FString>& args);
	void Execute_DrawSphere(const TArray<class FString>& args);
	void Execute_RayCast(const TArray<class FString>& args);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BtDebugDispActor">();
	}
	static class ABtDebugDispActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABtDebugDispActor>();
	}
};
static_assert(alignof(ABtDebugDispActor) == 0x000008, "Wrong alignment on ABtDebugDispActor");
static_assert(sizeof(ABtDebugDispActor) == 0x000390, "Wrong size on ABtDebugDispActor");

// Class UnionRun.BubbleItemBox
// 0x02B0 (0x05F0 - 0x0340)
class ABubbleItemBox final : public AUnionCourseObjectBase
{
public:
	uint8                                         Pad_340[0x10];                                     // 0x0340(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EItemBoxType                                  ItemBoxType;                                       // 0x0350(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ChangeItemBoxType;                                 // 0x0351(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_352[0x2];                                      // 0x0352(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitVelocity;                                       // 0x0354(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitDirection;                                      // 0x0358(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   NormalItemBoxMesh;                                 // 0x0370(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   DoubleItemBoxMesh;                                 // 0x0378(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   SpecialItemBoxMesh;                                // 0x0380(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemBoxColliderParam                  _ColliderParam;                                    // 0x0388(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemBoxColliderParam                  _DoubleBoxColliderParam;                           // 0x03B8(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemBoxColliderParam                  _SpecialBoxColliderParam;                          // 0x03E8(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoundingItemBoxColliderParam          _BoundingColliderParam;                            // 0x0418(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bShadowValid;                                      // 0x0448(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_449[0x7];                                      // 0x0449(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             shadowTransform;                                   // 0x0450(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         shadowHeightOffset;                                // 0x04B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetModelHeight;                                 // 0x04B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelocationWaitTime;                                // 0x04B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAutoToggleEnable;                               // 0x04BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4BD[0x3];                                      // 0x04BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoEnableStartTime;                               // 0x04C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoDisableTime;                                   // 0x04C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoEnableTime;                                    // 0x04C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseEventStart;                                     // 0x04CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4CD[0x3];                                      // 0x04CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x04D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D8[0x10C];                                    // 0x04D8(0x010C)(Fixing Size After Last Property [ Dumper-7 ])
	ESpecialObjGroup                              m_SpecialGroup;                                    // 0x05E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E5[0xB];                                      // 0x05E5(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HitRacer(int32 RacerIndex);
	void OnChangeItemBox(EItemBoxType ItemBoxType_0);
	void OnHitRacer(int32 RacerIndex);
	void OnPlayForceFeedback(int32 LocalPlayerIndex);
	void OnPlayTakeSound();
	void OnStartRelocation();
	void SetisReset(bool newParam);
	void SetItemBoxType(EItemBoxType Type);
	void SetItemBoxTypeEx(EItemBoxType Type);
	void SetVisibleEnable(bool IsEnable);
	void Update(float InDeltaTime);

	ESoundPan GetSoundPan() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BubbleItemBox">();
	}
	static class ABubbleItemBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABubbleItemBox>();
	}
};
static_assert(alignof(ABubbleItemBox) == 0x000010, "Wrong alignment on ABubbleItemBox");
static_assert(sizeof(ABubbleItemBox) == 0x0005F0, "Wrong size on ABubbleItemBox");
static_assert(offsetof(ABubbleItemBox, ItemBoxType) == 0x000350, "Member 'ABubbleItemBox::ItemBoxType' has a wrong offset!");
static_assert(offsetof(ABubbleItemBox, ChangeItemBoxType) == 0x000351, "Member 'ABubbleItemBox::ChangeItemBoxType' has a wrong offset!");
static_assert(offsetof(ABubbleItemBox, HitVelocity) == 0x000354, "Member 'ABubbleItemBox::HitVelocity' has a wrong offset!");
static_assert(offsetof(ABubbleItemBox, HitDirection) == 0x000358, "Member 'ABubbleItemBox::HitDirection' has a wrong offset!");
static_assert(offsetof(ABubbleItemBox, NormalItemBoxMesh) == 0x000370, "Member 'ABubbleItemBox::NormalItemBoxMesh' has a wrong offset!");
static_assert(offsetof(ABubbleItemBox, DoubleItemBoxMesh) == 0x000378, "Member 'ABubbleItemBox::DoubleItemBoxMesh' has a wrong offset!");
static_assert(offsetof(ABubbleItemBox, SpecialItemBoxMesh) == 0x000380, "Member 'ABubbleItemBox::SpecialItemBoxMesh' has a wrong offset!");
static_assert(offsetof(ABubbleItemBox, _ColliderParam) == 0x000388, "Member 'ABubbleItemBox::_ColliderParam' has a wrong offset!");
static_assert(offsetof(ABubbleItemBox, _DoubleBoxColliderParam) == 0x0003B8, "Member 'ABubbleItemBox::_DoubleBoxColliderParam' has a wrong offset!");
static_assert(offsetof(ABubbleItemBox, _SpecialBoxColliderParam) == 0x0003E8, "Member 'ABubbleItemBox::_SpecialBoxColliderParam' has a wrong offset!");
static_assert(offsetof(ABubbleItemBox, _BoundingColliderParam) == 0x000418, "Member 'ABubbleItemBox::_BoundingColliderParam' has a wrong offset!");
static_assert(offsetof(ABubbleItemBox, bShadowValid) == 0x000448, "Member 'ABubbleItemBox::bShadowValid' has a wrong offset!");
static_assert(offsetof(ABubbleItemBox, shadowTransform) == 0x000450, "Member 'ABubbleItemBox::shadowTransform' has a wrong offset!");
static_assert(offsetof(ABubbleItemBox, shadowHeightOffset) == 0x0004B0, "Member 'ABubbleItemBox::shadowHeightOffset' has a wrong offset!");
static_assert(offsetof(ABubbleItemBox, OffsetModelHeight) == 0x0004B4, "Member 'ABubbleItemBox::OffsetModelHeight' has a wrong offset!");
static_assert(offsetof(ABubbleItemBox, RelocationWaitTime) == 0x0004B8, "Member 'ABubbleItemBox::RelocationWaitTime' has a wrong offset!");
static_assert(offsetof(ABubbleItemBox, bIsAutoToggleEnable) == 0x0004BC, "Member 'ABubbleItemBox::bIsAutoToggleEnable' has a wrong offset!");
static_assert(offsetof(ABubbleItemBox, AutoEnableStartTime) == 0x0004C0, "Member 'ABubbleItemBox::AutoEnableStartTime' has a wrong offset!");
static_assert(offsetof(ABubbleItemBox, AutoDisableTime) == 0x0004C4, "Member 'ABubbleItemBox::AutoDisableTime' has a wrong offset!");
static_assert(offsetof(ABubbleItemBox, AutoEnableTime) == 0x0004C8, "Member 'ABubbleItemBox::AutoEnableTime' has a wrong offset!");
static_assert(offsetof(ABubbleItemBox, UseEventStart) == 0x0004CC, "Member 'ABubbleItemBox::UseEventStart' has a wrong offset!");
static_assert(offsetof(ABubbleItemBox, DefaultSceneRoot) == 0x0004D0, "Member 'ABubbleItemBox::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(ABubbleItemBox, m_SpecialGroup) == 0x0005E4, "Member 'ABubbleItemBox::m_SpecialGroup' has a wrong offset!");

// Class UnionRun.SimpleTravelRingObject
// 0x0028 (0x0368 - 0x0340)
class ASimpleTravelRingObject final : public AUnionCourseObjectBase
{
public:
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETravelRingType                               TravelRingType;                                    // 0x0348(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETravelRingSizeType                           RingSizeType;                                      // 0x0349(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETransformRingType                            TransformRingType;                                 // 0x034A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34B[0x5];                                      // 0x034B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            RingMeshBySize[0x2];                               // 0x0350(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0360(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	const ETransformRingType GetTransformRingType();
	const ETravelRingSizeType GetTravelRingSizeType();
	const ETravelRingType GetTravelRingType();
	void SetTransformRingType(const ETransformRingType Type);
	void SetTravelRingSizeType(const ETravelRingSizeType Type);
	void SetTravelRingType(const ETravelRingType Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleTravelRingObject">();
	}
	static class ASimpleTravelRingObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASimpleTravelRingObject>();
	}
};
static_assert(alignof(ASimpleTravelRingObject) == 0x000008, "Wrong alignment on ASimpleTravelRingObject");
static_assert(sizeof(ASimpleTravelRingObject) == 0x000368, "Wrong size on ASimpleTravelRingObject");
static_assert(offsetof(ASimpleTravelRingObject, StaticMeshComponent) == 0x000340, "Member 'ASimpleTravelRingObject::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(ASimpleTravelRingObject, TravelRingType) == 0x000348, "Member 'ASimpleTravelRingObject::TravelRingType' has a wrong offset!");
static_assert(offsetof(ASimpleTravelRingObject, RingSizeType) == 0x000349, "Member 'ASimpleTravelRingObject::RingSizeType' has a wrong offset!");
static_assert(offsetof(ASimpleTravelRingObject, TransformRingType) == 0x00034A, "Member 'ASimpleTravelRingObject::TransformRingType' has a wrong offset!");
static_assert(offsetof(ASimpleTravelRingObject, RingMeshBySize) == 0x000350, "Member 'ASimpleTravelRingObject::RingMeshBySize' has a wrong offset!");
static_assert(offsetof(ASimpleTravelRingObject, DefaultSceneRoot) == 0x000360, "Member 'ASimpleTravelRingObject::DefaultSceneRoot' has a wrong offset!");

// Class UnionRun.BubbleRing
// 0x0118 (0x0458 - 0x0340)
class ABubbleRing final : public AUnionCourseObjectBase
{
public:
	uint8                                         Pad_340[0x10];                                     // 0x0340(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              StaticMeshComponent;                               // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRingColliderParam                     _ColliderParam;                                    // 0x0358(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	EPackageRingType                              PackageRingType;                                   // 0x0378(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_379[0x3];                                      // 0x0379(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _RespawnWaitTime;                                  // 0x037C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RingNum;                                           // 0x0380(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RingNumMaterialIndex;                              // 0x0384(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0388(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_390[0xB5];                                     // 0x0390(0x00B5)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsAutoToggleEnable;                               // 0x0445(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_446[0x2];                                      // 0x0446(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoEnableStartTime;                               // 0x0448(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AutoDisableTime;                                   // 0x044C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AutoEnableTime;                                    // 0x0450(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESpecialObjGroup                              m_SpecialGroup;                                    // 0x0454(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_455[0x3];                                      // 0x0455(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HitRacer(int32 RacerIndex);
	void SetisReset(bool newParam);
	void SetRingNumMaterial();
	void SetRingType(EPackageRingType Type);
	void SetRingTypeEx(EPackageRingType Type);
	void Update(float InDeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BubbleRing">();
	}
	static class ABubbleRing* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABubbleRing>();
	}
};
static_assert(alignof(ABubbleRing) == 0x000008, "Wrong alignment on ABubbleRing");
static_assert(sizeof(ABubbleRing) == 0x000458, "Wrong size on ABubbleRing");
static_assert(offsetof(ABubbleRing, StaticMeshComponent) == 0x000350, "Member 'ABubbleRing::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(ABubbleRing, _ColliderParam) == 0x000358, "Member 'ABubbleRing::_ColliderParam' has a wrong offset!");
static_assert(offsetof(ABubbleRing, PackageRingType) == 0x000378, "Member 'ABubbleRing::PackageRingType' has a wrong offset!");
static_assert(offsetof(ABubbleRing, _RespawnWaitTime) == 0x00037C, "Member 'ABubbleRing::_RespawnWaitTime' has a wrong offset!");
static_assert(offsetof(ABubbleRing, RingNum) == 0x000380, "Member 'ABubbleRing::RingNum' has a wrong offset!");
static_assert(offsetof(ABubbleRing, RingNumMaterialIndex) == 0x000384, "Member 'ABubbleRing::RingNumMaterialIndex' has a wrong offset!");
static_assert(offsetof(ABubbleRing, DefaultSceneRoot) == 0x000388, "Member 'ABubbleRing::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(ABubbleRing, bIsAutoToggleEnable) == 0x000445, "Member 'ABubbleRing::bIsAutoToggleEnable' has a wrong offset!");
static_assert(offsetof(ABubbleRing, AutoEnableStartTime) == 0x000448, "Member 'ABubbleRing::AutoEnableStartTime' has a wrong offset!");
static_assert(offsetof(ABubbleRing, AutoDisableTime) == 0x00044C, "Member 'ABubbleRing::AutoDisableTime' has a wrong offset!");
static_assert(offsetof(ABubbleRing, AutoEnableTime) == 0x000450, "Member 'ABubbleRing::AutoEnableTime' has a wrong offset!");
static_assert(offsetof(ABubbleRing, m_SpecialGroup) == 0x000454, "Member 'ABubbleRing::m_SpecialGroup' has a wrong offset!");

// Class UnionRun.RespotObject
// 0x0110 (0x06C0 - 0x05B0)
class ARespotObject final : public AUnionGimmickObjectBase
{
public:
	bool                                          _bColliderParamUpdate;                             // 0x05B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B1[0x7];                                      // 0x05B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AUnionNavMarker>         _RespotTartgetMarker;                              // 0x05B8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CollisionSize;                                     // 0x05E0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F8[0x8];                                      // 0x05F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatrix                                RespotMatrix;                                      // 0x0600(0x0080)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0680(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticBodyComponent*                   StaticBodyComponent;                               // 0x0688(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class AUnionNavMarker>         _RespotTartgetMarkerOld;                           // 0x0690(0x0028)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6B8[0x8];                                      // 0x06B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetRespotMatrix();
	void SetRespotType();
	void UpdateRespotMatrix(const struct FTransform& NewTransform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RespotObject">();
	}
	static class ARespotObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARespotObject>();
	}
};
static_assert(alignof(ARespotObject) == 0x000010, "Wrong alignment on ARespotObject");
static_assert(sizeof(ARespotObject) == 0x0006C0, "Wrong size on ARespotObject");
static_assert(offsetof(ARespotObject, _bColliderParamUpdate) == 0x0005B0, "Member 'ARespotObject::_bColliderParamUpdate' has a wrong offset!");
static_assert(offsetof(ARespotObject, _RespotTartgetMarker) == 0x0005B8, "Member 'ARespotObject::_RespotTartgetMarker' has a wrong offset!");
static_assert(offsetof(ARespotObject, CollisionSize) == 0x0005E0, "Member 'ARespotObject::CollisionSize' has a wrong offset!");
static_assert(offsetof(ARespotObject, RespotMatrix) == 0x000600, "Member 'ARespotObject::RespotMatrix' has a wrong offset!");
static_assert(offsetof(ARespotObject, DefaultSceneRoot) == 0x000680, "Member 'ARespotObject::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(ARespotObject, StaticBodyComponent) == 0x000688, "Member 'ARespotObject::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(ARespotObject, _RespotTartgetMarkerOld) == 0x000690, "Member 'ARespotObject::_RespotTartgetMarkerOld' has a wrong offset!");

// Class UnionRun.CameraCollision
// 0x0030 (0x05E0 - 0x05B0)
class alignas(0x10) ACameraCollision final : public AUnionGimmickObjectBase
{
public:
	struct FVector                                CollisionSize;                                     // 0x05B0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        CameraId;                                          // 0x05C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EResultCameraProductionType                   ResultCameraType;                                  // 0x05CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5CD[0x3];                                      // 0x05CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            StaticBodyComponent;                               // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetCameraData(int32 NewCameraId, const struct FVector& NewBoxSize, EResultCameraProductionType NewResultCameraType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraCollision">();
	}
	static class ACameraCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACameraCollision>();
	}
};
static_assert(alignof(ACameraCollision) == 0x000010, "Wrong alignment on ACameraCollision");
static_assert(sizeof(ACameraCollision) == 0x0005E0, "Wrong size on ACameraCollision");
static_assert(offsetof(ACameraCollision, CollisionSize) == 0x0005B0, "Member 'ACameraCollision::CollisionSize' has a wrong offset!");
static_assert(offsetof(ACameraCollision, CameraId) == 0x0005C8, "Member 'ACameraCollision::CameraId' has a wrong offset!");
static_assert(offsetof(ACameraCollision, ResultCameraType) == 0x0005CC, "Member 'ACameraCollision::ResultCameraType' has a wrong offset!");
static_assert(offsetof(ACameraCollision, DefaultSceneRoot) == 0x0005D0, "Member 'ACameraCollision::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(ACameraCollision, StaticBodyComponent) == 0x0005D8, "Member 'ACameraCollision::StaticBodyComponent' has a wrong offset!");

// Class UnionRun.CameraExtensionParameterObject
// 0x0078 (0x0308 - 0x0290)
class ACameraExtensionParameterObject final : public AActor
{
public:
	struct FTremorParameter                       TremorParameter_Low;                               // 0x0290(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTremorParameter                       TremorParameter_Middle;                            // 0x02B8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTremorParameter                       TremorParameter_High;                              // 0x02E0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraExtensionParameterObject">();
	}
	static class ACameraExtensionParameterObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACameraExtensionParameterObject>();
	}
};
static_assert(alignof(ACameraExtensionParameterObject) == 0x000008, "Wrong alignment on ACameraExtensionParameterObject");
static_assert(sizeof(ACameraExtensionParameterObject) == 0x000308, "Wrong size on ACameraExtensionParameterObject");
static_assert(offsetof(ACameraExtensionParameterObject, TremorParameter_Low) == 0x000290, "Member 'ACameraExtensionParameterObject::TremorParameter_Low' has a wrong offset!");
static_assert(offsetof(ACameraExtensionParameterObject, TremorParameter_Middle) == 0x0002B8, "Member 'ACameraExtensionParameterObject::TremorParameter_Middle' has a wrong offset!");
static_assert(offsetof(ACameraExtensionParameterObject, TremorParameter_High) == 0x0002E0, "Member 'ACameraExtensionParameterObject::TremorParameter_High' has a wrong offset!");

// Class UnionRun.CameraMessageInterface
// 0x0000 (0x0000 - 0x0000)
class ICameraMessageInterface final
{
public:
	void NotifyCameraChanged(int32 PlayerControllerIndex, class AActor* PrevCamera, class AActor* NewCamera, const struct FViewTargetTransitionParams& BlendSetting);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraMessageInterface">();
	}
	static class ICameraMessageInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICameraMessageInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ICameraMessageInterface) == 0x000001, "Wrong alignment on ICameraMessageInterface");
static_assert(sizeof(ICameraMessageInterface) == 0x000001, "Wrong size on ICameraMessageInterface");

// Class UnionRun.ItemKingWhiteBoostObject
// 0x0060 (0x05D0 - 0x0570)
class AItemKingWhiteBoostObject : public AItemObjectBase
{
public:
	float                                         m_maxBoostTime;                                    // 0x0568(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_intervalTime;                                    // 0x056C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_soundComponent;                                  // 0x0570(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_578[0x58];                                     // 0x0578(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemKingWhiteBoostObject">();
	}
	static class AItemKingWhiteBoostObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemKingWhiteBoostObject>();
	}
};
static_assert(alignof(AItemKingWhiteBoostObject) == 0x000010, "Wrong alignment on AItemKingWhiteBoostObject");
static_assert(sizeof(AItemKingWhiteBoostObject) == 0x0005D0, "Wrong size on AItemKingWhiteBoostObject");
static_assert(offsetof(AItemKingWhiteBoostObject, m_maxBoostTime) == 0x000568, "Member 'AItemKingWhiteBoostObject::m_maxBoostTime' has a wrong offset!");
static_assert(offsetof(AItemKingWhiteBoostObject, m_intervalTime) == 0x00056C, "Member 'AItemKingWhiteBoostObject::m_intervalTime' has a wrong offset!");
static_assert(offsetof(AItemKingWhiteBoostObject, m_soundComponent) == 0x000570, "Member 'AItemKingWhiteBoostObject::m_soundComponent' has a wrong offset!");

// Class UnionRun.CarObject
// 0x02E0 (0x0570 - 0x0290)
class alignas(0x10) ACarObject final : public AActor
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Root;                                              // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGadgetComponent*                       GadgetComponent;                                   // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        ColliderRoot;                                      // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTriggerComponent*                      HitCommonTrigger;                                  // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTriggerComponent*                      HitEventTrigger;                                   // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTriggerComponent*                      RingTrigger;                                       // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTriggerComponent*                      RingAbsorbTrigger;                                 // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0[0x2A0];                                    // 0x02D0(0x02A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHitCommonTriggerConflict(const struct FHitTriggerInfo& HitInfo);
	void OnHitEventTriggerConflict(const struct FHitTriggerInfo& HitInfo);
	void OnHitRingTriggerConflict(const struct FHitTriggerInfo& HitInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CarObject">();
	}
	static class ACarObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACarObject>();
	}
};
static_assert(alignof(ACarObject) == 0x000010, "Wrong alignment on ACarObject");
static_assert(sizeof(ACarObject) == 0x000570, "Wrong size on ACarObject");
static_assert(offsetof(ACarObject, Root) == 0x000298, "Member 'ACarObject::Root' has a wrong offset!");
static_assert(offsetof(ACarObject, GadgetComponent) == 0x0002A0, "Member 'ACarObject::GadgetComponent' has a wrong offset!");
static_assert(offsetof(ACarObject, ColliderRoot) == 0x0002A8, "Member 'ACarObject::ColliderRoot' has a wrong offset!");
static_assert(offsetof(ACarObject, HitCommonTrigger) == 0x0002B0, "Member 'ACarObject::HitCommonTrigger' has a wrong offset!");
static_assert(offsetof(ACarObject, HitEventTrigger) == 0x0002B8, "Member 'ACarObject::HitEventTrigger' has a wrong offset!");
static_assert(offsetof(ACarObject, RingTrigger) == 0x0002C0, "Member 'ACarObject::RingTrigger' has a wrong offset!");
static_assert(offsetof(ACarObject, RingAbsorbTrigger) == 0x0002C8, "Member 'ACarObject::RingAbsorbTrigger' has a wrong offset!");

// Class UnionRun.GUNHunterAnimInstance
// 0x0000 (0x0370 - 0x0370)
class UGUNHunterAnimInstance final : public UEnemyAnimInstance
{
public:
	bool                                          IsAttackCharge;                                    // 0x0368(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDead;                                            // 0x0369(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDownAttack;                                      // 0x036A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36B[0x5];                                      // 0x036B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStartShootEnd();
	void SetIsAttackCharge(bool isChange);
	void SetIsDead(bool flag);

	bool IsShootState(EGUNHunterShootState State, bool isDown) const;
	bool IsStartMotion(EGUNHunterStartType Motion) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GUNHunterAnimInstance">();
	}
	static class UGUNHunterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGUNHunterAnimInstance>();
	}
};
static_assert(alignof(UGUNHunterAnimInstance) == 0x000010, "Wrong alignment on UGUNHunterAnimInstance");
static_assert(sizeof(UGUNHunterAnimInstance) == 0x000370, "Wrong size on UGUNHunterAnimInstance");
static_assert(offsetof(UGUNHunterAnimInstance, IsAttackCharge) == 0x000368, "Member 'UGUNHunterAnimInstance::IsAttackCharge' has a wrong offset!");
static_assert(offsetof(UGUNHunterAnimInstance, IsDead) == 0x000369, "Member 'UGUNHunterAnimInstance::IsDead' has a wrong offset!");
static_assert(offsetof(UGUNHunterAnimInstance, IsDownAttack) == 0x00036A, "Member 'UGUNHunterAnimInstance::IsDownAttack' has a wrong offset!");

// Class UnionRun.CheatItem
// 0x0258 (0x0280 - 0x0028)
class UCheatItem final : public UObject
{
public:
	uint8                                         Pad_28[0x258];                                     // 0x0028(0x0258)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Execute_AllRacerUseItemMode(const TArray<class FString>& args);
	void Execute_DebugItemCount(const TArray<class FString>& args);
	void Execute_DebugItemCountStop(const TArray<class FString>& args);
	void Execute_SetItemCapacity(const TArray<class FString>& args);
	void Execute_SetItemHitToItem(const TArray<class FString>& args);
	void Execute_SetItemHitToMachine(const TArray<class FString>& args);
	void Execute_SetItemRocketPunchForceNoReflect(const TArray<class FString>& args);
	void Execute_SetItemSlimeAutoUserInput(const TArray<class FString>& args);
	void Execute_ShowItemCount(const TArray<class FString>& args);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheatItem">();
	}
	static class UCheatItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCheatItem>();
	}
};
static_assert(alignof(UCheatItem) == 0x000008, "Wrong alignment on UCheatItem");
static_assert(sizeof(UCheatItem) == 0x000280, "Wrong size on UCheatItem");

// Class UnionRun.CheatPerformance
// 0x0020 (0x0048 - 0x0028)
class UCheatPerformance final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckRaceCheatManagerTick(int32 on);
	void Execute_CheatPerformanceSetSeq(const TArray<class FString>& args);
	void Execute_DebugRayCast(const TArray<class FString>& args);
	void Execute_DebugRayCastStop(const TArray<class FString>& args);
	void Execute_RaceTestConfig_SetAutoUnrealInsights(const TArray<class FString>& args);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheatPerformance">();
	}
	static class UCheatPerformance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCheatPerformance>();
	}
};
static_assert(alignof(UCheatPerformance) == 0x000008, "Wrong alignment on UCheatPerformance");
static_assert(sizeof(UCheatPerformance) == 0x000048, "Wrong size on UCheatPerformance");

// Class UnionRun.CheatRaceCommon
// 0x0000 (0x0028 - 0x0028)
class UCheatRaceCommon final : public UObject
{
public:
	void EnableSplitScreen(bool bInEnable);
	void RemoveAllWidgets();
	void SetVisibleUnionRunParam(bool bInVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheatRaceCommon">();
	}
	static class UCheatRaceCommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCheatRaceCommon>();
	}
};
static_assert(alignof(UCheatRaceCommon) == 0x000008, "Wrong alignment on UCheatRaceCommon");
static_assert(sizeof(UCheatRaceCommon) == 0x000028, "Wrong size on UCheatRaceCommon");

// Class UnionRun.PauseManager
// 0x0008 (0x0038 - 0x0030)
class UPauseManager final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetGamePaused(bool Paused, int32 RacerIndex);
	void SetGamePauseOwnerRacerIndex(int32 Index_0);
	void SetIsOnlineMode(bool IsOnlineMode);

	int32 GetGamePauseOwnerRacerIndex() const;
	bool IsGamePaused() const;
	bool IsGamePauseOwnerGoaled() const;
	bool IsOnlineMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PauseManager">();
	}
	static class UPauseManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPauseManager>();
	}
};
static_assert(alignof(UPauseManager) == 0x000008, "Wrong alignment on UPauseManager");
static_assert(sizeof(UPauseManager) == 0x000038, "Wrong size on UPauseManager");

// Class UnionRun.ColliderComponent
// 0x0260 (0x0300 - 0x00A0)
class alignas(0x10) UColliderComponent final : public UActorComponent
{
public:
	struct FCollider                              _Collision;                                        // 0x00A0(0x0030)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastSparseDelegateProperty_             OnCollision;                                       // 0x00E0(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	FMulticastSparseDelegateProperty_             OnCollisionWeapon;                                 // 0x00E1(0x0001)(InstancedReference, BlueprintAssignable, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x1DE];                                     // 0x00E2(0x01DE)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseSurfaceSetting;                                // 0x02C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FUnionSurfaceFlag                      EditSurfaceFlag;                                   // 0x02C1(0x001F)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	EUnionSurfaceType                             EditSurfaceType;                                   // 0x02E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E1[0x1F];                                     // 0x02E1(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCheckScaleEnabled(bool Enable);
	void SetCollisionProcessEnabled(bool Enable);
	void SetObjectCollisionEnabled(bool Enable);
	void SetOverrideTransform(const struct FTransform& trans);
	void SetScaleEnabled(bool Enable);
	void SetSurfaceFlag(const struct FUnionSurfaceFlag& flag);
	void SetSurfaceType(EUnionSurfaceType Type);

	bool GetCollisionProcessEnabled() const;
	const struct FTransform GetFinalTransform() const;
	bool GetObjectCollisionEnabled() const;
	const struct FTransform GetOverrideTransform() const;
	bool GetScaleEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ColliderComponent">();
	}
	static class UColliderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UColliderComponent>();
	}
};
static_assert(alignof(UColliderComponent) == 0x000010, "Wrong alignment on UColliderComponent");
static_assert(sizeof(UColliderComponent) == 0x000300, "Wrong size on UColliderComponent");
static_assert(offsetof(UColliderComponent, _Collision) == 0x0000A0, "Member 'UColliderComponent::_Collision' has a wrong offset!");
static_assert(offsetof(UColliderComponent, OnCollision) == 0x0000E0, "Member 'UColliderComponent::OnCollision' has a wrong offset!");
static_assert(offsetof(UColliderComponent, OnCollisionWeapon) == 0x0000E1, "Member 'UColliderComponent::OnCollisionWeapon' has a wrong offset!");
static_assert(offsetof(UColliderComponent, bUseSurfaceSetting) == 0x0002C0, "Member 'UColliderComponent::bUseSurfaceSetting' has a wrong offset!");
static_assert(offsetof(UColliderComponent, EditSurfaceFlag) == 0x0002C1, "Member 'UColliderComponent::EditSurfaceFlag' has a wrong offset!");
static_assert(offsetof(UColliderComponent, EditSurfaceType) == 0x0002E0, "Member 'UColliderComponent::EditSurfaceType' has a wrong offset!");

// Class UnionRun.RaceObjectSimpleAnimation
// 0x0058 (0x02E8 - 0x0290)
class ARaceObjectSimpleAnimation final : public AActor
{
public:
	class UUnionStaticMeshComponent*              StaticMeshComponent;                               // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransFrequency;                                    // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransAmplitude;                                    // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TransAxis;                                         // 0x02A0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotFrequency;                                      // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotAmplitude;                                      // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotAxis;                                           // 0x02C0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bContinuousRotation;                               // 0x02D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D9[0x3];                                      // 0x02D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScaleFrequency;                                    // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleAmplitude;                                    // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnlyUpdateWhenRendered;                            // 0x02E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E5[0x3];                                      // 0x02E5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateTransform();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceObjectSimpleAnimation">();
	}
	static class ARaceObjectSimpleAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARaceObjectSimpleAnimation>();
	}
};
static_assert(alignof(ARaceObjectSimpleAnimation) == 0x000008, "Wrong alignment on ARaceObjectSimpleAnimation");
static_assert(sizeof(ARaceObjectSimpleAnimation) == 0x0002E8, "Wrong size on ARaceObjectSimpleAnimation");
static_assert(offsetof(ARaceObjectSimpleAnimation, StaticMeshComponent) == 0x000290, "Member 'ARaceObjectSimpleAnimation::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(ARaceObjectSimpleAnimation, TransFrequency) == 0x000298, "Member 'ARaceObjectSimpleAnimation::TransFrequency' has a wrong offset!");
static_assert(offsetof(ARaceObjectSimpleAnimation, TransAmplitude) == 0x00029C, "Member 'ARaceObjectSimpleAnimation::TransAmplitude' has a wrong offset!");
static_assert(offsetof(ARaceObjectSimpleAnimation, TransAxis) == 0x0002A0, "Member 'ARaceObjectSimpleAnimation::TransAxis' has a wrong offset!");
static_assert(offsetof(ARaceObjectSimpleAnimation, RotFrequency) == 0x0002B8, "Member 'ARaceObjectSimpleAnimation::RotFrequency' has a wrong offset!");
static_assert(offsetof(ARaceObjectSimpleAnimation, RotAmplitude) == 0x0002BC, "Member 'ARaceObjectSimpleAnimation::RotAmplitude' has a wrong offset!");
static_assert(offsetof(ARaceObjectSimpleAnimation, RotAxis) == 0x0002C0, "Member 'ARaceObjectSimpleAnimation::RotAxis' has a wrong offset!");
static_assert(offsetof(ARaceObjectSimpleAnimation, bContinuousRotation) == 0x0002D8, "Member 'ARaceObjectSimpleAnimation::bContinuousRotation' has a wrong offset!");
static_assert(offsetof(ARaceObjectSimpleAnimation, ScaleFrequency) == 0x0002DC, "Member 'ARaceObjectSimpleAnimation::ScaleFrequency' has a wrong offset!");
static_assert(offsetof(ARaceObjectSimpleAnimation, ScaleAmplitude) == 0x0002E0, "Member 'ARaceObjectSimpleAnimation::ScaleAmplitude' has a wrong offset!");
static_assert(offsetof(ARaceObjectSimpleAnimation, OnlyUpdateWhenRendered) == 0x0002E4, "Member 'ARaceObjectSimpleAnimation::OnlyUpdateWhenRendered' has a wrong offset!");

// Class UnionRun.CollisionBaseComponent
// 0x00C0 (0x0350 - 0x0290)
class UCollisionBaseComponent : public UUnionSceneComponent
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EAttachmentType                               AttachmentType;                                    // 0x0298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsKinematic;                                      // 0x0299(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelfCollision;                              // 0x029A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bManualUpdate;                                     // 0x029B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActorScale;                                       // 0x029C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStaticBodyShapeType                          BodyType;                                          // 0x029D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29E[0x2];                                      // 0x029E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStaticBodySphereParam                 SphereParam;                                       // 0x02A0(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStaticBodyBoxParam                    BoxParam;                                          // 0x02A8(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FStaticBodyCylinderParam               CylinderParam;                                     // 0x02C0(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FStaticBodyCapsuleParam                CapsuleParam;                                      // 0x02C8(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LineThickness;                                     // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDomainNumber                                 DomainNumber;                                      // 0x02D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D5[0x7B];                                     // 0x02D5(0x007B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCollisionEnabled(bool bEnabled, bool bForceUpdate);
	void SetDomainNumber(EDomainNumber domain);
	void SetLocalScalingUE(const struct FVector& Scale);
	void SetOverrideTransform(const struct FTransform& trans);
	void UpdateCollisionShape();

	struct FVector GetLocalScalingUE() const;
	struct FTransform GetTransform() const;
	bool IsCollisionAvailable() const;
	bool IsCollisionEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollisionBaseComponent">();
	}
	static class UCollisionBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollisionBaseComponent>();
	}
};
static_assert(alignof(UCollisionBaseComponent) == 0x000010, "Wrong alignment on UCollisionBaseComponent");
static_assert(sizeof(UCollisionBaseComponent) == 0x000350, "Wrong size on UCollisionBaseComponent");
static_assert(offsetof(UCollisionBaseComponent, AttachmentType) == 0x000298, "Member 'UCollisionBaseComponent::AttachmentType' has a wrong offset!");
static_assert(offsetof(UCollisionBaseComponent, bIsKinematic) == 0x000299, "Member 'UCollisionBaseComponent::bIsKinematic' has a wrong offset!");
static_assert(offsetof(UCollisionBaseComponent, bIgnoreSelfCollision) == 0x00029A, "Member 'UCollisionBaseComponent::bIgnoreSelfCollision' has a wrong offset!");
static_assert(offsetof(UCollisionBaseComponent, bManualUpdate) == 0x00029B, "Member 'UCollisionBaseComponent::bManualUpdate' has a wrong offset!");
static_assert(offsetof(UCollisionBaseComponent, bActorScale) == 0x00029C, "Member 'UCollisionBaseComponent::bActorScale' has a wrong offset!");
static_assert(offsetof(UCollisionBaseComponent, BodyType) == 0x00029D, "Member 'UCollisionBaseComponent::BodyType' has a wrong offset!");
static_assert(offsetof(UCollisionBaseComponent, SphereParam) == 0x0002A0, "Member 'UCollisionBaseComponent::SphereParam' has a wrong offset!");
static_assert(offsetof(UCollisionBaseComponent, BoxParam) == 0x0002A8, "Member 'UCollisionBaseComponent::BoxParam' has a wrong offset!");
static_assert(offsetof(UCollisionBaseComponent, CylinderParam) == 0x0002C0, "Member 'UCollisionBaseComponent::CylinderParam' has a wrong offset!");
static_assert(offsetof(UCollisionBaseComponent, CapsuleParam) == 0x0002C8, "Member 'UCollisionBaseComponent::CapsuleParam' has a wrong offset!");
static_assert(offsetof(UCollisionBaseComponent, LineThickness) == 0x0002D0, "Member 'UCollisionBaseComponent::LineThickness' has a wrong offset!");
static_assert(offsetof(UCollisionBaseComponent, DomainNumber) == 0x0002D4, "Member 'UCollisionBaseComponent::DomainNumber' has a wrong offset!");

// Class UnionRun.CollisionMessageInterface
// 0x0000 (0x0000 - 0x0000)
class ICollisionMessageInterface final
{
public:
	void NotifyTriggerConflict(const struct FHitTriggerInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollisionMessageInterface">();
	}
	static class ICollisionMessageInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICollisionMessageInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ICollisionMessageInterface) == 0x000001, "Wrong alignment on ICollisionMessageInterface");
static_assert(sizeof(ICollisionMessageInterface) == 0x000001, "Wrong size on ICollisionMessageInterface");

// Class UnionRun.CourseDefinition
// 0x0000 (0x0028 - 0x0028)
class UCourseDefinition final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CourseDefinition">();
	}
	static class UCourseDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCourseDefinition>();
	}
};
static_assert(alignof(UCourseDefinition) == 0x000008, "Wrong alignment on UCourseDefinition");
static_assert(sizeof(UCourseDefinition) == 0x000028, "Wrong size on UCourseDefinition");

// Class UnionRun.RaceUISubPlayerName
// 0x0008 (0x02E8 - 0x02E0)
class URaceUISubPlayerName : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetGhostPfId();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceUISubPlayerName">();
	}
	static class URaceUISubPlayerName* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceUISubPlayerName>();
	}
};
static_assert(alignof(URaceUISubPlayerName) == 0x000008, "Wrong alignment on URaceUISubPlayerName");
static_assert(sizeof(URaceUISubPlayerName) == 0x0002E8, "Wrong size on URaceUISubPlayerName");

// Class UnionRun.CourseObjectAssetUserData
// 0x0008 (0x0030 - 0x0028)
class UCourseObjectAssetUserData final : public UAssetUserData
{
public:
	bool                                          bCourseObject;                                     // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBaseLap;                                          // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFinalLap;                                         // 0x002A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTimeTrial;                                        // 0x002B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecovery;                                         // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWallOnly;                                         // 0x002D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CourseObjectAssetUserData">();
	}
	static class UCourseObjectAssetUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCourseObjectAssetUserData>();
	}
};
static_assert(alignof(UCourseObjectAssetUserData) == 0x000008, "Wrong alignment on UCourseObjectAssetUserData");
static_assert(sizeof(UCourseObjectAssetUserData) == 0x000030, "Wrong size on UCourseObjectAssetUserData");
static_assert(offsetof(UCourseObjectAssetUserData, bCourseObject) == 0x000028, "Member 'UCourseObjectAssetUserData::bCourseObject' has a wrong offset!");
static_assert(offsetof(UCourseObjectAssetUserData, bBaseLap) == 0x000029, "Member 'UCourseObjectAssetUserData::bBaseLap' has a wrong offset!");
static_assert(offsetof(UCourseObjectAssetUserData, bFinalLap) == 0x00002A, "Member 'UCourseObjectAssetUserData::bFinalLap' has a wrong offset!");
static_assert(offsetof(UCourseObjectAssetUserData, bTimeTrial) == 0x00002B, "Member 'UCourseObjectAssetUserData::bTimeTrial' has a wrong offset!");
static_assert(offsetof(UCourseObjectAssetUserData, bRecovery) == 0x00002C, "Member 'UCourseObjectAssetUserData::bRecovery' has a wrong offset!");
static_assert(offsetof(UCourseObjectAssetUserData, bWallOnly) == 0x00002D, "Member 'UCourseObjectAssetUserData::bWallOnly' has a wrong offset!");

// Class UnionRun.ItemBlackBombBaseObject
// 0x0450 (0x09C0 - 0x0570)
class AItemBlackBombBaseObject : public AItemObjectBase
{
public:
	uint8                                         Pad_568[0x28];                                     // 0x0568(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        m_Root;                                            // 0x0590(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   m_staticMeshComponent;                             // 0x0598(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGOCMovement*                           m_movement;                                        // 0x05A0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTriggerComponent*                      m_trigger;                                         // 0x05A8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTriggerComponent*                      m_sensorTrigger;                                   // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemStaticBodyComponent*               m_staticBody;                                      // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_explosionEffect;                                 // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_rollSound;                                       // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_blinkSound;                                      // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_explosionSound;                                  // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_levelUpSound;                                    // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_explosionTime;                                   // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_sensorSize;                                      // 0x05EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_explosionSize;                                   // 0x05F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_explosionEffectSize;                             // 0x05F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        m_frontMoveSpeed_KPH;                              // 0x05F8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        m_backMoveSpeed_KPH;                               // 0x0608(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        m_fallSpeed_KPH;                                   // 0x0618(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        m_fallAcceleration_KPH;                            // 0x0628(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         m_throwFrontMoveCorrectionDistance;                // 0x0638(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRelativeMoveBackParameter             m_relativeMoveParamBack;                           // 0x063C(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          m_invincibleFromAttackItem;                        // 0x0654(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_canReflectWall;                                  // 0x0655(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_656[0x2];                                      // 0x0656(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        m_maxReflectNum;                                   // 0x0658(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_canBreakObject;                                  // 0x065C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_canCrushCar;                                     // 0x065D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65E[0x2];                                      // 0x065E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemSpeedParam                        m_boundHeight;                                     // 0x0660(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        m_boundGravity_KPH;                                // 0x0670(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         m_upgradeTime;                                     // 0x0680(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_explosionDamageTime;                             // 0x0684(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         m_blinkEmissiveMaterialIndex;                      // 0x0688(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_blinkEffectPower;                                // 0x068C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_blinkEffectSpeed;                                // 0x0690(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_blinkEffectSpeedFast;                            // 0x0694(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_normalBlinkEffectTime;                           // 0x0698(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_fastBlinkEffectTime;                             // 0x069C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             m_meshOffset;                                      // 0x06A0(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_scaleTimeFront;                                  // 0x0700(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_scaleMinFront;                                   // 0x0704(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_reflectMeshRadius;                               // 0x0708(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_reflectCenterHeightOffset;                       // 0x070C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_ignoreHolderTime;                                // 0x0710(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_rotateRatio;                                     // 0x0714(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_disableBoundTime;                                // 0x0718(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71C[0x4];                                      // 0x071C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCue*                          m_slowBlinkSoundCue;                               // 0x0720(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          m_fastBlinkSoundCue;                               // 0x0728(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          m_rollGroundSoundCue;                              // 0x0730(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          m_rollWaterSoundCue;                               // 0x0738(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_rollSoundRaycastInterval;                        // 0x0740(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_debugMoveControllerDraw;                         // 0x0744(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_745[0x27B];                                    // 0x0745(0x027B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTriggerConflict(const struct FHitTriggerInfo& HitInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemBlackBombBaseObject">();
	}
	static class AItemBlackBombBaseObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemBlackBombBaseObject>();
	}
};
static_assert(alignof(AItemBlackBombBaseObject) == 0x000010, "Wrong alignment on AItemBlackBombBaseObject");
static_assert(sizeof(AItemBlackBombBaseObject) == 0x0009C0, "Wrong size on AItemBlackBombBaseObject");
static_assert(offsetof(AItemBlackBombBaseObject, m_Root) == 0x000590, "Member 'AItemBlackBombBaseObject::m_Root' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_staticMeshComponent) == 0x000598, "Member 'AItemBlackBombBaseObject::m_staticMeshComponent' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_movement) == 0x0005A0, "Member 'AItemBlackBombBaseObject::m_movement' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_trigger) == 0x0005A8, "Member 'AItemBlackBombBaseObject::m_trigger' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_sensorTrigger) == 0x0005B0, "Member 'AItemBlackBombBaseObject::m_sensorTrigger' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_staticBody) == 0x0005B8, "Member 'AItemBlackBombBaseObject::m_staticBody' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_explosionEffect) == 0x0005C0, "Member 'AItemBlackBombBaseObject::m_explosionEffect' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_rollSound) == 0x0005C8, "Member 'AItemBlackBombBaseObject::m_rollSound' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_blinkSound) == 0x0005D0, "Member 'AItemBlackBombBaseObject::m_blinkSound' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_explosionSound) == 0x0005D8, "Member 'AItemBlackBombBaseObject::m_explosionSound' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_levelUpSound) == 0x0005E0, "Member 'AItemBlackBombBaseObject::m_levelUpSound' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_explosionTime) == 0x0005E8, "Member 'AItemBlackBombBaseObject::m_explosionTime' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_sensorSize) == 0x0005EC, "Member 'AItemBlackBombBaseObject::m_sensorSize' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_explosionSize) == 0x0005F0, "Member 'AItemBlackBombBaseObject::m_explosionSize' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_explosionEffectSize) == 0x0005F4, "Member 'AItemBlackBombBaseObject::m_explosionEffectSize' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_frontMoveSpeed_KPH) == 0x0005F8, "Member 'AItemBlackBombBaseObject::m_frontMoveSpeed_KPH' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_backMoveSpeed_KPH) == 0x000608, "Member 'AItemBlackBombBaseObject::m_backMoveSpeed_KPH' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_fallSpeed_KPH) == 0x000618, "Member 'AItemBlackBombBaseObject::m_fallSpeed_KPH' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_fallAcceleration_KPH) == 0x000628, "Member 'AItemBlackBombBaseObject::m_fallAcceleration_KPH' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_throwFrontMoveCorrectionDistance) == 0x000638, "Member 'AItemBlackBombBaseObject::m_throwFrontMoveCorrectionDistance' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_relativeMoveParamBack) == 0x00063C, "Member 'AItemBlackBombBaseObject::m_relativeMoveParamBack' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_invincibleFromAttackItem) == 0x000654, "Member 'AItemBlackBombBaseObject::m_invincibleFromAttackItem' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_canReflectWall) == 0x000655, "Member 'AItemBlackBombBaseObject::m_canReflectWall' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_maxReflectNum) == 0x000658, "Member 'AItemBlackBombBaseObject::m_maxReflectNum' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_canBreakObject) == 0x00065C, "Member 'AItemBlackBombBaseObject::m_canBreakObject' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_canCrushCar) == 0x00065D, "Member 'AItemBlackBombBaseObject::m_canCrushCar' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_boundHeight) == 0x000660, "Member 'AItemBlackBombBaseObject::m_boundHeight' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_boundGravity_KPH) == 0x000670, "Member 'AItemBlackBombBaseObject::m_boundGravity_KPH' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_upgradeTime) == 0x000680, "Member 'AItemBlackBombBaseObject::m_upgradeTime' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_explosionDamageTime) == 0x000684, "Member 'AItemBlackBombBaseObject::m_explosionDamageTime' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_blinkEmissiveMaterialIndex) == 0x000688, "Member 'AItemBlackBombBaseObject::m_blinkEmissiveMaterialIndex' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_blinkEffectPower) == 0x00068C, "Member 'AItemBlackBombBaseObject::m_blinkEffectPower' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_blinkEffectSpeed) == 0x000690, "Member 'AItemBlackBombBaseObject::m_blinkEffectSpeed' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_blinkEffectSpeedFast) == 0x000694, "Member 'AItemBlackBombBaseObject::m_blinkEffectSpeedFast' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_normalBlinkEffectTime) == 0x000698, "Member 'AItemBlackBombBaseObject::m_normalBlinkEffectTime' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_fastBlinkEffectTime) == 0x00069C, "Member 'AItemBlackBombBaseObject::m_fastBlinkEffectTime' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_meshOffset) == 0x0006A0, "Member 'AItemBlackBombBaseObject::m_meshOffset' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_scaleTimeFront) == 0x000700, "Member 'AItemBlackBombBaseObject::m_scaleTimeFront' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_scaleMinFront) == 0x000704, "Member 'AItemBlackBombBaseObject::m_scaleMinFront' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_reflectMeshRadius) == 0x000708, "Member 'AItemBlackBombBaseObject::m_reflectMeshRadius' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_reflectCenterHeightOffset) == 0x00070C, "Member 'AItemBlackBombBaseObject::m_reflectCenterHeightOffset' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_ignoreHolderTime) == 0x000710, "Member 'AItemBlackBombBaseObject::m_ignoreHolderTime' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_rotateRatio) == 0x000714, "Member 'AItemBlackBombBaseObject::m_rotateRatio' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_disableBoundTime) == 0x000718, "Member 'AItemBlackBombBaseObject::m_disableBoundTime' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_slowBlinkSoundCue) == 0x000720, "Member 'AItemBlackBombBaseObject::m_slowBlinkSoundCue' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_fastBlinkSoundCue) == 0x000728, "Member 'AItemBlackBombBaseObject::m_fastBlinkSoundCue' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_rollGroundSoundCue) == 0x000730, "Member 'AItemBlackBombBaseObject::m_rollGroundSoundCue' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_rollWaterSoundCue) == 0x000738, "Member 'AItemBlackBombBaseObject::m_rollWaterSoundCue' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_rollSoundRaycastInterval) == 0x000740, "Member 'AItemBlackBombBaseObject::m_rollSoundRaycastInterval' has a wrong offset!");
static_assert(offsetof(AItemBlackBombBaseObject, m_debugMoveControllerDraw) == 0x000744, "Member 'AItemBlackBombBaseObject::m_debugMoveControllerDraw' has a wrong offset!");

// Class UnionRun.ItemBlackBombLv1Object
// 0x0000 (0x09C0 - 0x09C0)
class AItemBlackBombLv1Object : public AItemBlackBombBaseObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemBlackBombLv1Object">();
	}
	static class AItemBlackBombLv1Object* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemBlackBombLv1Object>();
	}
};
static_assert(alignof(AItemBlackBombLv1Object) == 0x000010, "Wrong alignment on AItemBlackBombLv1Object");
static_assert(sizeof(AItemBlackBombLv1Object) == 0x0009C0, "Wrong size on AItemBlackBombLv1Object");

// Class UnionRun.CourseSequenceActorSpawner
// 0x0028 (0x0368 - 0x0340)
class ACourseSequenceActorSpawner final : public AUnionCourseObjectBase
{
public:
	TArray<struct FCourseSequenceSpawnActorInfo>  spawnActorInfo;                                    // 0x0340(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         spawnActors;                                       // 0x0350(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0360(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class AActor* GetSpawnActor(int32 Index_0);
	void PostSpawnSequenceActor();
	void SetSize(const struct FVector& Size);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CourseSequenceActorSpawner">();
	}
	static class ACourseSequenceActorSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACourseSequenceActorSpawner>();
	}
};
static_assert(alignof(ACourseSequenceActorSpawner) == 0x000008, "Wrong alignment on ACourseSequenceActorSpawner");
static_assert(sizeof(ACourseSequenceActorSpawner) == 0x000368, "Wrong size on ACourseSequenceActorSpawner");
static_assert(offsetof(ACourseSequenceActorSpawner, spawnActorInfo) == 0x000340, "Member 'ACourseSequenceActorSpawner::spawnActorInfo' has a wrong offset!");
static_assert(offsetof(ACourseSequenceActorSpawner, spawnActors) == 0x000350, "Member 'ACourseSequenceActorSpawner::spawnActors' has a wrong offset!");
static_assert(offsetof(ACourseSequenceActorSpawner, DefaultSceneRoot) == 0x000360, "Member 'ACourseSequenceActorSpawner::DefaultSceneRoot' has a wrong offset!");

// Class UnionRun.DancingBoo
// 0x0170 (0x0400 - 0x0290)
class alignas(0x10) ADancingBoo final : public AActor
{
public:
	class USceneComponent*                        SceneRoot;                                         // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionVATAnimEventComponent*            MeshA1;                                            // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionVATAnimEventComponent*            MeshA2;                                            // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionVATAnimEventComponent*            MeshB1;                                            // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionVATAnimEventComponent*            MeshB2;                                            // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionVATAnimEventComponent*            MeshC1;                                            // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionVATAnimEventComponent*            MeshC2;                                            // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BoomStroke;                                        // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotationDeg;                                       // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveSpeed;                                         // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D4[0x12C];                                    // 0x02D4(0x012C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DancingBoo">();
	}
	static class ADancingBoo* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADancingBoo>();
	}
};
static_assert(alignof(ADancingBoo) == 0x000010, "Wrong alignment on ADancingBoo");
static_assert(sizeof(ADancingBoo) == 0x000400, "Wrong size on ADancingBoo");
static_assert(offsetof(ADancingBoo, SceneRoot) == 0x000290, "Member 'ADancingBoo::SceneRoot' has a wrong offset!");
static_assert(offsetof(ADancingBoo, MeshA1) == 0x000298, "Member 'ADancingBoo::MeshA1' has a wrong offset!");
static_assert(offsetof(ADancingBoo, MeshA2) == 0x0002A0, "Member 'ADancingBoo::MeshA2' has a wrong offset!");
static_assert(offsetof(ADancingBoo, MeshB1) == 0x0002A8, "Member 'ADancingBoo::MeshB1' has a wrong offset!");
static_assert(offsetof(ADancingBoo, MeshB2) == 0x0002B0, "Member 'ADancingBoo::MeshB2' has a wrong offset!");
static_assert(offsetof(ADancingBoo, MeshC1) == 0x0002B8, "Member 'ADancingBoo::MeshC1' has a wrong offset!");
static_assert(offsetof(ADancingBoo, MeshC2) == 0x0002C0, "Member 'ADancingBoo::MeshC2' has a wrong offset!");
static_assert(offsetof(ADancingBoo, BoomStroke) == 0x0002C8, "Member 'ADancingBoo::BoomStroke' has a wrong offset!");
static_assert(offsetof(ADancingBoo, RotationDeg) == 0x0002CC, "Member 'ADancingBoo::RotationDeg' has a wrong offset!");
static_assert(offsetof(ADancingBoo, MoveSpeed) == 0x0002D0, "Member 'ADancingBoo::MoveSpeed' has a wrong offset!");

// Class UnionRun.DarkGaiaPhoenixAnimInstance
// 0x0000 (0x0370 - 0x0370)
class UDarkGaiaPhoenixAnimInstance final : public UEnemyAnimInstance
{
public:
	bool                                          bIsPhase1Attack;                                   // 0x0368(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPhase2Move;                                     // 0x0369(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPhase3Move;                                     // 0x036A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPhase3Attack;                                   // 0x036B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPhase3Mirror;                                   // 0x036C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36D[0x3];                                      // 0x036D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetIsPhase1Attack();
	bool GetIsPhase2Move();
	bool GetIsPhase3Attack();
	bool GetIsPhase3Mirror();
	bool GetIsPhase3Move();
	void SetIsPhase1Attack(bool flag);
	void SetIsPhase2Move(bool flag);
	void SetIsPhase3Attack(bool flag);
	void SetIsPhase3Mirror(bool flag);
	void SetIsPhase3Move(bool flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarkGaiaPhoenixAnimInstance">();
	}
	static class UDarkGaiaPhoenixAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarkGaiaPhoenixAnimInstance>();
	}
};
static_assert(alignof(UDarkGaiaPhoenixAnimInstance) == 0x000010, "Wrong alignment on UDarkGaiaPhoenixAnimInstance");
static_assert(sizeof(UDarkGaiaPhoenixAnimInstance) == 0x000370, "Wrong size on UDarkGaiaPhoenixAnimInstance");
static_assert(offsetof(UDarkGaiaPhoenixAnimInstance, bIsPhase1Attack) == 0x000368, "Member 'UDarkGaiaPhoenixAnimInstance::bIsPhase1Attack' has a wrong offset!");
static_assert(offsetof(UDarkGaiaPhoenixAnimInstance, bIsPhase2Move) == 0x000369, "Member 'UDarkGaiaPhoenixAnimInstance::bIsPhase2Move' has a wrong offset!");
static_assert(offsetof(UDarkGaiaPhoenixAnimInstance, bIsPhase3Move) == 0x00036A, "Member 'UDarkGaiaPhoenixAnimInstance::bIsPhase3Move' has a wrong offset!");
static_assert(offsetof(UDarkGaiaPhoenixAnimInstance, bIsPhase3Attack) == 0x00036B, "Member 'UDarkGaiaPhoenixAnimInstance::bIsPhase3Attack' has a wrong offset!");
static_assert(offsetof(UDarkGaiaPhoenixAnimInstance, bIsPhase3Mirror) == 0x00036C, "Member 'UDarkGaiaPhoenixAnimInstance::bIsPhase3Mirror' has a wrong offset!");

// Class UnionRun.RaceTestManager
// 0x0040 (0x0068 - 0x0028)
class URaceTestManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URaceTestConfig*                        m_config;                                          // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             m_itemTable;                                       // 0x0038(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         m_StageOpenedInfo;                                 // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceTestManager">();
	}
	static class URaceTestManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceTestManager>();
	}
};
static_assert(alignof(URaceTestManager) == 0x000008, "Wrong alignment on URaceTestManager");
static_assert(sizeof(URaceTestManager) == 0x000068, "Wrong size on URaceTestManager");
static_assert(offsetof(URaceTestManager, m_config) == 0x000030, "Member 'URaceTestManager::m_config' has a wrong offset!");
static_assert(offsetof(URaceTestManager, m_itemTable) == 0x000038, "Member 'URaceTestManager::m_itemTable' has a wrong offset!");
static_assert(offsetof(URaceTestManager, m_StageOpenedInfo) == 0x000058, "Member 'URaceTestManager::m_StageOpenedInfo' has a wrong offset!");

// Class UnionRun.GimmickMagmaDrop
// 0x0150 (0x0700 - 0x05B0)
class alignas(0x10) AGimmickMagmaDrop final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionVATMeshComponent*                 m_dropRootVATMesh;                                 // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        m_dropLocator;                                     // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionVATMeshComponent*                 m_dropVATMesh;                                     // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticBodyComponent*                   m_dropBody;                                        // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        m_puddleRoot;                                      // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              m_puddleMesh;                                      // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticBodyComponent*                   m_puddleBody;                                      // 0x05E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_dropSound;                                       // 0x05F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_collisionSound;                                  // 0x05F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_ignorePuddle;                                    // 0x0600(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_601[0x3];                                      // 0x0601(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_initialDelay;                                    // 0x0604(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_dropInterval;                                    // 0x0608(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_dropSpeed;                                       // 0x060C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_puddleLifeTime;                                  // 0x0610(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERacerDamageType                              m_damageType;                                      // 0x0614(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_615[0x3];                                      // 0x0615(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_searchPuddlePointDistanceLimit;                  // 0x0618(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_ignorePuddleDropDistance;                        // 0x061C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_puddleEmissiveStrengthMin;                       // 0x0620(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_puddleEmissiveStrengthTimeToMin;                 // 0x0624(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_puddleEmissiveStrengthMax;                       // 0x0628(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_puddleEmissiveStrengthTimeToMax;                 // 0x062C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_dropEmissiveValue;                               // 0x0630(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_dropEmissiveChangeTime;                          // 0x0634(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_dropEmissiveKeepTime;                            // 0x0638(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_dropEmissiveRevertTime;                          // 0x063C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_beforeDropEmissiveWithRoot;                      // 0x0640(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_641[0x3];                                      // 0x0641(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_icicleBaseAnimTime;                              // 0x0644(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         m_dropedFrame;                                     // 0x0648(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_debugSearchPuddlePointEvery;                     // 0x064C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64D[0x3];                                      // 0x064D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0650(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_658[0xA8];                                     // 0x0658(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickMagmaDrop">();
	}
	static class AGimmickMagmaDrop* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickMagmaDrop>();
	}
};
static_assert(alignof(AGimmickMagmaDrop) == 0x000010, "Wrong alignment on AGimmickMagmaDrop");
static_assert(sizeof(AGimmickMagmaDrop) == 0x000700, "Wrong size on AGimmickMagmaDrop");
static_assert(offsetof(AGimmickMagmaDrop, m_dropRootVATMesh) == 0x0005B8, "Member 'AGimmickMagmaDrop::m_dropRootVATMesh' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, m_dropLocator) == 0x0005C0, "Member 'AGimmickMagmaDrop::m_dropLocator' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, m_dropVATMesh) == 0x0005C8, "Member 'AGimmickMagmaDrop::m_dropVATMesh' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, m_dropBody) == 0x0005D0, "Member 'AGimmickMagmaDrop::m_dropBody' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, m_puddleRoot) == 0x0005D8, "Member 'AGimmickMagmaDrop::m_puddleRoot' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, m_puddleMesh) == 0x0005E0, "Member 'AGimmickMagmaDrop::m_puddleMesh' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, m_puddleBody) == 0x0005E8, "Member 'AGimmickMagmaDrop::m_puddleBody' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, m_dropSound) == 0x0005F0, "Member 'AGimmickMagmaDrop::m_dropSound' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, m_collisionSound) == 0x0005F8, "Member 'AGimmickMagmaDrop::m_collisionSound' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, m_ignorePuddle) == 0x000600, "Member 'AGimmickMagmaDrop::m_ignorePuddle' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, m_initialDelay) == 0x000604, "Member 'AGimmickMagmaDrop::m_initialDelay' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, m_dropInterval) == 0x000608, "Member 'AGimmickMagmaDrop::m_dropInterval' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, m_dropSpeed) == 0x00060C, "Member 'AGimmickMagmaDrop::m_dropSpeed' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, m_puddleLifeTime) == 0x000610, "Member 'AGimmickMagmaDrop::m_puddleLifeTime' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, m_damageType) == 0x000614, "Member 'AGimmickMagmaDrop::m_damageType' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, m_searchPuddlePointDistanceLimit) == 0x000618, "Member 'AGimmickMagmaDrop::m_searchPuddlePointDistanceLimit' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, m_ignorePuddleDropDistance) == 0x00061C, "Member 'AGimmickMagmaDrop::m_ignorePuddleDropDistance' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, m_puddleEmissiveStrengthMin) == 0x000620, "Member 'AGimmickMagmaDrop::m_puddleEmissiveStrengthMin' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, m_puddleEmissiveStrengthTimeToMin) == 0x000624, "Member 'AGimmickMagmaDrop::m_puddleEmissiveStrengthTimeToMin' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, m_puddleEmissiveStrengthMax) == 0x000628, "Member 'AGimmickMagmaDrop::m_puddleEmissiveStrengthMax' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, m_puddleEmissiveStrengthTimeToMax) == 0x00062C, "Member 'AGimmickMagmaDrop::m_puddleEmissiveStrengthTimeToMax' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, m_dropEmissiveValue) == 0x000630, "Member 'AGimmickMagmaDrop::m_dropEmissiveValue' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, m_dropEmissiveChangeTime) == 0x000634, "Member 'AGimmickMagmaDrop::m_dropEmissiveChangeTime' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, m_dropEmissiveKeepTime) == 0x000638, "Member 'AGimmickMagmaDrop::m_dropEmissiveKeepTime' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, m_dropEmissiveRevertTime) == 0x00063C, "Member 'AGimmickMagmaDrop::m_dropEmissiveRevertTime' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, m_beforeDropEmissiveWithRoot) == 0x000640, "Member 'AGimmickMagmaDrop::m_beforeDropEmissiveWithRoot' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, m_icicleBaseAnimTime) == 0x000644, "Member 'AGimmickMagmaDrop::m_icicleBaseAnimTime' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, m_dropedFrame) == 0x000648, "Member 'AGimmickMagmaDrop::m_dropedFrame' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, m_debugSearchPuddlePointEvery) == 0x00064C, "Member 'AGimmickMagmaDrop::m_debugSearchPuddlePointEvery' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaDrop, DefaultSceneRoot) == 0x000650, "Member 'AGimmickMagmaDrop::DefaultSceneRoot' has a wrong offset!");

// Class UnionRun.DeathEggAnimInstance
// 0x0000 (0x0370 - 0x0370)
class UDeathEggAnimInstance final : public UEnemyAnimInstance
{
public:
	void OnEnterPubchLoop();
	void OnEnterWait();

	bool IsPunchState(EDeathEggState State) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathEggAnimInstance">();
	}
	static class UDeathEggAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeathEggAnimInstance>();
	}
};
static_assert(alignof(UDeathEggAnimInstance) == 0x000010, "Wrong alignment on UDeathEggAnimInstance");
static_assert(sizeof(UDeathEggAnimInstance) == 0x000370, "Wrong size on UDeathEggAnimInstance");

// Class UnionRun.PackageRingInstanceObject
// 0x0120 (0x0460 - 0x0340)
class alignas(0x10) APackageRingInstanceObject final : public AUnionCourseObjectBase
{
public:
	EPackageRingType                              m_packageRingType;                                 // 0x0340(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_341[0x7];                                      // 0x0341(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHierarchicalInstancedStaticMeshComponent* m_hismDomain0;                                  // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHierarchicalInstancedStaticMeshComponent* m_hismDomain1;                                  // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHierarchicalInstancedStaticMeshComponent* m_hismDomain2;                                  // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHierarchicalInstancedStaticMeshComponent* m_hismDomain3;                                  // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0368(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_370[0xF0];                                     // 0x0370(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PackageRingInstanceObject">();
	}
	static class APackageRingInstanceObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<APackageRingInstanceObject>();
	}
};
static_assert(alignof(APackageRingInstanceObject) == 0x000010, "Wrong alignment on APackageRingInstanceObject");
static_assert(sizeof(APackageRingInstanceObject) == 0x000460, "Wrong size on APackageRingInstanceObject");
static_assert(offsetof(APackageRingInstanceObject, m_packageRingType) == 0x000340, "Member 'APackageRingInstanceObject::m_packageRingType' has a wrong offset!");
static_assert(offsetof(APackageRingInstanceObject, m_hismDomain0) == 0x000348, "Member 'APackageRingInstanceObject::m_hismDomain0' has a wrong offset!");
static_assert(offsetof(APackageRingInstanceObject, m_hismDomain1) == 0x000350, "Member 'APackageRingInstanceObject::m_hismDomain1' has a wrong offset!");
static_assert(offsetof(APackageRingInstanceObject, m_hismDomain2) == 0x000358, "Member 'APackageRingInstanceObject::m_hismDomain2' has a wrong offset!");
static_assert(offsetof(APackageRingInstanceObject, m_hismDomain3) == 0x000360, "Member 'APackageRingInstanceObject::m_hismDomain3' has a wrong offset!");
static_assert(offsetof(APackageRingInstanceObject, DefaultSceneRoot) == 0x000368, "Member 'APackageRingInstanceObject::DefaultSceneRoot' has a wrong offset!");

// Class UnionRun.DebugItemMenu
// 0x0058 (0x0080 - 0x0028)
class UDebugItemMenu final : public UObject
{
public:
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugItemMenu">();
	}
	static class UDebugItemMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugItemMenu>();
	}
};
static_assert(alignof(UDebugItemMenu) == 0x000008, "Wrong alignment on UDebugItemMenu");
static_assert(sizeof(UDebugItemMenu) == 0x000080, "Wrong size on UDebugItemMenu");

// Class UnionRun.DroppedObjectBase
// 0x0008 (0x0348 - 0x0340)
class ADroppedObjectBase : public AUnionCourseObjectBase
{
public:
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0340(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DroppedObjectBase">();
	}
	static class ADroppedObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADroppedObjectBase>();
	}
};
static_assert(alignof(ADroppedObjectBase) == 0x000008, "Wrong alignment on ADroppedObjectBase");
static_assert(sizeof(ADroppedObjectBase) == 0x000348, "Wrong size on ADroppedObjectBase");
static_assert(offsetof(ADroppedObjectBase, DefaultSceneRoot) == 0x000340, "Member 'ADroppedObjectBase::DefaultSceneRoot' has a wrong offset!");

// Class UnionRun.DroppedItemBox
// 0x0388 (0x06D0 - 0x0348)
class alignas(0x10) ADroppedItemBox final : public ADroppedObjectBase
{
public:
	uint8                                         Pad_348[0x30];                                     // 0x0348(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UGOCMovement*                           Movement;                                          // 0x0378(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticBodyComponent*                   BodyCollision;                                     // 0x0380(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      HitEffect;                                         // 0x0388(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    SpawnSound;                                        // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    HitSound;                                          // 0x0398(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTime;                                          // 0x03A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CountDownTime;                                     // 0x03A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionEnableTime_Owner;                         // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionEnableTime_Other;                         // 0x03AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemboxRelativeMoveParameter          RelativeMoveParam;                                 // 0x03B0(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FThrowingBackParameter                 DropParam;                                         // 0x03D8(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E4[0x4];                                      // 0x03E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCue*                          NormalSpawnSound;                                  // 0x03E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          DoubleSpawnSound;                                  // 0x03F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          NormalHitSound;                                    // 0x03F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          DoubleHitSound;                                    // 0x0400(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_408[0x28C];                                    // 0x0408(0x028C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_blinkIntervalTime;                               // 0x0694(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                m_doubleBoxScale;                                  // 0x0698(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         m_radius;                                          // 0x06B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         m_restitutionCoffi;                                // 0x06B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         m_sinkLength;                                      // 0x06B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6BC[0x14];                                     // 0x06BC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DroppedItemBox">();
	}
	static class ADroppedItemBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADroppedItemBox>();
	}
};
static_assert(alignof(ADroppedItemBox) == 0x000010, "Wrong alignment on ADroppedItemBox");
static_assert(sizeof(ADroppedItemBox) == 0x0006D0, "Wrong size on ADroppedItemBox");
static_assert(offsetof(ADroppedItemBox, Movement) == 0x000378, "Member 'ADroppedItemBox::Movement' has a wrong offset!");
static_assert(offsetof(ADroppedItemBox, BodyCollision) == 0x000380, "Member 'ADroppedItemBox::BodyCollision' has a wrong offset!");
static_assert(offsetof(ADroppedItemBox, HitEffect) == 0x000388, "Member 'ADroppedItemBox::HitEffect' has a wrong offset!");
static_assert(offsetof(ADroppedItemBox, SpawnSound) == 0x000390, "Member 'ADroppedItemBox::SpawnSound' has a wrong offset!");
static_assert(offsetof(ADroppedItemBox, HitSound) == 0x000398, "Member 'ADroppedItemBox::HitSound' has a wrong offset!");
static_assert(offsetof(ADroppedItemBox, LifeTime) == 0x0003A0, "Member 'ADroppedItemBox::LifeTime' has a wrong offset!");
static_assert(offsetof(ADroppedItemBox, CountDownTime) == 0x0003A4, "Member 'ADroppedItemBox::CountDownTime' has a wrong offset!");
static_assert(offsetof(ADroppedItemBox, CollisionEnableTime_Owner) == 0x0003A8, "Member 'ADroppedItemBox::CollisionEnableTime_Owner' has a wrong offset!");
static_assert(offsetof(ADroppedItemBox, CollisionEnableTime_Other) == 0x0003AC, "Member 'ADroppedItemBox::CollisionEnableTime_Other' has a wrong offset!");
static_assert(offsetof(ADroppedItemBox, RelativeMoveParam) == 0x0003B0, "Member 'ADroppedItemBox::RelativeMoveParam' has a wrong offset!");
static_assert(offsetof(ADroppedItemBox, DropParam) == 0x0003D8, "Member 'ADroppedItemBox::DropParam' has a wrong offset!");
static_assert(offsetof(ADroppedItemBox, NormalSpawnSound) == 0x0003E8, "Member 'ADroppedItemBox::NormalSpawnSound' has a wrong offset!");
static_assert(offsetof(ADroppedItemBox, DoubleSpawnSound) == 0x0003F0, "Member 'ADroppedItemBox::DoubleSpawnSound' has a wrong offset!");
static_assert(offsetof(ADroppedItemBox, NormalHitSound) == 0x0003F8, "Member 'ADroppedItemBox::NormalHitSound' has a wrong offset!");
static_assert(offsetof(ADroppedItemBox, DoubleHitSound) == 0x000400, "Member 'ADroppedItemBox::DoubleHitSound' has a wrong offset!");
static_assert(offsetof(ADroppedItemBox, m_blinkIntervalTime) == 0x000694, "Member 'ADroppedItemBox::m_blinkIntervalTime' has a wrong offset!");
static_assert(offsetof(ADroppedItemBox, m_doubleBoxScale) == 0x000698, "Member 'ADroppedItemBox::m_doubleBoxScale' has a wrong offset!");
static_assert(offsetof(ADroppedItemBox, m_radius) == 0x0006B0, "Member 'ADroppedItemBox::m_radius' has a wrong offset!");
static_assert(offsetof(ADroppedItemBox, m_restitutionCoffi) == 0x0006B4, "Member 'ADroppedItemBox::m_restitutionCoffi' has a wrong offset!");
static_assert(offsetof(ADroppedItemBox, m_sinkLength) == 0x0006B8, "Member 'ADroppedItemBox::m_sinkLength' has a wrong offset!");

// Class UnionRun.RaceUISubTimeTrialTimeLap
// 0x0038 (0x0318 - 0x02E0)
class URaceUISubTimeTrialTimeLap : public UUserWidget
{
public:
	TArray<class UImage*>                         NumberArr;                                         // 0x02E0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	class UTextBlock*                             TxtSign;                                           // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URichTextBlock*                         TxtDiff;                                           // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            BaseDiff;                                          // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBorder*                                BorderNum;                                         // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBorder*                                BorderDiff;                                        // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetLapDiffTime(int32 LapNum);
	void SetLapTime(const struct FRaceUITimeTrialTime& NewTime, int32 Lap);
	void SetLapTimeIsGhostReplay(int32 Lap);
	void SetLapTimeWithDiff(const struct FRaceUITimeTrialTime& NewTime, int32 Lap, bool IsVisibleDiff);
	struct FRaceUITimeTrialTime UpdateLapTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceUISubTimeTrialTimeLap">();
	}
	static class URaceUISubTimeTrialTimeLap* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceUISubTimeTrialTimeLap>();
	}
};
static_assert(alignof(URaceUISubTimeTrialTimeLap) == 0x000008, "Wrong alignment on URaceUISubTimeTrialTimeLap");
static_assert(sizeof(URaceUISubTimeTrialTimeLap) == 0x000318, "Wrong size on URaceUISubTimeTrialTimeLap");
static_assert(offsetof(URaceUISubTimeTrialTimeLap, NumberArr) == 0x0002E0, "Member 'URaceUISubTimeTrialTimeLap::NumberArr' has a wrong offset!");
static_assert(offsetof(URaceUISubTimeTrialTimeLap, TxtSign) == 0x0002F0, "Member 'URaceUISubTimeTrialTimeLap::TxtSign' has a wrong offset!");
static_assert(offsetof(URaceUISubTimeTrialTimeLap, TxtDiff) == 0x0002F8, "Member 'URaceUISubTimeTrialTimeLap::TxtDiff' has a wrong offset!");
static_assert(offsetof(URaceUISubTimeTrialTimeLap, BaseDiff) == 0x000300, "Member 'URaceUISubTimeTrialTimeLap::BaseDiff' has a wrong offset!");
static_assert(offsetof(URaceUISubTimeTrialTimeLap, BorderNum) == 0x000308, "Member 'URaceUISubTimeTrialTimeLap::BorderNum' has a wrong offset!");
static_assert(offsetof(URaceUISubTimeTrialTimeLap, BorderDiff) == 0x000310, "Member 'URaceUISubTimeTrialTimeLap::BorderDiff' has a wrong offset!");

// Class UnionRun.DroppedItemBoxFactory
// 0x00C0 (0x0350 - 0x0290)
class alignas(0x10) ADroppedItemBoxFactory final : public AActor
{
public:
	class UHierarchicalInstancedStaticMeshComponent* m_hismNormal;                                   // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHierarchicalInstancedStaticMeshComponent* m_hismDouble;                                   // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHierarchicalInstancedStaticMeshComponent* m_hismSpecial;                                  // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxAliveItemBoxNum;                                // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ADroppedItemBox>            DroppedItemBoxClass;                               // 0x02B0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ADroppedItemBox*>                m_droppedItemBoxs;                                 // 0x02B8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0x88];                                     // 0x02C8(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DroppedItemBoxFactory">();
	}
	static class ADroppedItemBoxFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADroppedItemBoxFactory>();
	}
};
static_assert(alignof(ADroppedItemBoxFactory) == 0x000010, "Wrong alignment on ADroppedItemBoxFactory");
static_assert(sizeof(ADroppedItemBoxFactory) == 0x000350, "Wrong size on ADroppedItemBoxFactory");
static_assert(offsetof(ADroppedItemBoxFactory, m_hismNormal) == 0x000290, "Member 'ADroppedItemBoxFactory::m_hismNormal' has a wrong offset!");
static_assert(offsetof(ADroppedItemBoxFactory, m_hismDouble) == 0x000298, "Member 'ADroppedItemBoxFactory::m_hismDouble' has a wrong offset!");
static_assert(offsetof(ADroppedItemBoxFactory, m_hismSpecial) == 0x0002A0, "Member 'ADroppedItemBoxFactory::m_hismSpecial' has a wrong offset!");
static_assert(offsetof(ADroppedItemBoxFactory, MaxAliveItemBoxNum) == 0x0002A8, "Member 'ADroppedItemBoxFactory::MaxAliveItemBoxNum' has a wrong offset!");
static_assert(offsetof(ADroppedItemBoxFactory, DroppedItemBoxClass) == 0x0002B0, "Member 'ADroppedItemBoxFactory::DroppedItemBoxClass' has a wrong offset!");
static_assert(offsetof(ADroppedItemBoxFactory, m_droppedItemBoxs) == 0x0002B8, "Member 'ADroppedItemBoxFactory::m_droppedItemBoxs' has a wrong offset!");

// Class UnionRun.ItemBoxObject
// 0x02C0 (0x0600 - 0x0340)
class AItemBoxObject final : public AUnionCourseObjectBase
{
public:
	uint8                                         Pad_340[0x10];                                     // 0x0340(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EItemBoxType                                  ItemBoxType;                                       // 0x0350(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ChangeItemBoxType;                                 // 0x0351(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemId                                       SpecifiedItem;                                     // 0x0352(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_353[0x1];                                      // 0x0353(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitVelocity;                                       // 0x0354(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitDirection;                                      // 0x0358(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemBoxColliderParam                  _ColliderParam;                                    // 0x0370(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemBoxColliderParam                  _DoubleBoxColliderParam;                           // 0x03A0(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemBoxColliderParam                  _SpecialBoxColliderParam;                          // 0x03D0(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoundingItemBoxColliderParam          _BoundingColliderParam;                            // 0x0400(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class URelocationMovement*                    RelocationMovement;                                // 0x0430(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShadowValid;                                      // 0x0438(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_439[0x7];                                      // 0x0439(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             shadowTransform;                                   // 0x0440(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         shadowHeightOffset;                                // 0x04A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetModelHeight;                                 // 0x04A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelocationWaitTimeToNormal;                        // 0x04A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelocationWaitTimeToRankMatch;                     // 0x04AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelocationWaitTimeToLegendMatch;                   // 0x04B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelocationWaitTimeToFesta;                         // 0x04B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelocationWaitTimeToFriendMatch;                   // 0x04B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RelocationWaitTimeToLocalCommunication;            // 0x04BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAutoToggleEnable;                               // 0x04C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C1[0x3];                                      // 0x04C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoEnableStartTime;                               // 0x04C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoDisableTime;                                   // 0x04C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoEnableTime;                                    // 0x04CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseEventStart;                                     // 0x04D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D1[0x7];                                      // 0x04D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x04D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticBodyComponent*                   StaticBodyComponent;                               // 0x04E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      NiagaraEffect;                                     // 0x04E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F0[0x108];                                    // 0x04F0(0x0108)(Fixing Size After Last Property [ Dumper-7 ])
	ESpecialObjGroup                              m_SpecialGroup;                                    // 0x05F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F9[0x3];                                      // 0x05F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TimeTrialIndex;                                    // 0x05FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnChangeItemBox(EItemBoxType ItemBoxType_0);
	void OnHitRacer(int32 RacerIndex);
	void OnPlayForceFeedback(int32 LocalPlayerIndex);
	void OnPlayTakeSound();
	void OnStartRelocation();
	void SetItemBoxType(EItemBoxType Type);
	void SetSpecifiedItem(EItemId Item);

	ESoundPan GetSoundPan() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemBoxObject">();
	}
	static class AItemBoxObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemBoxObject>();
	}
};
static_assert(alignof(AItemBoxObject) == 0x000010, "Wrong alignment on AItemBoxObject");
static_assert(sizeof(AItemBoxObject) == 0x000600, "Wrong size on AItemBoxObject");
static_assert(offsetof(AItemBoxObject, ItemBoxType) == 0x000350, "Member 'AItemBoxObject::ItemBoxType' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, ChangeItemBoxType) == 0x000351, "Member 'AItemBoxObject::ChangeItemBoxType' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, SpecifiedItem) == 0x000352, "Member 'AItemBoxObject::SpecifiedItem' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, HitVelocity) == 0x000354, "Member 'AItemBoxObject::HitVelocity' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, HitDirection) == 0x000358, "Member 'AItemBoxObject::HitDirection' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, _ColliderParam) == 0x000370, "Member 'AItemBoxObject::_ColliderParam' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, _DoubleBoxColliderParam) == 0x0003A0, "Member 'AItemBoxObject::_DoubleBoxColliderParam' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, _SpecialBoxColliderParam) == 0x0003D0, "Member 'AItemBoxObject::_SpecialBoxColliderParam' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, _BoundingColliderParam) == 0x000400, "Member 'AItemBoxObject::_BoundingColliderParam' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, RelocationMovement) == 0x000430, "Member 'AItemBoxObject::RelocationMovement' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, bShadowValid) == 0x000438, "Member 'AItemBoxObject::bShadowValid' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, shadowTransform) == 0x000440, "Member 'AItemBoxObject::shadowTransform' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, shadowHeightOffset) == 0x0004A0, "Member 'AItemBoxObject::shadowHeightOffset' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, OffsetModelHeight) == 0x0004A4, "Member 'AItemBoxObject::OffsetModelHeight' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, RelocationWaitTimeToNormal) == 0x0004A8, "Member 'AItemBoxObject::RelocationWaitTimeToNormal' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, RelocationWaitTimeToRankMatch) == 0x0004AC, "Member 'AItemBoxObject::RelocationWaitTimeToRankMatch' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, RelocationWaitTimeToLegendMatch) == 0x0004B0, "Member 'AItemBoxObject::RelocationWaitTimeToLegendMatch' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, RelocationWaitTimeToFesta) == 0x0004B4, "Member 'AItemBoxObject::RelocationWaitTimeToFesta' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, RelocationWaitTimeToFriendMatch) == 0x0004B8, "Member 'AItemBoxObject::RelocationWaitTimeToFriendMatch' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, RelocationWaitTimeToLocalCommunication) == 0x0004BC, "Member 'AItemBoxObject::RelocationWaitTimeToLocalCommunication' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, bIsAutoToggleEnable) == 0x0004C0, "Member 'AItemBoxObject::bIsAutoToggleEnable' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, AutoEnableStartTime) == 0x0004C4, "Member 'AItemBoxObject::AutoEnableStartTime' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, AutoDisableTime) == 0x0004C8, "Member 'AItemBoxObject::AutoDisableTime' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, AutoEnableTime) == 0x0004CC, "Member 'AItemBoxObject::AutoEnableTime' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, UseEventStart) == 0x0004D0, "Member 'AItemBoxObject::UseEventStart' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, DefaultSceneRoot) == 0x0004D8, "Member 'AItemBoxObject::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, StaticBodyComponent) == 0x0004E0, "Member 'AItemBoxObject::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, NiagaraEffect) == 0x0004E8, "Member 'AItemBoxObject::NiagaraEffect' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, m_SpecialGroup) == 0x0005F8, "Member 'AItemBoxObject::m_SpecialGroup' has a wrong offset!");
static_assert(offsetof(AItemBoxObject, TimeTrialIndex) == 0x0005FC, "Member 'AItemBoxObject::TimeTrialIndex' has a wrong offset!");

// Class UnionRun.DroppedRingFactory
// 0x0BB0 (0x0E40 - 0x0290)
class ADroppedRingFactory final : public AActor
{
public:
	struct FDroppedRingPlacementInfo              m_landHighRanker_RingHold_01_50;                   // 0x0290(0x001C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FDroppedRingPlacementInfo              m_landHighRanker_RingHold_51_100;                  // 0x02AC(0x001C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FDroppedRingPlacementInfo              m_landLowRanker;                                   // 0x02C8(0x001C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FDroppedRingPlacementInfo              m_flyHighRanker;                                   // 0x02E4(0x001C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FDroppedRingPlacementInfo              m_flyLowRanker;                                    // 0x0300(0x001C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FDroppedRingPlacementInfo              m_placementInfoGimmick;                            // 0x031C(0x001C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FDroppedRingLandJumpParameter          m_landJumpHighRanker_RingHold_01_50;               // 0x0338(0x0024)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FDroppedRingLandJumpParameter          m_landJumpHighRanker_RingHold_51_100;              // 0x035C(0x0024)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FDroppedRingLandJumpParameter          m_landJumpLowRanker;                               // 0x0380(0x0024)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FDroppedRingSkyJumpParameter           m_flyJumpHighRanker;                               // 0x03A4(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FDroppedRingSkyJumpParameter           m_flyJumpLowRanker;                                // 0x03BC(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FDroppedRingLandJumpParameter          m_jumpParamGimmick;                                // 0x03D4(0x0024)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F8[0xA48];                                    // 0x03F8(0x0A48)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayDroppedRingSound_DAMAGE_01(ESoundPan SoundPan);
	void OnPlayDroppedRingSound_HIT_01(const struct FVector& Position);
	void OnPlayDroppedRingSound_Large(ESoundPan SoundPan);
	void OnPlayDroppedRingSound_Medium(ESoundPan SoundPan);
	void OnPlayDroppedRingSound_Small(ESoundPan SoundPan);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DroppedRingFactory">();
	}
	static class ADroppedRingFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADroppedRingFactory>();
	}
};
static_assert(alignof(ADroppedRingFactory) == 0x000008, "Wrong alignment on ADroppedRingFactory");
static_assert(sizeof(ADroppedRingFactory) == 0x000E40, "Wrong size on ADroppedRingFactory");
static_assert(offsetof(ADroppedRingFactory, m_landHighRanker_RingHold_01_50) == 0x000290, "Member 'ADroppedRingFactory::m_landHighRanker_RingHold_01_50' has a wrong offset!");
static_assert(offsetof(ADroppedRingFactory, m_landHighRanker_RingHold_51_100) == 0x0002AC, "Member 'ADroppedRingFactory::m_landHighRanker_RingHold_51_100' has a wrong offset!");
static_assert(offsetof(ADroppedRingFactory, m_landLowRanker) == 0x0002C8, "Member 'ADroppedRingFactory::m_landLowRanker' has a wrong offset!");
static_assert(offsetof(ADroppedRingFactory, m_flyHighRanker) == 0x0002E4, "Member 'ADroppedRingFactory::m_flyHighRanker' has a wrong offset!");
static_assert(offsetof(ADroppedRingFactory, m_flyLowRanker) == 0x000300, "Member 'ADroppedRingFactory::m_flyLowRanker' has a wrong offset!");
static_assert(offsetof(ADroppedRingFactory, m_placementInfoGimmick) == 0x00031C, "Member 'ADroppedRingFactory::m_placementInfoGimmick' has a wrong offset!");
static_assert(offsetof(ADroppedRingFactory, m_landJumpHighRanker_RingHold_01_50) == 0x000338, "Member 'ADroppedRingFactory::m_landJumpHighRanker_RingHold_01_50' has a wrong offset!");
static_assert(offsetof(ADroppedRingFactory, m_landJumpHighRanker_RingHold_51_100) == 0x00035C, "Member 'ADroppedRingFactory::m_landJumpHighRanker_RingHold_51_100' has a wrong offset!");
static_assert(offsetof(ADroppedRingFactory, m_landJumpLowRanker) == 0x000380, "Member 'ADroppedRingFactory::m_landJumpLowRanker' has a wrong offset!");
static_assert(offsetof(ADroppedRingFactory, m_flyJumpHighRanker) == 0x0003A4, "Member 'ADroppedRingFactory::m_flyJumpHighRanker' has a wrong offset!");
static_assert(offsetof(ADroppedRingFactory, m_flyJumpLowRanker) == 0x0003BC, "Member 'ADroppedRingFactory::m_flyJumpLowRanker' has a wrong offset!");
static_assert(offsetof(ADroppedRingFactory, m_jumpParamGimmick) == 0x0003D4, "Member 'ADroppedRingFactory::m_jumpParamGimmick' has a wrong offset!");

// Class UnionRun.DroppedRingObject
// 0x0130 (0x0470 - 0x0340)
class ADroppedRingObject : public AUnionCourseObjectBase
{
public:
	uint8                                         Pad_340[0x8];                                      // 0x0340(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USuckedMovement*                        m_suckedMovement;                                  // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_modelMinScale;                                   // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_modelScaleTime;                                  // 0x0354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_landOffset;                                      // 0x0358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_lifeTime;                                        // 0x035C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_blinkTime;                                       // 0x0360(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_blinkingIntervalTime;                            // 0x0364(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_collisionInvalidTime;                            // 0x0368(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_restitutionCoffi;                                // 0x036C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         m_boundCount;                                      // 0x0370(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_374[0x4];                                      // 0x0374(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0378(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticBodyComponent*                   StaticBodyComponent;                               // 0x0380(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_388[0xB0];                                     // 0x0388(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	class URingGravityMovement*                   m_gravityMovement;                                 // 0x0438(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_440[0x30];                                     // 0x0440(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HitRacer(int32 RacerIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DroppedRingObject">();
	}
	static class ADroppedRingObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADroppedRingObject>();
	}
};
static_assert(alignof(ADroppedRingObject) == 0x000008, "Wrong alignment on ADroppedRingObject");
static_assert(sizeof(ADroppedRingObject) == 0x000470, "Wrong size on ADroppedRingObject");
static_assert(offsetof(ADroppedRingObject, m_suckedMovement) == 0x000348, "Member 'ADroppedRingObject::m_suckedMovement' has a wrong offset!");
static_assert(offsetof(ADroppedRingObject, m_modelMinScale) == 0x000350, "Member 'ADroppedRingObject::m_modelMinScale' has a wrong offset!");
static_assert(offsetof(ADroppedRingObject, m_modelScaleTime) == 0x000354, "Member 'ADroppedRingObject::m_modelScaleTime' has a wrong offset!");
static_assert(offsetof(ADroppedRingObject, m_landOffset) == 0x000358, "Member 'ADroppedRingObject::m_landOffset' has a wrong offset!");
static_assert(offsetof(ADroppedRingObject, m_lifeTime) == 0x00035C, "Member 'ADroppedRingObject::m_lifeTime' has a wrong offset!");
static_assert(offsetof(ADroppedRingObject, m_blinkTime) == 0x000360, "Member 'ADroppedRingObject::m_blinkTime' has a wrong offset!");
static_assert(offsetof(ADroppedRingObject, m_blinkingIntervalTime) == 0x000364, "Member 'ADroppedRingObject::m_blinkingIntervalTime' has a wrong offset!");
static_assert(offsetof(ADroppedRingObject, m_collisionInvalidTime) == 0x000368, "Member 'ADroppedRingObject::m_collisionInvalidTime' has a wrong offset!");
static_assert(offsetof(ADroppedRingObject, m_restitutionCoffi) == 0x00036C, "Member 'ADroppedRingObject::m_restitutionCoffi' has a wrong offset!");
static_assert(offsetof(ADroppedRingObject, m_boundCount) == 0x000370, "Member 'ADroppedRingObject::m_boundCount' has a wrong offset!");
static_assert(offsetof(ADroppedRingObject, DefaultSceneRoot) == 0x000378, "Member 'ADroppedRingObject::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(ADroppedRingObject, StaticBodyComponent) == 0x000380, "Member 'ADroppedRingObject::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(ADroppedRingObject, m_gravityMovement) == 0x000438, "Member 'ADroppedRingObject::m_gravityMovement' has a wrong offset!");

// Class UnionRun.EggChaserAnimInstance
// 0x0000 (0x0370 - 0x0370)
class UEggChaserAnimInstance final : public UEnemyAnimInstance
{
public:
	bool                                          bIsFly;                                            // 0x0368(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFlyToWait;                                      // 0x0369(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsWait;                                           // 0x036A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAttackReady;                                    // 0x036B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAttack;                                         // 0x036C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsWaitToFly;                                      // 0x036D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36E[0x2];                                      // 0x036E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetIsAttack();
	bool GetIsAttackReady();
	bool GetIsFly();
	bool GetIsFlyToWait();
	bool GetIsPhase3Move();
	bool GetIsWaitToFly();
	void SetIsAttack(bool flag);
	void SetIsAttackReady(bool flag);
	void SetIsFly(bool flag);
	void SetIsFlyToWait(bool flag);
	void SetIsWait(bool flag);
	void SetIsWaitToFly(bool flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EggChaserAnimInstance">();
	}
	static class UEggChaserAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEggChaserAnimInstance>();
	}
};
static_assert(alignof(UEggChaserAnimInstance) == 0x000010, "Wrong alignment on UEggChaserAnimInstance");
static_assert(sizeof(UEggChaserAnimInstance) == 0x000370, "Wrong size on UEggChaserAnimInstance");
static_assert(offsetof(UEggChaserAnimInstance, bIsFly) == 0x000368, "Member 'UEggChaserAnimInstance::bIsFly' has a wrong offset!");
static_assert(offsetof(UEggChaserAnimInstance, bIsFlyToWait) == 0x000369, "Member 'UEggChaserAnimInstance::bIsFlyToWait' has a wrong offset!");
static_assert(offsetof(UEggChaserAnimInstance, bIsWait) == 0x00036A, "Member 'UEggChaserAnimInstance::bIsWait' has a wrong offset!");
static_assert(offsetof(UEggChaserAnimInstance, bIsAttackReady) == 0x00036B, "Member 'UEggChaserAnimInstance::bIsAttackReady' has a wrong offset!");
static_assert(offsetof(UEggChaserAnimInstance, bIsAttack) == 0x00036C, "Member 'UEggChaserAnimInstance::bIsAttack' has a wrong offset!");
static_assert(offsetof(UEggChaserAnimInstance, bIsWaitToFly) == 0x00036D, "Member 'UEggChaserAnimInstance::bIsWaitToFly' has a wrong offset!");

// Class UnionRun.RaceUISubBoost
// 0x0098 (0x0378 - 0x02E0)
class URaceUISubBoost : public UUserWidget
{
public:
	class UWidgetAnimation*                       Level0InLoop;                                      // 0x02E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       IrregularInLoop;                                   // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       JustinOut;                                         // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       BoostNumInOut;                                     // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UImage*>                         DspBoostArr;                                       // 0x0300(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	class UImage*                                 DspPatBoostNum;                                    // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 EffIregularImage;                                  // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           IrregularChargeColor;                              // 0x0320(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FastFirstChargeColor;                              // 0x0330(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FastSecondChargeColor;                             // 0x0340(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FastThirdChargeColor;                              // 0x0350(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFastFirstGadget;                                 // 0x0360(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFastSecondGadget;                                // 0x0361(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFastThirdGadget;                                 // 0x0362(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStartVisibleNormal;                              // 0x0363(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInFever;                                         // 0x0364(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBoosting;                                        // 0x0365(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOpened;                                          // 0x0366(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_367[0x11];                                     // 0x0367(0x0011)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckBoostLevelInGhostReplay(int32 Level);
	bool IsFastFirstCharge(int32 RacerIndex);
	bool IsFastSecondCharge(int32 RacerIndex);
	bool IsFastThirdCharge(int32 RacerIndex);
	bool IsViewGhostReplay();
	void SetVisibleHUD(bool IsVisible_0, float DeltaTime);
	void SetWaitTimeJustBoostInGhostReplay(float Time);
	void UpdateChargeInfo(int32 ChargeLevel, float ChargeRate);

	bool GetIsOpened() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceUISubBoost">();
	}
	static class URaceUISubBoost* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceUISubBoost>();
	}
};
static_assert(alignof(URaceUISubBoost) == 0x000008, "Wrong alignment on URaceUISubBoost");
static_assert(sizeof(URaceUISubBoost) == 0x000378, "Wrong size on URaceUISubBoost");
static_assert(offsetof(URaceUISubBoost, Level0InLoop) == 0x0002E0, "Member 'URaceUISubBoost::Level0InLoop' has a wrong offset!");
static_assert(offsetof(URaceUISubBoost, IrregularInLoop) == 0x0002E8, "Member 'URaceUISubBoost::IrregularInLoop' has a wrong offset!");
static_assert(offsetof(URaceUISubBoost, JustinOut) == 0x0002F0, "Member 'URaceUISubBoost::JustinOut' has a wrong offset!");
static_assert(offsetof(URaceUISubBoost, BoostNumInOut) == 0x0002F8, "Member 'URaceUISubBoost::BoostNumInOut' has a wrong offset!");
static_assert(offsetof(URaceUISubBoost, DspBoostArr) == 0x000300, "Member 'URaceUISubBoost::DspBoostArr' has a wrong offset!");
static_assert(offsetof(URaceUISubBoost, DspPatBoostNum) == 0x000310, "Member 'URaceUISubBoost::DspPatBoostNum' has a wrong offset!");
static_assert(offsetof(URaceUISubBoost, EffIregularImage) == 0x000318, "Member 'URaceUISubBoost::EffIregularImage' has a wrong offset!");
static_assert(offsetof(URaceUISubBoost, IrregularChargeColor) == 0x000320, "Member 'URaceUISubBoost::IrregularChargeColor' has a wrong offset!");
static_assert(offsetof(URaceUISubBoost, FastFirstChargeColor) == 0x000330, "Member 'URaceUISubBoost::FastFirstChargeColor' has a wrong offset!");
static_assert(offsetof(URaceUISubBoost, FastSecondChargeColor) == 0x000340, "Member 'URaceUISubBoost::FastSecondChargeColor' has a wrong offset!");
static_assert(offsetof(URaceUISubBoost, FastThirdChargeColor) == 0x000350, "Member 'URaceUISubBoost::FastThirdChargeColor' has a wrong offset!");
static_assert(offsetof(URaceUISubBoost, IsFastFirstGadget) == 0x000360, "Member 'URaceUISubBoost::IsFastFirstGadget' has a wrong offset!");
static_assert(offsetof(URaceUISubBoost, IsFastSecondGadget) == 0x000361, "Member 'URaceUISubBoost::IsFastSecondGadget' has a wrong offset!");
static_assert(offsetof(URaceUISubBoost, IsFastThirdGadget) == 0x000362, "Member 'URaceUISubBoost::IsFastThirdGadget' has a wrong offset!");
static_assert(offsetof(URaceUISubBoost, IsStartVisibleNormal) == 0x000363, "Member 'URaceUISubBoost::IsStartVisibleNormal' has a wrong offset!");
static_assert(offsetof(URaceUISubBoost, IsInFever) == 0x000364, "Member 'URaceUISubBoost::IsInFever' has a wrong offset!");
static_assert(offsetof(URaceUISubBoost, IsBoosting) == 0x000365, "Member 'URaceUISubBoost::IsBoosting' has a wrong offset!");
static_assert(offsetof(URaceUISubBoost, IsOpened) == 0x000366, "Member 'URaceUISubBoost::IsOpened' has a wrong offset!");

// Class UnionRun.Gimmick_Extnd05_Enemy04004
// 0x00B0 (0x0660 - 0x05B0)
class alignas(0x10) AGimmick_Extnd05_Enemy04004 final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ERacerDamageType                              DamageType;                                        // 0x05B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B9[0x7];                                      // 0x05B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionSkeletalMeshComponent*            SkeletalMesh;                                      // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            BodyStaticBody;                                    // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            FootStaticBody;                                    // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            ArmStaticBody;                                     // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            BreakItemStaticBody;                               // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    EnemySound;                                        // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGimmick_Extnd05_EnemyWarning*          WarningEffect;                                     // 0x05F0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGimmick_Extnd05_EnemyLaser*            Laser;                                             // 0x05F8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 LaserEffectNode;                                   // 0x0600(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsMirrorMotion;                                    // 0x0608(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_609[0x3];                                      // 0x0609(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PunchTiming;                                       // 0x060C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WarningDuration;                                   // 0x0610(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DamageDuration;                                    // 0x0614(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_618[0x8];                                      // 0x0618(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          AnimSequenceAttack;                                // 0x0620(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_628[0x8];                                      // 0x0628(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          AnimSequenceDamaged;                               // 0x0630(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AnimSequenceIdle;                                  // 0x0638(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<int32>                                 ArmSkeletonIndexArray;                             // 0x0640(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int32>                                 EyeSkeletonIndexArray;                             // 0x0650(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	bool IsDamaged() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd05_Enemy04004">();
	}
	static class AGimmick_Extnd05_Enemy04004* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd05_Enemy04004>();
	}
};
static_assert(alignof(AGimmick_Extnd05_Enemy04004) == 0x000010, "Wrong alignment on AGimmick_Extnd05_Enemy04004");
static_assert(sizeof(AGimmick_Extnd05_Enemy04004) == 0x000660, "Wrong size on AGimmick_Extnd05_Enemy04004");
static_assert(offsetof(AGimmick_Extnd05_Enemy04004, DamageType) == 0x0005B8, "Member 'AGimmick_Extnd05_Enemy04004::DamageType' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_Enemy04004, SkeletalMesh) == 0x0005C0, "Member 'AGimmick_Extnd05_Enemy04004::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_Enemy04004, BodyStaticBody) == 0x0005C8, "Member 'AGimmick_Extnd05_Enemy04004::BodyStaticBody' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_Enemy04004, FootStaticBody) == 0x0005D0, "Member 'AGimmick_Extnd05_Enemy04004::FootStaticBody' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_Enemy04004, ArmStaticBody) == 0x0005D8, "Member 'AGimmick_Extnd05_Enemy04004::ArmStaticBody' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_Enemy04004, BreakItemStaticBody) == 0x0005E0, "Member 'AGimmick_Extnd05_Enemy04004::BreakItemStaticBody' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_Enemy04004, EnemySound) == 0x0005E8, "Member 'AGimmick_Extnd05_Enemy04004::EnemySound' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_Enemy04004, WarningEffect) == 0x0005F0, "Member 'AGimmick_Extnd05_Enemy04004::WarningEffect' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_Enemy04004, Laser) == 0x0005F8, "Member 'AGimmick_Extnd05_Enemy04004::Laser' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_Enemy04004, LaserEffectNode) == 0x000600, "Member 'AGimmick_Extnd05_Enemy04004::LaserEffectNode' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_Enemy04004, IsMirrorMotion) == 0x000608, "Member 'AGimmick_Extnd05_Enemy04004::IsMirrorMotion' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_Enemy04004, PunchTiming) == 0x00060C, "Member 'AGimmick_Extnd05_Enemy04004::PunchTiming' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_Enemy04004, WarningDuration) == 0x000610, "Member 'AGimmick_Extnd05_Enemy04004::WarningDuration' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_Enemy04004, DamageDuration) == 0x000614, "Member 'AGimmick_Extnd05_Enemy04004::DamageDuration' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_Enemy04004, AnimSequenceAttack) == 0x000620, "Member 'AGimmick_Extnd05_Enemy04004::AnimSequenceAttack' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_Enemy04004, AnimSequenceDamaged) == 0x000630, "Member 'AGimmick_Extnd05_Enemy04004::AnimSequenceDamaged' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_Enemy04004, AnimSequenceIdle) == 0x000638, "Member 'AGimmick_Extnd05_Enemy04004::AnimSequenceIdle' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_Enemy04004, ArmSkeletonIndexArray) == 0x000640, "Member 'AGimmick_Extnd05_Enemy04004::ArmSkeletonIndexArray' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_Enemy04004, EyeSkeletonIndexArray) == 0x000650, "Member 'AGimmick_Extnd05_Enemy04004::EyeSkeletonIndexArray' has a wrong offset!");

// Class UnionRun.UnionEnemyBase
// 0x0008 (0x05B8 - 0x05B0)
#pragma pack(push, 0x1)
class alignas(0x08) AUnionEnemyBase : public AUnionGimmickObjectBase
{
public:
	EEnemyType                                    EnemyType;                                         // 0x05B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERacerDamageType                              DamageType;                                        // 0x05B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B2[0x2];                                      // 0x05B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimationPlayRate;                                 // 0x05B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionEnemyBase">();
	}
	static class AUnionEnemyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnionEnemyBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(AUnionEnemyBase) == 0x000008, "Wrong alignment on AUnionEnemyBase");
static_assert(sizeof(AUnionEnemyBase) == 0x0005B8, "Wrong size on AUnionEnemyBase");
static_assert(offsetof(AUnionEnemyBase, EnemyType) == 0x0005B0, "Member 'AUnionEnemyBase::EnemyType' has a wrong offset!");
static_assert(offsetof(AUnionEnemyBase, DamageType) == 0x0005B1, "Member 'AUnionEnemyBase::DamageType' has a wrong offset!");
static_assert(offsetof(AUnionEnemyBase, AnimationPlayRate) == 0x0005B4, "Member 'AUnionEnemyBase::AnimationPlayRate' has a wrong offset!");

// Class UnionRun.EggDragoon
// 0x00B8 (0x0670 - 0x05B8)
class alignas(0x10) AEggDragoon final : public AUnionEnemyBase
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionSkeletalMeshComponent*            Mesh;                                              // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            Body;                                              // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      DrillEffect;                                       // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      BerserkEffect;                                     // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    DrillSound;                                        // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackLoopTime;                                    // 0x05E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackIntervalTime;                                // 0x05EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          NormalDrillCue;                                    // 0x05F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          HighSpeedDrillCue;                                 // 0x05F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugAttack;                                       // 0x0600(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_601[0x7];                                      // 0x0601(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimationAsset*                        DebugAttackAnimation;                              // 0x0608(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEggDragoonAnimInstance*                AnimInstance;                                      // 0x0610(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_618[0x58];                                     // 0x0618(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EggDragoon">();
	}
	static class AEggDragoon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEggDragoon>();
	}
};
static_assert(alignof(AEggDragoon) == 0x000010, "Wrong alignment on AEggDragoon");
static_assert(sizeof(AEggDragoon) == 0x000670, "Wrong size on AEggDragoon");
static_assert(offsetof(AEggDragoon, Mesh) == 0x0005C0, "Member 'AEggDragoon::Mesh' has a wrong offset!");
static_assert(offsetof(AEggDragoon, Body) == 0x0005C8, "Member 'AEggDragoon::Body' has a wrong offset!");
static_assert(offsetof(AEggDragoon, DrillEffect) == 0x0005D0, "Member 'AEggDragoon::DrillEffect' has a wrong offset!");
static_assert(offsetof(AEggDragoon, BerserkEffect) == 0x0005D8, "Member 'AEggDragoon::BerserkEffect' has a wrong offset!");
static_assert(offsetof(AEggDragoon, DrillSound) == 0x0005E0, "Member 'AEggDragoon::DrillSound' has a wrong offset!");
static_assert(offsetof(AEggDragoon, AttackLoopTime) == 0x0005E8, "Member 'AEggDragoon::AttackLoopTime' has a wrong offset!");
static_assert(offsetof(AEggDragoon, AttackIntervalTime) == 0x0005EC, "Member 'AEggDragoon::AttackIntervalTime' has a wrong offset!");
static_assert(offsetof(AEggDragoon, NormalDrillCue) == 0x0005F0, "Member 'AEggDragoon::NormalDrillCue' has a wrong offset!");
static_assert(offsetof(AEggDragoon, HighSpeedDrillCue) == 0x0005F8, "Member 'AEggDragoon::HighSpeedDrillCue' has a wrong offset!");
static_assert(offsetof(AEggDragoon, DebugAttack) == 0x000600, "Member 'AEggDragoon::DebugAttack' has a wrong offset!");
static_assert(offsetof(AEggDragoon, DebugAttackAnimation) == 0x000608, "Member 'AEggDragoon::DebugAttackAnimation' has a wrong offset!");
static_assert(offsetof(AEggDragoon, AnimInstance) == 0x000610, "Member 'AEggDragoon::AnimInstance' has a wrong offset!");

// Class UnionRun.EggDragoonAnimInstance
// 0x0000 (0x0370 - 0x0370)
class UEggDragoonAnimInstance final : public UEnemyAnimInstance
{
public:
	EEggDragoonState                              AttackState;                                       // 0x0368(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsActivate;                                        // 0x0369(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36A[0x6];                                      // 0x036A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEnterAttackLoop();
	void OnEnterAttackWait();

	bool IsAttackState(EEggDragoonState State) const;
	bool IsStateActivate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EggDragoonAnimInstance">();
	}
	static class UEggDragoonAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEggDragoonAnimInstance>();
	}
};
static_assert(alignof(UEggDragoonAnimInstance) == 0x000010, "Wrong alignment on UEggDragoonAnimInstance");
static_assert(sizeof(UEggDragoonAnimInstance) == 0x000370, "Wrong size on UEggDragoonAnimInstance");
static_assert(offsetof(UEggDragoonAnimInstance, AttackState) == 0x000368, "Member 'UEggDragoonAnimInstance::AttackState' has a wrong offset!");
static_assert(offsetof(UEggDragoonAnimInstance, IsActivate) == 0x000369, "Member 'UEggDragoonAnimInstance::IsActivate' has a wrong offset!");

// Class UnionRun.GimmickDashRing
// 0x0030 (0x05E0 - 0x05B0)
class alignas(0x10) AGimmickDashRing final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DashVelocity;                                      // 0x05B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5BC[0x4];                                      // 0x05BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGimmickStaticBodyComponent*            _GimmickStaticBodyComponent;                       // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionStaticMeshComponent*              _StaticMeshComponent;                              // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      _NiagaraComponent;                                 // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D8[0x8];                                      // 0x05D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickDashRing">();
	}
	static class AGimmickDashRing* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickDashRing>();
	}
};
static_assert(alignof(AGimmickDashRing) == 0x000010, "Wrong alignment on AGimmickDashRing");
static_assert(sizeof(AGimmickDashRing) == 0x0005E0, "Wrong size on AGimmickDashRing");
static_assert(offsetof(AGimmickDashRing, DashVelocity) == 0x0005B8, "Member 'AGimmickDashRing::DashVelocity' has a wrong offset!");
static_assert(offsetof(AGimmickDashRing, _GimmickStaticBodyComponent) == 0x0005C0, "Member 'AGimmickDashRing::_GimmickStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickDashRing, _StaticMeshComponent) == 0x0005C8, "Member 'AGimmickDashRing::_StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickDashRing, _NiagaraComponent) == 0x0005D0, "Member 'AGimmickDashRing::_NiagaraComponent' has a wrong offset!");

// Class UnionRun.EnemyAmbushTrex
// 0x00F8 (0x06B0 - 0x05B8)
class alignas(0x10) AEnemyAmbushTrex final : public AUnionEnemyBase
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionSkeletalMeshComponent*            SkeletalMeshComponent;                             // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDamage;                                         // 0x05C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C9[0x7];                                      // 0x05C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticBodyComponent*                   LeftFootStaticBodyComponent;                       // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticBodyComponent*                   RightFootStaticBodyComponent;                      // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticBodyComponent*                   HeadStaticBodyComponent;                           // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AItemBoxObject*>                 LinkItemBoxArray;                                  // 0x05F0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class AVATBreakObjectBase*>            LinkBreakObjectArray;                              // 0x0600(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AnimSequenceAttack;                                // 0x0610(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AnimSequenceDamage;                                // 0x0618(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_620[0x50];                                     // 0x0620(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UTrexAnimInstance*                      AnimInstance;                                      // 0x0670(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_678[0x38];                                     // 0x0678(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HitRacer(int32 RacerIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyAmbushTrex">();
	}
	static class AEnemyAmbushTrex* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyAmbushTrex>();
	}
};
static_assert(alignof(AEnemyAmbushTrex) == 0x000010, "Wrong alignment on AEnemyAmbushTrex");
static_assert(sizeof(AEnemyAmbushTrex) == 0x0006B0, "Wrong size on AEnemyAmbushTrex");
static_assert(offsetof(AEnemyAmbushTrex, SkeletalMeshComponent) == 0x0005C0, "Member 'AEnemyAmbushTrex::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyAmbushTrex, bIsDamage) == 0x0005C8, "Member 'AEnemyAmbushTrex::bIsDamage' has a wrong offset!");
static_assert(offsetof(AEnemyAmbushTrex, DefaultSceneRoot) == 0x0005D0, "Member 'AEnemyAmbushTrex::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AEnemyAmbushTrex, LeftFootStaticBodyComponent) == 0x0005D8, "Member 'AEnemyAmbushTrex::LeftFootStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyAmbushTrex, RightFootStaticBodyComponent) == 0x0005E0, "Member 'AEnemyAmbushTrex::RightFootStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyAmbushTrex, HeadStaticBodyComponent) == 0x0005E8, "Member 'AEnemyAmbushTrex::HeadStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyAmbushTrex, LinkItemBoxArray) == 0x0005F0, "Member 'AEnemyAmbushTrex::LinkItemBoxArray' has a wrong offset!");
static_assert(offsetof(AEnemyAmbushTrex, LinkBreakObjectArray) == 0x000600, "Member 'AEnemyAmbushTrex::LinkBreakObjectArray' has a wrong offset!");
static_assert(offsetof(AEnemyAmbushTrex, AnimSequenceAttack) == 0x000610, "Member 'AEnemyAmbushTrex::AnimSequenceAttack' has a wrong offset!");
static_assert(offsetof(AEnemyAmbushTrex, AnimSequenceDamage) == 0x000618, "Member 'AEnemyAmbushTrex::AnimSequenceDamage' has a wrong offset!");
static_assert(offsetof(AEnemyAmbushTrex, AnimInstance) == 0x000670, "Member 'AEnemyAmbushTrex::AnimInstance' has a wrong offset!");

// Class UnionRun.GimmickPolishingMachine
// 0x0230 (0x07E0 - 0x05B0)
class alignas(0x10) AGimmickPolishingMachine final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              m_roboMesh;                                        // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              m_shadowMesh;                                      // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        m_brushRotateRoot;                                 // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              m_brushMesh1;                                      // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              m_brushMesh2;                                      // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticBodyComponent*                   m_brushBody1;                                      // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticBodyComponent*                   m_brushBody2;                                      // 0x05E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_motorSound;                                      // 0x05F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_bounceSound;                                     // 0x05F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionBounceMoveComponent*              m_bounce;                                          // 0x0600(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERacerDamageType                              m_damageType;                                      // 0x0608(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_609[0x3];                                      // 0x0609(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_rootRotSpeed;                                    // 0x060C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_brushRotSpeed;                                   // 0x0610(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         m_allowBounce;                                     // 0x0614(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_615[0x3];                                      // 0x0615(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_checkGroundRaycastStartUpOffset;                 // 0x0618(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_checkGroundRaycastLength;                        // 0x061C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_autoShadowHeight;                                // 0x0620(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_621[0x3];                                      // 0x0621(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_shadowHeightOffset;                              // 0x0624(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_autoShadowUpVector;                              // 0x0628(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_629[0x3];                                      // 0x0629(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_autoShadowInterval;                              // 0x062C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_isComAvoidTiming;                                // 0x0630(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_631[0x1AF];                                    // 0x0631(0x01AF)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickPolishingMachine">();
	}
	static class AGimmickPolishingMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickPolishingMachine>();
	}
};
static_assert(alignof(AGimmickPolishingMachine) == 0x000010, "Wrong alignment on AGimmickPolishingMachine");
static_assert(sizeof(AGimmickPolishingMachine) == 0x0007E0, "Wrong size on AGimmickPolishingMachine");
static_assert(offsetof(AGimmickPolishingMachine, m_roboMesh) == 0x0005B8, "Member 'AGimmickPolishingMachine::m_roboMesh' has a wrong offset!");
static_assert(offsetof(AGimmickPolishingMachine, m_shadowMesh) == 0x0005C0, "Member 'AGimmickPolishingMachine::m_shadowMesh' has a wrong offset!");
static_assert(offsetof(AGimmickPolishingMachine, m_brushRotateRoot) == 0x0005C8, "Member 'AGimmickPolishingMachine::m_brushRotateRoot' has a wrong offset!");
static_assert(offsetof(AGimmickPolishingMachine, m_brushMesh1) == 0x0005D0, "Member 'AGimmickPolishingMachine::m_brushMesh1' has a wrong offset!");
static_assert(offsetof(AGimmickPolishingMachine, m_brushMesh2) == 0x0005D8, "Member 'AGimmickPolishingMachine::m_brushMesh2' has a wrong offset!");
static_assert(offsetof(AGimmickPolishingMachine, m_brushBody1) == 0x0005E0, "Member 'AGimmickPolishingMachine::m_brushBody1' has a wrong offset!");
static_assert(offsetof(AGimmickPolishingMachine, m_brushBody2) == 0x0005E8, "Member 'AGimmickPolishingMachine::m_brushBody2' has a wrong offset!");
static_assert(offsetof(AGimmickPolishingMachine, m_motorSound) == 0x0005F0, "Member 'AGimmickPolishingMachine::m_motorSound' has a wrong offset!");
static_assert(offsetof(AGimmickPolishingMachine, m_bounceSound) == 0x0005F8, "Member 'AGimmickPolishingMachine::m_bounceSound' has a wrong offset!");
static_assert(offsetof(AGimmickPolishingMachine, m_bounce) == 0x000600, "Member 'AGimmickPolishingMachine::m_bounce' has a wrong offset!");
static_assert(offsetof(AGimmickPolishingMachine, m_damageType) == 0x000608, "Member 'AGimmickPolishingMachine::m_damageType' has a wrong offset!");
static_assert(offsetof(AGimmickPolishingMachine, m_rootRotSpeed) == 0x00060C, "Member 'AGimmickPolishingMachine::m_rootRotSpeed' has a wrong offset!");
static_assert(offsetof(AGimmickPolishingMachine, m_brushRotSpeed) == 0x000610, "Member 'AGimmickPolishingMachine::m_brushRotSpeed' has a wrong offset!");
static_assert(offsetof(AGimmickPolishingMachine, m_allowBounce) == 0x000614, "Member 'AGimmickPolishingMachine::m_allowBounce' has a wrong offset!");
static_assert(offsetof(AGimmickPolishingMachine, m_checkGroundRaycastStartUpOffset) == 0x000618, "Member 'AGimmickPolishingMachine::m_checkGroundRaycastStartUpOffset' has a wrong offset!");
static_assert(offsetof(AGimmickPolishingMachine, m_checkGroundRaycastLength) == 0x00061C, "Member 'AGimmickPolishingMachine::m_checkGroundRaycastLength' has a wrong offset!");
static_assert(offsetof(AGimmickPolishingMachine, m_autoShadowHeight) == 0x000620, "Member 'AGimmickPolishingMachine::m_autoShadowHeight' has a wrong offset!");
static_assert(offsetof(AGimmickPolishingMachine, m_shadowHeightOffset) == 0x000624, "Member 'AGimmickPolishingMachine::m_shadowHeightOffset' has a wrong offset!");
static_assert(offsetof(AGimmickPolishingMachine, m_autoShadowUpVector) == 0x000628, "Member 'AGimmickPolishingMachine::m_autoShadowUpVector' has a wrong offset!");
static_assert(offsetof(AGimmickPolishingMachine, m_autoShadowInterval) == 0x00062C, "Member 'AGimmickPolishingMachine::m_autoShadowInterval' has a wrong offset!");
static_assert(offsetof(AGimmickPolishingMachine, m_isComAvoidTiming) == 0x000630, "Member 'AGimmickPolishingMachine::m_isComAvoidTiming' has a wrong offset!");

// Class UnionRun.EnemyAsura
// 0x0108 (0x06C0 - 0x05B8)
class alignas(0x10) AEnemyAsura final : public AUnionEnemyBase
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionSkeletalMeshComponent*            Mesh;                                              // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            Body;                                              // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextAttackInterval;                                // 0x05D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackReadyLoopWaitTime;                           // 0x05D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlamDelayTime;                                     // 0x05D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CanDamageTime;                                     // 0x05DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostPadAppearInterval;                            // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyActiveTime;                                    // 0x05E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AsuraBoostPadId;                                   // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5EC[0x4];                                      // 0x05EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABoostPadObject*>                BoostPadList;                                      // 0x05F0(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class AUnionSplineActor*>              SplineList;                                        // 0x0600(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          DebugAttack;                                       // 0x0610(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_611[0x7];                                      // 0x0611(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimationAsset*                        DebugAttackAnimation;                              // 0x0618(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugDrawArmCollision;                             // 0x0620(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_621[0x7];                                      // 0x0621(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAsuraAnimInstance*                     AnimInstance;                                      // 0x0628(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_630[0x90];                                     // 0x0630(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyAsura">();
	}
	static class AEnemyAsura* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyAsura>();
	}
};
static_assert(alignof(AEnemyAsura) == 0x000010, "Wrong alignment on AEnemyAsura");
static_assert(sizeof(AEnemyAsura) == 0x0006C0, "Wrong size on AEnemyAsura");
static_assert(offsetof(AEnemyAsura, Mesh) == 0x0005C0, "Member 'AEnemyAsura::Mesh' has a wrong offset!");
static_assert(offsetof(AEnemyAsura, Body) == 0x0005C8, "Member 'AEnemyAsura::Body' has a wrong offset!");
static_assert(offsetof(AEnemyAsura, NextAttackInterval) == 0x0005D0, "Member 'AEnemyAsura::NextAttackInterval' has a wrong offset!");
static_assert(offsetof(AEnemyAsura, AttackReadyLoopWaitTime) == 0x0005D4, "Member 'AEnemyAsura::AttackReadyLoopWaitTime' has a wrong offset!");
static_assert(offsetof(AEnemyAsura, SlamDelayTime) == 0x0005D8, "Member 'AEnemyAsura::SlamDelayTime' has a wrong offset!");
static_assert(offsetof(AEnemyAsura, CanDamageTime) == 0x0005DC, "Member 'AEnemyAsura::CanDamageTime' has a wrong offset!");
static_assert(offsetof(AEnemyAsura, BoostPadAppearInterval) == 0x0005E0, "Member 'AEnemyAsura::BoostPadAppearInterval' has a wrong offset!");
static_assert(offsetof(AEnemyAsura, BodyActiveTime) == 0x0005E4, "Member 'AEnemyAsura::BodyActiveTime' has a wrong offset!");
static_assert(offsetof(AEnemyAsura, AsuraBoostPadId) == 0x0005E8, "Member 'AEnemyAsura::AsuraBoostPadId' has a wrong offset!");
static_assert(offsetof(AEnemyAsura, BoostPadList) == 0x0005F0, "Member 'AEnemyAsura::BoostPadList' has a wrong offset!");
static_assert(offsetof(AEnemyAsura, SplineList) == 0x000600, "Member 'AEnemyAsura::SplineList' has a wrong offset!");
static_assert(offsetof(AEnemyAsura, DebugAttack) == 0x000610, "Member 'AEnemyAsura::DebugAttack' has a wrong offset!");
static_assert(offsetof(AEnemyAsura, DebugAttackAnimation) == 0x000618, "Member 'AEnemyAsura::DebugAttackAnimation' has a wrong offset!");
static_assert(offsetof(AEnemyAsura, DebugDrawArmCollision) == 0x000620, "Member 'AEnemyAsura::DebugDrawArmCollision' has a wrong offset!");
static_assert(offsetof(AEnemyAsura, AnimInstance) == 0x000628, "Member 'AEnemyAsura::AnimInstance' has a wrong offset!");

// Class UnionRun.RaceUISubBtnKey
// 0x0000 (0x02E0 - 0x02E0)
class URaceUISubBtnKey : public UUserWidget
{
public:
	void SetButtonState(int32 InState);

	class FText GetKeyDisplayName(const struct FKey& InKey, int32 PlayerControllerIndex) const;
	int32 GetMouseButtonIndex(const struct FKey& InKey) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceUISubBtnKey">();
	}
	static class URaceUISubBtnKey* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceUISubBtnKey>();
	}
};
static_assert(alignof(URaceUISubBtnKey) == 0x000008, "Wrong alignment on URaceUISubBtnKey");
static_assert(sizeof(URaceUISubBtnKey) == 0x0002E0, "Wrong size on URaceUISubBtnKey");

// Class UnionRun.EnemyAttackStoneStatue
// 0x0168 (0x0720 - 0x05B8)
class alignas(0x10) AEnemyAttackStoneStatue final : public AUnionEnemyBase
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        BeamActorRoot;                                     // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionVATMeshComponent*                 VATMeshComponent;                                  // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              UnderBodyMeshComponent;                            // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              LaserStaticMeshComponent;                          // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              LaserHitStaticMeshComponent;                       // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              LaserMuzzleStaticMeshComponent;                    // 0x05E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    MoveUpSoundComponent;                              // 0x05F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    LandHitSoundComponent;                             // 0x05F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    IdleMoveSoundComponent;                            // 0x0600(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    BeamSoundComponent;                                // 0x0608(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeamScaleRatio;                                    // 0x0610(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_614[0x4];                                      // 0x0614(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BeamScaleCurve;                                    // 0x0618(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      SparkEffect;                                       // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BeamScaleTime;                                     // 0x0628(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveUpTime;                                        // 0x062C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageMoveHight;                                   // 0x0630(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateSpeed;                                       // 0x0634(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RotateDirection;                                   // 0x0638(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_639[0x7];                                      // 0x0639(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DamageMoveUpCurve;                                 // 0x0640(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SparkEffectLocationOffset;                         // 0x0648(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseDamageMoveTremor;                               // 0x0660(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_661[0x3];                                      // 0x0661(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TremorEnableDistance;                              // 0x0664(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            m_MainStaticBodyComponent;                         // 0x0668(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTriggerComponent*                      m_StompTriggerComponent;                           // 0x0670(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_678[0xA8];                                     // 0x0678(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MovePositionUpdate(float Ratio);
	void OnStatueDamageFinishEvent();
	void OnStatueDamageStartEvent();
	void OnTremorEvent();
	void OnTriggerColliderConflict(const struct FHitTriggerInfo& HitInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyAttackStoneStatue">();
	}
	static class AEnemyAttackStoneStatue* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyAttackStoneStatue>();
	}
};
static_assert(alignof(AEnemyAttackStoneStatue) == 0x000010, "Wrong alignment on AEnemyAttackStoneStatue");
static_assert(sizeof(AEnemyAttackStoneStatue) == 0x000720, "Wrong size on AEnemyAttackStoneStatue");
static_assert(offsetof(AEnemyAttackStoneStatue, BeamActorRoot) == 0x0005C0, "Member 'AEnemyAttackStoneStatue::BeamActorRoot' has a wrong offset!");
static_assert(offsetof(AEnemyAttackStoneStatue, VATMeshComponent) == 0x0005C8, "Member 'AEnemyAttackStoneStatue::VATMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyAttackStoneStatue, UnderBodyMeshComponent) == 0x0005D0, "Member 'AEnemyAttackStoneStatue::UnderBodyMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyAttackStoneStatue, LaserStaticMeshComponent) == 0x0005D8, "Member 'AEnemyAttackStoneStatue::LaserStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyAttackStoneStatue, LaserHitStaticMeshComponent) == 0x0005E0, "Member 'AEnemyAttackStoneStatue::LaserHitStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyAttackStoneStatue, LaserMuzzleStaticMeshComponent) == 0x0005E8, "Member 'AEnemyAttackStoneStatue::LaserMuzzleStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyAttackStoneStatue, MoveUpSoundComponent) == 0x0005F0, "Member 'AEnemyAttackStoneStatue::MoveUpSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemyAttackStoneStatue, LandHitSoundComponent) == 0x0005F8, "Member 'AEnemyAttackStoneStatue::LandHitSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemyAttackStoneStatue, IdleMoveSoundComponent) == 0x000600, "Member 'AEnemyAttackStoneStatue::IdleMoveSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemyAttackStoneStatue, BeamSoundComponent) == 0x000608, "Member 'AEnemyAttackStoneStatue::BeamSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemyAttackStoneStatue, BeamScaleRatio) == 0x000610, "Member 'AEnemyAttackStoneStatue::BeamScaleRatio' has a wrong offset!");
static_assert(offsetof(AEnemyAttackStoneStatue, BeamScaleCurve) == 0x000618, "Member 'AEnemyAttackStoneStatue::BeamScaleCurve' has a wrong offset!");
static_assert(offsetof(AEnemyAttackStoneStatue, SparkEffect) == 0x000620, "Member 'AEnemyAttackStoneStatue::SparkEffect' has a wrong offset!");
static_assert(offsetof(AEnemyAttackStoneStatue, BeamScaleTime) == 0x000628, "Member 'AEnemyAttackStoneStatue::BeamScaleTime' has a wrong offset!");
static_assert(offsetof(AEnemyAttackStoneStatue, MoveUpTime) == 0x00062C, "Member 'AEnemyAttackStoneStatue::MoveUpTime' has a wrong offset!");
static_assert(offsetof(AEnemyAttackStoneStatue, DamageMoveHight) == 0x000630, "Member 'AEnemyAttackStoneStatue::DamageMoveHight' has a wrong offset!");
static_assert(offsetof(AEnemyAttackStoneStatue, RotateSpeed) == 0x000634, "Member 'AEnemyAttackStoneStatue::RotateSpeed' has a wrong offset!");
static_assert(offsetof(AEnemyAttackStoneStatue, RotateDirection) == 0x000638, "Member 'AEnemyAttackStoneStatue::RotateDirection' has a wrong offset!");
static_assert(offsetof(AEnemyAttackStoneStatue, DamageMoveUpCurve) == 0x000640, "Member 'AEnemyAttackStoneStatue::DamageMoveUpCurve' has a wrong offset!");
static_assert(offsetof(AEnemyAttackStoneStatue, SparkEffectLocationOffset) == 0x000648, "Member 'AEnemyAttackStoneStatue::SparkEffectLocationOffset' has a wrong offset!");
static_assert(offsetof(AEnemyAttackStoneStatue, UseDamageMoveTremor) == 0x000660, "Member 'AEnemyAttackStoneStatue::UseDamageMoveTremor' has a wrong offset!");
static_assert(offsetof(AEnemyAttackStoneStatue, TremorEnableDistance) == 0x000664, "Member 'AEnemyAttackStoneStatue::TremorEnableDistance' has a wrong offset!");
static_assert(offsetof(AEnemyAttackStoneStatue, m_MainStaticBodyComponent) == 0x000668, "Member 'AEnemyAttackStoneStatue::m_MainStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyAttackStoneStatue, m_StompTriggerComponent) == 0x000670, "Member 'AEnemyAttackStoneStatue::m_StompTriggerComponent' has a wrong offset!");

// Class UnionRun.EnemyBigTrain
// 0x0138 (0x06F0 - 0x05B8)
class alignas(0x10) AEnemyBigTrain final : public AUnionEnemyBase
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TrainRecoveryTime;                                 // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovefinishRate;                                    // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrainAnimationPlayRate;                            // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5CC[0x4];                                      // 0x05CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TrainWarpLocation;                                 // 0x05D0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_IsSteamAttackOnly;                               // 0x05E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E9[0x3];                                      // 0x05E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TremorHighDistance;                                // 0x05EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TremorMiddleDistance;                              // 0x05F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TremorLowDistance;                                 // 0x05F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_SmokeEffectComponent;                            // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_SteamEffectComponent;                            // 0x0600(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_SmokeSoundComponent;                             // 0x0608(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_WarningSoundComponent;                           // 0x0610(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_CarHitSoundComponent;                            // 0x0618(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_MoveSoundComponent;                              // 0x0620(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTriggerComponent*                      m_CarSearchTriggerComponent;                       // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionSkeletalMeshComponent*            TrainSkeletalMeshComponent;                        // 0x0630(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColliderParam                         _ColliderParam;                                    // 0x0638(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsDamage;                                         // 0x0639(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63A[0x6];                                      // 0x063A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UGimmickStaticBodyComponent*            m_MainBodyStaticBodyComponent;                     // 0x0640(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            m_SideBodyStaticBodyComponent;                     // 0x0648(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            m_FrontRightWheelStaticBodyComponent;              // 0x0650(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            m_FrontLeftWheelStaticBodyComponent;               // 0x0658(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            m_MiddleRightWheelStaticBodyComponent;             // 0x0660(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            m_MiddleLeftWheelStaticBodyComponent;              // 0x0668(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            m_RearRightWheelStaticBodyComponent;               // 0x0670(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            m_RearLeftWheelStaticBodyComponent;                // 0x0678(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            m_RightShutterStaticBodyComponent;                 // 0x0680(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            m_LeftShutterStaticBodyComponent;                  // 0x0688(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_690[0x58];                                     // 0x0690(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UTrainAnimInstance*                     AnimInstance;                                      // 0x06E8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ChangeStateMove();
	void ChangeStateReturnStart();
	void ChangeStateStay();
	void OnPlayMoveSound();
	void OnStopMoveSound();
	void OnTremorEvent();
	void OnTriggerColliderConflict(const struct FHitTriggerInfo& HitInfo);
	void OnTriggerColliderConflictSteamAttack(const struct FHitTriggerInfo& HitInfo);
	void OnUpdateMoveSoundLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyBigTrain">();
	}
	static class AEnemyBigTrain* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyBigTrain>();
	}
};
static_assert(alignof(AEnemyBigTrain) == 0x000010, "Wrong alignment on AEnemyBigTrain");
static_assert(sizeof(AEnemyBigTrain) == 0x0006F0, "Wrong size on AEnemyBigTrain");
static_assert(offsetof(AEnemyBigTrain, TrainRecoveryTime) == 0x0005C0, "Member 'AEnemyBigTrain::TrainRecoveryTime' has a wrong offset!");
static_assert(offsetof(AEnemyBigTrain, MovefinishRate) == 0x0005C4, "Member 'AEnemyBigTrain::MovefinishRate' has a wrong offset!");
static_assert(offsetof(AEnemyBigTrain, TrainAnimationPlayRate) == 0x0005C8, "Member 'AEnemyBigTrain::TrainAnimationPlayRate' has a wrong offset!");
static_assert(offsetof(AEnemyBigTrain, TrainWarpLocation) == 0x0005D0, "Member 'AEnemyBigTrain::TrainWarpLocation' has a wrong offset!");
static_assert(offsetof(AEnemyBigTrain, m_IsSteamAttackOnly) == 0x0005E8, "Member 'AEnemyBigTrain::m_IsSteamAttackOnly' has a wrong offset!");
static_assert(offsetof(AEnemyBigTrain, TremorHighDistance) == 0x0005EC, "Member 'AEnemyBigTrain::TremorHighDistance' has a wrong offset!");
static_assert(offsetof(AEnemyBigTrain, TremorMiddleDistance) == 0x0005F0, "Member 'AEnemyBigTrain::TremorMiddleDistance' has a wrong offset!");
static_assert(offsetof(AEnemyBigTrain, TremorLowDistance) == 0x0005F4, "Member 'AEnemyBigTrain::TremorLowDistance' has a wrong offset!");
static_assert(offsetof(AEnemyBigTrain, m_SmokeEffectComponent) == 0x0005F8, "Member 'AEnemyBigTrain::m_SmokeEffectComponent' has a wrong offset!");
static_assert(offsetof(AEnemyBigTrain, m_SteamEffectComponent) == 0x000600, "Member 'AEnemyBigTrain::m_SteamEffectComponent' has a wrong offset!");
static_assert(offsetof(AEnemyBigTrain, m_SmokeSoundComponent) == 0x000608, "Member 'AEnemyBigTrain::m_SmokeSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemyBigTrain, m_WarningSoundComponent) == 0x000610, "Member 'AEnemyBigTrain::m_WarningSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemyBigTrain, m_CarHitSoundComponent) == 0x000618, "Member 'AEnemyBigTrain::m_CarHitSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemyBigTrain, m_MoveSoundComponent) == 0x000620, "Member 'AEnemyBigTrain::m_MoveSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemyBigTrain, m_CarSearchTriggerComponent) == 0x000628, "Member 'AEnemyBigTrain::m_CarSearchTriggerComponent' has a wrong offset!");
static_assert(offsetof(AEnemyBigTrain, TrainSkeletalMeshComponent) == 0x000630, "Member 'AEnemyBigTrain::TrainSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyBigTrain, _ColliderParam) == 0x000638, "Member 'AEnemyBigTrain::_ColliderParam' has a wrong offset!");
static_assert(offsetof(AEnemyBigTrain, bIsDamage) == 0x000639, "Member 'AEnemyBigTrain::bIsDamage' has a wrong offset!");
static_assert(offsetof(AEnemyBigTrain, m_MainBodyStaticBodyComponent) == 0x000640, "Member 'AEnemyBigTrain::m_MainBodyStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyBigTrain, m_SideBodyStaticBodyComponent) == 0x000648, "Member 'AEnemyBigTrain::m_SideBodyStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyBigTrain, m_FrontRightWheelStaticBodyComponent) == 0x000650, "Member 'AEnemyBigTrain::m_FrontRightWheelStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyBigTrain, m_FrontLeftWheelStaticBodyComponent) == 0x000658, "Member 'AEnemyBigTrain::m_FrontLeftWheelStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyBigTrain, m_MiddleRightWheelStaticBodyComponent) == 0x000660, "Member 'AEnemyBigTrain::m_MiddleRightWheelStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyBigTrain, m_MiddleLeftWheelStaticBodyComponent) == 0x000668, "Member 'AEnemyBigTrain::m_MiddleLeftWheelStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyBigTrain, m_RearRightWheelStaticBodyComponent) == 0x000670, "Member 'AEnemyBigTrain::m_RearRightWheelStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyBigTrain, m_RearLeftWheelStaticBodyComponent) == 0x000678, "Member 'AEnemyBigTrain::m_RearLeftWheelStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyBigTrain, m_RightShutterStaticBodyComponent) == 0x000680, "Member 'AEnemyBigTrain::m_RightShutterStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyBigTrain, m_LeftShutterStaticBodyComponent) == 0x000688, "Member 'AEnemyBigTrain::m_LeftShutterStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyBigTrain, AnimInstance) == 0x0006E8, "Member 'AEnemyBigTrain::AnimInstance' has a wrong offset!");

// Class UnionRun.GimmickMoveFloatBoo
// 0x0020 (0x05D0 - 0x05B0)
class alignas(0x10) AGimmickMoveFloatBoo final : public AUnionGimmickObjectBase
{
public:
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionVATAnimEventComponent*            BooVATMeshComponent;                               // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AnimStartFrame;                                    // 0x05C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C4[0xC];                                      // 0x05C4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickMoveFloatBoo">();
	}
	static class AGimmickMoveFloatBoo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickMoveFloatBoo>();
	}
};
static_assert(alignof(AGimmickMoveFloatBoo) == 0x000010, "Wrong alignment on AGimmickMoveFloatBoo");
static_assert(sizeof(AGimmickMoveFloatBoo) == 0x0005D0, "Wrong size on AGimmickMoveFloatBoo");
static_assert(offsetof(AGimmickMoveFloatBoo, DefaultSceneRoot) == 0x0005B0, "Member 'AGimmickMoveFloatBoo::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AGimmickMoveFloatBoo, BooVATMeshComponent) == 0x0005B8, "Member 'AGimmickMoveFloatBoo::BooVATMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickMoveFloatBoo, AnimStartFrame) == 0x0005C0, "Member 'AGimmickMoveFloatBoo::AnimStartFrame' has a wrong offset!");

// Class UnionRun.EnemyBoo
// 0x0118 (0x06D0 - 0x05B8)
class alignas(0x10) AEnemyBoo final : public AUnionEnemyBase
{
public:
	class UUnionVATAnimEventComponent*            VATMeshComponent;                                  // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NiagaraBarrel;                                     // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AEnemyBooBarrel*>                BarrelActorArray;                                  // 0x05C8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          bInterval;                                         // 0x05D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D9[0x3];                                      // 0x05D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpawnFrame;                                        // 0x05DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AnimStartFrame;                                    // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SpawnEffectFrame;                                  // 0x05E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ThrowingSoundFrame;                                // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PrepareSoundFrame;                                 // 0x05EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         IntervalSpawnFrame;                                // 0x05F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         IntervalAnimStartFrame;                            // 0x05F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         IntervalSpawnEffectFrame;                          // 0x05F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         IntervalThrowingSoundFrame;                        // 0x05FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         IntervalPrepareSoundFrame;                         // 0x0600(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_604[0x4];                                      // 0x0604(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         m_BarrelEffect_NS;                                 // 0x0608(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_610[0xC0];                                     // 0x0610(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyBoo">();
	}
	static class AEnemyBoo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyBoo>();
	}
};
static_assert(alignof(AEnemyBoo) == 0x000010, "Wrong alignment on AEnemyBoo");
static_assert(sizeof(AEnemyBoo) == 0x0006D0, "Wrong size on AEnemyBoo");
static_assert(offsetof(AEnemyBoo, VATMeshComponent) == 0x0005B8, "Member 'AEnemyBoo::VATMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyBoo, NiagaraBarrel) == 0x0005C0, "Member 'AEnemyBoo::NiagaraBarrel' has a wrong offset!");
static_assert(offsetof(AEnemyBoo, BarrelActorArray) == 0x0005C8, "Member 'AEnemyBoo::BarrelActorArray' has a wrong offset!");
static_assert(offsetof(AEnemyBoo, bInterval) == 0x0005D8, "Member 'AEnemyBoo::bInterval' has a wrong offset!");
static_assert(offsetof(AEnemyBoo, SpawnFrame) == 0x0005DC, "Member 'AEnemyBoo::SpawnFrame' has a wrong offset!");
static_assert(offsetof(AEnemyBoo, AnimStartFrame) == 0x0005E0, "Member 'AEnemyBoo::AnimStartFrame' has a wrong offset!");
static_assert(offsetof(AEnemyBoo, SpawnEffectFrame) == 0x0005E4, "Member 'AEnemyBoo::SpawnEffectFrame' has a wrong offset!");
static_assert(offsetof(AEnemyBoo, ThrowingSoundFrame) == 0x0005E8, "Member 'AEnemyBoo::ThrowingSoundFrame' has a wrong offset!");
static_assert(offsetof(AEnemyBoo, PrepareSoundFrame) == 0x0005EC, "Member 'AEnemyBoo::PrepareSoundFrame' has a wrong offset!");
static_assert(offsetof(AEnemyBoo, IntervalSpawnFrame) == 0x0005F0, "Member 'AEnemyBoo::IntervalSpawnFrame' has a wrong offset!");
static_assert(offsetof(AEnemyBoo, IntervalAnimStartFrame) == 0x0005F4, "Member 'AEnemyBoo::IntervalAnimStartFrame' has a wrong offset!");
static_assert(offsetof(AEnemyBoo, IntervalSpawnEffectFrame) == 0x0005F8, "Member 'AEnemyBoo::IntervalSpawnEffectFrame' has a wrong offset!");
static_assert(offsetof(AEnemyBoo, IntervalThrowingSoundFrame) == 0x0005FC, "Member 'AEnemyBoo::IntervalThrowingSoundFrame' has a wrong offset!");
static_assert(offsetof(AEnemyBoo, IntervalPrepareSoundFrame) == 0x000600, "Member 'AEnemyBoo::IntervalPrepareSoundFrame' has a wrong offset!");
static_assert(offsetof(AEnemyBoo, m_BarrelEffect_NS) == 0x000608, "Member 'AEnemyBoo::m_BarrelEffect_NS' has a wrong offset!");

// Class UnionRun.Gimmick_Extnd05_VolcanoWarning
// 0x0050 (0x0600 - 0x05B0)
class alignas(0x10) AGimmick_Extnd05_VolcanoWarning final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      WarningEffect;                                     // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      FireEffect;                                        // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            FireStaticBody;                                    // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    HitSound;                                          // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGimmick_Extnd05_VolcanoRock*           VolcanoRock;                                       // 0x05D8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Radius;                                            // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FireDuration;                                      // 0x05E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WarningStartRate;                                  // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5EC[0x14];                                     // 0x05EC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd05_VolcanoWarning">();
	}
	static class AGimmick_Extnd05_VolcanoWarning* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd05_VolcanoWarning>();
	}
};
static_assert(alignof(AGimmick_Extnd05_VolcanoWarning) == 0x000010, "Wrong alignment on AGimmick_Extnd05_VolcanoWarning");
static_assert(sizeof(AGimmick_Extnd05_VolcanoWarning) == 0x000600, "Wrong size on AGimmick_Extnd05_VolcanoWarning");
static_assert(offsetof(AGimmick_Extnd05_VolcanoWarning, WarningEffect) == 0x0005B8, "Member 'AGimmick_Extnd05_VolcanoWarning::WarningEffect' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_VolcanoWarning, FireEffect) == 0x0005C0, "Member 'AGimmick_Extnd05_VolcanoWarning::FireEffect' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_VolcanoWarning, FireStaticBody) == 0x0005C8, "Member 'AGimmick_Extnd05_VolcanoWarning::FireStaticBody' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_VolcanoWarning, HitSound) == 0x0005D0, "Member 'AGimmick_Extnd05_VolcanoWarning::HitSound' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_VolcanoWarning, VolcanoRock) == 0x0005D8, "Member 'AGimmick_Extnd05_VolcanoWarning::VolcanoRock' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_VolcanoWarning, Radius) == 0x0005E0, "Member 'AGimmick_Extnd05_VolcanoWarning::Radius' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_VolcanoWarning, FireDuration) == 0x0005E4, "Member 'AGimmick_Extnd05_VolcanoWarning::FireDuration' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_VolcanoWarning, WarningStartRate) == 0x0005E8, "Member 'AGimmick_Extnd05_VolcanoWarning::WarningStartRate' has a wrong offset!");

// Class UnionRun.EnemyBooBarrel
// 0x00C8 (0x0680 - 0x05B8)
class alignas(0x10) AEnemyBooBarrel final : public AUnionEnemyBase
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              StaticMeshComponent;                               // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticBodyComponent*                   StaticBodyComponent;                               // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      NiagaraExplosion;                                  // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      NiagaraBounce;                                     // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotSpeed;                                          // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsCourseObject;                                    // 0x05EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5ED[0x3];                                      // 0x05ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 BounceEffectSpawnRate;                             // 0x05F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_600[0x80];                                     // 0x0600(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyBooBarrel">();
	}
	static class AEnemyBooBarrel* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyBooBarrel>();
	}
};
static_assert(alignof(AEnemyBooBarrel) == 0x000010, "Wrong alignment on AEnemyBooBarrel");
static_assert(sizeof(AEnemyBooBarrel) == 0x000680, "Wrong size on AEnemyBooBarrel");
static_assert(offsetof(AEnemyBooBarrel, StaticMeshComponent) == 0x0005C0, "Member 'AEnemyBooBarrel::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyBooBarrel, DefaultSceneRoot) == 0x0005C8, "Member 'AEnemyBooBarrel::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AEnemyBooBarrel, StaticBodyComponent) == 0x0005D0, "Member 'AEnemyBooBarrel::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyBooBarrel, NiagaraExplosion) == 0x0005D8, "Member 'AEnemyBooBarrel::NiagaraExplosion' has a wrong offset!");
static_assert(offsetof(AEnemyBooBarrel, NiagaraBounce) == 0x0005E0, "Member 'AEnemyBooBarrel::NiagaraBounce' has a wrong offset!");
static_assert(offsetof(AEnemyBooBarrel, RotSpeed) == 0x0005E8, "Member 'AEnemyBooBarrel::RotSpeed' has a wrong offset!");
static_assert(offsetof(AEnemyBooBarrel, IsCourseObject) == 0x0005EC, "Member 'AEnemyBooBarrel::IsCourseObject' has a wrong offset!");
static_assert(offsetof(AEnemyBooBarrel, BounceEffectSpawnRate) == 0x0005F0, "Member 'AEnemyBooBarrel::BounceEffectSpawnRate' has a wrong offset!");

// Class UnionRun.EnemyDarkGaiaPhoenix
// 0x00B8 (0x0670 - 0x05B8)
class alignas(0x10) AEnemyDarkGaiaPhoenix final : public AUnionEnemyBase
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovefinishRate;                                    // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C4[0x4];                                      // 0x05C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Phase3WarpLocation;                                // 0x05C8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceSelectAttack;                                 // 0x05E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceLeftAttack;                                   // 0x05E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E2[0x6];                                      // 0x05E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionAtomComponent*                    BodySoundComponent;                                // 0x05E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionSkeletalMeshComponent*            m_BodySkeletalMeshComponent;                       // 0x05F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_bodyEffect;                                      // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AEnemyPhoenixFeatherPerformance*> PerfomanceActorArray;                             // 0x0600(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_610[0x50];                                     // 0x0610(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UDarkGaiaPhoenixAnimInstance*           AnimInstance;                                      // 0x0660(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_668[0x8];                                      // 0x0668(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayMoveSound();
	void OnStopMoveSound();
	void OnUpdateMoveSoundLocation();
	void StartAttack();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyDarkGaiaPhoenix">();
	}
	static class AEnemyDarkGaiaPhoenix* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyDarkGaiaPhoenix>();
	}
};
static_assert(alignof(AEnemyDarkGaiaPhoenix) == 0x000010, "Wrong alignment on AEnemyDarkGaiaPhoenix");
static_assert(sizeof(AEnemyDarkGaiaPhoenix) == 0x000670, "Wrong size on AEnemyDarkGaiaPhoenix");
static_assert(offsetof(AEnemyDarkGaiaPhoenix, MovefinishRate) == 0x0005C0, "Member 'AEnemyDarkGaiaPhoenix::MovefinishRate' has a wrong offset!");
static_assert(offsetof(AEnemyDarkGaiaPhoenix, Phase3WarpLocation) == 0x0005C8, "Member 'AEnemyDarkGaiaPhoenix::Phase3WarpLocation' has a wrong offset!");
static_assert(offsetof(AEnemyDarkGaiaPhoenix, ForceSelectAttack) == 0x0005E0, "Member 'AEnemyDarkGaiaPhoenix::ForceSelectAttack' has a wrong offset!");
static_assert(offsetof(AEnemyDarkGaiaPhoenix, ForceLeftAttack) == 0x0005E1, "Member 'AEnemyDarkGaiaPhoenix::ForceLeftAttack' has a wrong offset!");
static_assert(offsetof(AEnemyDarkGaiaPhoenix, BodySoundComponent) == 0x0005E8, "Member 'AEnemyDarkGaiaPhoenix::BodySoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemyDarkGaiaPhoenix, m_BodySkeletalMeshComponent) == 0x0005F0, "Member 'AEnemyDarkGaiaPhoenix::m_BodySkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyDarkGaiaPhoenix, m_bodyEffect) == 0x0005F8, "Member 'AEnemyDarkGaiaPhoenix::m_bodyEffect' has a wrong offset!");
static_assert(offsetof(AEnemyDarkGaiaPhoenix, PerfomanceActorArray) == 0x000600, "Member 'AEnemyDarkGaiaPhoenix::PerfomanceActorArray' has a wrong offset!");
static_assert(offsetof(AEnemyDarkGaiaPhoenix, AnimInstance) == 0x000660, "Member 'AEnemyDarkGaiaPhoenix::AnimInstance' has a wrong offset!");

// Class UnionRun.EnemyDarkGaiaPhoenixPhase3
// 0x00E8 (0x06A0 - 0x05B8)
class alignas(0x10) AEnemyDarkGaiaPhoenixPhase3 final : public AUnionEnemyBase
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ForceSelectAttack;                                 // 0x05C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceLeftAttack;                                   // 0x05C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C2[0x2];                                      // 0x05C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AppearTime;                                        // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FirstAttackIsLeft;                                 // 0x05C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C9[0x7];                                      // 0x05C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionAtomComponent*                    BodySoundComponent;                                // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionSkeletalMeshComponent*            m_BodySkeletalMeshComponent;                       // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_bodyEffect;                                      // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E8[0x58];                                     // 0x05E8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UDarkGaiaPhoenixAnimInstance*           AnimInstance;                                      // 0x0640(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_648[0x40];                                     // 0x0648(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class AEnemyPhoenixFireAttack*                RightFireAttack;                                   // 0x0688(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AEnemyPhoenixFireAttack*                LeftFireAttack;                                    // 0x0690(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_698[0x8];                                      // 0x0698(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateAttackEffect(bool IsRight, bool isMirrer);
	void OnPlayMoveSound();
	void OnStopMoveSound();
	void OnUpdateMoveSoundLocation();
	void WingAttack(bool IsRight, bool isMirrer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyDarkGaiaPhoenixPhase3">();
	}
	static class AEnemyDarkGaiaPhoenixPhase3* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyDarkGaiaPhoenixPhase3>();
	}
};
static_assert(alignof(AEnemyDarkGaiaPhoenixPhase3) == 0x000010, "Wrong alignment on AEnemyDarkGaiaPhoenixPhase3");
static_assert(sizeof(AEnemyDarkGaiaPhoenixPhase3) == 0x0006A0, "Wrong size on AEnemyDarkGaiaPhoenixPhase3");
static_assert(offsetof(AEnemyDarkGaiaPhoenixPhase3, ForceSelectAttack) == 0x0005C0, "Member 'AEnemyDarkGaiaPhoenixPhase3::ForceSelectAttack' has a wrong offset!");
static_assert(offsetof(AEnemyDarkGaiaPhoenixPhase3, ForceLeftAttack) == 0x0005C1, "Member 'AEnemyDarkGaiaPhoenixPhase3::ForceLeftAttack' has a wrong offset!");
static_assert(offsetof(AEnemyDarkGaiaPhoenixPhase3, AppearTime) == 0x0005C4, "Member 'AEnemyDarkGaiaPhoenixPhase3::AppearTime' has a wrong offset!");
static_assert(offsetof(AEnemyDarkGaiaPhoenixPhase3, FirstAttackIsLeft) == 0x0005C8, "Member 'AEnemyDarkGaiaPhoenixPhase3::FirstAttackIsLeft' has a wrong offset!");
static_assert(offsetof(AEnemyDarkGaiaPhoenixPhase3, BodySoundComponent) == 0x0005D0, "Member 'AEnemyDarkGaiaPhoenixPhase3::BodySoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemyDarkGaiaPhoenixPhase3, m_BodySkeletalMeshComponent) == 0x0005D8, "Member 'AEnemyDarkGaiaPhoenixPhase3::m_BodySkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyDarkGaiaPhoenixPhase3, m_bodyEffect) == 0x0005E0, "Member 'AEnemyDarkGaiaPhoenixPhase3::m_bodyEffect' has a wrong offset!");
static_assert(offsetof(AEnemyDarkGaiaPhoenixPhase3, AnimInstance) == 0x000640, "Member 'AEnemyDarkGaiaPhoenixPhase3::AnimInstance' has a wrong offset!");
static_assert(offsetof(AEnemyDarkGaiaPhoenixPhase3, RightFireAttack) == 0x000688, "Member 'AEnemyDarkGaiaPhoenixPhase3::RightFireAttack' has a wrong offset!");
static_assert(offsetof(AEnemyDarkGaiaPhoenixPhase3, LeftFireAttack) == 0x000690, "Member 'AEnemyDarkGaiaPhoenixPhase3::LeftFireAttack' has a wrong offset!");

// Class UnionRun.GimmickFeatherBombWarning
// 0x00B0 (0x0660 - 0x05B0)
class alignas(0x10) AGimmickFeatherBombWarning final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReadyParticleRadiusParameter;                      // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarningActiveTime;                                 // 0x05BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BombAttackingTime;                                 // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BombEffectOffsetHeight;                            // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplodeParticleRadiusParameter;                    // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplodeParticleDurationParameter;                  // 0x05CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERacerDamageType                              DamageType;                                        // 0x05D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D1[0x7];                                      // 0x05D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      m_attackReadyEffect;                               // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_bombAttackEffect;                                // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    BombExplodeSoundComponent;                         // 0x05E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            m_BombStaticBodyComponent;                         // 0x05F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F8[0x68];                                     // 0x05F8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickFeatherBombWarning">();
	}
	static class AGimmickFeatherBombWarning* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickFeatherBombWarning>();
	}
};
static_assert(alignof(AGimmickFeatherBombWarning) == 0x000010, "Wrong alignment on AGimmickFeatherBombWarning");
static_assert(sizeof(AGimmickFeatherBombWarning) == 0x000660, "Wrong size on AGimmickFeatherBombWarning");
static_assert(offsetof(AGimmickFeatherBombWarning, ReadyParticleRadiusParameter) == 0x0005B8, "Member 'AGimmickFeatherBombWarning::ReadyParticleRadiusParameter' has a wrong offset!");
static_assert(offsetof(AGimmickFeatherBombWarning, WarningActiveTime) == 0x0005BC, "Member 'AGimmickFeatherBombWarning::WarningActiveTime' has a wrong offset!");
static_assert(offsetof(AGimmickFeatherBombWarning, BombAttackingTime) == 0x0005C0, "Member 'AGimmickFeatherBombWarning::BombAttackingTime' has a wrong offset!");
static_assert(offsetof(AGimmickFeatherBombWarning, BombEffectOffsetHeight) == 0x0005C4, "Member 'AGimmickFeatherBombWarning::BombEffectOffsetHeight' has a wrong offset!");
static_assert(offsetof(AGimmickFeatherBombWarning, ExplodeParticleRadiusParameter) == 0x0005C8, "Member 'AGimmickFeatherBombWarning::ExplodeParticleRadiusParameter' has a wrong offset!");
static_assert(offsetof(AGimmickFeatherBombWarning, ExplodeParticleDurationParameter) == 0x0005CC, "Member 'AGimmickFeatherBombWarning::ExplodeParticleDurationParameter' has a wrong offset!");
static_assert(offsetof(AGimmickFeatherBombWarning, DamageType) == 0x0005D0, "Member 'AGimmickFeatherBombWarning::DamageType' has a wrong offset!");
static_assert(offsetof(AGimmickFeatherBombWarning, m_attackReadyEffect) == 0x0005D8, "Member 'AGimmickFeatherBombWarning::m_attackReadyEffect' has a wrong offset!");
static_assert(offsetof(AGimmickFeatherBombWarning, m_bombAttackEffect) == 0x0005E0, "Member 'AGimmickFeatherBombWarning::m_bombAttackEffect' has a wrong offset!");
static_assert(offsetof(AGimmickFeatherBombWarning, BombExplodeSoundComponent) == 0x0005E8, "Member 'AGimmickFeatherBombWarning::BombExplodeSoundComponent' has a wrong offset!");
static_assert(offsetof(AGimmickFeatherBombWarning, m_BombStaticBodyComponent) == 0x0005F0, "Member 'AGimmickFeatherBombWarning::m_BombStaticBodyComponent' has a wrong offset!");

// Class UnionRun.EnemyDeathEgg
// 0x00E8 (0x06A0 - 0x05B8)
class alignas(0x10) AEnemyDeathEgg final : public AUnionEnemyBase
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionSkeletalMeshComponent*            Mesh;                                              // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            Body;                                              // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackIntervalTime;                                // 0x05D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PunchLoopTime;                                     // 0x05D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugDrawCollider;                                 // 0x05D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D9[0x7];                                      // 0x05D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDeathEggAnimInstance*                  AnimInstance;                                      // 0x05E0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E8[0xB8];                                     // 0x05E8(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyDeathEgg">();
	}
	static class AEnemyDeathEgg* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyDeathEgg>();
	}
};
static_assert(alignof(AEnemyDeathEgg) == 0x000010, "Wrong alignment on AEnemyDeathEgg");
static_assert(sizeof(AEnemyDeathEgg) == 0x0006A0, "Wrong size on AEnemyDeathEgg");
static_assert(offsetof(AEnemyDeathEgg, Mesh) == 0x0005C0, "Member 'AEnemyDeathEgg::Mesh' has a wrong offset!");
static_assert(offsetof(AEnemyDeathEgg, Body) == 0x0005C8, "Member 'AEnemyDeathEgg::Body' has a wrong offset!");
static_assert(offsetof(AEnemyDeathEgg, AttackIntervalTime) == 0x0005D0, "Member 'AEnemyDeathEgg::AttackIntervalTime' has a wrong offset!");
static_assert(offsetof(AEnemyDeathEgg, PunchLoopTime) == 0x0005D4, "Member 'AEnemyDeathEgg::PunchLoopTime' has a wrong offset!");
static_assert(offsetof(AEnemyDeathEgg, DebugDrawCollider) == 0x0005D8, "Member 'AEnemyDeathEgg::DebugDrawCollider' has a wrong offset!");
static_assert(offsetof(AEnemyDeathEgg, AnimInstance) == 0x0005E0, "Member 'AEnemyDeathEgg::AnimInstance' has a wrong offset!");

// Class UnionRun.GimmckEventCollision
// 0x0050 (0x0600 - 0x05B0)
class alignas(0x10) AGimmckEventCollision final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                m_boxExtent;                                       // 0x05B8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStageId                                      m_stageId;                                         // 0x05D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D1[0x3];                                      // 0x05D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         m_uniqueEventId;                                   // 0x05D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AUnionGimmickObjectBase*>        SubscribingGimmicks;                               // 0x05D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticBodyComponent*                   StaticBodyComponent;                               // 0x05F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bNotifyRepeatedly;                                 // 0x05F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F9[0x7];                                      // 0x05F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEventId(EUnionEventId EventId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmckEventCollision">();
	}
	static class AGimmckEventCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmckEventCollision>();
	}
};
static_assert(alignof(AGimmckEventCollision) == 0x000010, "Wrong alignment on AGimmckEventCollision");
static_assert(sizeof(AGimmckEventCollision) == 0x000600, "Wrong size on AGimmckEventCollision");
static_assert(offsetof(AGimmckEventCollision, m_boxExtent) == 0x0005B8, "Member 'AGimmckEventCollision::m_boxExtent' has a wrong offset!");
static_assert(offsetof(AGimmckEventCollision, m_stageId) == 0x0005D0, "Member 'AGimmckEventCollision::m_stageId' has a wrong offset!");
static_assert(offsetof(AGimmckEventCollision, m_uniqueEventId) == 0x0005D4, "Member 'AGimmckEventCollision::m_uniqueEventId' has a wrong offset!");
static_assert(offsetof(AGimmckEventCollision, SubscribingGimmicks) == 0x0005D8, "Member 'AGimmckEventCollision::SubscribingGimmicks' has a wrong offset!");
static_assert(offsetof(AGimmckEventCollision, DefaultSceneRoot) == 0x0005E8, "Member 'AGimmckEventCollision::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AGimmckEventCollision, StaticBodyComponent) == 0x0005F0, "Member 'AGimmckEventCollision::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmckEventCollision, bNotifyRepeatedly) == 0x0005F8, "Member 'AGimmckEventCollision::bNotifyRepeatedly' has a wrong offset!");

// Class UnionRun.EnemyEggChaser
// 0x00F8 (0x06B0 - 0x05B8)
class alignas(0x10) AEnemyEggChaser final : public AUnionEnemyBase
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AppearTime;                                        // 0x05C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChaseAttackingTime;                                // 0x05C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackWarningTime;                                 // 0x05C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackCollisionActiveTime;                         // 0x05CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaserScale;                                        // 0x05D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D4[0x4];                                      // 0x05D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionSkeletalMeshComponent*            m_BodySkeletalMeshComponent;                       // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              m_RightLaserStaticMeshComponent;                   // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              m_LeftLaserStaticMeshComponent;                    // 0x05E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              m_RightLaserHitStaticMeshComponent;                // 0x05F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              m_LeftLaserHitStaticMeshComponent;                 // 0x05F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              m_BurnerStaticMeshComponent;                       // 0x0600(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            m_RightAttackStaticBodyComponent;                  // 0x0608(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            m_LeftAttackStaticBodyComponent;                   // 0x0610(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    LaserAttackSoundComponent;                         // 0x0618(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_BurnerEffect;                                    // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_RightAttackHitEffect;                            // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_LeftAttackHitEffect;                             // 0x0630(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_638[0x70];                                     // 0x0638(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UEggChaserAnimInstance*                 AnimInstance;                                      // 0x06A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ActivateAttack();
	void ActivateChase();
	void StartAttack(bool IsEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyEggChaser">();
	}
	static class AEnemyEggChaser* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyEggChaser>();
	}
};
static_assert(alignof(AEnemyEggChaser) == 0x000010, "Wrong alignment on AEnemyEggChaser");
static_assert(sizeof(AEnemyEggChaser) == 0x0006B0, "Wrong size on AEnemyEggChaser");
static_assert(offsetof(AEnemyEggChaser, AppearTime) == 0x0005C0, "Member 'AEnemyEggChaser::AppearTime' has a wrong offset!");
static_assert(offsetof(AEnemyEggChaser, ChaseAttackingTime) == 0x0005C4, "Member 'AEnemyEggChaser::ChaseAttackingTime' has a wrong offset!");
static_assert(offsetof(AEnemyEggChaser, AttackWarningTime) == 0x0005C8, "Member 'AEnemyEggChaser::AttackWarningTime' has a wrong offset!");
static_assert(offsetof(AEnemyEggChaser, AttackCollisionActiveTime) == 0x0005CC, "Member 'AEnemyEggChaser::AttackCollisionActiveTime' has a wrong offset!");
static_assert(offsetof(AEnemyEggChaser, LaserScale) == 0x0005D0, "Member 'AEnemyEggChaser::LaserScale' has a wrong offset!");
static_assert(offsetof(AEnemyEggChaser, m_BodySkeletalMeshComponent) == 0x0005D8, "Member 'AEnemyEggChaser::m_BodySkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyEggChaser, m_RightLaserStaticMeshComponent) == 0x0005E0, "Member 'AEnemyEggChaser::m_RightLaserStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyEggChaser, m_LeftLaserStaticMeshComponent) == 0x0005E8, "Member 'AEnemyEggChaser::m_LeftLaserStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyEggChaser, m_RightLaserHitStaticMeshComponent) == 0x0005F0, "Member 'AEnemyEggChaser::m_RightLaserHitStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyEggChaser, m_LeftLaserHitStaticMeshComponent) == 0x0005F8, "Member 'AEnemyEggChaser::m_LeftLaserHitStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyEggChaser, m_BurnerStaticMeshComponent) == 0x000600, "Member 'AEnemyEggChaser::m_BurnerStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyEggChaser, m_RightAttackStaticBodyComponent) == 0x000608, "Member 'AEnemyEggChaser::m_RightAttackStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyEggChaser, m_LeftAttackStaticBodyComponent) == 0x000610, "Member 'AEnemyEggChaser::m_LeftAttackStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyEggChaser, LaserAttackSoundComponent) == 0x000618, "Member 'AEnemyEggChaser::LaserAttackSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemyEggChaser, m_BurnerEffect) == 0x000620, "Member 'AEnemyEggChaser::m_BurnerEffect' has a wrong offset!");
static_assert(offsetof(AEnemyEggChaser, m_RightAttackHitEffect) == 0x000628, "Member 'AEnemyEggChaser::m_RightAttackHitEffect' has a wrong offset!");
static_assert(offsetof(AEnemyEggChaser, m_LeftAttackHitEffect) == 0x000630, "Member 'AEnemyEggChaser::m_LeftAttackHitEffect' has a wrong offset!");
static_assert(offsetof(AEnemyEggChaser, AnimInstance) == 0x0006A8, "Member 'AEnemyEggChaser::AnimInstance' has a wrong offset!");

// Class UnionRun.EnemyFlowerTentacle
// 0x0118 (0x06D0 - 0x05B8)
class alignas(0x10) AEnemyFlowerTentacle final : public AUnionEnemyBase
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttackEffectOffsetHeight;                          // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarningEffectOffsetHeight;                         // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivateWaitTime;                                  // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TentacleIdleTime;                                  // 0x05CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TentacleAdditionalIdleTime;                        // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TentacleReadyTime;                                 // 0x05D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TentacleAppearTime;                                // 0x05D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TentacleAttackTime;                                // 0x05DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TentacleDigTime;                                   // 0x05E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AttackMotionIndex;                                 // 0x05E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AttackStartFrame;                                  // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AttackEndFrame;                                    // 0x05EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleMotionIndex;                                   // 0x05F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleStartFrame;                                    // 0x05F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleEndFrame;                                      // 0x05F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DigMotionIndex;                                    // 0x05FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DigStartFrame;                                     // 0x0600(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DigEndFrame;                                       // 0x0604(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionSkeletalMeshComponent*            PlantSkeletalMeshComponent;                        // 0x0608(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionVATMeshComponent*                 VATModelMeshComponent;                             // 0x0610(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    TentacleUpSoundComponent;                          // 0x0618(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    TentacleWarningSoundComponent;                     // 0x0620(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_WarningSmokeEffect;                              // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_AttackStartEffect;                               // 0x0630(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0638(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            m_TentacleStaticBodyComponent;                     // 0x0640(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_648[0x88];                                     // 0x0648(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyFlowerTentacle">();
	}
	static class AEnemyFlowerTentacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyFlowerTentacle>();
	}
};
static_assert(alignof(AEnemyFlowerTentacle) == 0x000010, "Wrong alignment on AEnemyFlowerTentacle");
static_assert(sizeof(AEnemyFlowerTentacle) == 0x0006D0, "Wrong size on AEnemyFlowerTentacle");
static_assert(offsetof(AEnemyFlowerTentacle, AttackEffectOffsetHeight) == 0x0005C0, "Member 'AEnemyFlowerTentacle::AttackEffectOffsetHeight' has a wrong offset!");
static_assert(offsetof(AEnemyFlowerTentacle, WarningEffectOffsetHeight) == 0x0005C4, "Member 'AEnemyFlowerTentacle::WarningEffectOffsetHeight' has a wrong offset!");
static_assert(offsetof(AEnemyFlowerTentacle, ActivateWaitTime) == 0x0005C8, "Member 'AEnemyFlowerTentacle::ActivateWaitTime' has a wrong offset!");
static_assert(offsetof(AEnemyFlowerTentacle, TentacleIdleTime) == 0x0005CC, "Member 'AEnemyFlowerTentacle::TentacleIdleTime' has a wrong offset!");
static_assert(offsetof(AEnemyFlowerTentacle, TentacleAdditionalIdleTime) == 0x0005D0, "Member 'AEnemyFlowerTentacle::TentacleAdditionalIdleTime' has a wrong offset!");
static_assert(offsetof(AEnemyFlowerTentacle, TentacleReadyTime) == 0x0005D4, "Member 'AEnemyFlowerTentacle::TentacleReadyTime' has a wrong offset!");
static_assert(offsetof(AEnemyFlowerTentacle, TentacleAppearTime) == 0x0005D8, "Member 'AEnemyFlowerTentacle::TentacleAppearTime' has a wrong offset!");
static_assert(offsetof(AEnemyFlowerTentacle, TentacleAttackTime) == 0x0005DC, "Member 'AEnemyFlowerTentacle::TentacleAttackTime' has a wrong offset!");
static_assert(offsetof(AEnemyFlowerTentacle, TentacleDigTime) == 0x0005E0, "Member 'AEnemyFlowerTentacle::TentacleDigTime' has a wrong offset!");
static_assert(offsetof(AEnemyFlowerTentacle, AttackMotionIndex) == 0x0005E4, "Member 'AEnemyFlowerTentacle::AttackMotionIndex' has a wrong offset!");
static_assert(offsetof(AEnemyFlowerTentacle, AttackStartFrame) == 0x0005E8, "Member 'AEnemyFlowerTentacle::AttackStartFrame' has a wrong offset!");
static_assert(offsetof(AEnemyFlowerTentacle, AttackEndFrame) == 0x0005EC, "Member 'AEnemyFlowerTentacle::AttackEndFrame' has a wrong offset!");
static_assert(offsetof(AEnemyFlowerTentacle, IdleMotionIndex) == 0x0005F0, "Member 'AEnemyFlowerTentacle::IdleMotionIndex' has a wrong offset!");
static_assert(offsetof(AEnemyFlowerTentacle, IdleStartFrame) == 0x0005F4, "Member 'AEnemyFlowerTentacle::IdleStartFrame' has a wrong offset!");
static_assert(offsetof(AEnemyFlowerTentacle, IdleEndFrame) == 0x0005F8, "Member 'AEnemyFlowerTentacle::IdleEndFrame' has a wrong offset!");
static_assert(offsetof(AEnemyFlowerTentacle, DigMotionIndex) == 0x0005FC, "Member 'AEnemyFlowerTentacle::DigMotionIndex' has a wrong offset!");
static_assert(offsetof(AEnemyFlowerTentacle, DigStartFrame) == 0x000600, "Member 'AEnemyFlowerTentacle::DigStartFrame' has a wrong offset!");
static_assert(offsetof(AEnemyFlowerTentacle, DigEndFrame) == 0x000604, "Member 'AEnemyFlowerTentacle::DigEndFrame' has a wrong offset!");
static_assert(offsetof(AEnemyFlowerTentacle, PlantSkeletalMeshComponent) == 0x000608, "Member 'AEnemyFlowerTentacle::PlantSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyFlowerTentacle, VATModelMeshComponent) == 0x000610, "Member 'AEnemyFlowerTentacle::VATModelMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyFlowerTentacle, TentacleUpSoundComponent) == 0x000618, "Member 'AEnemyFlowerTentacle::TentacleUpSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemyFlowerTentacle, TentacleWarningSoundComponent) == 0x000620, "Member 'AEnemyFlowerTentacle::TentacleWarningSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemyFlowerTentacle, m_WarningSmokeEffect) == 0x000628, "Member 'AEnemyFlowerTentacle::m_WarningSmokeEffect' has a wrong offset!");
static_assert(offsetof(AEnemyFlowerTentacle, m_AttackStartEffect) == 0x000630, "Member 'AEnemyFlowerTentacle::m_AttackStartEffect' has a wrong offset!");
static_assert(offsetof(AEnemyFlowerTentacle, DefaultSceneRoot) == 0x000638, "Member 'AEnemyFlowerTentacle::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AEnemyFlowerTentacle, m_TentacleStaticBodyComponent) == 0x000640, "Member 'AEnemyFlowerTentacle::m_TentacleStaticBodyComponent' has a wrong offset!");

// Class UnionRun.EnemyFossilBase
// 0x0018 (0x05D0 - 0x05B8)
class alignas(0x10) AEnemyFossilBase : public AUnionEnemyBase
{
public:
	class UUnionSkeletalMeshComponent*            BodySkeletalMeshComponent;                         // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_isFinalLap;                                      // 0x05C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C1[0x7];                                      // 0x05C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionAtomComponent*                    BreakSoundComponent;                               // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyFossilBase">();
	}
	static class AEnemyFossilBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyFossilBase>();
	}
};
static_assert(alignof(AEnemyFossilBase) == 0x000010, "Wrong alignment on AEnemyFossilBase");
static_assert(sizeof(AEnemyFossilBase) == 0x0005D0, "Wrong size on AEnemyFossilBase");
static_assert(offsetof(AEnemyFossilBase, BodySkeletalMeshComponent) == 0x0005B8, "Member 'AEnemyFossilBase::BodySkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyFossilBase, m_isFinalLap) == 0x0005C0, "Member 'AEnemyFossilBase::m_isFinalLap' has a wrong offset!");
static_assert(offsetof(AEnemyFossilBase, BreakSoundComponent) == 0x0005C8, "Member 'AEnemyFossilBase::BreakSoundComponent' has a wrong offset!");

// Class UnionRun.GimmickPaintShower
// 0x0120 (0x06D0 - 0x05B0)
class alignas(0x10) AGimmickPaintShower final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x10];                                     // 0x05B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        m_movableRoot;                                     // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              m_staticMesh;                                      // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              m_shadowMesh;                                      // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            m_body;                                            // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_alertSound;                                      // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_showerSound;                                     // 0x05E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_showerReadyEffect;                               // 0x05F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_showerEffect;                                    // 0x05F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERacerDamageType                              m_damageType;                                      // 0x0600(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVehicleFreshlyPaint                          m_paintColor;                                      // 0x0601(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_602[0x2];                                      // 0x0602(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_intervalTime;                                    // 0x0604(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_emissiveEffectTime;                              // 0x0608(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_showerTime;                                      // 0x060C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_firstDelayTime;                                  // 0x0610(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_collisionFallTime;                               // 0x0614(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_collisionDisappearTime;                          // 0x0618(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_isStopMoveForShower;                             // 0x061C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPaintShowerHeightRecalcTiming                m_showerHeightRecalctiming;                        // 0x061D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61E[0x2];                                      // 0x061E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_showerEffectHeightOffset;                        // 0x0620(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_autoShadowHeight;                                // 0x0624(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_625[0x3];                                      // 0x0625(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_shadowHeightOffset;                              // 0x0628(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_autoShadowUpVector;                              // 0x062C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62D[0x3];                                      // 0x062D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         m_emissiveStrengthMaterialIndex;                   // 0x0630(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_maxEmissiveStrength;                             // 0x0634(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_minEmissiveStrength;                             // 0x0638(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63C[0x4];                                      // 0x063C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            m_emissiveCurve;                                   // 0x0640(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_emissiveFadeOutTime;                             // 0x0648(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64C[0x84];                                     // 0x064C(0x0084)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickPaintShower">();
	}
	static class AGimmickPaintShower* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickPaintShower>();
	}
};
static_assert(alignof(AGimmickPaintShower) == 0x000010, "Wrong alignment on AGimmickPaintShower");
static_assert(sizeof(AGimmickPaintShower) == 0x0006D0, "Wrong size on AGimmickPaintShower");
static_assert(offsetof(AGimmickPaintShower, m_movableRoot) == 0x0005C0, "Member 'AGimmickPaintShower::m_movableRoot' has a wrong offset!");
static_assert(offsetof(AGimmickPaintShower, m_staticMesh) == 0x0005C8, "Member 'AGimmickPaintShower::m_staticMesh' has a wrong offset!");
static_assert(offsetof(AGimmickPaintShower, m_shadowMesh) == 0x0005D0, "Member 'AGimmickPaintShower::m_shadowMesh' has a wrong offset!");
static_assert(offsetof(AGimmickPaintShower, m_body) == 0x0005D8, "Member 'AGimmickPaintShower::m_body' has a wrong offset!");
static_assert(offsetof(AGimmickPaintShower, m_alertSound) == 0x0005E0, "Member 'AGimmickPaintShower::m_alertSound' has a wrong offset!");
static_assert(offsetof(AGimmickPaintShower, m_showerSound) == 0x0005E8, "Member 'AGimmickPaintShower::m_showerSound' has a wrong offset!");
static_assert(offsetof(AGimmickPaintShower, m_showerReadyEffect) == 0x0005F0, "Member 'AGimmickPaintShower::m_showerReadyEffect' has a wrong offset!");
static_assert(offsetof(AGimmickPaintShower, m_showerEffect) == 0x0005F8, "Member 'AGimmickPaintShower::m_showerEffect' has a wrong offset!");
static_assert(offsetof(AGimmickPaintShower, m_damageType) == 0x000600, "Member 'AGimmickPaintShower::m_damageType' has a wrong offset!");
static_assert(offsetof(AGimmickPaintShower, m_paintColor) == 0x000601, "Member 'AGimmickPaintShower::m_paintColor' has a wrong offset!");
static_assert(offsetof(AGimmickPaintShower, m_intervalTime) == 0x000604, "Member 'AGimmickPaintShower::m_intervalTime' has a wrong offset!");
static_assert(offsetof(AGimmickPaintShower, m_emissiveEffectTime) == 0x000608, "Member 'AGimmickPaintShower::m_emissiveEffectTime' has a wrong offset!");
static_assert(offsetof(AGimmickPaintShower, m_showerTime) == 0x00060C, "Member 'AGimmickPaintShower::m_showerTime' has a wrong offset!");
static_assert(offsetof(AGimmickPaintShower, m_firstDelayTime) == 0x000610, "Member 'AGimmickPaintShower::m_firstDelayTime' has a wrong offset!");
static_assert(offsetof(AGimmickPaintShower, m_collisionFallTime) == 0x000614, "Member 'AGimmickPaintShower::m_collisionFallTime' has a wrong offset!");
static_assert(offsetof(AGimmickPaintShower, m_collisionDisappearTime) == 0x000618, "Member 'AGimmickPaintShower::m_collisionDisappearTime' has a wrong offset!");
static_assert(offsetof(AGimmickPaintShower, m_isStopMoveForShower) == 0x00061C, "Member 'AGimmickPaintShower::m_isStopMoveForShower' has a wrong offset!");
static_assert(offsetof(AGimmickPaintShower, m_showerHeightRecalctiming) == 0x00061D, "Member 'AGimmickPaintShower::m_showerHeightRecalctiming' has a wrong offset!");
static_assert(offsetof(AGimmickPaintShower, m_showerEffectHeightOffset) == 0x000620, "Member 'AGimmickPaintShower::m_showerEffectHeightOffset' has a wrong offset!");
static_assert(offsetof(AGimmickPaintShower, m_autoShadowHeight) == 0x000624, "Member 'AGimmickPaintShower::m_autoShadowHeight' has a wrong offset!");
static_assert(offsetof(AGimmickPaintShower, m_shadowHeightOffset) == 0x000628, "Member 'AGimmickPaintShower::m_shadowHeightOffset' has a wrong offset!");
static_assert(offsetof(AGimmickPaintShower, m_autoShadowUpVector) == 0x00062C, "Member 'AGimmickPaintShower::m_autoShadowUpVector' has a wrong offset!");
static_assert(offsetof(AGimmickPaintShower, m_emissiveStrengthMaterialIndex) == 0x000630, "Member 'AGimmickPaintShower::m_emissiveStrengthMaterialIndex' has a wrong offset!");
static_assert(offsetof(AGimmickPaintShower, m_maxEmissiveStrength) == 0x000634, "Member 'AGimmickPaintShower::m_maxEmissiveStrength' has a wrong offset!");
static_assert(offsetof(AGimmickPaintShower, m_minEmissiveStrength) == 0x000638, "Member 'AGimmickPaintShower::m_minEmissiveStrength' has a wrong offset!");
static_assert(offsetof(AGimmickPaintShower, m_emissiveCurve) == 0x000640, "Member 'AGimmickPaintShower::m_emissiveCurve' has a wrong offset!");
static_assert(offsetof(AGimmickPaintShower, m_emissiveFadeOutTime) == 0x000648, "Member 'AGimmickPaintShower::m_emissiveFadeOutTime' has a wrong offset!");

// Class UnionRun.EnemyFossilDipro
// 0x0080 (0x0650 - 0x05D0)
class AEnemyFossilDipro final : public AEnemyFossilBase
{
public:
	uint8                                         Pad_5D0[0x8];                                      // 0x05D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageRecoveryTime;                                // 0x05D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5DC[0x4];                                      // 0x05DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGimmickStaticBodyComponent*            FossilBodyComponent;                               // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            FossilNeck3BodyComponent;                          // 0x05E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F0[0x58];                                     // 0x05F0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UFossilTrexAnimInstance*                AnimInstance;                                      // 0x0648(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyFossilDipro">();
	}
	static class AEnemyFossilDipro* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyFossilDipro>();
	}
};
static_assert(alignof(AEnemyFossilDipro) == 0x000010, "Wrong alignment on AEnemyFossilDipro");
static_assert(sizeof(AEnemyFossilDipro) == 0x000650, "Wrong size on AEnemyFossilDipro");
static_assert(offsetof(AEnemyFossilDipro, DamageRecoveryTime) == 0x0005D8, "Member 'AEnemyFossilDipro::DamageRecoveryTime' has a wrong offset!");
static_assert(offsetof(AEnemyFossilDipro, FossilBodyComponent) == 0x0005E0, "Member 'AEnemyFossilDipro::FossilBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyFossilDipro, FossilNeck3BodyComponent) == 0x0005E8, "Member 'AEnemyFossilDipro::FossilNeck3BodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyFossilDipro, AnimInstance) == 0x000648, "Member 'AEnemyFossilDipro::AnimInstance' has a wrong offset!");

// Class UnionRun.Gimmick_Extnd07_ObjectController
// 0x0030 (0x05E0 - 0x05B0)
class alignas(0x10) AGimmick_Extnd07_ObjectController final : public AUnionGimmickObjectBase
{
public:
	class UMaterialParameterCollection*           MaterialParam;                                     // 0x05B0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B8[0x28];                                     // 0x05B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd07_ObjectController">();
	}
	static class AGimmick_Extnd07_ObjectController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd07_ObjectController>();
	}
};
static_assert(alignof(AGimmick_Extnd07_ObjectController) == 0x000010, "Wrong alignment on AGimmick_Extnd07_ObjectController");
static_assert(sizeof(AGimmick_Extnd07_ObjectController) == 0x0005E0, "Wrong size on AGimmick_Extnd07_ObjectController");
static_assert(offsetof(AGimmick_Extnd07_ObjectController, MaterialParam) == 0x0005B0, "Member 'AGimmick_Extnd07_ObjectController::MaterialParam' has a wrong offset!");

// Class UnionRun.EnemyFossilTrex
// 0x00B0 (0x0680 - 0x05D0)
class AEnemyFossilTrex final : public AEnemyFossilBase
{
public:
	uint8                                         Pad_5D0[0x8];                                      // 0x05D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsTypeB;                                          // 0x05D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D9[0x3];                                      // 0x05D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageRecoveryTime;                                // 0x05DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            FossilBodyComponent;                               // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            FossilRightHandBodyComponent;                      // 0x05E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            FossilLeftHandBodyComponent;                       // 0x05F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            FossilWaistBodyComponent;                          // 0x05F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            FossilChestBodyComponent;                          // 0x0600(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            LeftFootStaticBodyComponent;                       // 0x0608(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            RightFootStaticBodyComponent;                      // 0x0610(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_618[0x58];                                     // 0x0618(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UFossilTrexAnimInstance*                AnimInstance;                                      // 0x0670(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_678[0x8];                                      // 0x0678(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyFossilTrex">();
	}
	static class AEnemyFossilTrex* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyFossilTrex>();
	}
};
static_assert(alignof(AEnemyFossilTrex) == 0x000010, "Wrong alignment on AEnemyFossilTrex");
static_assert(sizeof(AEnemyFossilTrex) == 0x000680, "Wrong size on AEnemyFossilTrex");
static_assert(offsetof(AEnemyFossilTrex, bIsTypeB) == 0x0005D8, "Member 'AEnemyFossilTrex::bIsTypeB' has a wrong offset!");
static_assert(offsetof(AEnemyFossilTrex, DamageRecoveryTime) == 0x0005DC, "Member 'AEnemyFossilTrex::DamageRecoveryTime' has a wrong offset!");
static_assert(offsetof(AEnemyFossilTrex, FossilBodyComponent) == 0x0005E0, "Member 'AEnemyFossilTrex::FossilBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyFossilTrex, FossilRightHandBodyComponent) == 0x0005E8, "Member 'AEnemyFossilTrex::FossilRightHandBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyFossilTrex, FossilLeftHandBodyComponent) == 0x0005F0, "Member 'AEnemyFossilTrex::FossilLeftHandBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyFossilTrex, FossilWaistBodyComponent) == 0x0005F8, "Member 'AEnemyFossilTrex::FossilWaistBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyFossilTrex, FossilChestBodyComponent) == 0x000600, "Member 'AEnemyFossilTrex::FossilChestBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyFossilTrex, LeftFootStaticBodyComponent) == 0x000608, "Member 'AEnemyFossilTrex::LeftFootStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyFossilTrex, RightFootStaticBodyComponent) == 0x000610, "Member 'AEnemyFossilTrex::RightFootStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyFossilTrex, AnimInstance) == 0x000670, "Member 'AEnemyFossilTrex::AnimInstance' has a wrong offset!");

// Class UnionRun.EnemyFossilTrexBite
// 0x0080 (0x0650 - 0x05D0)
class AEnemyFossilTrexBite final : public AEnemyFossilBase
{
public:
	uint8                                         Pad_5D0[0x8];                                      // 0x05D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsTypeB;                                          // 0x05D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D9[0x3];                                      // 0x05D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageRecoveryTime;                                // 0x05DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            FossilBodyComponent;                               // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            FossilBodyUpComponent;                             // 0x05E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F0[0x58];                                     // 0x05F0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UFossilTrexAnimInstance*                AnimInstance;                                      // 0x0648(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyFossilTrexBite">();
	}
	static class AEnemyFossilTrexBite* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyFossilTrexBite>();
	}
};
static_assert(alignof(AEnemyFossilTrexBite) == 0x000010, "Wrong alignment on AEnemyFossilTrexBite");
static_assert(sizeof(AEnemyFossilTrexBite) == 0x000650, "Wrong size on AEnemyFossilTrexBite");
static_assert(offsetof(AEnemyFossilTrexBite, bIsTypeB) == 0x0005D8, "Member 'AEnemyFossilTrexBite::bIsTypeB' has a wrong offset!");
static_assert(offsetof(AEnemyFossilTrexBite, DamageRecoveryTime) == 0x0005DC, "Member 'AEnemyFossilTrexBite::DamageRecoveryTime' has a wrong offset!");
static_assert(offsetof(AEnemyFossilTrexBite, FossilBodyComponent) == 0x0005E0, "Member 'AEnemyFossilTrexBite::FossilBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyFossilTrexBite, FossilBodyUpComponent) == 0x0005E8, "Member 'AEnemyFossilTrexBite::FossilBodyUpComponent' has a wrong offset!");
static_assert(offsetof(AEnemyFossilTrexBite, AnimInstance) == 0x000648, "Member 'AEnemyFossilTrexBite::AnimInstance' has a wrong offset!");

// Class UnionRun.EnemyHeadButtTrex
// 0x00D8 (0x0690 - 0x05B8)
class alignas(0x10) AEnemyHeadButtTrex final : public AUnionEnemyBase
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionSkeletalMeshComponent*            SkeletalMeshComponent;                             // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isForceBoot;                                       // 0x05C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isMirror;                                          // 0x05C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5CA[0x2];                                      // 0x05CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TremorHighDistance;                                // 0x05CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TremorMiddleDistance;                              // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TremorLowDistance;                                 // 0x05D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DamageMontage;                                     // 0x05D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticBodyComponent*                   HeadStaticBodyComponent;                           // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticBodyComponent*                   JawStaticBodyComponent;                            // 0x05F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AnimSequenceAppear;                                // 0x05F8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AnimSequenceLoop;                                  // 0x0600(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_608[0x50];                                     // 0x0608(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UHeadButtTrexAnimInstance*              AnimInstance;                                      // 0x0658(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_660[0x30];                                     // 0x0660(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDestroyRockEvent();
	void OnTremorEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyHeadButtTrex">();
	}
	static class AEnemyHeadButtTrex* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyHeadButtTrex>();
	}
};
static_assert(alignof(AEnemyHeadButtTrex) == 0x000010, "Wrong alignment on AEnemyHeadButtTrex");
static_assert(sizeof(AEnemyHeadButtTrex) == 0x000690, "Wrong size on AEnemyHeadButtTrex");
static_assert(offsetof(AEnemyHeadButtTrex, SkeletalMeshComponent) == 0x0005C0, "Member 'AEnemyHeadButtTrex::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyHeadButtTrex, isForceBoot) == 0x0005C8, "Member 'AEnemyHeadButtTrex::isForceBoot' has a wrong offset!");
static_assert(offsetof(AEnemyHeadButtTrex, isMirror) == 0x0005C9, "Member 'AEnemyHeadButtTrex::isMirror' has a wrong offset!");
static_assert(offsetof(AEnemyHeadButtTrex, TremorHighDistance) == 0x0005CC, "Member 'AEnemyHeadButtTrex::TremorHighDistance' has a wrong offset!");
static_assert(offsetof(AEnemyHeadButtTrex, TremorMiddleDistance) == 0x0005D0, "Member 'AEnemyHeadButtTrex::TremorMiddleDistance' has a wrong offset!");
static_assert(offsetof(AEnemyHeadButtTrex, TremorLowDistance) == 0x0005D4, "Member 'AEnemyHeadButtTrex::TremorLowDistance' has a wrong offset!");
static_assert(offsetof(AEnemyHeadButtTrex, DamageMontage) == 0x0005D8, "Member 'AEnemyHeadButtTrex::DamageMontage' has a wrong offset!");
static_assert(offsetof(AEnemyHeadButtTrex, DefaultSceneRoot) == 0x0005E0, "Member 'AEnemyHeadButtTrex::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AEnemyHeadButtTrex, HeadStaticBodyComponent) == 0x0005E8, "Member 'AEnemyHeadButtTrex::HeadStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyHeadButtTrex, JawStaticBodyComponent) == 0x0005F0, "Member 'AEnemyHeadButtTrex::JawStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyHeadButtTrex, AnimSequenceAppear) == 0x0005F8, "Member 'AEnemyHeadButtTrex::AnimSequenceAppear' has a wrong offset!");
static_assert(offsetof(AEnemyHeadButtTrex, AnimSequenceLoop) == 0x000600, "Member 'AEnemyHeadButtTrex::AnimSequenceLoop' has a wrong offset!");
static_assert(offsetof(AEnemyHeadButtTrex, AnimInstance) == 0x000658, "Member 'AEnemyHeadButtTrex::AnimInstance' has a wrong offset!");

// Class UnionRun.Gimmick_Extnd04_BombFlame
// 0x0040 (0x05F0 - 0x05B0)
class alignas(0x10) AGimmick_Extnd04_BombFlame final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x10];                                     // 0x05B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              BodyStatickMeshComponent;                          // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      SmokeEffect;                                       // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            FlameStaticBodyComponent;                          // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    FlameSoundComponent;                               // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERacerDamageType                              DamageType;                                        // 0x05E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E1[0xF];                                      // 0x05E1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd04_BombFlame">();
	}
	static class AGimmick_Extnd04_BombFlame* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd04_BombFlame>();
	}
};
static_assert(alignof(AGimmick_Extnd04_BombFlame) == 0x000010, "Wrong alignment on AGimmick_Extnd04_BombFlame");
static_assert(sizeof(AGimmick_Extnd04_BombFlame) == 0x0005F0, "Wrong size on AGimmick_Extnd04_BombFlame");
static_assert(offsetof(AGimmick_Extnd04_BombFlame, BodyStatickMeshComponent) == 0x0005C0, "Member 'AGimmick_Extnd04_BombFlame::BodyStatickMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_BombFlame, SmokeEffect) == 0x0005C8, "Member 'AGimmick_Extnd04_BombFlame::SmokeEffect' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_BombFlame, FlameStaticBodyComponent) == 0x0005D0, "Member 'AGimmick_Extnd04_BombFlame::FlameStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_BombFlame, FlameSoundComponent) == 0x0005D8, "Member 'AGimmick_Extnd04_BombFlame::FlameSoundComponent' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_BombFlame, DamageType) == 0x0005E0, "Member 'AGimmick_Extnd04_BombFlame::DamageType' has a wrong offset!");

// Class UnionRun.EnemyMoai
// 0x0128 (0x06E0 - 0x05B8)
class alignas(0x10) AEnemyMoai final : public AUnionEnemyBase
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              MainMoaiMeshComponent;                             // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      HitLandSmokeEffect;                                // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    HitLandSoundComponent;                             // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    MoveUpSoundComponent;                              // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveUpTime;                                        // 0x05E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageMoveHight;                                   // 0x05E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DamageMoveUpCurve;                                 // 0x05E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseDamageMoveTremor;                               // 0x05F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F1[0x3];                                      // 0x05F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TremorEnableDistance;                              // 0x05F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TremorHighDistance;                                // 0x05F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TremorMiddleDistance;                              // 0x05FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TremorLowDistance;                                 // 0x0600(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_604[0x4];                                      // 0x0604(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGimmickStaticBodyComponent*            m_MainStaticBodyComponent;                         // 0x0608(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTriggerComponent*                      m_StompTriggerComponent;                           // 0x0610(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_618[0xC8];                                     // 0x0618(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MovePositionUpdate(float Ratio);
	void OnTremorEvent();
	void OnTriggerColliderConflict(const struct FHitTriggerInfo& HitInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyMoai">();
	}
	static class AEnemyMoai* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyMoai>();
	}
};
static_assert(alignof(AEnemyMoai) == 0x000010, "Wrong alignment on AEnemyMoai");
static_assert(sizeof(AEnemyMoai) == 0x0006E0, "Wrong size on AEnemyMoai");
static_assert(offsetof(AEnemyMoai, MainMoaiMeshComponent) == 0x0005C0, "Member 'AEnemyMoai::MainMoaiMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyMoai, HitLandSmokeEffect) == 0x0005C8, "Member 'AEnemyMoai::HitLandSmokeEffect' has a wrong offset!");
static_assert(offsetof(AEnemyMoai, HitLandSoundComponent) == 0x0005D0, "Member 'AEnemyMoai::HitLandSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemyMoai, MoveUpSoundComponent) == 0x0005D8, "Member 'AEnemyMoai::MoveUpSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemyMoai, MoveUpTime) == 0x0005E0, "Member 'AEnemyMoai::MoveUpTime' has a wrong offset!");
static_assert(offsetof(AEnemyMoai, DamageMoveHight) == 0x0005E4, "Member 'AEnemyMoai::DamageMoveHight' has a wrong offset!");
static_assert(offsetof(AEnemyMoai, DamageMoveUpCurve) == 0x0005E8, "Member 'AEnemyMoai::DamageMoveUpCurve' has a wrong offset!");
static_assert(offsetof(AEnemyMoai, UseDamageMoveTremor) == 0x0005F0, "Member 'AEnemyMoai::UseDamageMoveTremor' has a wrong offset!");
static_assert(offsetof(AEnemyMoai, TremorEnableDistance) == 0x0005F4, "Member 'AEnemyMoai::TremorEnableDistance' has a wrong offset!");
static_assert(offsetof(AEnemyMoai, TremorHighDistance) == 0x0005F8, "Member 'AEnemyMoai::TremorHighDistance' has a wrong offset!");
static_assert(offsetof(AEnemyMoai, TremorMiddleDistance) == 0x0005FC, "Member 'AEnemyMoai::TremorMiddleDistance' has a wrong offset!");
static_assert(offsetof(AEnemyMoai, TremorLowDistance) == 0x000600, "Member 'AEnemyMoai::TremorLowDistance' has a wrong offset!");
static_assert(offsetof(AEnemyMoai, m_MainStaticBodyComponent) == 0x000608, "Member 'AEnemyMoai::m_MainStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyMoai, m_StompTriggerComponent) == 0x000610, "Member 'AEnemyMoai::m_StompTriggerComponent' has a wrong offset!");

// Class UnionRun.GimmickBlastBox
// 0x0040 (0x05F0 - 0x05B0)
class alignas(0x10) AGimmickBlastBox final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              StaticMeshComponent;                               // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGimmickStaticBodyComponent*            StaticBodyComponent;                               // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      BlastEffect;                                       // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionAtomComponent*                    BlastSound;                                        // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlastDuration;                                     // 0x05D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5DC[0x14];                                     // 0x05DC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickBlastBox">();
	}
	static class AGimmickBlastBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickBlastBox>();
	}
};
static_assert(alignof(AGimmickBlastBox) == 0x000010, "Wrong alignment on AGimmickBlastBox");
static_assert(sizeof(AGimmickBlastBox) == 0x0005F0, "Wrong size on AGimmickBlastBox");
static_assert(offsetof(AGimmickBlastBox, StaticMeshComponent) == 0x0005B8, "Member 'AGimmickBlastBox::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickBlastBox, StaticBodyComponent) == 0x0005C0, "Member 'AGimmickBlastBox::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickBlastBox, BlastEffect) == 0x0005C8, "Member 'AGimmickBlastBox::BlastEffect' has a wrong offset!");
static_assert(offsetof(AGimmickBlastBox, BlastSound) == 0x0005D0, "Member 'AGimmickBlastBox::BlastSound' has a wrong offset!");
static_assert(offsetof(AGimmickBlastBox, BlastDuration) == 0x0005D8, "Member 'AGimmickBlastBox::BlastDuration' has a wrong offset!");

// Class UnionRun.EnemyMoaiFinalLap
// 0x0188 (0x0740 - 0x05B8)
class alignas(0x10) AEnemyMoaiFinalLap final : public AUnionEnemyBase
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionVATMeshComponent*                 VATMeshComponent;                                  // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      HitLandSmokeEffect;                                // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    HitLandSoundComponent;                             // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    MoveUpSoundComponent;                              // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveDownTime;                                      // 0x05E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveUpTime;                                        // 0x05E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallReadyTime;                                     // 0x05E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownWaitTime;                                      // 0x05EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownFinishTime;                                    // 0x05F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownHight;                                         // 0x05F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpHight;                                           // 0x05F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageMoveHight;                                   // 0x05FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MoveDownCurve;                                     // 0x0600(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MoveUpCurve;                                       // 0x0608(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DamageMoveUpCurve;                                 // 0x0610(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseDamageMoveTremor;                               // 0x0618(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseNormalMoveTremor;                               // 0x0619(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61A[0x2];                                      // 0x061A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TremorEnableDistance;                              // 0x061C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TremorHighDistance;                                // 0x0620(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TremorMiddleDistance;                              // 0x0624(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TremorLowDistance;                                 // 0x0628(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(float Output)>                 MoaiMovePosisionUpdateEvent;                       // 0x062C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             MoaiMoveFinishedEvent;                             // 0x063C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64C[0x4];                                      // 0x064C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGimmickStaticBodyComponent*            m_MainStaticBodyComponent;                         // 0x0650(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTriggerComponent*                      m_StompTriggerComponent;                           // 0x0658(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_660[0xE0];                                     // 0x0660(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MovePositionFinished();
	void MovePositionUpdate(float Ratio);
	void OnTremorEvent();
	void OnTriggerColliderConflict(const struct FHitTriggerInfo& HitInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyMoaiFinalLap">();
	}
	static class AEnemyMoaiFinalLap* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyMoaiFinalLap>();
	}
};
static_assert(alignof(AEnemyMoaiFinalLap) == 0x000010, "Wrong alignment on AEnemyMoaiFinalLap");
static_assert(sizeof(AEnemyMoaiFinalLap) == 0x000740, "Wrong size on AEnemyMoaiFinalLap");
static_assert(offsetof(AEnemyMoaiFinalLap, VATMeshComponent) == 0x0005C0, "Member 'AEnemyMoaiFinalLap::VATMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyMoaiFinalLap, HitLandSmokeEffect) == 0x0005C8, "Member 'AEnemyMoaiFinalLap::HitLandSmokeEffect' has a wrong offset!");
static_assert(offsetof(AEnemyMoaiFinalLap, HitLandSoundComponent) == 0x0005D0, "Member 'AEnemyMoaiFinalLap::HitLandSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemyMoaiFinalLap, MoveUpSoundComponent) == 0x0005D8, "Member 'AEnemyMoaiFinalLap::MoveUpSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemyMoaiFinalLap, MoveDownTime) == 0x0005E0, "Member 'AEnemyMoaiFinalLap::MoveDownTime' has a wrong offset!");
static_assert(offsetof(AEnemyMoaiFinalLap, MoveUpTime) == 0x0005E4, "Member 'AEnemyMoaiFinalLap::MoveUpTime' has a wrong offset!");
static_assert(offsetof(AEnemyMoaiFinalLap, FallReadyTime) == 0x0005E8, "Member 'AEnemyMoaiFinalLap::FallReadyTime' has a wrong offset!");
static_assert(offsetof(AEnemyMoaiFinalLap, DownWaitTime) == 0x0005EC, "Member 'AEnemyMoaiFinalLap::DownWaitTime' has a wrong offset!");
static_assert(offsetof(AEnemyMoaiFinalLap, DownFinishTime) == 0x0005F0, "Member 'AEnemyMoaiFinalLap::DownFinishTime' has a wrong offset!");
static_assert(offsetof(AEnemyMoaiFinalLap, DownHight) == 0x0005F4, "Member 'AEnemyMoaiFinalLap::DownHight' has a wrong offset!");
static_assert(offsetof(AEnemyMoaiFinalLap, UpHight) == 0x0005F8, "Member 'AEnemyMoaiFinalLap::UpHight' has a wrong offset!");
static_assert(offsetof(AEnemyMoaiFinalLap, DamageMoveHight) == 0x0005FC, "Member 'AEnemyMoaiFinalLap::DamageMoveHight' has a wrong offset!");
static_assert(offsetof(AEnemyMoaiFinalLap, MoveDownCurve) == 0x000600, "Member 'AEnemyMoaiFinalLap::MoveDownCurve' has a wrong offset!");
static_assert(offsetof(AEnemyMoaiFinalLap, MoveUpCurve) == 0x000608, "Member 'AEnemyMoaiFinalLap::MoveUpCurve' has a wrong offset!");
static_assert(offsetof(AEnemyMoaiFinalLap, DamageMoveUpCurve) == 0x000610, "Member 'AEnemyMoaiFinalLap::DamageMoveUpCurve' has a wrong offset!");
static_assert(offsetof(AEnemyMoaiFinalLap, UseDamageMoveTremor) == 0x000618, "Member 'AEnemyMoaiFinalLap::UseDamageMoveTremor' has a wrong offset!");
static_assert(offsetof(AEnemyMoaiFinalLap, UseNormalMoveTremor) == 0x000619, "Member 'AEnemyMoaiFinalLap::UseNormalMoveTremor' has a wrong offset!");
static_assert(offsetof(AEnemyMoaiFinalLap, TremorEnableDistance) == 0x00061C, "Member 'AEnemyMoaiFinalLap::TremorEnableDistance' has a wrong offset!");
static_assert(offsetof(AEnemyMoaiFinalLap, TremorHighDistance) == 0x000620, "Member 'AEnemyMoaiFinalLap::TremorHighDistance' has a wrong offset!");
static_assert(offsetof(AEnemyMoaiFinalLap, TremorMiddleDistance) == 0x000624, "Member 'AEnemyMoaiFinalLap::TremorMiddleDistance' has a wrong offset!");
static_assert(offsetof(AEnemyMoaiFinalLap, TremorLowDistance) == 0x000628, "Member 'AEnemyMoaiFinalLap::TremorLowDistance' has a wrong offset!");
static_assert(offsetof(AEnemyMoaiFinalLap, MoaiMovePosisionUpdateEvent) == 0x00062C, "Member 'AEnemyMoaiFinalLap::MoaiMovePosisionUpdateEvent' has a wrong offset!");
static_assert(offsetof(AEnemyMoaiFinalLap, MoaiMoveFinishedEvent) == 0x00063C, "Member 'AEnemyMoaiFinalLap::MoaiMoveFinishedEvent' has a wrong offset!");
static_assert(offsetof(AEnemyMoaiFinalLap, m_MainStaticBodyComponent) == 0x000650, "Member 'AEnemyMoaiFinalLap::m_MainStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyMoaiFinalLap, m_StompTriggerComponent) == 0x000658, "Member 'AEnemyMoaiFinalLap::m_StompTriggerComponent' has a wrong offset!");

// Class UnionRun.EnemyNal
// 0x0088 (0x0640 - 0x05B8)
class alignas(0x10) AEnemyNal final : public AUnionEnemyBase
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionVATAnimEventComponent*            VATMesh;                                           // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            Body;                                              // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      ExplosionEffect1;                                  // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      ExplosionEffect2;                                  // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VATDamageAnimIndex;                                // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExplosionFrame1;                                   // 0x05E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExplosionFrame2;                                   // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5EC[0x54];                                     // 0x05EC(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyNal">();
	}
	static class AEnemyNal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyNal>();
	}
};
static_assert(alignof(AEnemyNal) == 0x000010, "Wrong alignment on AEnemyNal");
static_assert(sizeof(AEnemyNal) == 0x000640, "Wrong size on AEnemyNal");
static_assert(offsetof(AEnemyNal, VATMesh) == 0x0005C0, "Member 'AEnemyNal::VATMesh' has a wrong offset!");
static_assert(offsetof(AEnemyNal, Body) == 0x0005C8, "Member 'AEnemyNal::Body' has a wrong offset!");
static_assert(offsetof(AEnemyNal, ExplosionEffect1) == 0x0005D0, "Member 'AEnemyNal::ExplosionEffect1' has a wrong offset!");
static_assert(offsetof(AEnemyNal, ExplosionEffect2) == 0x0005D8, "Member 'AEnemyNal::ExplosionEffect2' has a wrong offset!");
static_assert(offsetof(AEnemyNal, VATDamageAnimIndex) == 0x0005E0, "Member 'AEnemyNal::VATDamageAnimIndex' has a wrong offset!");
static_assert(offsetof(AEnemyNal, ExplosionFrame1) == 0x0005E4, "Member 'AEnemyNal::ExplosionFrame1' has a wrong offset!");
static_assert(offsetof(AEnemyNal, ExplosionFrame2) == 0x0005E8, "Member 'AEnemyNal::ExplosionFrame2' has a wrong offset!");

// Class UnionRun.EnemyObake
// 0x0138 (0x06F0 - 0x05B8)
class alignas(0x10) AEnemyObake final : public AUnionEnemyBase
{
public:
	float                                         MovingAttackIntervalTime;                          // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackingTime;                                     // 0x05BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackIntervalTime;                                // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IdleAnimationIndex;                                // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AttackAnimationIndex;                              // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5CC[0x4];                                      // 0x05CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionVATAnimEventComponent*            VATModelMeshComponent;                             // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_AttackSoundComponent;                            // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_AttackStartSoundComponent;                       // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E8[0x78];                                     // 0x05E8(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class AGimmickObakeFlameField*                FlameAttack1st;                                    // 0x0660(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGimmickObakeFlameField*                FlameLoopAttack1st;                                // 0x0668(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGimmickObakeFlameField*                FlameAttack2nd;                                    // 0x0670(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AEnemyObakeBomb*>                FlameBombActorArray;                               // 0x0678(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_688[0x68];                                     // 0x0688(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyObake">();
	}
	static class AEnemyObake* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyObake>();
	}
};
static_assert(alignof(AEnemyObake) == 0x000010, "Wrong alignment on AEnemyObake");
static_assert(sizeof(AEnemyObake) == 0x0006F0, "Wrong size on AEnemyObake");
static_assert(offsetof(AEnemyObake, MovingAttackIntervalTime) == 0x0005B8, "Member 'AEnemyObake::MovingAttackIntervalTime' has a wrong offset!");
static_assert(offsetof(AEnemyObake, AttackingTime) == 0x0005BC, "Member 'AEnemyObake::AttackingTime' has a wrong offset!");
static_assert(offsetof(AEnemyObake, AttackIntervalTime) == 0x0005C0, "Member 'AEnemyObake::AttackIntervalTime' has a wrong offset!");
static_assert(offsetof(AEnemyObake, IdleAnimationIndex) == 0x0005C4, "Member 'AEnemyObake::IdleAnimationIndex' has a wrong offset!");
static_assert(offsetof(AEnemyObake, AttackAnimationIndex) == 0x0005C8, "Member 'AEnemyObake::AttackAnimationIndex' has a wrong offset!");
static_assert(offsetof(AEnemyObake, VATModelMeshComponent) == 0x0005D0, "Member 'AEnemyObake::VATModelMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyObake, m_AttackSoundComponent) == 0x0005D8, "Member 'AEnemyObake::m_AttackSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemyObake, m_AttackStartSoundComponent) == 0x0005E0, "Member 'AEnemyObake::m_AttackStartSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemyObake, FlameAttack1st) == 0x000660, "Member 'AEnemyObake::FlameAttack1st' has a wrong offset!");
static_assert(offsetof(AEnemyObake, FlameLoopAttack1st) == 0x000668, "Member 'AEnemyObake::FlameLoopAttack1st' has a wrong offset!");
static_assert(offsetof(AEnemyObake, FlameAttack2nd) == 0x000670, "Member 'AEnemyObake::FlameAttack2nd' has a wrong offset!");
static_assert(offsetof(AEnemyObake, FlameBombActorArray) == 0x000678, "Member 'AEnemyObake::FlameBombActorArray' has a wrong offset!");

// Class UnionRun.GimmickRingDropper
// 0x0020 (0x05D0 - 0x05B0)
class alignas(0x10) AGimmickRingDropper final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x4];                                      // 0x05B0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DropStartTime;                                     // 0x05B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Interval;                                          // 0x05B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _DropRingCount;                                    // 0x05BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C8[0x8];                                      // 0x05C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DropRings(int32 DropRingCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickRingDropper">();
	}
	static class AGimmickRingDropper* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickRingDropper>();
	}
};
static_assert(alignof(AGimmickRingDropper) == 0x000010, "Wrong alignment on AGimmickRingDropper");
static_assert(sizeof(AGimmickRingDropper) == 0x0005D0, "Wrong size on AGimmickRingDropper");
static_assert(offsetof(AGimmickRingDropper, DropStartTime) == 0x0005B4, "Member 'AGimmickRingDropper::DropStartTime' has a wrong offset!");
static_assert(offsetof(AGimmickRingDropper, Interval) == 0x0005B8, "Member 'AGimmickRingDropper::Interval' has a wrong offset!");
static_assert(offsetof(AGimmickRingDropper, _DropRingCount) == 0x0005BC, "Member 'AGimmickRingDropper::_DropRingCount' has a wrong offset!");
static_assert(offsetof(AGimmickRingDropper, DefaultSceneRoot) == 0x0005C0, "Member 'AGimmickRingDropper::DefaultSceneRoot' has a wrong offset!");

// Class UnionRun.EnemyObakeBomb
// 0x00E8 (0x06A0 - 0x05B8)
class alignas(0x10) AEnemyObakeBomb final : public AUnionEnemyBase
{
public:
	float                                         BombActveTime;                                     // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BombExplodeTime;                                   // 0x05BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeed;                                         // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivateExplosionLength;                           // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              m_BombMesh;                                        // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            m_BombStaticBodyComponent;                         // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      m_FireEffect;                                      // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    m_AttackSoundComponent;                            // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGimmickObakeFlameField*                FlameAttack1st;                                    // 0x05E8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGimmickObakeFlameField*                FlameLoopAttack1st;                                // 0x05F0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGimmickObakeFlameField*                FlameAttack2nd;                                    // 0x05F8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_600[0xA0];                                     // 0x0600(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyObakeBomb">();
	}
	static class AEnemyObakeBomb* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyObakeBomb>();
	}
};
static_assert(alignof(AEnemyObakeBomb) == 0x000010, "Wrong alignment on AEnemyObakeBomb");
static_assert(sizeof(AEnemyObakeBomb) == 0x0006A0, "Wrong size on AEnemyObakeBomb");
static_assert(offsetof(AEnemyObakeBomb, BombActveTime) == 0x0005B8, "Member 'AEnemyObakeBomb::BombActveTime' has a wrong offset!");
static_assert(offsetof(AEnemyObakeBomb, BombExplodeTime) == 0x0005BC, "Member 'AEnemyObakeBomb::BombExplodeTime' has a wrong offset!");
static_assert(offsetof(AEnemyObakeBomb, MoveSpeed) == 0x0005C0, "Member 'AEnemyObakeBomb::MoveSpeed' has a wrong offset!");
static_assert(offsetof(AEnemyObakeBomb, ActivateExplosionLength) == 0x0005C4, "Member 'AEnemyObakeBomb::ActivateExplosionLength' has a wrong offset!");
static_assert(offsetof(AEnemyObakeBomb, m_BombMesh) == 0x0005C8, "Member 'AEnemyObakeBomb::m_BombMesh' has a wrong offset!");
static_assert(offsetof(AEnemyObakeBomb, m_BombStaticBodyComponent) == 0x0005D0, "Member 'AEnemyObakeBomb::m_BombStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyObakeBomb, m_FireEffect) == 0x0005D8, "Member 'AEnemyObakeBomb::m_FireEffect' has a wrong offset!");
static_assert(offsetof(AEnemyObakeBomb, m_AttackSoundComponent) == 0x0005E0, "Member 'AEnemyObakeBomb::m_AttackSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemyObakeBomb, FlameAttack1st) == 0x0005E8, "Member 'AEnemyObakeBomb::FlameAttack1st' has a wrong offset!");
static_assert(offsetof(AEnemyObakeBomb, FlameLoopAttack1st) == 0x0005F0, "Member 'AEnemyObakeBomb::FlameLoopAttack1st' has a wrong offset!");
static_assert(offsetof(AEnemyObakeBomb, FlameAttack2nd) == 0x0005F8, "Member 'AEnemyObakeBomb::FlameAttack2nd' has a wrong offset!");

// Class UnionRun.GimmickSlowNet
// 0x0090 (0x0640 - 0x05B0)
class alignas(0x10) AGimmickSlowNet final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x10];                                     // 0x05B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	ERacerDamageType                              DamageType;                                        // 0x05C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C1[0x3];                                      // 0x05C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RelocateTime;                                      // 0x05C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              NetMesh;                                           // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      ObjectBreakEffect;                                 // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            BodyComponent;                                     // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E0[0x60];                                     // 0x05E0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickSlowNet">();
	}
	static class AGimmickSlowNet* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickSlowNet>();
	}
};
static_assert(alignof(AGimmickSlowNet) == 0x000010, "Wrong alignment on AGimmickSlowNet");
static_assert(sizeof(AGimmickSlowNet) == 0x000640, "Wrong size on AGimmickSlowNet");
static_assert(offsetof(AGimmickSlowNet, DamageType) == 0x0005C0, "Member 'AGimmickSlowNet::DamageType' has a wrong offset!");
static_assert(offsetof(AGimmickSlowNet, RelocateTime) == 0x0005C4, "Member 'AGimmickSlowNet::RelocateTime' has a wrong offset!");
static_assert(offsetof(AGimmickSlowNet, NetMesh) == 0x0005C8, "Member 'AGimmickSlowNet::NetMesh' has a wrong offset!");
static_assert(offsetof(AGimmickSlowNet, ObjectBreakEffect) == 0x0005D0, "Member 'AGimmickSlowNet::ObjectBreakEffect' has a wrong offset!");
static_assert(offsetof(AGimmickSlowNet, BodyComponent) == 0x0005D8, "Member 'AGimmickSlowNet::BodyComponent' has a wrong offset!");

// Class UnionRun.EnemyPhoenixFeatherBomb
// 0x00D8 (0x0690 - 0x05B8)
class alignas(0x10) AEnemyPhoenixFeatherBomb final : public AUnionEnemyBase
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FirstAdditionalIdleTime;                           // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntervalTime;                                      // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackReadyEffectStartRate;                        // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackReadyEffectStopRate;                         // 0x05CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackExplosionStartRate;                          // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D4[0x4];                                      // 0x05D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AbsorbedFeatherScale;                              // 0x05D8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              BombStaticMeshComponent;                           // 0x05F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGOCMovement*                           m_movement;                                        // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_attackReadyEffect;                               // 0x0600(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    FiredSoundComponent;                               // 0x0608(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticBodyComponent*                   m_BombAbsorbedBody;                                // 0x0610(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGimmickFeatherBombWarning*             AttackWarning;                                     // 0x0618(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_620[0x50];                                     // 0x0620(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                m_initScale;                                       // 0x0670(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_688[0x8];                                      // 0x0688(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyPhoenixFeatherBomb">();
	}
	static class AEnemyPhoenixFeatherBomb* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyPhoenixFeatherBomb>();
	}
};
static_assert(alignof(AEnemyPhoenixFeatherBomb) == 0x000010, "Wrong alignment on AEnemyPhoenixFeatherBomb");
static_assert(sizeof(AEnemyPhoenixFeatherBomb) == 0x000690, "Wrong size on AEnemyPhoenixFeatherBomb");
static_assert(offsetof(AEnemyPhoenixFeatherBomb, FirstAdditionalIdleTime) == 0x0005C0, "Member 'AEnemyPhoenixFeatherBomb::FirstAdditionalIdleTime' has a wrong offset!");
static_assert(offsetof(AEnemyPhoenixFeatherBomb, IntervalTime) == 0x0005C4, "Member 'AEnemyPhoenixFeatherBomb::IntervalTime' has a wrong offset!");
static_assert(offsetof(AEnemyPhoenixFeatherBomb, AttackReadyEffectStartRate) == 0x0005C8, "Member 'AEnemyPhoenixFeatherBomb::AttackReadyEffectStartRate' has a wrong offset!");
static_assert(offsetof(AEnemyPhoenixFeatherBomb, AttackReadyEffectStopRate) == 0x0005CC, "Member 'AEnemyPhoenixFeatherBomb::AttackReadyEffectStopRate' has a wrong offset!");
static_assert(offsetof(AEnemyPhoenixFeatherBomb, AttackExplosionStartRate) == 0x0005D0, "Member 'AEnemyPhoenixFeatherBomb::AttackExplosionStartRate' has a wrong offset!");
static_assert(offsetof(AEnemyPhoenixFeatherBomb, AbsorbedFeatherScale) == 0x0005D8, "Member 'AEnemyPhoenixFeatherBomb::AbsorbedFeatherScale' has a wrong offset!");
static_assert(offsetof(AEnemyPhoenixFeatherBomb, BombStaticMeshComponent) == 0x0005F0, "Member 'AEnemyPhoenixFeatherBomb::BombStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyPhoenixFeatherBomb, m_movement) == 0x0005F8, "Member 'AEnemyPhoenixFeatherBomb::m_movement' has a wrong offset!");
static_assert(offsetof(AEnemyPhoenixFeatherBomb, m_attackReadyEffect) == 0x000600, "Member 'AEnemyPhoenixFeatherBomb::m_attackReadyEffect' has a wrong offset!");
static_assert(offsetof(AEnemyPhoenixFeatherBomb, FiredSoundComponent) == 0x000608, "Member 'AEnemyPhoenixFeatherBomb::FiredSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemyPhoenixFeatherBomb, m_BombAbsorbedBody) == 0x000610, "Member 'AEnemyPhoenixFeatherBomb::m_BombAbsorbedBody' has a wrong offset!");
static_assert(offsetof(AEnemyPhoenixFeatherBomb, AttackWarning) == 0x000618, "Member 'AEnemyPhoenixFeatherBomb::AttackWarning' has a wrong offset!");
static_assert(offsetof(AEnemyPhoenixFeatherBomb, m_initScale) == 0x000670, "Member 'AEnemyPhoenixFeatherBomb::m_initScale' has a wrong offset!");

// Class UnionRun.EnemyPhoenixFeatherPerformance
// 0x0098 (0x0650 - 0x05B8)
class alignas(0x10) AEnemyPhoenixFeatherPerformance final : public AUnionEnemyBase
{
public:
	float                                         ParticleRadiusParameter;                           // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParticleDurationParameter;                         // 0x05BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstAdditionalIdleTime;                           // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntervalTime;                                      // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrackReadyStartRate;                              // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrackExplosionStartRate;                          // 0x05CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BombEffectTime;                                    // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D4[0x4];                                      // 0x05D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              BombStaticMeshComponent;                           // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_explosionEffect;                                 // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            m_BombStaticBodyComponent;                         // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F0[0x60];                                     // 0x05F0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyPhoenixFeatherPerformance">();
	}
	static class AEnemyPhoenixFeatherPerformance* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyPhoenixFeatherPerformance>();
	}
};
static_assert(alignof(AEnemyPhoenixFeatherPerformance) == 0x000010, "Wrong alignment on AEnemyPhoenixFeatherPerformance");
static_assert(sizeof(AEnemyPhoenixFeatherPerformance) == 0x000650, "Wrong size on AEnemyPhoenixFeatherPerformance");
static_assert(offsetof(AEnemyPhoenixFeatherPerformance, ParticleRadiusParameter) == 0x0005B8, "Member 'AEnemyPhoenixFeatherPerformance::ParticleRadiusParameter' has a wrong offset!");
static_assert(offsetof(AEnemyPhoenixFeatherPerformance, ParticleDurationParameter) == 0x0005BC, "Member 'AEnemyPhoenixFeatherPerformance::ParticleDurationParameter' has a wrong offset!");
static_assert(offsetof(AEnemyPhoenixFeatherPerformance, FirstAdditionalIdleTime) == 0x0005C0, "Member 'AEnemyPhoenixFeatherPerformance::FirstAdditionalIdleTime' has a wrong offset!");
static_assert(offsetof(AEnemyPhoenixFeatherPerformance, IntervalTime) == 0x0005C4, "Member 'AEnemyPhoenixFeatherPerformance::IntervalTime' has a wrong offset!");
static_assert(offsetof(AEnemyPhoenixFeatherPerformance, ArrackReadyStartRate) == 0x0005C8, "Member 'AEnemyPhoenixFeatherPerformance::ArrackReadyStartRate' has a wrong offset!");
static_assert(offsetof(AEnemyPhoenixFeatherPerformance, ArrackExplosionStartRate) == 0x0005CC, "Member 'AEnemyPhoenixFeatherPerformance::ArrackExplosionStartRate' has a wrong offset!");
static_assert(offsetof(AEnemyPhoenixFeatherPerformance, BombEffectTime) == 0x0005D0, "Member 'AEnemyPhoenixFeatherPerformance::BombEffectTime' has a wrong offset!");
static_assert(offsetof(AEnemyPhoenixFeatherPerformance, BombStaticMeshComponent) == 0x0005D8, "Member 'AEnemyPhoenixFeatherPerformance::BombStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyPhoenixFeatherPerformance, m_explosionEffect) == 0x0005E0, "Member 'AEnemyPhoenixFeatherPerformance::m_explosionEffect' has a wrong offset!");
static_assert(offsetof(AEnemyPhoenixFeatherPerformance, m_BombStaticBodyComponent) == 0x0005E8, "Member 'AEnemyPhoenixFeatherPerformance::m_BombStaticBodyComponent' has a wrong offset!");

// Class UnionRun.EnemyPhoenixFireAttack
// 0x0088 (0x0640 - 0x05B8)
class alignas(0x10) AEnemyPhoenixFireAttack final : public AUnionEnemyBase
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ParticleIntParameterSetting;                       // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackContinueTime;                                // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_FireEffect;                                      // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    BurningSoundComponent;                             // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            m_FireStaticBodyComponent;                         // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E0[0x60];                                     // 0x05E0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyPhoenixFireAttack">();
	}
	static class AEnemyPhoenixFireAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyPhoenixFireAttack>();
	}
};
static_assert(alignof(AEnemyPhoenixFireAttack) == 0x000010, "Wrong alignment on AEnemyPhoenixFireAttack");
static_assert(sizeof(AEnemyPhoenixFireAttack) == 0x000640, "Wrong size on AEnemyPhoenixFireAttack");
static_assert(offsetof(AEnemyPhoenixFireAttack, ParticleIntParameterSetting) == 0x0005C0, "Member 'AEnemyPhoenixFireAttack::ParticleIntParameterSetting' has a wrong offset!");
static_assert(offsetof(AEnemyPhoenixFireAttack, AttackContinueTime) == 0x0005C4, "Member 'AEnemyPhoenixFireAttack::AttackContinueTime' has a wrong offset!");
static_assert(offsetof(AEnemyPhoenixFireAttack, m_FireEffect) == 0x0005C8, "Member 'AEnemyPhoenixFireAttack::m_FireEffect' has a wrong offset!");
static_assert(offsetof(AEnemyPhoenixFireAttack, BurningSoundComponent) == 0x0005D0, "Member 'AEnemyPhoenixFireAttack::BurningSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemyPhoenixFireAttack, m_FireStaticBodyComponent) == 0x0005D8, "Member 'AEnemyPhoenixFireAttack::m_FireStaticBodyComponent' has a wrong offset!");

// Class UnionRun.Gimmick_Extnd04_NaGate
// 0x0050 (0x0600 - 0x05B0)
class alignas(0x10) AGimmick_Extnd04_NaGate final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              Mesh;                                              // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      Effect;                                            // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    Sound;                                             // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    PassSound;                                         // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            Body;                                              // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TriggerFlags;                                      // 0x05E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E4[0x1C];                                     // 0x05E4(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd04_NaGate">();
	}
	static class AGimmick_Extnd04_NaGate* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd04_NaGate>();
	}
};
static_assert(alignof(AGimmick_Extnd04_NaGate) == 0x000010, "Wrong alignment on AGimmick_Extnd04_NaGate");
static_assert(sizeof(AGimmick_Extnd04_NaGate) == 0x000600, "Wrong size on AGimmick_Extnd04_NaGate");
static_assert(offsetof(AGimmick_Extnd04_NaGate, Mesh) == 0x0005B8, "Member 'AGimmick_Extnd04_NaGate::Mesh' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_NaGate, Effect) == 0x0005C0, "Member 'AGimmick_Extnd04_NaGate::Effect' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_NaGate, Sound) == 0x0005C8, "Member 'AGimmick_Extnd04_NaGate::Sound' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_NaGate, PassSound) == 0x0005D0, "Member 'AGimmick_Extnd04_NaGate::PassSound' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_NaGate, Body) == 0x0005D8, "Member 'AGimmick_Extnd04_NaGate::Body' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_NaGate, TriggerFlags) == 0x0005E0, "Member 'AGimmick_Extnd04_NaGate::TriggerFlags' has a wrong offset!");

// Class UnionRun.EnemyShipPaddle
// 0x00C8 (0x0680 - 0x05B8)
class alignas(0x10) AEnemyShipPaddle final : public AUnionEnemyBase
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              MainMeshComponent;                                 // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    MoveUpSoundComponent;                              // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    RollingSoundComponent;                             // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveUpTime;                                        // 0x05D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageMoveHight;                                   // 0x05DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotSpeed;                                          // 0x05E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E4[0x4];                                      // 0x05E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DamageMoveUpCurve;                                 // 0x05E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRolling;                                        // 0x05F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F1[0x7];                                      // 0x05F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            m_MainStaticBodyComponent;                         // 0x0600(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_608[0x78];                                     // 0x0608(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MovePositionUpdate(float Ratio);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyShipPaddle">();
	}
	static class AEnemyShipPaddle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyShipPaddle>();
	}
};
static_assert(alignof(AEnemyShipPaddle) == 0x000010, "Wrong alignment on AEnemyShipPaddle");
static_assert(sizeof(AEnemyShipPaddle) == 0x000680, "Wrong size on AEnemyShipPaddle");
static_assert(offsetof(AEnemyShipPaddle, MainMeshComponent) == 0x0005C0, "Member 'AEnemyShipPaddle::MainMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyShipPaddle, MoveUpSoundComponent) == 0x0005C8, "Member 'AEnemyShipPaddle::MoveUpSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemyShipPaddle, RollingSoundComponent) == 0x0005D0, "Member 'AEnemyShipPaddle::RollingSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemyShipPaddle, MoveUpTime) == 0x0005D8, "Member 'AEnemyShipPaddle::MoveUpTime' has a wrong offset!");
static_assert(offsetof(AEnemyShipPaddle, DamageMoveHight) == 0x0005DC, "Member 'AEnemyShipPaddle::DamageMoveHight' has a wrong offset!");
static_assert(offsetof(AEnemyShipPaddle, RotSpeed) == 0x0005E0, "Member 'AEnemyShipPaddle::RotSpeed' has a wrong offset!");
static_assert(offsetof(AEnemyShipPaddle, DamageMoveUpCurve) == 0x0005E8, "Member 'AEnemyShipPaddle::DamageMoveUpCurve' has a wrong offset!");
static_assert(offsetof(AEnemyShipPaddle, bIsRolling) == 0x0005F0, "Member 'AEnemyShipPaddle::bIsRolling' has a wrong offset!");
static_assert(offsetof(AEnemyShipPaddle, DefaultSceneRoot) == 0x0005F8, "Member 'AEnemyShipPaddle::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AEnemyShipPaddle, m_MainStaticBodyComponent) == 0x000600, "Member 'AEnemyShipPaddle::m_MainStaticBodyComponent' has a wrong offset!");

// Class UnionRun.GimmickChandelier
// 0x00B0 (0x0660 - 0x05B0)
class alignas(0x10) AGimmickChandelier final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionStaticMeshComponent*              _StaticMeshComponent;                              // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            _WallStaticBody;                                   // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            _TriggerStaticBody;                                // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            _PressStaticBody;                                  // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      _NiagaraEffect;                                    // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    _RiseSound;                                        // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    _DropSound;                                        // 0x05F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _DropHeight;                                       // 0x05F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _RiseStartTime;                                    // 0x05FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _GravitationalAcceleration;                        // 0x0600(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _RiseDuration;                                     // 0x0604(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _RiseDurationFast;                                 // 0x0608(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60C[0x4];                                      // 0x060C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               _BodyMaterial;                                     // 0x0610(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_618[0x48];                                     // 0x0618(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickChandelier">();
	}
	static class AGimmickChandelier* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickChandelier>();
	}
};
static_assert(alignof(AGimmickChandelier) == 0x000010, "Wrong alignment on AGimmickChandelier");
static_assert(sizeof(AGimmickChandelier) == 0x000660, "Wrong size on AGimmickChandelier");
static_assert(offsetof(AGimmickChandelier, DefaultSceneRoot) == 0x0005B8, "Member 'AGimmickChandelier::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AGimmickChandelier, _StaticMeshComponent) == 0x0005C0, "Member 'AGimmickChandelier::_StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickChandelier, _WallStaticBody) == 0x0005C8, "Member 'AGimmickChandelier::_WallStaticBody' has a wrong offset!");
static_assert(offsetof(AGimmickChandelier, _TriggerStaticBody) == 0x0005D0, "Member 'AGimmickChandelier::_TriggerStaticBody' has a wrong offset!");
static_assert(offsetof(AGimmickChandelier, _PressStaticBody) == 0x0005D8, "Member 'AGimmickChandelier::_PressStaticBody' has a wrong offset!");
static_assert(offsetof(AGimmickChandelier, _NiagaraEffect) == 0x0005E0, "Member 'AGimmickChandelier::_NiagaraEffect' has a wrong offset!");
static_assert(offsetof(AGimmickChandelier, _RiseSound) == 0x0005E8, "Member 'AGimmickChandelier::_RiseSound' has a wrong offset!");
static_assert(offsetof(AGimmickChandelier, _DropSound) == 0x0005F0, "Member 'AGimmickChandelier::_DropSound' has a wrong offset!");
static_assert(offsetof(AGimmickChandelier, _DropHeight) == 0x0005F8, "Member 'AGimmickChandelier::_DropHeight' has a wrong offset!");
static_assert(offsetof(AGimmickChandelier, _RiseStartTime) == 0x0005FC, "Member 'AGimmickChandelier::_RiseStartTime' has a wrong offset!");
static_assert(offsetof(AGimmickChandelier, _GravitationalAcceleration) == 0x000600, "Member 'AGimmickChandelier::_GravitationalAcceleration' has a wrong offset!");
static_assert(offsetof(AGimmickChandelier, _RiseDuration) == 0x000604, "Member 'AGimmickChandelier::_RiseDuration' has a wrong offset!");
static_assert(offsetof(AGimmickChandelier, _RiseDurationFast) == 0x000608, "Member 'AGimmickChandelier::_RiseDurationFast' has a wrong offset!");
static_assert(offsetof(AGimmickChandelier, _BodyMaterial) == 0x000610, "Member 'AGimmickChandelier::_BodyMaterial' has a wrong offset!");

// Class UnionRun.EnemyShootingGUNHunter
// 0x01A8 (0x0760 - 0x05B8)
class alignas(0x10) AEnemyShootingGUNHunter final : public AUnionEnemyBase
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionSkeletalMeshComponent*            Mesh;                                              // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            Body;                                              // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      MuzzleEffect;                                      // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      DeadEffect;                                        // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    ShootSound;                                        // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    DestroySound;                                      // 0x05E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGUNHunterStartType                           StartMotionType;                                   // 0x05F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDownAttack;                                      // 0x05F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F2[0x2];                                      // 0x05F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FirstDelayTime;                                    // 0x05F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShotIntervalTime;                                  // 0x05F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShotChargeTime;                                    // 0x05FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShotAnimTime;                                      // 0x0600(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownShotAnimTime;                                  // 0x0604(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanHitBody;                                        // 0x0608(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_609[0x3];                                      // 0x0609(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlowawayTime;                                      // 0x060C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeadEffectDelayTime;                               // 0x0610(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeadWaitTime;                                      // 0x0614(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespawnSearchRacerRange;                           // 0x0618(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61C[0x4];                                      // 0x061C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGUNHunterAnimInstance>     ShootingAnimationInstance;                         // 0x0620(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BulletScale;                                       // 0x0628(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BulletSpeed;                                       // 0x062C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BulletFallSpeed;                                   // 0x0630(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletPoolNum;                                     // 0x0634(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DirectionStartOffset;                              // 0x0638(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DownAttackDirectionStartOffset;                    // 0x0650(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AGUNHunterBullet>           BulletReference;                                   // 0x0668(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebugDirectionLength;                              // 0x0670(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_674[0x4];                                      // 0x0674(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimationAsset*                        DebugAttackAnimation;                              // 0x0678(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        DebugDownAttackAnimation;                          // 0x0680(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_688[0xD8];                                     // 0x0688(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyShootingGUNHunter">();
	}
	static class AEnemyShootingGUNHunter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyShootingGUNHunter>();
	}
};
static_assert(alignof(AEnemyShootingGUNHunter) == 0x000010, "Wrong alignment on AEnemyShootingGUNHunter");
static_assert(sizeof(AEnemyShootingGUNHunter) == 0x000760, "Wrong size on AEnemyShootingGUNHunter");
static_assert(offsetof(AEnemyShootingGUNHunter, Mesh) == 0x0005C0, "Member 'AEnemyShootingGUNHunter::Mesh' has a wrong offset!");
static_assert(offsetof(AEnemyShootingGUNHunter, Body) == 0x0005C8, "Member 'AEnemyShootingGUNHunter::Body' has a wrong offset!");
static_assert(offsetof(AEnemyShootingGUNHunter, MuzzleEffect) == 0x0005D0, "Member 'AEnemyShootingGUNHunter::MuzzleEffect' has a wrong offset!");
static_assert(offsetof(AEnemyShootingGUNHunter, DeadEffect) == 0x0005D8, "Member 'AEnemyShootingGUNHunter::DeadEffect' has a wrong offset!");
static_assert(offsetof(AEnemyShootingGUNHunter, ShootSound) == 0x0005E0, "Member 'AEnemyShootingGUNHunter::ShootSound' has a wrong offset!");
static_assert(offsetof(AEnemyShootingGUNHunter, DestroySound) == 0x0005E8, "Member 'AEnemyShootingGUNHunter::DestroySound' has a wrong offset!");
static_assert(offsetof(AEnemyShootingGUNHunter, StartMotionType) == 0x0005F0, "Member 'AEnemyShootingGUNHunter::StartMotionType' has a wrong offset!");
static_assert(offsetof(AEnemyShootingGUNHunter, IsDownAttack) == 0x0005F1, "Member 'AEnemyShootingGUNHunter::IsDownAttack' has a wrong offset!");
static_assert(offsetof(AEnemyShootingGUNHunter, FirstDelayTime) == 0x0005F4, "Member 'AEnemyShootingGUNHunter::FirstDelayTime' has a wrong offset!");
static_assert(offsetof(AEnemyShootingGUNHunter, ShotIntervalTime) == 0x0005F8, "Member 'AEnemyShootingGUNHunter::ShotIntervalTime' has a wrong offset!");
static_assert(offsetof(AEnemyShootingGUNHunter, ShotChargeTime) == 0x0005FC, "Member 'AEnemyShootingGUNHunter::ShotChargeTime' has a wrong offset!");
static_assert(offsetof(AEnemyShootingGUNHunter, ShotAnimTime) == 0x000600, "Member 'AEnemyShootingGUNHunter::ShotAnimTime' has a wrong offset!");
static_assert(offsetof(AEnemyShootingGUNHunter, DownShotAnimTime) == 0x000604, "Member 'AEnemyShootingGUNHunter::DownShotAnimTime' has a wrong offset!");
static_assert(offsetof(AEnemyShootingGUNHunter, CanHitBody) == 0x000608, "Member 'AEnemyShootingGUNHunter::CanHitBody' has a wrong offset!");
static_assert(offsetof(AEnemyShootingGUNHunter, BlowawayTime) == 0x00060C, "Member 'AEnemyShootingGUNHunter::BlowawayTime' has a wrong offset!");
static_assert(offsetof(AEnemyShootingGUNHunter, DeadEffectDelayTime) == 0x000610, "Member 'AEnemyShootingGUNHunter::DeadEffectDelayTime' has a wrong offset!");
static_assert(offsetof(AEnemyShootingGUNHunter, DeadWaitTime) == 0x000614, "Member 'AEnemyShootingGUNHunter::DeadWaitTime' has a wrong offset!");
static_assert(offsetof(AEnemyShootingGUNHunter, RespawnSearchRacerRange) == 0x000618, "Member 'AEnemyShootingGUNHunter::RespawnSearchRacerRange' has a wrong offset!");
static_assert(offsetof(AEnemyShootingGUNHunter, ShootingAnimationInstance) == 0x000620, "Member 'AEnemyShootingGUNHunter::ShootingAnimationInstance' has a wrong offset!");
static_assert(offsetof(AEnemyShootingGUNHunter, BulletScale) == 0x000628, "Member 'AEnemyShootingGUNHunter::BulletScale' has a wrong offset!");
static_assert(offsetof(AEnemyShootingGUNHunter, BulletSpeed) == 0x00062C, "Member 'AEnemyShootingGUNHunter::BulletSpeed' has a wrong offset!");
static_assert(offsetof(AEnemyShootingGUNHunter, BulletFallSpeed) == 0x000630, "Member 'AEnemyShootingGUNHunter::BulletFallSpeed' has a wrong offset!");
static_assert(offsetof(AEnemyShootingGUNHunter, BulletPoolNum) == 0x000634, "Member 'AEnemyShootingGUNHunter::BulletPoolNum' has a wrong offset!");
static_assert(offsetof(AEnemyShootingGUNHunter, DirectionStartOffset) == 0x000638, "Member 'AEnemyShootingGUNHunter::DirectionStartOffset' has a wrong offset!");
static_assert(offsetof(AEnemyShootingGUNHunter, DownAttackDirectionStartOffset) == 0x000650, "Member 'AEnemyShootingGUNHunter::DownAttackDirectionStartOffset' has a wrong offset!");
static_assert(offsetof(AEnemyShootingGUNHunter, BulletReference) == 0x000668, "Member 'AEnemyShootingGUNHunter::BulletReference' has a wrong offset!");
static_assert(offsetof(AEnemyShootingGUNHunter, DebugDirectionLength) == 0x000670, "Member 'AEnemyShootingGUNHunter::DebugDirectionLength' has a wrong offset!");
static_assert(offsetof(AEnemyShootingGUNHunter, DebugAttackAnimation) == 0x000678, "Member 'AEnemyShootingGUNHunter::DebugAttackAnimation' has a wrong offset!");
static_assert(offsetof(AEnemyShootingGUNHunter, DebugDownAttackAnimation) == 0x000680, "Member 'AEnemyShootingGUNHunter::DebugDownAttackAnimation' has a wrong offset!");

// Class UnionRun.EnemySmallTrain
// 0x0128 (0x06E0 - 0x05B8)
class alignas(0x10) AEnemySmallTrain final : public AUnionEnemyBase
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TrainJumpHeight;                                   // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrainRecoveryTime;                                 // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrainDamegeRetryTime;                              // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrainDamageContinueRecoveryTime;                   // 0x05CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrainDamegeContinueRetryTime;                      // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrainDamegeContinueRetryStartFrame;                // 0x05D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovefinishRate;                                    // 0x05D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrainAnimationPlayRate;                            // 0x05DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TrainWarpLocation;                                 // 0x05E0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TrainAnimStartFrame;                               // 0x05F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TrainAnimDamageStartFrame;                         // 0x05FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TrainIdleAnimationIndex;                           // 0x0600(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TrainDamageAnimationIndex;                         // 0x0604(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_TrainSmokeEffect;                                // 0x0608(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_TrainSteamEffect;                                // 0x0610(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_SmokeSoundComponent;                             // 0x0618(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_WarningSoundComponent;                           // 0x0620(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_CarHitSoundComponent;                            // 0x0628(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_MoveSoundComponent;                              // 0x0630(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTriggerComponent*                      m_CarSearchTriggerComponent;                       // 0x0638(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionVATMeshComponent*                 VATMeshComponent;                                  // 0x0640(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0648(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            m_MainStaticBodyComponent;                         // 0x0650(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            m_SubStaticBodyComponent;                          // 0x0658(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_660[0x80];                                     // 0x0660(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeStateMove();
	void ChangeStateReturnStart();
	void ChangeStateStay();
	void OnPlayMoveSound();
	void OnStopMoveSound();
	void OnTriggerColliderConflict(const struct FHitTriggerInfo& HitInfo);
	void OnUpdateMoveSoundLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemySmallTrain">();
	}
	static class AEnemySmallTrain* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemySmallTrain>();
	}
};
static_assert(alignof(AEnemySmallTrain) == 0x000010, "Wrong alignment on AEnemySmallTrain");
static_assert(sizeof(AEnemySmallTrain) == 0x0006E0, "Wrong size on AEnemySmallTrain");
static_assert(offsetof(AEnemySmallTrain, TrainJumpHeight) == 0x0005C0, "Member 'AEnemySmallTrain::TrainJumpHeight' has a wrong offset!");
static_assert(offsetof(AEnemySmallTrain, TrainRecoveryTime) == 0x0005C4, "Member 'AEnemySmallTrain::TrainRecoveryTime' has a wrong offset!");
static_assert(offsetof(AEnemySmallTrain, TrainDamegeRetryTime) == 0x0005C8, "Member 'AEnemySmallTrain::TrainDamegeRetryTime' has a wrong offset!");
static_assert(offsetof(AEnemySmallTrain, TrainDamageContinueRecoveryTime) == 0x0005CC, "Member 'AEnemySmallTrain::TrainDamageContinueRecoveryTime' has a wrong offset!");
static_assert(offsetof(AEnemySmallTrain, TrainDamegeContinueRetryTime) == 0x0005D0, "Member 'AEnemySmallTrain::TrainDamegeContinueRetryTime' has a wrong offset!");
static_assert(offsetof(AEnemySmallTrain, TrainDamegeContinueRetryStartFrame) == 0x0005D4, "Member 'AEnemySmallTrain::TrainDamegeContinueRetryStartFrame' has a wrong offset!");
static_assert(offsetof(AEnemySmallTrain, MovefinishRate) == 0x0005D8, "Member 'AEnemySmallTrain::MovefinishRate' has a wrong offset!");
static_assert(offsetof(AEnemySmallTrain, TrainAnimationPlayRate) == 0x0005DC, "Member 'AEnemySmallTrain::TrainAnimationPlayRate' has a wrong offset!");
static_assert(offsetof(AEnemySmallTrain, TrainWarpLocation) == 0x0005E0, "Member 'AEnemySmallTrain::TrainWarpLocation' has a wrong offset!");
static_assert(offsetof(AEnemySmallTrain, TrainAnimStartFrame) == 0x0005F8, "Member 'AEnemySmallTrain::TrainAnimStartFrame' has a wrong offset!");
static_assert(offsetof(AEnemySmallTrain, TrainAnimDamageStartFrame) == 0x0005FC, "Member 'AEnemySmallTrain::TrainAnimDamageStartFrame' has a wrong offset!");
static_assert(offsetof(AEnemySmallTrain, TrainIdleAnimationIndex) == 0x000600, "Member 'AEnemySmallTrain::TrainIdleAnimationIndex' has a wrong offset!");
static_assert(offsetof(AEnemySmallTrain, TrainDamageAnimationIndex) == 0x000604, "Member 'AEnemySmallTrain::TrainDamageAnimationIndex' has a wrong offset!");
static_assert(offsetof(AEnemySmallTrain, m_TrainSmokeEffect) == 0x000608, "Member 'AEnemySmallTrain::m_TrainSmokeEffect' has a wrong offset!");
static_assert(offsetof(AEnemySmallTrain, m_TrainSteamEffect) == 0x000610, "Member 'AEnemySmallTrain::m_TrainSteamEffect' has a wrong offset!");
static_assert(offsetof(AEnemySmallTrain, m_SmokeSoundComponent) == 0x000618, "Member 'AEnemySmallTrain::m_SmokeSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemySmallTrain, m_WarningSoundComponent) == 0x000620, "Member 'AEnemySmallTrain::m_WarningSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemySmallTrain, m_CarHitSoundComponent) == 0x000628, "Member 'AEnemySmallTrain::m_CarHitSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemySmallTrain, m_MoveSoundComponent) == 0x000630, "Member 'AEnemySmallTrain::m_MoveSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemySmallTrain, m_CarSearchTriggerComponent) == 0x000638, "Member 'AEnemySmallTrain::m_CarSearchTriggerComponent' has a wrong offset!");
static_assert(offsetof(AEnemySmallTrain, VATMeshComponent) == 0x000640, "Member 'AEnemySmallTrain::VATMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemySmallTrain, DefaultSceneRoot) == 0x000648, "Member 'AEnemySmallTrain::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AEnemySmallTrain, m_MainStaticBodyComponent) == 0x000650, "Member 'AEnemySmallTrain::m_MainStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemySmallTrain, m_SubStaticBodyComponent) == 0x000658, "Member 'AEnemySmallTrain::m_SubStaticBodyComponent' has a wrong offset!");

// Class UnionRun.EnemySnake
// 0x00B8 (0x0670 - 0x05B8)
class alignas(0x10) AEnemySnake final : public AUnionEnemyBase
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageRecoveryTime;                                // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackingTime;                                     // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackInterval;                                    // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5CC[0x4];                                      // 0x05CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionAtomComponent*                    DanageSoundComponent;                              // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionSkeletalMeshComponent*            SnakeSkeletalMeshComponent;                        // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            SnakeBodyComponent;                                // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTriggerComponent*                      m_FindTriggerComponent;                            // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDamage;                                         // 0x05F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAttack;                                         // 0x05F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F2[0x6E];                                     // 0x05F2(0x006E)(Fixing Size After Last Property [ Dumper-7 ])
	class USnakeAnimInstance*                     AnimInstance;                                      // 0x0660(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_668[0x8];                                      // 0x0668(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTriggerColliderConflict(const struct FHitTriggerInfo& HitInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemySnake">();
	}
	static class AEnemySnake* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemySnake>();
	}
};
static_assert(alignof(AEnemySnake) == 0x000010, "Wrong alignment on AEnemySnake");
static_assert(sizeof(AEnemySnake) == 0x000670, "Wrong size on AEnemySnake");
static_assert(offsetof(AEnemySnake, DamageRecoveryTime) == 0x0005C0, "Member 'AEnemySnake::DamageRecoveryTime' has a wrong offset!");
static_assert(offsetof(AEnemySnake, AttackingTime) == 0x0005C4, "Member 'AEnemySnake::AttackingTime' has a wrong offset!");
static_assert(offsetof(AEnemySnake, AttackInterval) == 0x0005C8, "Member 'AEnemySnake::AttackInterval' has a wrong offset!");
static_assert(offsetof(AEnemySnake, DanageSoundComponent) == 0x0005D0, "Member 'AEnemySnake::DanageSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemySnake, SnakeSkeletalMeshComponent) == 0x0005D8, "Member 'AEnemySnake::SnakeSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemySnake, SnakeBodyComponent) == 0x0005E0, "Member 'AEnemySnake::SnakeBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemySnake, m_FindTriggerComponent) == 0x0005E8, "Member 'AEnemySnake::m_FindTriggerComponent' has a wrong offset!");
static_assert(offsetof(AEnemySnake, bIsDamage) == 0x0005F0, "Member 'AEnemySnake::bIsDamage' has a wrong offset!");
static_assert(offsetof(AEnemySnake, bIsAttack) == 0x0005F1, "Member 'AEnemySnake::bIsAttack' has a wrong offset!");
static_assert(offsetof(AEnemySnake, AnimInstance) == 0x000660, "Member 'AEnemySnake::AnimInstance' has a wrong offset!");

// Class UnionRun.GimmickBigWave
// 0x0050 (0x0600 - 0x05B0)
class alignas(0x10) AGimmickBigWave final : public AUnionGimmickObjectBase
{
public:
	class UUnionStaticMeshComponent*              StaticMeshComponent;                               // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    MoveSoundComponent;                                // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            GimmickStaticBodyComponent01;                      // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            GimmickStaticBodyComponent02;                      // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            GimmickStaticBodyComponent03;                      // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          m_bAutoMove;                                       // 0x05D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D9[0x27];                                     // 0x05D9(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickBigWave">();
	}
	static class AGimmickBigWave* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickBigWave>();
	}
};
static_assert(alignof(AGimmickBigWave) == 0x000010, "Wrong alignment on AGimmickBigWave");
static_assert(sizeof(AGimmickBigWave) == 0x000600, "Wrong size on AGimmickBigWave");
static_assert(offsetof(AGimmickBigWave, StaticMeshComponent) == 0x0005B0, "Member 'AGimmickBigWave::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickBigWave, MoveSoundComponent) == 0x0005B8, "Member 'AGimmickBigWave::MoveSoundComponent' has a wrong offset!");
static_assert(offsetof(AGimmickBigWave, GimmickStaticBodyComponent01) == 0x0005C0, "Member 'AGimmickBigWave::GimmickStaticBodyComponent01' has a wrong offset!");
static_assert(offsetof(AGimmickBigWave, GimmickStaticBodyComponent02) == 0x0005C8, "Member 'AGimmickBigWave::GimmickStaticBodyComponent02' has a wrong offset!");
static_assert(offsetof(AGimmickBigWave, GimmickStaticBodyComponent03) == 0x0005D0, "Member 'AGimmickBigWave::GimmickStaticBodyComponent03' has a wrong offset!");
static_assert(offsetof(AGimmickBigWave, m_bAutoMove) == 0x0005D8, "Member 'AGimmickBigWave::m_bAutoMove' has a wrong offset!");

// Class UnionRun.EnemySquid
// 0x01D8 (0x0790 - 0x05B8)
class alignas(0x10) AEnemySquid final : public AUnionEnemyBase
{
public:
	class UUnionSkeletalMeshComponent*            SquidMesh;                                         // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    Sound;                                             // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LeftMuzzle;                                        // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      RightMuzzle;                                       // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FollowPathTime;                                    // 0x05D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5DC[0x4];                                      // 0x05DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEnemySquidPhase1Attack                Phase1Attack;                                      // 0x05E0(0x0048)(Edit, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FollowPathCurve;                                   // 0x0628(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEnemySquidPhase2Attack                Phase2Attack;                                      // 0x0630(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MoveToPhase2LocationTime;                          // 0x064C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FollowPathRotOffset;                               // 0x0650(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           MaterialParam;                                     // 0x0668(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AEnemySquidDestination*                 RoadStartPoint;                                    // 0x0670(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AEnemySquidDestination*                 RoadEndPoint;                                      // 0x0678(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AEnemySquidDestination*>         Destinations;                                      // 0x0680(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class AUnionSplineActor*                      MoveToPhase2Path;                                  // 0x0690(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletPoolNum;                                     // 0x0698(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69C[0x4];                                      // 0x069C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AEnemySquidBullet>          BulletReference;                                   // 0x06A0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugShootPhase1;                                  // 0x06A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugShootPhase2;                                  // 0x06A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6AA[0x6];                                      // 0x06AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionSplineComponent*                  ToPhase2Spline;                                    // 0x06B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USquidAnimInstance*                     AnimInstance;                                      // 0x06B8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C0[0xD0];                                     // 0x06C0(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemySquid">();
	}
	static class AEnemySquid* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemySquid>();
	}
};
static_assert(alignof(AEnemySquid) == 0x000010, "Wrong alignment on AEnemySquid");
static_assert(sizeof(AEnemySquid) == 0x000790, "Wrong size on AEnemySquid");
static_assert(offsetof(AEnemySquid, SquidMesh) == 0x0005B8, "Member 'AEnemySquid::SquidMesh' has a wrong offset!");
static_assert(offsetof(AEnemySquid, Sound) == 0x0005C0, "Member 'AEnemySquid::Sound' has a wrong offset!");
static_assert(offsetof(AEnemySquid, LeftMuzzle) == 0x0005C8, "Member 'AEnemySquid::LeftMuzzle' has a wrong offset!");
static_assert(offsetof(AEnemySquid, RightMuzzle) == 0x0005D0, "Member 'AEnemySquid::RightMuzzle' has a wrong offset!");
static_assert(offsetof(AEnemySquid, FollowPathTime) == 0x0005D8, "Member 'AEnemySquid::FollowPathTime' has a wrong offset!");
static_assert(offsetof(AEnemySquid, Phase1Attack) == 0x0005E0, "Member 'AEnemySquid::Phase1Attack' has a wrong offset!");
static_assert(offsetof(AEnemySquid, FollowPathCurve) == 0x000628, "Member 'AEnemySquid::FollowPathCurve' has a wrong offset!");
static_assert(offsetof(AEnemySquid, Phase2Attack) == 0x000630, "Member 'AEnemySquid::Phase2Attack' has a wrong offset!");
static_assert(offsetof(AEnemySquid, MoveToPhase2LocationTime) == 0x00064C, "Member 'AEnemySquid::MoveToPhase2LocationTime' has a wrong offset!");
static_assert(offsetof(AEnemySquid, FollowPathRotOffset) == 0x000650, "Member 'AEnemySquid::FollowPathRotOffset' has a wrong offset!");
static_assert(offsetof(AEnemySquid, MaterialParam) == 0x000668, "Member 'AEnemySquid::MaterialParam' has a wrong offset!");
static_assert(offsetof(AEnemySquid, RoadStartPoint) == 0x000670, "Member 'AEnemySquid::RoadStartPoint' has a wrong offset!");
static_assert(offsetof(AEnemySquid, RoadEndPoint) == 0x000678, "Member 'AEnemySquid::RoadEndPoint' has a wrong offset!");
static_assert(offsetof(AEnemySquid, Destinations) == 0x000680, "Member 'AEnemySquid::Destinations' has a wrong offset!");
static_assert(offsetof(AEnemySquid, MoveToPhase2Path) == 0x000690, "Member 'AEnemySquid::MoveToPhase2Path' has a wrong offset!");
static_assert(offsetof(AEnemySquid, BulletPoolNum) == 0x000698, "Member 'AEnemySquid::BulletPoolNum' has a wrong offset!");
static_assert(offsetof(AEnemySquid, BulletReference) == 0x0006A0, "Member 'AEnemySquid::BulletReference' has a wrong offset!");
static_assert(offsetof(AEnemySquid, DebugShootPhase1) == 0x0006A8, "Member 'AEnemySquid::DebugShootPhase1' has a wrong offset!");
static_assert(offsetof(AEnemySquid, DebugShootPhase2) == 0x0006A9, "Member 'AEnemySquid::DebugShootPhase2' has a wrong offset!");
static_assert(offsetof(AEnemySquid, ToPhase2Spline) == 0x0006B0, "Member 'AEnemySquid::ToPhase2Spline' has a wrong offset!");
static_assert(offsetof(AEnemySquid, AnimInstance) == 0x0006B8, "Member 'AEnemySquid::AnimInstance' has a wrong offset!");

// Class UnionRun.GimmickBubble
// 0x06B0 (0x0C60 - 0x05B0)
class AGimmickBubble final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionVATMeshComponent*                 VATMeshComponent;                                  // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_BubbleBreakEffectComponent;                      // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_AppearSoundComponent;                            // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_BreakSoundComponent;                             // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTimelineComponent*                     BubbleScaleTimelineComponent;                      // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        IncludeItemRoot;                                   // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChildActorComponent*                   ChildActorItemBoxes;                               // 0x05E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChildActorComponent*                   ChildActorRings;                                   // 0x05F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            BubbleStaticBodyComponent;                         // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AppearScaleTime;                                   // 0x0600(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AppearEnableCollisionTime;                         // 0x0604(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakIdleTime;                                     // 0x0608(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60C[0x4];                                      // 0x060C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BubbleMaxScale;                                    // 0x0610(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AppearEffectOffset;                                // 0x0628(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AppearEffectScale;                                 // 0x0640(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoBreakTime;                                     // 0x0658(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BubbleMoveLenght;                                  // 0x065C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivateWaitTime;                                  // 0x0660(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakReadyTime;                                    // 0x0664(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakReadyMoveLength;                              // 0x0668(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_66C[0x4];                                      // 0x066C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VioletVoidAbsorbTargetScale_ItemBox;               // 0x0670(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VioletVoidAbsorbTargetScale_Ring;                  // 0x0688(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             VioletVoidAbsorbInitialTransform_ItemBox;          // 0x06A0(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             VioletVoidAbsorbInitialTransform_Ring;             // 0x0700(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              BodyStatickMeshComponent;                          // 0x0760(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSBubbleBonusParam                     BonusParam_ItemBox;                                // 0x0768(0x0070)(Edit, EditFixedSize, NoDestructor, NativeAccessSpecifierPublic)
	struct FSBubbleBonusParam                     BonusParam_ItemBoxW;                               // 0x07D8(0x0070)(Edit, EditFixedSize, NoDestructor, NativeAccessSpecifierPublic)
	struct FSBubbleBonusParam                     BonusParam_ItemBoxSp;                              // 0x0848(0x0070)(Edit, EditFixedSize, NoDestructor, NativeAccessSpecifierPublic)
	struct FSBubbleBonusParam                     BonusParam_Ring5;                                  // 0x08B8(0x0070)(Edit, EditFixedSize, NoDestructor, NativeAccessSpecifierPublic)
	struct FSBubbleBonusParam                     BonusParam_Ring10;                                 // 0x0928(0x0070)(Edit, EditFixedSize, NoDestructor, NativeAccessSpecifierPublic)
	struct FSBubbleBonusParam                     BonusParam_Ring20;                                 // 0x0998(0x0070)(Edit, EditFixedSize, NoDestructor, NativeAccessSpecifierPublic)
	struct FSBubbleBonusParam                     BonusParam_Ring100;                                // 0x0A08(0x0070)(Edit, EditFixedSize, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class AItemBoxObject>             ItemBoxReference;                                  // 0x0A78(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APackageRingObject>         PackageRingReference;                              // 0x0A80(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             BonusItemData;                                     // 0x0A88(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DatatableRowName;                                  // 0x0A90(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isUseForceBonusSetting;                            // 0x0A98(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBubbleBonusType                              FirstBonusType;                                    // 0x0A99(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9A[0x6];                                      // 0x0A9A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BubbleAppearMoveCurve;                             // 0x0AA0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            BubbleScaleCurve;                                  // 0x0AA8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            BubbleBreakMoveCurve;                              // 0x0AB0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(float Output)>                 BubbleScaleUpdateEvent;                            // 0x0AB8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             BubbleScaleFinishedEvent;                          // 0x0AC8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(float Output)>                 BubbleMoveUpdateEvent;                             // 0x0AD8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             BubbleMoveFinishedEvent;                           // 0x0AE8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0AF8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        BubbleMeshRoot;                                    // 0x0B00(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B08[0x14C];                                    // 0x0B08(0x014C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurveFloat;                                        // 0x0C54(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C58[0x8];                                      // 0x0C58(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BubbleIdleMoveFinished();
	void BubbleIdleMoveUpdate(float Ratio);
	void BubbleScaleFinished();
	void BubbleScaleUpdate(float Ratio);
	void ForceSetDomainNumber(EDomainNumber Number);
	void ForceUpdate(float DeltaTime);
	void ManualUpdate(float InDeltaTime);
	void OnGetBonusItem(EBubbleBonusType BonusType, int32 RacerIndex);
	void SetVisivleBonusItemType(EBubbleBonusType BonusType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickBubble">();
	}
	static class AGimmickBubble* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickBubble>();
	}
};
static_assert(alignof(AGimmickBubble) == 0x000010, "Wrong alignment on AGimmickBubble");
static_assert(sizeof(AGimmickBubble) == 0x000C60, "Wrong size on AGimmickBubble");
static_assert(offsetof(AGimmickBubble, VATMeshComponent) == 0x0005B8, "Member 'AGimmickBubble::VATMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, m_BubbleBreakEffectComponent) == 0x0005C0, "Member 'AGimmickBubble::m_BubbleBreakEffectComponent' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, m_AppearSoundComponent) == 0x0005C8, "Member 'AGimmickBubble::m_AppearSoundComponent' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, m_BreakSoundComponent) == 0x0005D0, "Member 'AGimmickBubble::m_BreakSoundComponent' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, BubbleScaleTimelineComponent) == 0x0005D8, "Member 'AGimmickBubble::BubbleScaleTimelineComponent' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, IncludeItemRoot) == 0x0005E0, "Member 'AGimmickBubble::IncludeItemRoot' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, ChildActorItemBoxes) == 0x0005E8, "Member 'AGimmickBubble::ChildActorItemBoxes' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, ChildActorRings) == 0x0005F0, "Member 'AGimmickBubble::ChildActorRings' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, BubbleStaticBodyComponent) == 0x0005F8, "Member 'AGimmickBubble::BubbleStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, AppearScaleTime) == 0x000600, "Member 'AGimmickBubble::AppearScaleTime' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, AppearEnableCollisionTime) == 0x000604, "Member 'AGimmickBubble::AppearEnableCollisionTime' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, BreakIdleTime) == 0x000608, "Member 'AGimmickBubble::BreakIdleTime' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, BubbleMaxScale) == 0x000610, "Member 'AGimmickBubble::BubbleMaxScale' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, AppearEffectOffset) == 0x000628, "Member 'AGimmickBubble::AppearEffectOffset' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, AppearEffectScale) == 0x000640, "Member 'AGimmickBubble::AppearEffectScale' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, AutoBreakTime) == 0x000658, "Member 'AGimmickBubble::AutoBreakTime' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, BubbleMoveLenght) == 0x00065C, "Member 'AGimmickBubble::BubbleMoveLenght' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, ActivateWaitTime) == 0x000660, "Member 'AGimmickBubble::ActivateWaitTime' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, BreakReadyTime) == 0x000664, "Member 'AGimmickBubble::BreakReadyTime' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, BreakReadyMoveLength) == 0x000668, "Member 'AGimmickBubble::BreakReadyMoveLength' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, VioletVoidAbsorbTargetScale_ItemBox) == 0x000670, "Member 'AGimmickBubble::VioletVoidAbsorbTargetScale_ItemBox' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, VioletVoidAbsorbTargetScale_Ring) == 0x000688, "Member 'AGimmickBubble::VioletVoidAbsorbTargetScale_Ring' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, VioletVoidAbsorbInitialTransform_ItemBox) == 0x0006A0, "Member 'AGimmickBubble::VioletVoidAbsorbInitialTransform_ItemBox' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, VioletVoidAbsorbInitialTransform_Ring) == 0x000700, "Member 'AGimmickBubble::VioletVoidAbsorbInitialTransform_Ring' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, BodyStatickMeshComponent) == 0x000760, "Member 'AGimmickBubble::BodyStatickMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, BonusParam_ItemBox) == 0x000768, "Member 'AGimmickBubble::BonusParam_ItemBox' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, BonusParam_ItemBoxW) == 0x0007D8, "Member 'AGimmickBubble::BonusParam_ItemBoxW' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, BonusParam_ItemBoxSp) == 0x000848, "Member 'AGimmickBubble::BonusParam_ItemBoxSp' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, BonusParam_Ring5) == 0x0008B8, "Member 'AGimmickBubble::BonusParam_Ring5' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, BonusParam_Ring10) == 0x000928, "Member 'AGimmickBubble::BonusParam_Ring10' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, BonusParam_Ring20) == 0x000998, "Member 'AGimmickBubble::BonusParam_Ring20' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, BonusParam_Ring100) == 0x000A08, "Member 'AGimmickBubble::BonusParam_Ring100' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, ItemBoxReference) == 0x000A78, "Member 'AGimmickBubble::ItemBoxReference' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, PackageRingReference) == 0x000A80, "Member 'AGimmickBubble::PackageRingReference' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, BonusItemData) == 0x000A88, "Member 'AGimmickBubble::BonusItemData' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, DatatableRowName) == 0x000A90, "Member 'AGimmickBubble::DatatableRowName' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, isUseForceBonusSetting) == 0x000A98, "Member 'AGimmickBubble::isUseForceBonusSetting' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, FirstBonusType) == 0x000A99, "Member 'AGimmickBubble::FirstBonusType' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, BubbleAppearMoveCurve) == 0x000AA0, "Member 'AGimmickBubble::BubbleAppearMoveCurve' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, BubbleScaleCurve) == 0x000AA8, "Member 'AGimmickBubble::BubbleScaleCurve' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, BubbleBreakMoveCurve) == 0x000AB0, "Member 'AGimmickBubble::BubbleBreakMoveCurve' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, BubbleScaleUpdateEvent) == 0x000AB8, "Member 'AGimmickBubble::BubbleScaleUpdateEvent' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, BubbleScaleFinishedEvent) == 0x000AC8, "Member 'AGimmickBubble::BubbleScaleFinishedEvent' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, BubbleMoveUpdateEvent) == 0x000AD8, "Member 'AGimmickBubble::BubbleMoveUpdateEvent' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, BubbleMoveFinishedEvent) == 0x000AE8, "Member 'AGimmickBubble::BubbleMoveFinishedEvent' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, DefaultSceneRoot) == 0x000AF8, "Member 'AGimmickBubble::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, BubbleMeshRoot) == 0x000B00, "Member 'AGimmickBubble::BubbleMeshRoot' has a wrong offset!");
static_assert(offsetof(AGimmickBubble, CurveFloat) == 0x000C54, "Member 'AGimmickBubble::CurveFloat' has a wrong offset!");

// Class UnionRun.EnemySquidBullet
// 0x0138 (0x06F0 - 0x05B8)
class alignas(0x10) AEnemySquidBullet final : public AUnionEnemyBase
{
public:
	class UUnionStaticMeshComponent*              Mesh;                                              // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      BulletEffect;                                      // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            Body;                                              // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightOnPath;                                      // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D4[0x4];                                      // 0x05D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         Bullet;                                            // 0x05D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         Hit;                                               // 0x05E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E8[0x108];                                    // 0x05E8(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemySquidBullet">();
	}
	static class AEnemySquidBullet* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemySquidBullet>();
	}
};
static_assert(alignof(AEnemySquidBullet) == 0x000010, "Wrong alignment on AEnemySquidBullet");
static_assert(sizeof(AEnemySquidBullet) == 0x0006F0, "Wrong size on AEnemySquidBullet");
static_assert(offsetof(AEnemySquidBullet, Mesh) == 0x0005B8, "Member 'AEnemySquidBullet::Mesh' has a wrong offset!");
static_assert(offsetof(AEnemySquidBullet, BulletEffect) == 0x0005C0, "Member 'AEnemySquidBullet::BulletEffect' has a wrong offset!");
static_assert(offsetof(AEnemySquidBullet, Body) == 0x0005C8, "Member 'AEnemySquidBullet::Body' has a wrong offset!");
static_assert(offsetof(AEnemySquidBullet, HeightOnPath) == 0x0005D0, "Member 'AEnemySquidBullet::HeightOnPath' has a wrong offset!");
static_assert(offsetof(AEnemySquidBullet, Bullet) == 0x0005D8, "Member 'AEnemySquidBullet::Bullet' has a wrong offset!");
static_assert(offsetof(AEnemySquidBullet, Hit) == 0x0005E0, "Member 'AEnemySquidBullet::Hit' has a wrong offset!");

// Class UnionRun.EnemySquidDestination
// 0x01D0 (0x0780 - 0x05B0)
class alignas(0x10) AEnemySquidDestination final : public AUnionGimmickObjectBase
{
public:
	int32                                         UniqueID;                                          // 0x05B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B4[0x4];                                      // 0x05B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C0[0x1C0];                                    // 0x05C0(0x01C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EditorCalcDestination();
	void EditorUpdatePathLocation(TSoftObjectPtr<class AActor> SplineActor);
	void OnEditorCalcDestEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemySquidDestination">();
	}
	static class AEnemySquidDestination* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemySquidDestination>();
	}
};
static_assert(alignof(AEnemySquidDestination) == 0x000010, "Wrong alignment on AEnemySquidDestination");
static_assert(sizeof(AEnemySquidDestination) == 0x000780, "Wrong size on AEnemySquidDestination");
static_assert(offsetof(AEnemySquidDestination, UniqueID) == 0x0005B0, "Member 'AEnemySquidDestination::UniqueID' has a wrong offset!");
static_assert(offsetof(AEnemySquidDestination, DefaultSceneRoot) == 0x0005B8, "Member 'AEnemySquidDestination::DefaultSceneRoot' has a wrong offset!");

// Class UnionRun.EnemySquidObject
// 0x0008 (0x0348 - 0x0340)
class AEnemySquidObject final : public AUnionCourseObjectBase
{
public:
	class UUnionStaticMeshComponent*              Mesh;                                              // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemySquidObject">();
	}
	static class AEnemySquidObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemySquidObject>();
	}
};
static_assert(alignof(AEnemySquidObject) == 0x000008, "Wrong alignment on AEnemySquidObject");
static_assert(sizeof(AEnemySquidObject) == 0x000348, "Wrong size on AEnemySquidObject");
static_assert(offsetof(AEnemySquidObject, Mesh) == 0x000340, "Member 'AEnemySquidObject::Mesh' has a wrong offset!");

// Class UnionRun.GimmickMoveRunwayBoo
// 0x0020 (0x05D0 - 0x05B0)
class alignas(0x10) AGimmickMoveRunwayBoo final : public AUnionGimmickObjectBase
{
public:
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionVATAnimEventComponent*            BooVATMeshComponent;                               // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AnimStartFrame;                                    // 0x05C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C4[0xC];                                      // 0x05C4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickMoveRunwayBoo">();
	}
	static class AGimmickMoveRunwayBoo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickMoveRunwayBoo>();
	}
};
static_assert(alignof(AGimmickMoveRunwayBoo) == 0x000010, "Wrong alignment on AGimmickMoveRunwayBoo");
static_assert(sizeof(AGimmickMoveRunwayBoo) == 0x0005D0, "Wrong size on AGimmickMoveRunwayBoo");
static_assert(offsetof(AGimmickMoveRunwayBoo, DefaultSceneRoot) == 0x0005B0, "Member 'AGimmickMoveRunwayBoo::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AGimmickMoveRunwayBoo, BooVATMeshComponent) == 0x0005B8, "Member 'AGimmickMoveRunwayBoo::BooVATMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickMoveRunwayBoo, AnimStartFrame) == 0x0005C0, "Member 'AGimmickMoveRunwayBoo::AnimStartFrame' has a wrong offset!");

// Class UnionRun.EnemyStoneStatue
// 0x0108 (0x06C0 - 0x05B8)
class alignas(0x10) AEnemyStoneStatue final : public AUnionEnemyBase
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionVATMeshComponent*                 VATMeshComponent;                                  // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    MoveUpSoundComponent;                              // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    LandHitSoundComponent;                             // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveUpTime;                                        // 0x05D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageMoveHight;                                   // 0x05DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DamageMoveUpCurve;                                 // 0x05E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseDamageMoveTremor;                               // 0x05E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E9[0x3];                                      // 0x05E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TremorEnableDistance;                              // 0x05EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            m_MainStaticBodyComponent;                         // 0x05F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTriggerComponent*                      m_StompTriggerComponent;                           // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_600[0xC0];                                     // 0x0600(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MovePositionUpdate(float Ratio);
	void OnTremorEvent();
	void OnTriggerColliderConflict(const struct FHitTriggerInfo& HitInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyStoneStatue">();
	}
	static class AEnemyStoneStatue* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyStoneStatue>();
	}
};
static_assert(alignof(AEnemyStoneStatue) == 0x000010, "Wrong alignment on AEnemyStoneStatue");
static_assert(sizeof(AEnemyStoneStatue) == 0x0006C0, "Wrong size on AEnemyStoneStatue");
static_assert(offsetof(AEnemyStoneStatue, VATMeshComponent) == 0x0005C0, "Member 'AEnemyStoneStatue::VATMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyStoneStatue, MoveUpSoundComponent) == 0x0005C8, "Member 'AEnemyStoneStatue::MoveUpSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemyStoneStatue, LandHitSoundComponent) == 0x0005D0, "Member 'AEnemyStoneStatue::LandHitSoundComponent' has a wrong offset!");
static_assert(offsetof(AEnemyStoneStatue, MoveUpTime) == 0x0005D8, "Member 'AEnemyStoneStatue::MoveUpTime' has a wrong offset!");
static_assert(offsetof(AEnemyStoneStatue, DamageMoveHight) == 0x0005DC, "Member 'AEnemyStoneStatue::DamageMoveHight' has a wrong offset!");
static_assert(offsetof(AEnemyStoneStatue, DamageMoveUpCurve) == 0x0005E0, "Member 'AEnemyStoneStatue::DamageMoveUpCurve' has a wrong offset!");
static_assert(offsetof(AEnemyStoneStatue, UseDamageMoveTremor) == 0x0005E8, "Member 'AEnemyStoneStatue::UseDamageMoveTremor' has a wrong offset!");
static_assert(offsetof(AEnemyStoneStatue, TremorEnableDistance) == 0x0005EC, "Member 'AEnemyStoneStatue::TremorEnableDistance' has a wrong offset!");
static_assert(offsetof(AEnemyStoneStatue, m_MainStaticBodyComponent) == 0x0005F0, "Member 'AEnemyStoneStatue::m_MainStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyStoneStatue, m_StompTriggerComponent) == 0x0005F8, "Member 'AEnemyStoneStatue::m_StompTriggerComponent' has a wrong offset!");

// Class UnionRun.RaceUISubAiming
// 0x0068 (0x0348 - 0x02E0)
class URaceUISubAiming : public UUserWidget
{
public:
	class UUnionRaceUI*                           RaceHUD;                                           // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               Overlay01;                                         // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               Overlay02;                                         // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 AimingImage;                                       // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 LockOnImage;                                       // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       WaitAnim;                                          // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       LockOnAnim;                                        // 0x0310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       LostAnim;                                          // 0x0318(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       ShotAnim;                                          // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanelSlot*                       CanvasSlot;                                        // 0x0328(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoundHandle                           AimingUseBeforeSoundHandle;                        // 0x0330(0x0004)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               AimingMID;                                         // 0x0338(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_340[0x8];                                      // 0x0340(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitParam();
	void ReStartAimingUseBeforeSound(int32 PlayerControllerIndex);
	void SetRaceHUD(class UUnionRaceUI* inRaceHud, int32 localPlayerNum);
	void StopSound(bool bPause);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceUISubAiming">();
	}
	static class URaceUISubAiming* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceUISubAiming>();
	}
};
static_assert(alignof(URaceUISubAiming) == 0x000008, "Wrong alignment on URaceUISubAiming");
static_assert(sizeof(URaceUISubAiming) == 0x000348, "Wrong size on URaceUISubAiming");
static_assert(offsetof(URaceUISubAiming, RaceHUD) == 0x0002E0, "Member 'URaceUISubAiming::RaceHUD' has a wrong offset!");
static_assert(offsetof(URaceUISubAiming, Overlay01) == 0x0002E8, "Member 'URaceUISubAiming::Overlay01' has a wrong offset!");
static_assert(offsetof(URaceUISubAiming, Overlay02) == 0x0002F0, "Member 'URaceUISubAiming::Overlay02' has a wrong offset!");
static_assert(offsetof(URaceUISubAiming, AimingImage) == 0x0002F8, "Member 'URaceUISubAiming::AimingImage' has a wrong offset!");
static_assert(offsetof(URaceUISubAiming, LockOnImage) == 0x000300, "Member 'URaceUISubAiming::LockOnImage' has a wrong offset!");
static_assert(offsetof(URaceUISubAiming, WaitAnim) == 0x000308, "Member 'URaceUISubAiming::WaitAnim' has a wrong offset!");
static_assert(offsetof(URaceUISubAiming, LockOnAnim) == 0x000310, "Member 'URaceUISubAiming::LockOnAnim' has a wrong offset!");
static_assert(offsetof(URaceUISubAiming, LostAnim) == 0x000318, "Member 'URaceUISubAiming::LostAnim' has a wrong offset!");
static_assert(offsetof(URaceUISubAiming, ShotAnim) == 0x000320, "Member 'URaceUISubAiming::ShotAnim' has a wrong offset!");
static_assert(offsetof(URaceUISubAiming, CanvasSlot) == 0x000328, "Member 'URaceUISubAiming::CanvasSlot' has a wrong offset!");
static_assert(offsetof(URaceUISubAiming, AimingUseBeforeSoundHandle) == 0x000330, "Member 'URaceUISubAiming::AimingUseBeforeSoundHandle' has a wrong offset!");
static_assert(offsetof(URaceUISubAiming, AimingMID) == 0x000338, "Member 'URaceUISubAiming::AimingMID' has a wrong offset!");

// Class UnionRun.EnemyTentacle
// 0x00C8 (0x0680 - 0x05B8)
class alignas(0x10) AEnemyTentacle final : public AUnionEnemyBase
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionVATAnimEventComponent*            VATMeshComponent;                                  // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            StaticBodyComponent;                               // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      NiagaraAttack;                                     // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AttackStartFrame;                                  // 0x05D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AttackEndFrame;                                    // 0x05DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SquashedEndFrame;                                  // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TentacleAnimStartFrame;                            // 0x05E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AttackEffectFrame;                                 // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AttackBlinkFrame;                                  // 0x05EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F0[0x60];                                     // 0x05F0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BlinkAnimCurve;                                    // 0x0650(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               TentacleMID;                                       // 0x0658(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_660[0x20];                                     // 0x0660(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAttackBlink();
	void OnHitFramePrint();
	void TimelineStep(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyTentacle">();
	}
	static class AEnemyTentacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyTentacle>();
	}
};
static_assert(alignof(AEnemyTentacle) == 0x000010, "Wrong alignment on AEnemyTentacle");
static_assert(sizeof(AEnemyTentacle) == 0x000680, "Wrong size on AEnemyTentacle");
static_assert(offsetof(AEnemyTentacle, VATMeshComponent) == 0x0005C0, "Member 'AEnemyTentacle::VATMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyTentacle, StaticBodyComponent) == 0x0005C8, "Member 'AEnemyTentacle::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyTentacle, NiagaraAttack) == 0x0005D0, "Member 'AEnemyTentacle::NiagaraAttack' has a wrong offset!");
static_assert(offsetof(AEnemyTentacle, AttackStartFrame) == 0x0005D8, "Member 'AEnemyTentacle::AttackStartFrame' has a wrong offset!");
static_assert(offsetof(AEnemyTentacle, AttackEndFrame) == 0x0005DC, "Member 'AEnemyTentacle::AttackEndFrame' has a wrong offset!");
static_assert(offsetof(AEnemyTentacle, SquashedEndFrame) == 0x0005E0, "Member 'AEnemyTentacle::SquashedEndFrame' has a wrong offset!");
static_assert(offsetof(AEnemyTentacle, TentacleAnimStartFrame) == 0x0005E4, "Member 'AEnemyTentacle::TentacleAnimStartFrame' has a wrong offset!");
static_assert(offsetof(AEnemyTentacle, AttackEffectFrame) == 0x0005E8, "Member 'AEnemyTentacle::AttackEffectFrame' has a wrong offset!");
static_assert(offsetof(AEnemyTentacle, AttackBlinkFrame) == 0x0005EC, "Member 'AEnemyTentacle::AttackBlinkFrame' has a wrong offset!");
static_assert(offsetof(AEnemyTentacle, BlinkAnimCurve) == 0x000650, "Member 'AEnemyTentacle::BlinkAnimCurve' has a wrong offset!");
static_assert(offsetof(AEnemyTentacle, TentacleMID) == 0x000658, "Member 'AEnemyTentacle::TentacleMID' has a wrong offset!");

// Class UnionRun.RoadsideFire
// 0x0090 (0x0640 - 0x05B0)
class alignas(0x10) ARoadsideFire final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ARoadsideFire*                          PairFire;                                          // 0x05B8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              _StaticMeshComponent;                              // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      _SparkEffect;                                      // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            _StaticBody;                                       // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    _AppearSound;                                      // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERacerDamageType                              _DamageType;                                       // 0x05E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E1[0x3];                                      // 0x05E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _AppearDistance;                                   // 0x05E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ScaleDuration;                                     // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5EC[0x4];                                      // 0x05EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               FireMaterial;                                      // 0x05F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F8[0x48];                                     // 0x05F8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoadsideFire">();
	}
	static class ARoadsideFire* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARoadsideFire>();
	}
};
static_assert(alignof(ARoadsideFire) == 0x000010, "Wrong alignment on ARoadsideFire");
static_assert(sizeof(ARoadsideFire) == 0x000640, "Wrong size on ARoadsideFire");
static_assert(offsetof(ARoadsideFire, PairFire) == 0x0005B8, "Member 'ARoadsideFire::PairFire' has a wrong offset!");
static_assert(offsetof(ARoadsideFire, _StaticMeshComponent) == 0x0005C0, "Member 'ARoadsideFire::_StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(ARoadsideFire, _SparkEffect) == 0x0005C8, "Member 'ARoadsideFire::_SparkEffect' has a wrong offset!");
static_assert(offsetof(ARoadsideFire, _StaticBody) == 0x0005D0, "Member 'ARoadsideFire::_StaticBody' has a wrong offset!");
static_assert(offsetof(ARoadsideFire, _AppearSound) == 0x0005D8, "Member 'ARoadsideFire::_AppearSound' has a wrong offset!");
static_assert(offsetof(ARoadsideFire, _DamageType) == 0x0005E0, "Member 'ARoadsideFire::_DamageType' has a wrong offset!");
static_assert(offsetof(ARoadsideFire, _AppearDistance) == 0x0005E4, "Member 'ARoadsideFire::_AppearDistance' has a wrong offset!");
static_assert(offsetof(ARoadsideFire, ScaleDuration) == 0x0005E8, "Member 'ARoadsideFire::ScaleDuration' has a wrong offset!");
static_assert(offsetof(ARoadsideFire, FireMaterial) == 0x0005F0, "Member 'ARoadsideFire::FireMaterial' has a wrong offset!");

// Class UnionRun.EnemyTower
// 0x0198 (0x0750 - 0x05B8)
class alignas(0x10) AEnemyTower final : public AUnionEnemyBase
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Root;                                              // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionSkeletalMeshComponent*            TowerMesh;                                         // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            StaticBody;                                        // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    RingSound;                                         // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    TowerSound;                                        // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LandingEffect;                                     // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERacerDamageType                              SquashedType;                                      // 0x05F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F1[0x3];                                      // 0x05F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveTime;                                          // 0x05F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RoundStart;                                        // 0x05F8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RoundEnd;                                          // 0x0610(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundTime;                                         // 0x0628(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62C[0x4];                                      // 0x062C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RoundCurve;                                        // 0x0630(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallReadyTime;                                     // 0x0638(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStopAtReady;                                     // 0x063C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63D[0x3];                                      // 0x063D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FallTime;                                          // 0x0640(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_644[0x4];                                      // 0x0644(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            FallCurve;                                         // 0x0648(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandedWaitTime;                                    // 0x0650(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefloatingTime;                                    // 0x0654(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStopAtRefloating;                                // 0x0658(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_659[0x7];                                      // 0x0659(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RefloatingCurve;                                   // 0x0660(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StanTime;                                          // 0x0668(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StanBounceTime;                                    // 0x066C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StanBounceHeight;                                  // 0x0670(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StanRefloatingTime;                                // 0x0674(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            StanBounceCurve;                                   // 0x0678(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          AttackReadySound;                                  // 0x0680(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          LandSound;                                         // 0x0688(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          DamageSound;                                       // 0x0690(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTowerAnimInstance*                     AnimInstance;                                      // 0x0698(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6A0[0xB0];                                     // 0x06A0(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyTower">();
	}
	static class AEnemyTower* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyTower>();
	}
};
static_assert(alignof(AEnemyTower) == 0x000010, "Wrong alignment on AEnemyTower");
static_assert(sizeof(AEnemyTower) == 0x000750, "Wrong size on AEnemyTower");
static_assert(offsetof(AEnemyTower, Root) == 0x0005C0, "Member 'AEnemyTower::Root' has a wrong offset!");
static_assert(offsetof(AEnemyTower, TowerMesh) == 0x0005C8, "Member 'AEnemyTower::TowerMesh' has a wrong offset!");
static_assert(offsetof(AEnemyTower, StaticBody) == 0x0005D0, "Member 'AEnemyTower::StaticBody' has a wrong offset!");
static_assert(offsetof(AEnemyTower, RingSound) == 0x0005D8, "Member 'AEnemyTower::RingSound' has a wrong offset!");
static_assert(offsetof(AEnemyTower, TowerSound) == 0x0005E0, "Member 'AEnemyTower::TowerSound' has a wrong offset!");
static_assert(offsetof(AEnemyTower, LandingEffect) == 0x0005E8, "Member 'AEnemyTower::LandingEffect' has a wrong offset!");
static_assert(offsetof(AEnemyTower, SquashedType) == 0x0005F0, "Member 'AEnemyTower::SquashedType' has a wrong offset!");
static_assert(offsetof(AEnemyTower, MoveTime) == 0x0005F4, "Member 'AEnemyTower::MoveTime' has a wrong offset!");
static_assert(offsetof(AEnemyTower, RoundStart) == 0x0005F8, "Member 'AEnemyTower::RoundStart' has a wrong offset!");
static_assert(offsetof(AEnemyTower, RoundEnd) == 0x000610, "Member 'AEnemyTower::RoundEnd' has a wrong offset!");
static_assert(offsetof(AEnemyTower, RoundTime) == 0x000628, "Member 'AEnemyTower::RoundTime' has a wrong offset!");
static_assert(offsetof(AEnemyTower, RoundCurve) == 0x000630, "Member 'AEnemyTower::RoundCurve' has a wrong offset!");
static_assert(offsetof(AEnemyTower, FallReadyTime) == 0x000638, "Member 'AEnemyTower::FallReadyTime' has a wrong offset!");
static_assert(offsetof(AEnemyTower, IsStopAtReady) == 0x00063C, "Member 'AEnemyTower::IsStopAtReady' has a wrong offset!");
static_assert(offsetof(AEnemyTower, FallTime) == 0x000640, "Member 'AEnemyTower::FallTime' has a wrong offset!");
static_assert(offsetof(AEnemyTower, FallCurve) == 0x000648, "Member 'AEnemyTower::FallCurve' has a wrong offset!");
static_assert(offsetof(AEnemyTower, LandedWaitTime) == 0x000650, "Member 'AEnemyTower::LandedWaitTime' has a wrong offset!");
static_assert(offsetof(AEnemyTower, RefloatingTime) == 0x000654, "Member 'AEnemyTower::RefloatingTime' has a wrong offset!");
static_assert(offsetof(AEnemyTower, IsStopAtRefloating) == 0x000658, "Member 'AEnemyTower::IsStopAtRefloating' has a wrong offset!");
static_assert(offsetof(AEnemyTower, RefloatingCurve) == 0x000660, "Member 'AEnemyTower::RefloatingCurve' has a wrong offset!");
static_assert(offsetof(AEnemyTower, StanTime) == 0x000668, "Member 'AEnemyTower::StanTime' has a wrong offset!");
static_assert(offsetof(AEnemyTower, StanBounceTime) == 0x00066C, "Member 'AEnemyTower::StanBounceTime' has a wrong offset!");
static_assert(offsetof(AEnemyTower, StanBounceHeight) == 0x000670, "Member 'AEnemyTower::StanBounceHeight' has a wrong offset!");
static_assert(offsetof(AEnemyTower, StanRefloatingTime) == 0x000674, "Member 'AEnemyTower::StanRefloatingTime' has a wrong offset!");
static_assert(offsetof(AEnemyTower, StanBounceCurve) == 0x000678, "Member 'AEnemyTower::StanBounceCurve' has a wrong offset!");
static_assert(offsetof(AEnemyTower, AttackReadySound) == 0x000680, "Member 'AEnemyTower::AttackReadySound' has a wrong offset!");
static_assert(offsetof(AEnemyTower, LandSound) == 0x000688, "Member 'AEnemyTower::LandSound' has a wrong offset!");
static_assert(offsetof(AEnemyTower, DamageSound) == 0x000690, "Member 'AEnemyTower::DamageSound' has a wrong offset!");
static_assert(offsetof(AEnemyTower, AnimInstance) == 0x000698, "Member 'AEnemyTower::AnimInstance' has a wrong offset!");

// Class UnionRun.EnemyTrex
// 0x0178 (0x0730 - 0x05B8)
class alignas(0x10) AEnemyTrex final : public AUnionEnemyBase
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionSkeletalMeshComponent*            SkeletalMeshComponent;                             // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableHudAttackInfo;                              // 0x05C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C9[0x3];                                      // 0x05C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TremorHighDistance;                                // 0x05CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TremorMiddleDistance;                              // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TremorLowDistance;                                 // 0x05D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnStartRate;                                     // 0x05D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5DC[0x4];                                      // 0x05DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           DamageMontage;                                     // 0x05E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnIsValid;                                      // 0x05E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTurnEnd;                                        // 0x05E9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTurnReady;                                      // 0x05EA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5EB[0x1];                                      // 0x05EB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnValidStartTime;                                // 0x05EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnValidTime;                                     // 0x05F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnEndTime;                                       // 0x05F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticBodyComponent*                   LeftFootStaticBodyComponent;                       // 0x0600(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticBodyComponent*                   RightFootStaticBodyComponent;                      // 0x0608(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticBodyComponent*                   HeadStaticBodyComponent;                           // 0x0610(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticBodyComponent*                   Tail01StaticBodyComponent;                         // 0x0618(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticBodyComponent*                   Tail02StaticBodyComponent;                         // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticBodyComponent*                   Body01StaticBodyComponent;                         // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AItemBoxObject*>                 LinkItemBoxArray;                                  // 0x0630(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class AVATBreakObjectBase*>            LinkBreakObjectArray;                              // 0x0640(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AnimSequenceMove;                                  // 0x0650(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AnimSequenceTurn;                                  // 0x0658(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AnimSequenceDamage;                                // 0x0660(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_668[0x50];                                     // 0x0668(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UTrexAnimInstance*                      AnimInstance;                                      // 0x06B8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C0[0x70];                                     // 0x06C0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTremorEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyTrex">();
	}
	static class AEnemyTrex* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyTrex>();
	}
};
static_assert(alignof(AEnemyTrex) == 0x000010, "Wrong alignment on AEnemyTrex");
static_assert(sizeof(AEnemyTrex) == 0x000730, "Wrong size on AEnemyTrex");
static_assert(offsetof(AEnemyTrex, SkeletalMeshComponent) == 0x0005C0, "Member 'AEnemyTrex::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyTrex, bEnableHudAttackInfo) == 0x0005C8, "Member 'AEnemyTrex::bEnableHudAttackInfo' has a wrong offset!");
static_assert(offsetof(AEnemyTrex, TremorHighDistance) == 0x0005CC, "Member 'AEnemyTrex::TremorHighDistance' has a wrong offset!");
static_assert(offsetof(AEnemyTrex, TremorMiddleDistance) == 0x0005D0, "Member 'AEnemyTrex::TremorMiddleDistance' has a wrong offset!");
static_assert(offsetof(AEnemyTrex, TremorLowDistance) == 0x0005D4, "Member 'AEnemyTrex::TremorLowDistance' has a wrong offset!");
static_assert(offsetof(AEnemyTrex, TurnStartRate) == 0x0005D8, "Member 'AEnemyTrex::TurnStartRate' has a wrong offset!");
static_assert(offsetof(AEnemyTrex, DamageMontage) == 0x0005E0, "Member 'AEnemyTrex::DamageMontage' has a wrong offset!");
static_assert(offsetof(AEnemyTrex, bTurnIsValid) == 0x0005E8, "Member 'AEnemyTrex::bTurnIsValid' has a wrong offset!");
static_assert(offsetof(AEnemyTrex, bIsTurnEnd) == 0x0005E9, "Member 'AEnemyTrex::bIsTurnEnd' has a wrong offset!");
static_assert(offsetof(AEnemyTrex, bIsTurnReady) == 0x0005EA, "Member 'AEnemyTrex::bIsTurnReady' has a wrong offset!");
static_assert(offsetof(AEnemyTrex, TurnValidStartTime) == 0x0005EC, "Member 'AEnemyTrex::TurnValidStartTime' has a wrong offset!");
static_assert(offsetof(AEnemyTrex, TurnValidTime) == 0x0005F0, "Member 'AEnemyTrex::TurnValidTime' has a wrong offset!");
static_assert(offsetof(AEnemyTrex, TurnEndTime) == 0x0005F4, "Member 'AEnemyTrex::TurnEndTime' has a wrong offset!");
static_assert(offsetof(AEnemyTrex, DefaultSceneRoot) == 0x0005F8, "Member 'AEnemyTrex::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AEnemyTrex, LeftFootStaticBodyComponent) == 0x000600, "Member 'AEnemyTrex::LeftFootStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyTrex, RightFootStaticBodyComponent) == 0x000608, "Member 'AEnemyTrex::RightFootStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyTrex, HeadStaticBodyComponent) == 0x000610, "Member 'AEnemyTrex::HeadStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyTrex, Tail01StaticBodyComponent) == 0x000618, "Member 'AEnemyTrex::Tail01StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyTrex, Tail02StaticBodyComponent) == 0x000620, "Member 'AEnemyTrex::Tail02StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyTrex, Body01StaticBodyComponent) == 0x000628, "Member 'AEnemyTrex::Body01StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyTrex, LinkItemBoxArray) == 0x000630, "Member 'AEnemyTrex::LinkItemBoxArray' has a wrong offset!");
static_assert(offsetof(AEnemyTrex, LinkBreakObjectArray) == 0x000640, "Member 'AEnemyTrex::LinkBreakObjectArray' has a wrong offset!");
static_assert(offsetof(AEnemyTrex, AnimSequenceMove) == 0x000650, "Member 'AEnemyTrex::AnimSequenceMove' has a wrong offset!");
static_assert(offsetof(AEnemyTrex, AnimSequenceTurn) == 0x000658, "Member 'AEnemyTrex::AnimSequenceTurn' has a wrong offset!");
static_assert(offsetof(AEnemyTrex, AnimSequenceDamage) == 0x000660, "Member 'AEnemyTrex::AnimSequenceDamage' has a wrong offset!");
static_assert(offsetof(AEnemyTrex, AnimInstance) == 0x0006B8, "Member 'AEnemyTrex::AnimInstance' has a wrong offset!");

// Class UnionRun.EnemyTruck
// 0x00C8 (0x0680 - 0x05B8)
class alignas(0x10) AEnemyTruck final : public AUnionEnemyBase
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DisaapearEffectPlayRate;                           // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TruckAnimationPlayRate;                            // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStaticMesh*>                    TruckMeshList;                                     // 0x05C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              m_MainMeshComponent;                               // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_explosionEffect;                                 // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_appearEffect;                                    // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_disappearEffect;                                 // 0x05F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_moveSound;                                       // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_explosionSound;                                  // 0x0600(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            m_MainStaticBodyComponent;                         // 0x0608(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            m_RoofStaticBodyComponent;                         // 0x0610(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_618[0x68];                                     // 0x0618(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayMoveSound();
	void OnStopMoveSound();
	void OnUpdateMoveSoundLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyTruck">();
	}
	static class AEnemyTruck* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyTruck>();
	}
};
static_assert(alignof(AEnemyTruck) == 0x000010, "Wrong alignment on AEnemyTruck");
static_assert(sizeof(AEnemyTruck) == 0x000680, "Wrong size on AEnemyTruck");
static_assert(offsetof(AEnemyTruck, DisaapearEffectPlayRate) == 0x0005C0, "Member 'AEnemyTruck::DisaapearEffectPlayRate' has a wrong offset!");
static_assert(offsetof(AEnemyTruck, TruckAnimationPlayRate) == 0x0005C4, "Member 'AEnemyTruck::TruckAnimationPlayRate' has a wrong offset!");
static_assert(offsetof(AEnemyTruck, TruckMeshList) == 0x0005C8, "Member 'AEnemyTruck::TruckMeshList' has a wrong offset!");
static_assert(offsetof(AEnemyTruck, m_MainMeshComponent) == 0x0005D8, "Member 'AEnemyTruck::m_MainMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemyTruck, m_explosionEffect) == 0x0005E0, "Member 'AEnemyTruck::m_explosionEffect' has a wrong offset!");
static_assert(offsetof(AEnemyTruck, m_appearEffect) == 0x0005E8, "Member 'AEnemyTruck::m_appearEffect' has a wrong offset!");
static_assert(offsetof(AEnemyTruck, m_disappearEffect) == 0x0005F0, "Member 'AEnemyTruck::m_disappearEffect' has a wrong offset!");
static_assert(offsetof(AEnemyTruck, m_moveSound) == 0x0005F8, "Member 'AEnemyTruck::m_moveSound' has a wrong offset!");
static_assert(offsetof(AEnemyTruck, m_explosionSound) == 0x000600, "Member 'AEnemyTruck::m_explosionSound' has a wrong offset!");
static_assert(offsetof(AEnemyTruck, m_MainStaticBodyComponent) == 0x000608, "Member 'AEnemyTruck::m_MainStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemyTruck, m_RoofStaticBodyComponent) == 0x000610, "Member 'AEnemyTruck::m_RoofStaticBodyComponent' has a wrong offset!");

// Class UnionRun.GimmickDonutHoop
// 0x0280 (0x0830 - 0x05B0)
class alignas(0x10) AGimmickDonutHoop final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        m_Root;                                            // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              m_donutMesh;                                       // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            m_body1;                                           // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            m_body2;                                           // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            m_body3;                                           // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            m_body4;                                           // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            m_body5;                                           // 0x05E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            m_body6;                                           // 0x05F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              m_hookMesh;                                        // 0x05F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_hitSound;                                        // 0x0600(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERacerDamageType                              m_damageType;                                      // 0x0608(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_609[0x3];                                      // 0x0609(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_disappearTime;                                   // 0x060C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_fallSpeed;                                       // 0x0610(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_blowawayRatio;                                   // 0x0614(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_blowawayRotateRatioPitch;                        // 0x0618(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_blowawayRotateRatioYaw;                          // 0x061C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                m_centerObjectPoint;                               // 0x0620(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AItemBoxObject>             m_centerItemBoxReference;                          // 0x0638(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APackageRingObject>         m_centerPackageRingReference;                      // 0x0640(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_isPhysicsHook;                                   // 0x0648(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_649[0x3];                                      // 0x0649(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         m_hookRollSpeedRatio;                              // 0x064C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_hookRollAmplitudeRatio;                          // 0x0650(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_hookRollDampRatio;                               // 0x0654(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_658[0x158];                                    // 0x0658(0x0158)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 m_spawnedCenterObj;                                // 0x07B0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7B8[0x78];                                     // 0x07B8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickDonutHoop">();
	}
	static class AGimmickDonutHoop* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickDonutHoop>();
	}
};
static_assert(alignof(AGimmickDonutHoop) == 0x000010, "Wrong alignment on AGimmickDonutHoop");
static_assert(sizeof(AGimmickDonutHoop) == 0x000830, "Wrong size on AGimmickDonutHoop");
static_assert(offsetof(AGimmickDonutHoop, m_Root) == 0x0005B8, "Member 'AGimmickDonutHoop::m_Root' has a wrong offset!");
static_assert(offsetof(AGimmickDonutHoop, m_donutMesh) == 0x0005C0, "Member 'AGimmickDonutHoop::m_donutMesh' has a wrong offset!");
static_assert(offsetof(AGimmickDonutHoop, m_body1) == 0x0005C8, "Member 'AGimmickDonutHoop::m_body1' has a wrong offset!");
static_assert(offsetof(AGimmickDonutHoop, m_body2) == 0x0005D0, "Member 'AGimmickDonutHoop::m_body2' has a wrong offset!");
static_assert(offsetof(AGimmickDonutHoop, m_body3) == 0x0005D8, "Member 'AGimmickDonutHoop::m_body3' has a wrong offset!");
static_assert(offsetof(AGimmickDonutHoop, m_body4) == 0x0005E0, "Member 'AGimmickDonutHoop::m_body4' has a wrong offset!");
static_assert(offsetof(AGimmickDonutHoop, m_body5) == 0x0005E8, "Member 'AGimmickDonutHoop::m_body5' has a wrong offset!");
static_assert(offsetof(AGimmickDonutHoop, m_body6) == 0x0005F0, "Member 'AGimmickDonutHoop::m_body6' has a wrong offset!");
static_assert(offsetof(AGimmickDonutHoop, m_hookMesh) == 0x0005F8, "Member 'AGimmickDonutHoop::m_hookMesh' has a wrong offset!");
static_assert(offsetof(AGimmickDonutHoop, m_hitSound) == 0x000600, "Member 'AGimmickDonutHoop::m_hitSound' has a wrong offset!");
static_assert(offsetof(AGimmickDonutHoop, m_damageType) == 0x000608, "Member 'AGimmickDonutHoop::m_damageType' has a wrong offset!");
static_assert(offsetof(AGimmickDonutHoop, m_disappearTime) == 0x00060C, "Member 'AGimmickDonutHoop::m_disappearTime' has a wrong offset!");
static_assert(offsetof(AGimmickDonutHoop, m_fallSpeed) == 0x000610, "Member 'AGimmickDonutHoop::m_fallSpeed' has a wrong offset!");
static_assert(offsetof(AGimmickDonutHoop, m_blowawayRatio) == 0x000614, "Member 'AGimmickDonutHoop::m_blowawayRatio' has a wrong offset!");
static_assert(offsetof(AGimmickDonutHoop, m_blowawayRotateRatioPitch) == 0x000618, "Member 'AGimmickDonutHoop::m_blowawayRotateRatioPitch' has a wrong offset!");
static_assert(offsetof(AGimmickDonutHoop, m_blowawayRotateRatioYaw) == 0x00061C, "Member 'AGimmickDonutHoop::m_blowawayRotateRatioYaw' has a wrong offset!");
static_assert(offsetof(AGimmickDonutHoop, m_centerObjectPoint) == 0x000620, "Member 'AGimmickDonutHoop::m_centerObjectPoint' has a wrong offset!");
static_assert(offsetof(AGimmickDonutHoop, m_centerItemBoxReference) == 0x000638, "Member 'AGimmickDonutHoop::m_centerItemBoxReference' has a wrong offset!");
static_assert(offsetof(AGimmickDonutHoop, m_centerPackageRingReference) == 0x000640, "Member 'AGimmickDonutHoop::m_centerPackageRingReference' has a wrong offset!");
static_assert(offsetof(AGimmickDonutHoop, m_isPhysicsHook) == 0x000648, "Member 'AGimmickDonutHoop::m_isPhysicsHook' has a wrong offset!");
static_assert(offsetof(AGimmickDonutHoop, m_hookRollSpeedRatio) == 0x00064C, "Member 'AGimmickDonutHoop::m_hookRollSpeedRatio' has a wrong offset!");
static_assert(offsetof(AGimmickDonutHoop, m_hookRollAmplitudeRatio) == 0x000650, "Member 'AGimmickDonutHoop::m_hookRollAmplitudeRatio' has a wrong offset!");
static_assert(offsetof(AGimmickDonutHoop, m_hookRollDampRatio) == 0x000654, "Member 'AGimmickDonutHoop::m_hookRollDampRatio' has a wrong offset!");
static_assert(offsetof(AGimmickDonutHoop, m_spawnedCenterObj) == 0x0007B0, "Member 'AGimmickDonutHoop::m_spawnedCenterObj' has a wrong offset!");

// Class UnionRun.Enemy_Extnd04_Enemy04001
// 0x0168 (0x0720 - 0x05B8)
class alignas(0x10) AEnemy_Extnd04_Enemy04001 final : public AUnionEnemyBase
{
public:
	class UUnionSkeletalMeshComponent*            Mesh;                                              // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            Body;                                              // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    ShootSound;                                        // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ToAttackPathTransferTime;                          // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackMoveSpeed_KPH;                               // 0x05D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 AttackPointIndex;                                  // 0x05D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         AttackReadyTime;                                   // 0x05E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CalcRotateTime;                                    // 0x05EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackTime;                                        // 0x05F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F4[0x4];                                      // 0x05F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               AttackMoveRotOffset;                               // 0x05F8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                BulletOffset;                                      // 0x0610(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AEnemy_Extnd04_Enemy04001Bullet*> BulletArray;                                      // 0x0628(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class AUnionSplineActor*                      AttackSplineActor;                                 // 0x0638(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEnemy_Extnd04_Enemy04001Anim*          AnimInstance;                                      // 0x0640(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionSplineComponent*                  AttackSpline;                                      // 0x0648(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_650[0xD0];                                     // 0x0650(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Enemy_Extnd04_Enemy04001">();
	}
	static class AEnemy_Extnd04_Enemy04001* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemy_Extnd04_Enemy04001>();
	}
};
static_assert(alignof(AEnemy_Extnd04_Enemy04001) == 0x000010, "Wrong alignment on AEnemy_Extnd04_Enemy04001");
static_assert(sizeof(AEnemy_Extnd04_Enemy04001) == 0x000720, "Wrong size on AEnemy_Extnd04_Enemy04001");
static_assert(offsetof(AEnemy_Extnd04_Enemy04001, Mesh) == 0x0005B8, "Member 'AEnemy_Extnd04_Enemy04001::Mesh' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd04_Enemy04001, Body) == 0x0005C0, "Member 'AEnemy_Extnd04_Enemy04001::Body' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd04_Enemy04001, ShootSound) == 0x0005C8, "Member 'AEnemy_Extnd04_Enemy04001::ShootSound' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd04_Enemy04001, ToAttackPathTransferTime) == 0x0005D0, "Member 'AEnemy_Extnd04_Enemy04001::ToAttackPathTransferTime' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd04_Enemy04001, AttackMoveSpeed_KPH) == 0x0005D4, "Member 'AEnemy_Extnd04_Enemy04001::AttackMoveSpeed_KPH' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd04_Enemy04001, AttackPointIndex) == 0x0005D8, "Member 'AEnemy_Extnd04_Enemy04001::AttackPointIndex' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd04_Enemy04001, AttackReadyTime) == 0x0005E8, "Member 'AEnemy_Extnd04_Enemy04001::AttackReadyTime' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd04_Enemy04001, CalcRotateTime) == 0x0005EC, "Member 'AEnemy_Extnd04_Enemy04001::CalcRotateTime' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd04_Enemy04001, AttackTime) == 0x0005F0, "Member 'AEnemy_Extnd04_Enemy04001::AttackTime' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd04_Enemy04001, AttackMoveRotOffset) == 0x0005F8, "Member 'AEnemy_Extnd04_Enemy04001::AttackMoveRotOffset' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd04_Enemy04001, BulletOffset) == 0x000610, "Member 'AEnemy_Extnd04_Enemy04001::BulletOffset' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd04_Enemy04001, BulletArray) == 0x000628, "Member 'AEnemy_Extnd04_Enemy04001::BulletArray' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd04_Enemy04001, AttackSplineActor) == 0x000638, "Member 'AEnemy_Extnd04_Enemy04001::AttackSplineActor' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd04_Enemy04001, AnimInstance) == 0x000640, "Member 'AEnemy_Extnd04_Enemy04001::AnimInstance' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd04_Enemy04001, AttackSpline) == 0x000648, "Member 'AEnemy_Extnd04_Enemy04001::AttackSpline' has a wrong offset!");

// Class UnionRun.Enemy_Extnd04_Enemy04001Anim
// 0x0000 (0x0370 - 0x0370)
class UEnemy_Extnd04_Enemy04001Anim final : public UEnemyAnimInstance
{
public:
	void OnEnterWait();

	bool IsAnimState(EEnemy04001State State) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Enemy_Extnd04_Enemy04001Anim">();
	}
	static class UEnemy_Extnd04_Enemy04001Anim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemy_Extnd04_Enemy04001Anim>();
	}
};
static_assert(alignof(UEnemy_Extnd04_Enemy04001Anim) == 0x000010, "Wrong alignment on UEnemy_Extnd04_Enemy04001Anim");
static_assert(sizeof(UEnemy_Extnd04_Enemy04001Anim) == 0x000370, "Wrong size on UEnemy_Extnd04_Enemy04001Anim");

// Class UnionRun.Enemy_Extnd04_Enemy04001Bullet
// 0x0070 (0x0620 - 0x05B0)
class alignas(0x10) AEnemy_Extnd04_Enemy04001Bullet final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionVATAnimEventComponent*            VATMesh;                                           // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            Body;                                              // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    BreakSound;                                        // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERacerDamageType                              DamageType;                                        // 0x05D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D1[0x3];                                      // 0x05D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveSpeed_KPH;                                     // 0x05D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveStopDistance;                                  // 0x05D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5DC[0x4];                                      // 0x05DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               MoveRotOffset;                                     // 0x05E0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F8[0x28];                                     // 0x05F8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Enemy_Extnd04_Enemy04001Bullet">();
	}
	static class AEnemy_Extnd04_Enemy04001Bullet* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemy_Extnd04_Enemy04001Bullet>();
	}
};
static_assert(alignof(AEnemy_Extnd04_Enemy04001Bullet) == 0x000010, "Wrong alignment on AEnemy_Extnd04_Enemy04001Bullet");
static_assert(sizeof(AEnemy_Extnd04_Enemy04001Bullet) == 0x000620, "Wrong size on AEnemy_Extnd04_Enemy04001Bullet");
static_assert(offsetof(AEnemy_Extnd04_Enemy04001Bullet, VATMesh) == 0x0005B8, "Member 'AEnemy_Extnd04_Enemy04001Bullet::VATMesh' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd04_Enemy04001Bullet, Body) == 0x0005C0, "Member 'AEnemy_Extnd04_Enemy04001Bullet::Body' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd04_Enemy04001Bullet, BreakSound) == 0x0005C8, "Member 'AEnemy_Extnd04_Enemy04001Bullet::BreakSound' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd04_Enemy04001Bullet, DamageType) == 0x0005D0, "Member 'AEnemy_Extnd04_Enemy04001Bullet::DamageType' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd04_Enemy04001Bullet, MoveSpeed_KPH) == 0x0005D4, "Member 'AEnemy_Extnd04_Enemy04001Bullet::MoveSpeed_KPH' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd04_Enemy04001Bullet, MoveStopDistance) == 0x0005D8, "Member 'AEnemy_Extnd04_Enemy04001Bullet::MoveStopDistance' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd04_Enemy04001Bullet, MoveRotOffset) == 0x0005E0, "Member 'AEnemy_Extnd04_Enemy04001Bullet::MoveRotOffset' has a wrong offset!");

// Class UnionRun.GimmickPressMachine
// 0x0130 (0x06E0 - 0x05B0)
class alignas(0x10) AGimmickPressMachine final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsCourseObject;                                   // 0x05B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B9[0x7];                                      // 0x05B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              StaticMeshComponent;                               // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            WallStaticBody;                                    // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            PressStaticBody;                                   // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            JumpStaticBody1;                                   // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            JumpStaticBody2;                                   // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            JumpStaticBody3;                                   // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x05F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    LandingSound;                                      // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    SteamSound;                                        // 0x0600(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERacerDamageType                              DamageType;                                        // 0x0608(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_609[0x3];                                      // 0x0609(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxHeight;                                         // 0x060C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StartTime;                                         // 0x0610(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DownDuration;                                      // 0x0614(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PressingDuration;                                  // 0x0618(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UpDuration;                                        // 0x061C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         IdleDuration;                                      // 0x0620(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _TremorHighDistance;                               // 0x0624(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _TremorMiddleDistance;                             // 0x0628(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _TremorLowDistance;                                // 0x062C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            CameraShakeCollision;                              // 0x0630(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            CurveIdle;                                         // 0x0638(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            CurvePressing;                                     // 0x0640(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            CurveStrokeDown;                                   // 0x0648(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            CurveStrokeUp;                                     // 0x0650(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_658[0x70];                                     // 0x0658(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               LampMaterial;                                      // 0x06C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6D0[0x10];                                     // 0x06D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickPressMachine">();
	}
	static class AGimmickPressMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickPressMachine>();
	}
};
static_assert(alignof(AGimmickPressMachine) == 0x000010, "Wrong alignment on AGimmickPressMachine");
static_assert(sizeof(AGimmickPressMachine) == 0x0006E0, "Wrong size on AGimmickPressMachine");
static_assert(offsetof(AGimmickPressMachine, bIsCourseObject) == 0x0005B8, "Member 'AGimmickPressMachine::bIsCourseObject' has a wrong offset!");
static_assert(offsetof(AGimmickPressMachine, StaticMeshComponent) == 0x0005C0, "Member 'AGimmickPressMachine::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickPressMachine, WallStaticBody) == 0x0005C8, "Member 'AGimmickPressMachine::WallStaticBody' has a wrong offset!");
static_assert(offsetof(AGimmickPressMachine, PressStaticBody) == 0x0005D0, "Member 'AGimmickPressMachine::PressStaticBody' has a wrong offset!");
static_assert(offsetof(AGimmickPressMachine, JumpStaticBody1) == 0x0005D8, "Member 'AGimmickPressMachine::JumpStaticBody1' has a wrong offset!");
static_assert(offsetof(AGimmickPressMachine, JumpStaticBody2) == 0x0005E0, "Member 'AGimmickPressMachine::JumpStaticBody2' has a wrong offset!");
static_assert(offsetof(AGimmickPressMachine, JumpStaticBody3) == 0x0005E8, "Member 'AGimmickPressMachine::JumpStaticBody3' has a wrong offset!");
static_assert(offsetof(AGimmickPressMachine, NiagaraComponent) == 0x0005F0, "Member 'AGimmickPressMachine::NiagaraComponent' has a wrong offset!");
static_assert(offsetof(AGimmickPressMachine, LandingSound) == 0x0005F8, "Member 'AGimmickPressMachine::LandingSound' has a wrong offset!");
static_assert(offsetof(AGimmickPressMachine, SteamSound) == 0x000600, "Member 'AGimmickPressMachine::SteamSound' has a wrong offset!");
static_assert(offsetof(AGimmickPressMachine, DamageType) == 0x000608, "Member 'AGimmickPressMachine::DamageType' has a wrong offset!");
static_assert(offsetof(AGimmickPressMachine, MaxHeight) == 0x00060C, "Member 'AGimmickPressMachine::MaxHeight' has a wrong offset!");
static_assert(offsetof(AGimmickPressMachine, StartTime) == 0x000610, "Member 'AGimmickPressMachine::StartTime' has a wrong offset!");
static_assert(offsetof(AGimmickPressMachine, DownDuration) == 0x000614, "Member 'AGimmickPressMachine::DownDuration' has a wrong offset!");
static_assert(offsetof(AGimmickPressMachine, PressingDuration) == 0x000618, "Member 'AGimmickPressMachine::PressingDuration' has a wrong offset!");
static_assert(offsetof(AGimmickPressMachine, UpDuration) == 0x00061C, "Member 'AGimmickPressMachine::UpDuration' has a wrong offset!");
static_assert(offsetof(AGimmickPressMachine, IdleDuration) == 0x000620, "Member 'AGimmickPressMachine::IdleDuration' has a wrong offset!");
static_assert(offsetof(AGimmickPressMachine, _TremorHighDistance) == 0x000624, "Member 'AGimmickPressMachine::_TremorHighDistance' has a wrong offset!");
static_assert(offsetof(AGimmickPressMachine, _TremorMiddleDistance) == 0x000628, "Member 'AGimmickPressMachine::_TremorMiddleDistance' has a wrong offset!");
static_assert(offsetof(AGimmickPressMachine, _TremorLowDistance) == 0x00062C, "Member 'AGimmickPressMachine::_TremorLowDistance' has a wrong offset!");
static_assert(offsetof(AGimmickPressMachine, CameraShakeCollision) == 0x000630, "Member 'AGimmickPressMachine::CameraShakeCollision' has a wrong offset!");
static_assert(offsetof(AGimmickPressMachine, CurveIdle) == 0x000638, "Member 'AGimmickPressMachine::CurveIdle' has a wrong offset!");
static_assert(offsetof(AGimmickPressMachine, CurvePressing) == 0x000640, "Member 'AGimmickPressMachine::CurvePressing' has a wrong offset!");
static_assert(offsetof(AGimmickPressMachine, CurveStrokeDown) == 0x000648, "Member 'AGimmickPressMachine::CurveStrokeDown' has a wrong offset!");
static_assert(offsetof(AGimmickPressMachine, CurveStrokeUp) == 0x000650, "Member 'AGimmickPressMachine::CurveStrokeUp' has a wrong offset!");
static_assert(offsetof(AGimmickPressMachine, LampMaterial) == 0x0006C8, "Member 'AGimmickPressMachine::LampMaterial' has a wrong offset!");

// Class UnionRun.Enemy_Extnd06_Enemy06001
// 0x0178 (0x0730 - 0x05B8)
class alignas(0x10) AEnemy_Extnd06_Enemy06001 final : public AUnionEnemyBase
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EEnemy_Extnd06_Enemy06001_Type, class USkeletalMesh*> ModelByType;                          // 0x05C0(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<EEnemy_Extnd06_Enemy06001_Type, class UAnimSequence*> AnimationByType;                      // 0x0610(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<EEnemy_Extnd06_Enemy06001_Type, struct FEnemy_Extnd06_Enemy06001_Size> CollisionExtentsByType; // 0x0660(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	EEnemy_Extnd06_Enemy06001_Type                Type;                                              // 0x06B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6B1[0x3];                                      // 0x06B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotateSpeed;                                       // 0x06B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsTurnRight;                                       // 0x06B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6B9[0x3];                                      // 0x06B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxJumpHeight;                                     // 0x06BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RiseTime;                                          // 0x06C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HoverTime;                                         // 0x06C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FallTime;                                          // 0x06C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DelayTime;                                         // 0x06CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionSkeletalMeshComponent*            ModelComponent;                                    // 0x06D0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            CollisionComponent;                                // 0x06D8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6E0[0x50];                                     // 0x06E0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Enemy_Extnd06_Enemy06001">();
	}
	static class AEnemy_Extnd06_Enemy06001* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemy_Extnd06_Enemy06001>();
	}
};
static_assert(alignof(AEnemy_Extnd06_Enemy06001) == 0x000010, "Wrong alignment on AEnemy_Extnd06_Enemy06001");
static_assert(sizeof(AEnemy_Extnd06_Enemy06001) == 0x000730, "Wrong size on AEnemy_Extnd06_Enemy06001");
static_assert(offsetof(AEnemy_Extnd06_Enemy06001, ModelByType) == 0x0005C0, "Member 'AEnemy_Extnd06_Enemy06001::ModelByType' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd06_Enemy06001, AnimationByType) == 0x000610, "Member 'AEnemy_Extnd06_Enemy06001::AnimationByType' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd06_Enemy06001, CollisionExtentsByType) == 0x000660, "Member 'AEnemy_Extnd06_Enemy06001::CollisionExtentsByType' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd06_Enemy06001, Type) == 0x0006B0, "Member 'AEnemy_Extnd06_Enemy06001::Type' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd06_Enemy06001, RotateSpeed) == 0x0006B4, "Member 'AEnemy_Extnd06_Enemy06001::RotateSpeed' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd06_Enemy06001, IsTurnRight) == 0x0006B8, "Member 'AEnemy_Extnd06_Enemy06001::IsTurnRight' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd06_Enemy06001, MaxJumpHeight) == 0x0006BC, "Member 'AEnemy_Extnd06_Enemy06001::MaxJumpHeight' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd06_Enemy06001, RiseTime) == 0x0006C0, "Member 'AEnemy_Extnd06_Enemy06001::RiseTime' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd06_Enemy06001, HoverTime) == 0x0006C4, "Member 'AEnemy_Extnd06_Enemy06001::HoverTime' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd06_Enemy06001, FallTime) == 0x0006C8, "Member 'AEnemy_Extnd06_Enemy06001::FallTime' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd06_Enemy06001, DelayTime) == 0x0006CC, "Member 'AEnemy_Extnd06_Enemy06001::DelayTime' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd06_Enemy06001, ModelComponent) == 0x0006D0, "Member 'AEnemy_Extnd06_Enemy06001::ModelComponent' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd06_Enemy06001, CollisionComponent) == 0x0006D8, "Member 'AEnemy_Extnd06_Enemy06001::CollisionComponent' has a wrong offset!");

// Class UnionRun.RaceUISubGadget
// 0x0000 (0x02E0 - 0x02E0)
class URaceUISubGadget : public UUserWidget
{
public:
	bool IsNotEnableGadget(EGadgetId gadgetId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceUISubGadget">();
	}
	static class URaceUISubGadget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceUISubGadget>();
	}
};
static_assert(alignof(URaceUISubGadget) == 0x000008, "Wrong alignment on URaceUISubGadget");
static_assert(sizeof(URaceUISubGadget) == 0x0002E0, "Wrong size on URaceUISubGadget");

// Class UnionRun.GimmickGandBell
// 0x0090 (0x0640 - 0x05B0)
class alignas(0x10) AGimmickGandBell final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveTime;                                          // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5BC[0x4];                                      // 0x05BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              BodyStatickMeshComponent;                          // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionVATMeshComponent*                 BellVatMeshComponent;                              // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            MainStaticBodyComponent;                           // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    HitSoundComponent;                                 // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E0[0x60];                                     // 0x05E0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayHitAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickGandBell">();
	}
	static class AGimmickGandBell* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickGandBell>();
	}
};
static_assert(alignof(AGimmickGandBell) == 0x000010, "Wrong alignment on AGimmickGandBell");
static_assert(sizeof(AGimmickGandBell) == 0x000640, "Wrong size on AGimmickGandBell");
static_assert(offsetof(AGimmickGandBell, MoveTime) == 0x0005B8, "Member 'AGimmickGandBell::MoveTime' has a wrong offset!");
static_assert(offsetof(AGimmickGandBell, BodyStatickMeshComponent) == 0x0005C0, "Member 'AGimmickGandBell::BodyStatickMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickGandBell, BellVatMeshComponent) == 0x0005C8, "Member 'AGimmickGandBell::BellVatMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickGandBell, MainStaticBodyComponent) == 0x0005D0, "Member 'AGimmickGandBell::MainStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickGandBell, HitSoundComponent) == 0x0005D8, "Member 'AGimmickGandBell::HitSoundComponent' has a wrong offset!");

// Class UnionRun.Enemy_Extnd06_Object_06001
// 0x01F8 (0x07B0 - 0x05B8)
class alignas(0x10) AEnemy_Extnd06_Object_06001 final : public AUnionEnemyBase
{
public:
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EEnemy_Extnd06_Object_06001_Type, class USkeletalMesh*> ModelByType;                        // 0x05C0(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<EEnemy_Extnd06_Object_06001_Type, class UStaticMesh*> ModelForAbsorbedByType;               // 0x0610(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<EEnemy_Extnd06_Object_06001_Type, struct FEnemy_Extnd06_Object_06001_Size> CollisionExtentsByType; // 0x0660(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<EEnemy_Extnd06_Object_06001_Type, TSubclassOf<class UEnemy_Extnd06_Object_06001_Anim>> AnimationByType; // 0x06B0(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	EEnemy_Extnd06_Object_06001_Type              Type;                                              // 0x0700(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_701[0x3];                                      // 0x0701(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotateSpeed;                                       // 0x0704(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsTurnRight;                                       // 0x0708(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_709[0x3];                                      // 0x0709(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AbsorbTargetScale;                                 // 0x070C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FieldOfViewDegree;                                 // 0x0710(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FieldOfViewLength;                                 // 0x0714(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FieldOfViewHeight;                                 // 0x0718(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_71C[0x4];                                      // 0x071C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FieldOfViewOffset;                                 // 0x0720(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionSkeletalMeshComponent*            ModelComponent;                                    // 0x0738(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            CollisionComponent;                                // 0x0740(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTriggerComponent*                      SensorComponent;                                   // 0x0748(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEnemy_Extnd06_Object_06001_Anim*       AnimInstance;                                      // 0x0750(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_758[0x58];                                     // 0x0758(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTriggerColliderConflict(const struct FHitTriggerInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Enemy_Extnd06_Object_06001">();
	}
	static class AEnemy_Extnd06_Object_06001* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemy_Extnd06_Object_06001>();
	}
};
static_assert(alignof(AEnemy_Extnd06_Object_06001) == 0x000010, "Wrong alignment on AEnemy_Extnd06_Object_06001");
static_assert(sizeof(AEnemy_Extnd06_Object_06001) == 0x0007B0, "Wrong size on AEnemy_Extnd06_Object_06001");
static_assert(offsetof(AEnemy_Extnd06_Object_06001, ModelByType) == 0x0005C0, "Member 'AEnemy_Extnd06_Object_06001::ModelByType' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd06_Object_06001, ModelForAbsorbedByType) == 0x000610, "Member 'AEnemy_Extnd06_Object_06001::ModelForAbsorbedByType' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd06_Object_06001, CollisionExtentsByType) == 0x000660, "Member 'AEnemy_Extnd06_Object_06001::CollisionExtentsByType' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd06_Object_06001, AnimationByType) == 0x0006B0, "Member 'AEnemy_Extnd06_Object_06001::AnimationByType' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd06_Object_06001, Type) == 0x000700, "Member 'AEnemy_Extnd06_Object_06001::Type' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd06_Object_06001, RotateSpeed) == 0x000704, "Member 'AEnemy_Extnd06_Object_06001::RotateSpeed' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd06_Object_06001, IsTurnRight) == 0x000708, "Member 'AEnemy_Extnd06_Object_06001::IsTurnRight' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd06_Object_06001, AbsorbTargetScale) == 0x00070C, "Member 'AEnemy_Extnd06_Object_06001::AbsorbTargetScale' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd06_Object_06001, FieldOfViewDegree) == 0x000710, "Member 'AEnemy_Extnd06_Object_06001::FieldOfViewDegree' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd06_Object_06001, FieldOfViewLength) == 0x000714, "Member 'AEnemy_Extnd06_Object_06001::FieldOfViewLength' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd06_Object_06001, FieldOfViewHeight) == 0x000718, "Member 'AEnemy_Extnd06_Object_06001::FieldOfViewHeight' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd06_Object_06001, FieldOfViewOffset) == 0x000720, "Member 'AEnemy_Extnd06_Object_06001::FieldOfViewOffset' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd06_Object_06001, ModelComponent) == 0x000738, "Member 'AEnemy_Extnd06_Object_06001::ModelComponent' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd06_Object_06001, CollisionComponent) == 0x000740, "Member 'AEnemy_Extnd06_Object_06001::CollisionComponent' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd06_Object_06001, SensorComponent) == 0x000748, "Member 'AEnemy_Extnd06_Object_06001::SensorComponent' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd06_Object_06001, AnimInstance) == 0x000750, "Member 'AEnemy_Extnd06_Object_06001::AnimInstance' has a wrong offset!");

// Class UnionRun.OneDirectionActor
// 0x0080 (0x0310 - 0x0290)
class AOneDirectionActor final : public AActor
{
public:
	class USceneComponent*                        MeshRoot;                                          // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHierarchicalInstancedStaticMeshComponent* InstancedMesh;                                  // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PointStart;                                        // 0x02A0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PointEnd;                                          // 0x02B8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrowInterval;                                     // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ArrowScale;                                        // 0x02D8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F0[0x20];                                     // 0x02F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OneDirectionActor">();
	}
	static class AOneDirectionActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOneDirectionActor>();
	}
};
static_assert(alignof(AOneDirectionActor) == 0x000008, "Wrong alignment on AOneDirectionActor");
static_assert(sizeof(AOneDirectionActor) == 0x000310, "Wrong size on AOneDirectionActor");
static_assert(offsetof(AOneDirectionActor, MeshRoot) == 0x000290, "Member 'AOneDirectionActor::MeshRoot' has a wrong offset!");
static_assert(offsetof(AOneDirectionActor, InstancedMesh) == 0x000298, "Member 'AOneDirectionActor::InstancedMesh' has a wrong offset!");
static_assert(offsetof(AOneDirectionActor, PointStart) == 0x0002A0, "Member 'AOneDirectionActor::PointStart' has a wrong offset!");
static_assert(offsetof(AOneDirectionActor, PointEnd) == 0x0002B8, "Member 'AOneDirectionActor::PointEnd' has a wrong offset!");
static_assert(offsetof(AOneDirectionActor, ArrowInterval) == 0x0002D0, "Member 'AOneDirectionActor::ArrowInterval' has a wrong offset!");
static_assert(offsetof(AOneDirectionActor, ArrowScale) == 0x0002D8, "Member 'AOneDirectionActor::ArrowScale' has a wrong offset!");

// Class UnionRun.Enemy_Extnd06_Object_06001_Anim
// 0x0000 (0x0370 - 0x0370)
class UEnemy_Extnd06_Object_06001_Anim final : public UEnemyAnimInstance
{
public:
	bool                                          IsChaseMode;                                       // 0x0368(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_369[0x7];                                      // 0x0369(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Enemy_Extnd06_Object_06001_Anim">();
	}
	static class UEnemy_Extnd06_Object_06001_Anim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemy_Extnd06_Object_06001_Anim>();
	}
};
static_assert(alignof(UEnemy_Extnd06_Object_06001_Anim) == 0x000010, "Wrong alignment on UEnemy_Extnd06_Object_06001_Anim");
static_assert(sizeof(UEnemy_Extnd06_Object_06001_Anim) == 0x000370, "Wrong size on UEnemy_Extnd06_Object_06001_Anim");
static_assert(offsetof(UEnemy_Extnd06_Object_06001_Anim, IsChaseMode) == 0x000368, "Member 'UEnemy_Extnd06_Object_06001_Anim::IsChaseMode' has a wrong offset!");

// Class UnionRun.Enemy_Extnd09_Enemy09001_Attack
// 0x00B0 (0x0660 - 0x05B0)
class alignas(0x10) AEnemy_Extnd09_Enemy09001_Attack final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionSkeletalMeshComponent*            SkeletalMesh;                                      // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGimmickStaticBodyComponent*            BodyStaticBody;                                    // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionAtomComponent*                    ShotSound;                                         // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      ShotEffect;                                        // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AEnemy_Extnd09_Enemy09001_Shot*> ShotObjects;                                       // 0x05D8(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         Interval;                                          // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShotSpan;                                          // 0x05EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxShotNum;                                        // 0x05F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageDuration;                                    // 0x05F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AddRingCount;                                      // 0x05F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5FC[0x64];                                     // 0x05FC(0x0064)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsAttacking() const;
	bool IsDamaged() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Enemy_Extnd09_Enemy09001_Attack">();
	}
	static class AEnemy_Extnd09_Enemy09001_Attack* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemy_Extnd09_Enemy09001_Attack>();
	}
};
static_assert(alignof(AEnemy_Extnd09_Enemy09001_Attack) == 0x000010, "Wrong alignment on AEnemy_Extnd09_Enemy09001_Attack");
static_assert(sizeof(AEnemy_Extnd09_Enemy09001_Attack) == 0x000660, "Wrong size on AEnemy_Extnd09_Enemy09001_Attack");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Attack, SkeletalMesh) == 0x0005B8, "Member 'AEnemy_Extnd09_Enemy09001_Attack::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Attack, BodyStaticBody) == 0x0005C0, "Member 'AEnemy_Extnd09_Enemy09001_Attack::BodyStaticBody' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Attack, ShotSound) == 0x0005C8, "Member 'AEnemy_Extnd09_Enemy09001_Attack::ShotSound' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Attack, ShotEffect) == 0x0005D0, "Member 'AEnemy_Extnd09_Enemy09001_Attack::ShotEffect' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Attack, ShotObjects) == 0x0005D8, "Member 'AEnemy_Extnd09_Enemy09001_Attack::ShotObjects' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Attack, Interval) == 0x0005E8, "Member 'AEnemy_Extnd09_Enemy09001_Attack::Interval' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Attack, ShotSpan) == 0x0005EC, "Member 'AEnemy_Extnd09_Enemy09001_Attack::ShotSpan' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Attack, MaxShotNum) == 0x0005F0, "Member 'AEnemy_Extnd09_Enemy09001_Attack::MaxShotNum' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Attack, DamageDuration) == 0x0005F4, "Member 'AEnemy_Extnd09_Enemy09001_Attack::DamageDuration' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Attack, AddRingCount) == 0x0005F8, "Member 'AEnemy_Extnd09_Enemy09001_Attack::AddRingCount' has a wrong offset!");

// Class UnionRun.Enemy_Extnd09_Enemy09001_Move
// 0x02F0 (0x08A0 - 0x05B0)
class alignas(0x10) AEnemy_Extnd09_Enemy09001_Move final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionSkeletalMeshComponent*            SkeletalMesh;                                      // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionSkeletalMeshComponent*            SkeletalMesh_Marking;                              // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGimmickStaticBodyComponent*            BodyStaticBody;                                    // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionAtomComponent*                    MoveStartSound;                                    // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionAtomComponent*                    MoveEndSound;                                      // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      MoveStartEffect;                                   // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      MoveEndEffect;                                     // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IntervalTime;                                      // 0x05F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PartsMoveDuration;                                 // 0x05F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PartsMoveSpan;                                     // 0x05F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ModelHeight;                                       // 0x05FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        OffsetGrid;                                        // 0x0600(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         AddRingCount;                                      // 0x0610(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_614[0x6C];                                     // 0x0614(0x006C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUnionStaticMeshComponent*>      BodyParts;                                         // 0x0680(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_690[0xC8];                                     // 0x0690(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	class UGimmickStaticBodyComponent*            PartsStaticBody0;                                  // 0x0758(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGimmickStaticBodyComponent*            PartsStaticBody1;                                  // 0x0760(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGimmickStaticBodyComponent*            PartsStaticBody2;                                  // 0x0768(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGimmickStaticBodyComponent*            PartsStaticBody3;                                  // 0x0770(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGimmickStaticBodyComponent*            PartsStaticBody4;                                  // 0x0778(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGimmickStaticBodyComponent*>    PartsStaticBodies;                                 // 0x0780(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              PartsStaticMesh0;                                  // 0x0790(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              PartsStaticMesh1;                                  // 0x0798(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              PartsStaticMesh2;                                  // 0x07A0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              PartsStaticMesh3;                                  // 0x07A8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              PartsStaticMesh4;                                  // 0x07B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUnionStaticMeshComponent*>      PartsStaticMeshes;                                 // 0x07B8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      PartsEffect0;                                      // 0x07C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      PartsEffect1;                                      // 0x07D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      PartsEffect2;                                      // 0x07D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      PartsEffect3;                                      // 0x07E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      PartsEffect4;                                      // 0x07E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UNiagaraComponent*>              PartsEffects;                                      // 0x07F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              BodyParts0;                                        // 0x0800(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              BodyParts1;                                        // 0x0808(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              BodyParts2;                                        // 0x0810(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              BodyParts3;                                        // 0x0818(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              BodyParts4;                                        // 0x0820(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              BodyParts5;                                        // 0x0828(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              BodyParts6;                                        // 0x0830(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              BodyParts7;                                        // 0x0838(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              BodyParts8;                                        // 0x0840(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              BodyParts9;                                        // 0x0848(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              BodyParts10;                                       // 0x0850(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              BodyParts11;                                       // 0x0858(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              BodyParts12;                                       // 0x0860(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              BodyParts13;                                       // 0x0868(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              BodyParts14;                                       // 0x0870(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              BodyParts15;                                       // 0x0878(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              BodyParts16;                                       // 0x0880(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              BodyParts17;                                       // 0x0888(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              BodyParts18;                                       // 0x0890(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              BodyParts19;                                       // 0x0898(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Enemy_Extnd09_Enemy09001_Move">();
	}
	static class AEnemy_Extnd09_Enemy09001_Move* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemy_Extnd09_Enemy09001_Move>();
	}
};
static_assert(alignof(AEnemy_Extnd09_Enemy09001_Move) == 0x000010, "Wrong alignment on AEnemy_Extnd09_Enemy09001_Move");
static_assert(sizeof(AEnemy_Extnd09_Enemy09001_Move) == 0x0008A0, "Wrong size on AEnemy_Extnd09_Enemy09001_Move");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, SkeletalMesh) == 0x0005B8, "Member 'AEnemy_Extnd09_Enemy09001_Move::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, SkeletalMesh_Marking) == 0x0005C0, "Member 'AEnemy_Extnd09_Enemy09001_Move::SkeletalMesh_Marking' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, BodyStaticBody) == 0x0005C8, "Member 'AEnemy_Extnd09_Enemy09001_Move::BodyStaticBody' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, MoveStartSound) == 0x0005D0, "Member 'AEnemy_Extnd09_Enemy09001_Move::MoveStartSound' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, MoveEndSound) == 0x0005D8, "Member 'AEnemy_Extnd09_Enemy09001_Move::MoveEndSound' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, MoveStartEffect) == 0x0005E0, "Member 'AEnemy_Extnd09_Enemy09001_Move::MoveStartEffect' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, MoveEndEffect) == 0x0005E8, "Member 'AEnemy_Extnd09_Enemy09001_Move::MoveEndEffect' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, IntervalTime) == 0x0005F0, "Member 'AEnemy_Extnd09_Enemy09001_Move::IntervalTime' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, PartsMoveDuration) == 0x0005F4, "Member 'AEnemy_Extnd09_Enemy09001_Move::PartsMoveDuration' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, PartsMoveSpan) == 0x0005F8, "Member 'AEnemy_Extnd09_Enemy09001_Move::PartsMoveSpan' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, ModelHeight) == 0x0005FC, "Member 'AEnemy_Extnd09_Enemy09001_Move::ModelHeight' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, OffsetGrid) == 0x000600, "Member 'AEnemy_Extnd09_Enemy09001_Move::OffsetGrid' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, AddRingCount) == 0x000610, "Member 'AEnemy_Extnd09_Enemy09001_Move::AddRingCount' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, BodyParts) == 0x000680, "Member 'AEnemy_Extnd09_Enemy09001_Move::BodyParts' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, PartsStaticBody0) == 0x000758, "Member 'AEnemy_Extnd09_Enemy09001_Move::PartsStaticBody0' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, PartsStaticBody1) == 0x000760, "Member 'AEnemy_Extnd09_Enemy09001_Move::PartsStaticBody1' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, PartsStaticBody2) == 0x000768, "Member 'AEnemy_Extnd09_Enemy09001_Move::PartsStaticBody2' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, PartsStaticBody3) == 0x000770, "Member 'AEnemy_Extnd09_Enemy09001_Move::PartsStaticBody3' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, PartsStaticBody4) == 0x000778, "Member 'AEnemy_Extnd09_Enemy09001_Move::PartsStaticBody4' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, PartsStaticBodies) == 0x000780, "Member 'AEnemy_Extnd09_Enemy09001_Move::PartsStaticBodies' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, PartsStaticMesh0) == 0x000790, "Member 'AEnemy_Extnd09_Enemy09001_Move::PartsStaticMesh0' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, PartsStaticMesh1) == 0x000798, "Member 'AEnemy_Extnd09_Enemy09001_Move::PartsStaticMesh1' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, PartsStaticMesh2) == 0x0007A0, "Member 'AEnemy_Extnd09_Enemy09001_Move::PartsStaticMesh2' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, PartsStaticMesh3) == 0x0007A8, "Member 'AEnemy_Extnd09_Enemy09001_Move::PartsStaticMesh3' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, PartsStaticMesh4) == 0x0007B0, "Member 'AEnemy_Extnd09_Enemy09001_Move::PartsStaticMesh4' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, PartsStaticMeshes) == 0x0007B8, "Member 'AEnemy_Extnd09_Enemy09001_Move::PartsStaticMeshes' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, PartsEffect0) == 0x0007C8, "Member 'AEnemy_Extnd09_Enemy09001_Move::PartsEffect0' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, PartsEffect1) == 0x0007D0, "Member 'AEnemy_Extnd09_Enemy09001_Move::PartsEffect1' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, PartsEffect2) == 0x0007D8, "Member 'AEnemy_Extnd09_Enemy09001_Move::PartsEffect2' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, PartsEffect3) == 0x0007E0, "Member 'AEnemy_Extnd09_Enemy09001_Move::PartsEffect3' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, PartsEffect4) == 0x0007E8, "Member 'AEnemy_Extnd09_Enemy09001_Move::PartsEffect4' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, PartsEffects) == 0x0007F0, "Member 'AEnemy_Extnd09_Enemy09001_Move::PartsEffects' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, BodyParts0) == 0x000800, "Member 'AEnemy_Extnd09_Enemy09001_Move::BodyParts0' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, BodyParts1) == 0x000808, "Member 'AEnemy_Extnd09_Enemy09001_Move::BodyParts1' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, BodyParts2) == 0x000810, "Member 'AEnemy_Extnd09_Enemy09001_Move::BodyParts2' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, BodyParts3) == 0x000818, "Member 'AEnemy_Extnd09_Enemy09001_Move::BodyParts3' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, BodyParts4) == 0x000820, "Member 'AEnemy_Extnd09_Enemy09001_Move::BodyParts4' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, BodyParts5) == 0x000828, "Member 'AEnemy_Extnd09_Enemy09001_Move::BodyParts5' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, BodyParts6) == 0x000830, "Member 'AEnemy_Extnd09_Enemy09001_Move::BodyParts6' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, BodyParts7) == 0x000838, "Member 'AEnemy_Extnd09_Enemy09001_Move::BodyParts7' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, BodyParts8) == 0x000840, "Member 'AEnemy_Extnd09_Enemy09001_Move::BodyParts8' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, BodyParts9) == 0x000848, "Member 'AEnemy_Extnd09_Enemy09001_Move::BodyParts9' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, BodyParts10) == 0x000850, "Member 'AEnemy_Extnd09_Enemy09001_Move::BodyParts10' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, BodyParts11) == 0x000858, "Member 'AEnemy_Extnd09_Enemy09001_Move::BodyParts11' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, BodyParts12) == 0x000860, "Member 'AEnemy_Extnd09_Enemy09001_Move::BodyParts12' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, BodyParts13) == 0x000868, "Member 'AEnemy_Extnd09_Enemy09001_Move::BodyParts13' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, BodyParts14) == 0x000870, "Member 'AEnemy_Extnd09_Enemy09001_Move::BodyParts14' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, BodyParts15) == 0x000878, "Member 'AEnemy_Extnd09_Enemy09001_Move::BodyParts15' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, BodyParts16) == 0x000880, "Member 'AEnemy_Extnd09_Enemy09001_Move::BodyParts16' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, BodyParts17) == 0x000888, "Member 'AEnemy_Extnd09_Enemy09001_Move::BodyParts17' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, BodyParts18) == 0x000890, "Member 'AEnemy_Extnd09_Enemy09001_Move::BodyParts18' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Move, BodyParts19) == 0x000898, "Member 'AEnemy_Extnd09_Enemy09001_Move::BodyParts19' has a wrong offset!");

// Class UnionRun.GimmickFireDragon
// 0x0060 (0x0610 - 0x05B0)
class alignas(0x10) AGimmickFireDragon final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionSkeletalMeshComponent*            m_skeletalMesh;                                    // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStaticBodyComponent*>           m_bodyList;                                        // 0x05C0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	ERacerDamageType                              DamageType;                                        // 0x05D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D1[0x7];                                      // 0x05D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E0[0x30];                                     // 0x05E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickFireDragon">();
	}
	static class AGimmickFireDragon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickFireDragon>();
	}
};
static_assert(alignof(AGimmickFireDragon) == 0x000010, "Wrong alignment on AGimmickFireDragon");
static_assert(sizeof(AGimmickFireDragon) == 0x000610, "Wrong size on AGimmickFireDragon");
static_assert(offsetof(AGimmickFireDragon, m_skeletalMesh) == 0x0005B8, "Member 'AGimmickFireDragon::m_skeletalMesh' has a wrong offset!");
static_assert(offsetof(AGimmickFireDragon, m_bodyList) == 0x0005C0, "Member 'AGimmickFireDragon::m_bodyList' has a wrong offset!");
static_assert(offsetof(AGimmickFireDragon, DamageType) == 0x0005D0, "Member 'AGimmickFireDragon::DamageType' has a wrong offset!");
static_assert(offsetof(AGimmickFireDragon, DefaultSceneRoot) == 0x0005D8, "Member 'AGimmickFireDragon::DefaultSceneRoot' has a wrong offset!");

// Class UnionRun.Enemy_Extnd09_Enemy09001_Shot
// 0x0080 (0x0630 - 0x05B0)
class alignas(0x10) AEnemy_Extnd09_Enemy09001_Shot final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGimmickStaticBodyComponent*            StaticBodyComponent;                               // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            MoveCurve;                                         // 0x05D0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x05D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5DC[0x54];                                     // 0x05DC(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Enemy_Extnd09_Enemy09001_Shot">();
	}
	static class AEnemy_Extnd09_Enemy09001_Shot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemy_Extnd09_Enemy09001_Shot>();
	}
};
static_assert(alignof(AEnemy_Extnd09_Enemy09001_Shot) == 0x000010, "Wrong alignment on AEnemy_Extnd09_Enemy09001_Shot");
static_assert(sizeof(AEnemy_Extnd09_Enemy09001_Shot) == 0x000630, "Wrong size on AEnemy_Extnd09_Enemy09001_Shot");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Shot, StaticBodyComponent) == 0x0005B8, "Member 'AEnemy_Extnd09_Enemy09001_Shot::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Shot, StaticMeshComponent) == 0x0005C0, "Member 'AEnemy_Extnd09_Enemy09001_Shot::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Shot, NiagaraComponent) == 0x0005C8, "Member 'AEnemy_Extnd09_Enemy09001_Shot::NiagaraComponent' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Shot, MoveCurve) == 0x0005D0, "Member 'AEnemy_Extnd09_Enemy09001_Shot::MoveCurve' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09001_Shot, Duration) == 0x0005D8, "Member 'AEnemy_Extnd09_Enemy09001_Shot::Duration' has a wrong offset!");

// Class UnionRun.Enemy_Extnd09_Enemy09002
// 0x0040 (0x05F0 - 0x05B0)
class alignas(0x10) AEnemy_Extnd09_Enemy09002 final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionSkeletalMeshComponent*            SkeletalMesh;                                      // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGimmickStaticBodyComponent*            StaticBody;                                        // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      BreakEffect;                                       // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionAtomComponent*                    BreakSound;                                        // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AddRingCount;                                      // 0x05D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefenseInterval;                                   // 0x05DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefenseDuration;                                   // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E4[0xC];                                      // 0x05E4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsDefensive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Enemy_Extnd09_Enemy09002">();
	}
	static class AEnemy_Extnd09_Enemy09002* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemy_Extnd09_Enemy09002>();
	}
};
static_assert(alignof(AEnemy_Extnd09_Enemy09002) == 0x000010, "Wrong alignment on AEnemy_Extnd09_Enemy09002");
static_assert(sizeof(AEnemy_Extnd09_Enemy09002) == 0x0005F0, "Wrong size on AEnemy_Extnd09_Enemy09002");
static_assert(offsetof(AEnemy_Extnd09_Enemy09002, SkeletalMesh) == 0x0005B8, "Member 'AEnemy_Extnd09_Enemy09002::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09002, StaticBody) == 0x0005C0, "Member 'AEnemy_Extnd09_Enemy09002::StaticBody' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09002, BreakEffect) == 0x0005C8, "Member 'AEnemy_Extnd09_Enemy09002::BreakEffect' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09002, BreakSound) == 0x0005D0, "Member 'AEnemy_Extnd09_Enemy09002::BreakSound' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09002, AddRingCount) == 0x0005D8, "Member 'AEnemy_Extnd09_Enemy09002::AddRingCount' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09002, DefenseInterval) == 0x0005DC, "Member 'AEnemy_Extnd09_Enemy09002::DefenseInterval' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09002, DefenseDuration) == 0x0005E0, "Member 'AEnemy_Extnd09_Enemy09002::DefenseDuration' has a wrong offset!");

// Class UnionRun.Enemy_Extnd09_Enemy09003
// 0x0060 (0x0610 - 0x05B0)
class alignas(0x10) AEnemy_Extnd09_Enemy09003 final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionSkeletalMeshComponent*            SkeletalMesh;                                      // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGimmickStaticBodyComponent*            StaticBody;                                        // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionAtomComponent*                    MoveSound;                                         // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionAtomComponent*                    ShotSound;                                         // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AEnemy_Extnd09_Enemy09003_Shot*         ShotObject;                                        // 0x05D8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShotSpan;                                          // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageDuration;                                    // 0x05E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AddRingCount;                                      // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5EC[0x24];                                     // 0x05EC(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Enemy_Extnd09_Enemy09003">();
	}
	static class AEnemy_Extnd09_Enemy09003* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemy_Extnd09_Enemy09003>();
	}
};
static_assert(alignof(AEnemy_Extnd09_Enemy09003) == 0x000010, "Wrong alignment on AEnemy_Extnd09_Enemy09003");
static_assert(sizeof(AEnemy_Extnd09_Enemy09003) == 0x000610, "Wrong size on AEnemy_Extnd09_Enemy09003");
static_assert(offsetof(AEnemy_Extnd09_Enemy09003, SkeletalMesh) == 0x0005B8, "Member 'AEnemy_Extnd09_Enemy09003::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09003, StaticBody) == 0x0005C0, "Member 'AEnemy_Extnd09_Enemy09003::StaticBody' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09003, MoveSound) == 0x0005C8, "Member 'AEnemy_Extnd09_Enemy09003::MoveSound' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09003, ShotSound) == 0x0005D0, "Member 'AEnemy_Extnd09_Enemy09003::ShotSound' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09003, ShotObject) == 0x0005D8, "Member 'AEnemy_Extnd09_Enemy09003::ShotObject' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09003, ShotSpan) == 0x0005E0, "Member 'AEnemy_Extnd09_Enemy09003::ShotSpan' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09003, DamageDuration) == 0x0005E4, "Member 'AEnemy_Extnd09_Enemy09003::DamageDuration' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09003, AddRingCount) == 0x0005E8, "Member 'AEnemy_Extnd09_Enemy09003::AddRingCount' has a wrong offset!");

// Class UnionRun.GimmickBakubaku
// 0x0040 (0x05F0 - 0x05B0)
class alignas(0x10) AGimmickBakubaku final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshComponent*                         GFurComponent;                                     // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionSkeletalMeshComponent*            SkeletalMeshComponent;                             // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGimmickStaticBodyComponent*            StaticBodyComponent;                               // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    MoveAtomComponent;                                 // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERacerDamageType                              _DamageType;                                       // 0x05D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D9[0x3];                                      // 0x05D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _flinchEndTime;                                    // 0x05DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _mouthAngleDeg;                                    // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bInit;                                            // 0x05E4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bIsFlinching;                                     // 0x05E5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E6[0x2];                                      // 0x05E6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _flinchingTime;                                    // 0x05E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5EC[0x4];                                      // 0x05EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFlinch();
	void OnFlinchEnd();

	bool GetIsFlinching() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickBakubaku">();
	}
	static class AGimmickBakubaku* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickBakubaku>();
	}
};
static_assert(alignof(AGimmickBakubaku) == 0x000010, "Wrong alignment on AGimmickBakubaku");
static_assert(sizeof(AGimmickBakubaku) == 0x0005F0, "Wrong size on AGimmickBakubaku");
static_assert(offsetof(AGimmickBakubaku, GFurComponent) == 0x0005B8, "Member 'AGimmickBakubaku::GFurComponent' has a wrong offset!");
static_assert(offsetof(AGimmickBakubaku, SkeletalMeshComponent) == 0x0005C0, "Member 'AGimmickBakubaku::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickBakubaku, StaticBodyComponent) == 0x0005C8, "Member 'AGimmickBakubaku::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickBakubaku, MoveAtomComponent) == 0x0005D0, "Member 'AGimmickBakubaku::MoveAtomComponent' has a wrong offset!");
static_assert(offsetof(AGimmickBakubaku, _DamageType) == 0x0005D8, "Member 'AGimmickBakubaku::_DamageType' has a wrong offset!");
static_assert(offsetof(AGimmickBakubaku, _flinchEndTime) == 0x0005DC, "Member 'AGimmickBakubaku::_flinchEndTime' has a wrong offset!");
static_assert(offsetof(AGimmickBakubaku, _mouthAngleDeg) == 0x0005E0, "Member 'AGimmickBakubaku::_mouthAngleDeg' has a wrong offset!");
static_assert(offsetof(AGimmickBakubaku, _bInit) == 0x0005E4, "Member 'AGimmickBakubaku::_bInit' has a wrong offset!");
static_assert(offsetof(AGimmickBakubaku, _bIsFlinching) == 0x0005E5, "Member 'AGimmickBakubaku::_bIsFlinching' has a wrong offset!");
static_assert(offsetof(AGimmickBakubaku, _flinchingTime) == 0x0005E8, "Member 'AGimmickBakubaku::_flinchingTime' has a wrong offset!");

// Class UnionRun.Enemy_Extnd09_Enemy09003_Shot
// 0x0060 (0x0610 - 0x05B0)
class alignas(0x10) AEnemy_Extnd09_Enemy09003_Shot final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGimmickStaticBodyComponent*            StaticBodyComponent;                               // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAtomComponent*                         AtomComponent;                                     // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Gravity;                                           // 0x05D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D4[0x3C];                                     // 0x05D4(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Enemy_Extnd09_Enemy09003_Shot">();
	}
	static class AEnemy_Extnd09_Enemy09003_Shot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemy_Extnd09_Enemy09003_Shot>();
	}
};
static_assert(alignof(AEnemy_Extnd09_Enemy09003_Shot) == 0x000010, "Wrong alignment on AEnemy_Extnd09_Enemy09003_Shot");
static_assert(sizeof(AEnemy_Extnd09_Enemy09003_Shot) == 0x000610, "Wrong size on AEnemy_Extnd09_Enemy09003_Shot");
static_assert(offsetof(AEnemy_Extnd09_Enemy09003_Shot, StaticBodyComponent) == 0x0005B8, "Member 'AEnemy_Extnd09_Enemy09003_Shot::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09003_Shot, StaticMeshComponent) == 0x0005C0, "Member 'AEnemy_Extnd09_Enemy09003_Shot::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09003_Shot, AtomComponent) == 0x0005C8, "Member 'AEnemy_Extnd09_Enemy09003_Shot::AtomComponent' has a wrong offset!");
static_assert(offsetof(AEnemy_Extnd09_Enemy09003_Shot, Gravity) == 0x0005D0, "Member 'AEnemy_Extnd09_Enemy09003_Shot::Gravity' has a wrong offset!");

// Class UnionRun.GimmickManipulatedVehicle
// 0x0130 (0x06E0 - 0x05B0)
class alignas(0x10) AGimmickManipulatedVehicle final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveUpTime;                                        // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageMoveHight;                                   // 0x05BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DamageMoveUpCurve;                                 // 0x05C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERacerDamageType                              DamageType;                                        // 0x05C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSplineMove;                                      // 0x05C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsExecuteIdleMove;                                // 0x05CA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5CB[0x1];                                      // 0x05CB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdleMoveRotateTime;                                // 0x05CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleMoveLocationTime;                              // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D4[0x4];                                      // 0x05D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           IdleMoveCurve;                                     // 0x05D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            IdleRotateYaxisCurve;                              // 0x05E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            IdleRotateZaxisCurve;                              // 0x05E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleMoveHorizontal;                                // 0x05F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleMoveVertical;                                  // 0x05F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleRotateYaxis;                                   // 0x05F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleRotateZaxis;                                   // 0x05FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              BodyStatickMeshComponent;                          // 0x0600(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              ShadowStatickMeshComponent;                        // 0x0608(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    MoveUpSoundComponent;                              // 0x0610(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    MoveSoundComponent;                                // 0x0618(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            m_MainStaticBodyComponent;                         // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_630[0xB0];                                     // 0x0630(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DebugUpdateIdleMove(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickManipulatedVehicle">();
	}
	static class AGimmickManipulatedVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickManipulatedVehicle>();
	}
};
static_assert(alignof(AGimmickManipulatedVehicle) == 0x000010, "Wrong alignment on AGimmickManipulatedVehicle");
static_assert(sizeof(AGimmickManipulatedVehicle) == 0x0006E0, "Wrong size on AGimmickManipulatedVehicle");
static_assert(offsetof(AGimmickManipulatedVehicle, MoveUpTime) == 0x0005B8, "Member 'AGimmickManipulatedVehicle::MoveUpTime' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedVehicle, DamageMoveHight) == 0x0005BC, "Member 'AGimmickManipulatedVehicle::DamageMoveHight' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedVehicle, DamageMoveUpCurve) == 0x0005C0, "Member 'AGimmickManipulatedVehicle::DamageMoveUpCurve' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedVehicle, DamageType) == 0x0005C8, "Member 'AGimmickManipulatedVehicle::DamageType' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedVehicle, IsSplineMove) == 0x0005C9, "Member 'AGimmickManipulatedVehicle::IsSplineMove' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedVehicle, bIsExecuteIdleMove) == 0x0005CA, "Member 'AGimmickManipulatedVehicle::bIsExecuteIdleMove' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedVehicle, IdleMoveRotateTime) == 0x0005CC, "Member 'AGimmickManipulatedVehicle::IdleMoveRotateTime' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedVehicle, IdleMoveLocationTime) == 0x0005D0, "Member 'AGimmickManipulatedVehicle::IdleMoveLocationTime' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedVehicle, IdleMoveCurve) == 0x0005D8, "Member 'AGimmickManipulatedVehicle::IdleMoveCurve' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedVehicle, IdleRotateYaxisCurve) == 0x0005E0, "Member 'AGimmickManipulatedVehicle::IdleRotateYaxisCurve' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedVehicle, IdleRotateZaxisCurve) == 0x0005E8, "Member 'AGimmickManipulatedVehicle::IdleRotateZaxisCurve' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedVehicle, IdleMoveHorizontal) == 0x0005F0, "Member 'AGimmickManipulatedVehicle::IdleMoveHorizontal' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedVehicle, IdleMoveVertical) == 0x0005F4, "Member 'AGimmickManipulatedVehicle::IdleMoveVertical' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedVehicle, IdleRotateYaxis) == 0x0005F8, "Member 'AGimmickManipulatedVehicle::IdleRotateYaxis' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedVehicle, IdleRotateZaxis) == 0x0005FC, "Member 'AGimmickManipulatedVehicle::IdleRotateZaxis' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedVehicle, BodyStatickMeshComponent) == 0x000600, "Member 'AGimmickManipulatedVehicle::BodyStatickMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedVehicle, ShadowStatickMeshComponent) == 0x000608, "Member 'AGimmickManipulatedVehicle::ShadowStatickMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedVehicle, MoveUpSoundComponent) == 0x000610, "Member 'AGimmickManipulatedVehicle::MoveUpSoundComponent' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedVehicle, MoveSoundComponent) == 0x000618, "Member 'AGimmickManipulatedVehicle::MoveSoundComponent' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedVehicle, DefaultSceneRoot) == 0x000620, "Member 'AGimmickManipulatedVehicle::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedVehicle, m_MainStaticBodyComponent) == 0x000628, "Member 'AGimmickManipulatedVehicle::m_MainStaticBodyComponent' has a wrong offset!");

// Class UnionRun.FlowerTentacleAnimInstance
// 0x0000 (0x0370 - 0x0370)
class UFlowerTentacleAnimInstance final : public UEnemyAnimInstance
{
public:
	bool                                          bIsDisappear;                                      // 0x0368(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAttack;                                         // 0x0369(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAppear;                                         // 0x036A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36B[0x5];                                      // 0x036B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetIIsAppear();
	bool GetIsAttack();
	bool GetIsDisappear();
	void SetIsAppear(bool flag);
	void SetIsAttack(bool flag);
	void SetIsDisappear(bool flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowerTentacleAnimInstance">();
	}
	static class UFlowerTentacleAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowerTentacleAnimInstance>();
	}
};
static_assert(alignof(UFlowerTentacleAnimInstance) == 0x000010, "Wrong alignment on UFlowerTentacleAnimInstance");
static_assert(sizeof(UFlowerTentacleAnimInstance) == 0x000370, "Wrong size on UFlowerTentacleAnimInstance");
static_assert(offsetof(UFlowerTentacleAnimInstance, bIsDisappear) == 0x000368, "Member 'UFlowerTentacleAnimInstance::bIsDisappear' has a wrong offset!");
static_assert(offsetof(UFlowerTentacleAnimInstance, bIsAttack) == 0x000369, "Member 'UFlowerTentacleAnimInstance::bIsAttack' has a wrong offset!");
static_assert(offsetof(UFlowerTentacleAnimInstance, bIsAppear) == 0x00036A, "Member 'UFlowerTentacleAnimInstance::bIsAppear' has a wrong offset!");

// Class UnionRun.PredictTestManager
// 0x0080 (0x00A8 - 0x0028)
class UPredictTestManager final : public UObject
{
public:
	uint8                                         Pad_28[0x80];                                      // 0x0028(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PredictTestManager">();
	}
	static class UPredictTestManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPredictTestManager>();
	}
};
static_assert(alignof(UPredictTestManager) == 0x000008, "Wrong alignment on UPredictTestManager");
static_assert(sizeof(UPredictTestManager) == 0x0000A8, "Wrong size on UPredictTestManager");

// Class UnionRun.FossilTrexAnimInstance
// 0x0000 (0x0370 - 0x0370)
class UFossilTrexAnimInstance final : public UEnemyAnimInstance
{
public:
	bool                                          bIsDamage;                                         // 0x0368(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAttack;                                         // 0x0369(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTypeB;                                          // 0x036A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36B[0x5];                                      // 0x036B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetIsAttack();
	bool GetIsTYpeB();
	void SetIsAttack(bool flag);
	void SetIsDamage(bool flag);
	void SetIsTypeB(bool flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FossilTrexAnimInstance">();
	}
	static class UFossilTrexAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFossilTrexAnimInstance>();
	}
};
static_assert(alignof(UFossilTrexAnimInstance) == 0x000010, "Wrong alignment on UFossilTrexAnimInstance");
static_assert(sizeof(UFossilTrexAnimInstance) == 0x000370, "Wrong size on UFossilTrexAnimInstance");
static_assert(offsetof(UFossilTrexAnimInstance, bIsDamage) == 0x000368, "Member 'UFossilTrexAnimInstance::bIsDamage' has a wrong offset!");
static_assert(offsetof(UFossilTrexAnimInstance, bIsAttack) == 0x000369, "Member 'UFossilTrexAnimInstance::bIsAttack' has a wrong offset!");
static_assert(offsetof(UFossilTrexAnimInstance, bIsTypeB) == 0x00036A, "Member 'UFossilTrexAnimInstance::bIsTypeB' has a wrong offset!");

// Class UnionRun.GadgetBase
// 0x0078 (0x00A0 - 0x0028)
class UGadgetBase : public UObject
{
public:
	uint8                                         Pad_28[0x78];                                      // 0x0028(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetBase">();
	}
	static class UGadgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetBase>();
	}
};
static_assert(alignof(UGadgetBase) == 0x000008, "Wrong alignment on UGadgetBase");
static_assert(sizeof(UGadgetBase) == 0x0000A0, "Wrong size on UGadgetBase");

// Class UnionRun.Gadget2LapGetItem
// 0x0008 (0x00A8 - 0x00A0)
class UGadget2LapGetItem final : public UGadgetBase
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gadget2LapGetItem">();
	}
	static class UGadget2LapGetItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadget2LapGetItem>();
	}
};
static_assert(alignof(UGadget2LapGetItem) == 0x000008, "Wrong alignment on UGadget2LapGetItem");
static_assert(sizeof(UGadget2LapGetItem) == 0x0000A8, "Wrong size on UGadget2LapGetItem");

// Class UnionRun.Gimmick_Extnd04_EaEntrance
// 0x0040 (0x05F0 - 0x05B0)
class alignas(0x10) AGimmick_Extnd04_EaEntrance final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              Mesh;                                              // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      Effect;                                            // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    Sound;                                             // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            Body;                                              // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    PassSound;                                         // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E0[0x10];                                     // 0x05E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd04_EaEntrance">();
	}
	static class AGimmick_Extnd04_EaEntrance* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd04_EaEntrance>();
	}
};
static_assert(alignof(AGimmick_Extnd04_EaEntrance) == 0x000010, "Wrong alignment on AGimmick_Extnd04_EaEntrance");
static_assert(sizeof(AGimmick_Extnd04_EaEntrance) == 0x0005F0, "Wrong size on AGimmick_Extnd04_EaEntrance");
static_assert(offsetof(AGimmick_Extnd04_EaEntrance, Mesh) == 0x0005B8, "Member 'AGimmick_Extnd04_EaEntrance::Mesh' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_EaEntrance, Effect) == 0x0005C0, "Member 'AGimmick_Extnd04_EaEntrance::Effect' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_EaEntrance, Sound) == 0x0005C8, "Member 'AGimmick_Extnd04_EaEntrance::Sound' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_EaEntrance, Body) == 0x0005D0, "Member 'AGimmick_Extnd04_EaEntrance::Body' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_EaEntrance, PassSound) == 0x0005D8, "Member 'AGimmick_Extnd04_EaEntrance::PassSound' has a wrong offset!");

// Class UnionRun.Gadget3LapGetItem
// 0x0008 (0x00A8 - 0x00A0)
class UGadget3LapGetItem final : public UGadgetBase
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gadget3LapGetItem">();
	}
	static class UGadget3LapGetItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadget3LapGetItem>();
	}
};
static_assert(alignof(UGadget3LapGetItem) == 0x000008, "Wrong alignment on UGadget3LapGetItem");
static_assert(sizeof(UGadget3LapGetItem) == 0x0000A8, "Wrong size on UGadget3LapGetItem");

// Class UnionRun.GadgetMachineTuneBase
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetMachineTuneBase : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetMachineTuneBase">();
	}
	static class UGadgetMachineTuneBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetMachineTuneBase>();
	}
};
static_assert(alignof(UGadgetMachineTuneBase) == 0x000008, "Wrong alignment on UGadgetMachineTuneBase");
static_assert(sizeof(UGadgetMachineTuneBase) == 0x0000A0, "Wrong size on UGadgetMachineTuneBase");

// Class UnionRun.GadgetAccelTune
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetAccelTune final : public UGadgetMachineTuneBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetAccelTune">();
	}
	static class UGadgetAccelTune* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetAccelTune>();
	}
};
static_assert(alignof(UGadgetAccelTune) == 0x000008, "Wrong alignment on UGadgetAccelTune");
static_assert(sizeof(UGadgetAccelTune) == 0x0000A0, "Wrong size on UGadgetAccelTune");

// Class UnionRun.VATBreakObjectBase
// 0x00F0 (0x06A0 - 0x05B0)
class alignas(0x10) AVATBreakObjectBase : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              StaticMeshComponent;                               // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionVATMeshComponent*                 VATMeshComponent;                                  // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            StaticBodyComponent;                               // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EBreakObjType                                 BreakObjType;                                      // 0x05D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EBreakConditionType                           BreakConditionType;                                // 0x05D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          InValidRotation;                                   // 0x05DA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5DB[0x1];                                      // 0x05DB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HighBreakSpeedThreshold;                           // 0x05DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsForceLowBreakType;                               // 0x05E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsStaticMeshVisible;                               // 0x05E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          isRelocate;                                        // 0x05E2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E3[0x1];                                      // 0x05E3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RelocateTimer;                                     // 0x05E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RelocateRange;                                     // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EBreakDamageType                              BreakDamageType;                                   // 0x05EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERacerDamageType                              DamageType;                                        // 0x05ED(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5EE[0x2];                                      // 0x05EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CrashSoundTimer;                                   // 0x05F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         VATAnimStartFrame;                                 // 0x05F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F8[0xA8];                                     // 0x05F8(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayBreakEvent();
	void OnPlayClashSound();
	void OnVATUpdate(class UUnionVATMeshComponent* VATComponent, const struct FUnionVATSequenceInfo& SequenceInfo);

	EBreakSpeedType GetBreakSpeedType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VATBreakObjectBase">();
	}
	static class AVATBreakObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVATBreakObjectBase>();
	}
};
static_assert(alignof(AVATBreakObjectBase) == 0x000010, "Wrong alignment on AVATBreakObjectBase");
static_assert(sizeof(AVATBreakObjectBase) == 0x0006A0, "Wrong size on AVATBreakObjectBase");
static_assert(offsetof(AVATBreakObjectBase, StaticMeshComponent) == 0x0005B8, "Member 'AVATBreakObjectBase::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AVATBreakObjectBase, VATMeshComponent) == 0x0005C0, "Member 'AVATBreakObjectBase::VATMeshComponent' has a wrong offset!");
static_assert(offsetof(AVATBreakObjectBase, DefaultSceneRoot) == 0x0005C8, "Member 'AVATBreakObjectBase::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AVATBreakObjectBase, StaticBodyComponent) == 0x0005D0, "Member 'AVATBreakObjectBase::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AVATBreakObjectBase, BreakObjType) == 0x0005D8, "Member 'AVATBreakObjectBase::BreakObjType' has a wrong offset!");
static_assert(offsetof(AVATBreakObjectBase, BreakConditionType) == 0x0005D9, "Member 'AVATBreakObjectBase::BreakConditionType' has a wrong offset!");
static_assert(offsetof(AVATBreakObjectBase, InValidRotation) == 0x0005DA, "Member 'AVATBreakObjectBase::InValidRotation' has a wrong offset!");
static_assert(offsetof(AVATBreakObjectBase, HighBreakSpeedThreshold) == 0x0005DC, "Member 'AVATBreakObjectBase::HighBreakSpeedThreshold' has a wrong offset!");
static_assert(offsetof(AVATBreakObjectBase, IsForceLowBreakType) == 0x0005E0, "Member 'AVATBreakObjectBase::IsForceLowBreakType' has a wrong offset!");
static_assert(offsetof(AVATBreakObjectBase, IsStaticMeshVisible) == 0x0005E1, "Member 'AVATBreakObjectBase::IsStaticMeshVisible' has a wrong offset!");
static_assert(offsetof(AVATBreakObjectBase, isRelocate) == 0x0005E2, "Member 'AVATBreakObjectBase::isRelocate' has a wrong offset!");
static_assert(offsetof(AVATBreakObjectBase, RelocateTimer) == 0x0005E4, "Member 'AVATBreakObjectBase::RelocateTimer' has a wrong offset!");
static_assert(offsetof(AVATBreakObjectBase, RelocateRange) == 0x0005E8, "Member 'AVATBreakObjectBase::RelocateRange' has a wrong offset!");
static_assert(offsetof(AVATBreakObjectBase, BreakDamageType) == 0x0005EC, "Member 'AVATBreakObjectBase::BreakDamageType' has a wrong offset!");
static_assert(offsetof(AVATBreakObjectBase, DamageType) == 0x0005ED, "Member 'AVATBreakObjectBase::DamageType' has a wrong offset!");
static_assert(offsetof(AVATBreakObjectBase, CrashSoundTimer) == 0x0005F0, "Member 'AVATBreakObjectBase::CrashSoundTimer' has a wrong offset!");
static_assert(offsetof(AVATBreakObjectBase, VATAnimStartFrame) == 0x0005F4, "Member 'AVATBreakObjectBase::VATAnimStartFrame' has a wrong offset!");

// Class UnionRun.GadgetAddActionBoatPlane
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetAddActionBoatPlane final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetAddActionBoatPlane">();
	}
	static class UGadgetAddActionBoatPlane* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetAddActionBoatPlane>();
	}
};
static_assert(alignof(UGadgetAddActionBoatPlane) == 0x000008, "Wrong alignment on UGadgetAddActionBoatPlane");
static_assert(sizeof(UGadgetAddActionBoatPlane) == 0x0000A0, "Wrong size on UGadgetAddActionBoatPlane");

// Class UnionRun.GimmickMoveRoad
// 0x0080 (0x0630 - 0x05B0)
class alignas(0x10) AGimmickMoveRoad final : public AUnionGimmickObjectBase
{
public:
	class UUnionStaticMeshComponent*              BodyStatickMeshComponent;                          // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AGimmickMoveRoadCube*>           CubeActorArray;                                    // 0x05B8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            m_MainStaticBodyComponent;                         // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D8[0x58];                                     // 0x05D8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickMoveRoad">();
	}
	static class AGimmickMoveRoad* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickMoveRoad>();
	}
};
static_assert(alignof(AGimmickMoveRoad) == 0x000010, "Wrong alignment on AGimmickMoveRoad");
static_assert(sizeof(AGimmickMoveRoad) == 0x000630, "Wrong size on AGimmickMoveRoad");
static_assert(offsetof(AGimmickMoveRoad, BodyStatickMeshComponent) == 0x0005B0, "Member 'AGimmickMoveRoad::BodyStatickMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickMoveRoad, CubeActorArray) == 0x0005B8, "Member 'AGimmickMoveRoad::CubeActorArray' has a wrong offset!");
static_assert(offsetof(AGimmickMoveRoad, DefaultSceneRoot) == 0x0005C8, "Member 'AGimmickMoveRoad::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AGimmickMoveRoad, m_MainStaticBodyComponent) == 0x0005D0, "Member 'AGimmickMoveRoad::m_MainStaticBodyComponent' has a wrong offset!");

// Class UnionRun.GadgetAddDoubleWisps
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetAddDoubleWisps final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetAddDoubleWisps">();
	}
	static class UGadgetAddDoubleWisps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetAddDoubleWisps>();
	}
};
static_assert(alignof(UGadgetAddDoubleWisps) == 0x000008, "Wrong alignment on UGadgetAddDoubleWisps");
static_assert(sizeof(UGadgetAddDoubleWisps) == 0x0000A0, "Wrong size on UGadgetAddDoubleWisps");

// Class UnionRun.RaceTestConfig
// 0x0168 (0x0198 - 0x0030)
class URaceTestConfig final : public UDataAsset
{
public:
	ERaceType                                     RaceType;                                          // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRaceTestStageSetting>          StageId;                                           // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	ERaceTestSelectTravelType                     TravelType;                                        // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPriorityMenuSettingForFreeRunStageId;             // 0x0049(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRaceTestRacerSetting>          Players;                                           // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRaceTestRacerSetting>          COMs;                                              // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsGhostMachineDisable;                            // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideCamera;                                   // 0x0071(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x2];                                       // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideCameraVFov;                                // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideCameraOffset;                              // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideCameraTargetY;                             // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideCameraTargetZ;                             // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideCameraElevation;                           // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpeedClassId                                 SpeedClass;                                        // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERaceSettingGrouping                          RaceGroupType;                                     // 0x0089(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGroupRaceRule                                RaceGroupRule;                                     // 0x008A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B[0x5];                                       // 0x008B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, EGroupColorId>                    RaceGroupColor;                                    // 0x0090(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FString>                         ConsoleCommandList;                                // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	ERaceFrameRate                                FixedFps;                                          // 0x00F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         FixedRandomSeed;                                   // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisabledGameHighLoading;                          // 0x0100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoHud;                                            // 0x0101(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoBgm;                                            // 0x0102(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableFootCut;                                    // 0x0103(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TagNameToDestroyActor;                             // 0x0108(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LimitedLogCategory;                                // 0x0118(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoDebugText;                                      // 0x0128(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoCourseObject;                                   // 0x0129(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoGimmickObject;                                  // 0x012A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12B[0x1];                                      // 0x012B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RacerRingNum;                                      // 0x012C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoRingObject;                                     // 0x0130(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             ItemSettingTable;                                  // 0x0138(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableItemTableSynchro;                          // 0x0140(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoItemBox;                                        // 0x0141(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_142[0x2];                                      // 0x0142(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ItemLotteryRouletteTime;                           // 0x0144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemId                                       FixedLotteryItem;                                  // 0x0148(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bItemNoHitLayerMachine;                            // 0x0149(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bItemNoHitLayerItem;                               // 0x014A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14B[0x1];                                      // 0x014B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ItemCapacityMaxNum;                                // 0x014C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableItemCountDownPerformance;                  // 0x0150(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bItemRocketPuntchForceNoReflect;                   // 0x0151(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bItemSlimeAutoUserInput;                           // 0x0152(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERaceLoadTestMode                             RaceLoadTestMode;                                  // 0x0153(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ERaceTestPathSelectType>               PathSelectTypes;                                   // 0x0158(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bOverridePathCamera;                               // 0x0168(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x3];                                      // 0x0169(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverridePathCameraVFov;                            // 0x016C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverridePathCameraOffset;                          // 0x0170(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverridePathCameraTargetY;                         // 0x0174(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverridePathCameraTargetZ;                         // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverridePathCameraElevation;                       // 0x017C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RaceLoadTestCount;                                 // 0x0180(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoKibana;                                       // 0x0184(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDetailKibana;                                 // 0x0185(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDebugKibana;                                  // 0x0186(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOutputLogForRaceLoadTest;                         // 0x0187(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOutputLogFileForRaceLoadTest;                     // 0x0188(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoUnrealInsights;                               // 0x0189(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoProfileGpu;                                   // 0x018A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18B[0x1];                                      // 0x018B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoProfileGpuInterval;                            // 0x018C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoProfileGpuThreshold;                           // 0x0190(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoCsvProfile;                                   // 0x0194(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_195[0x3];                                      // 0x0195(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceTestConfig">();
	}
	static class URaceTestConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceTestConfig>();
	}
};
static_assert(alignof(URaceTestConfig) == 0x000008, "Wrong alignment on URaceTestConfig");
static_assert(sizeof(URaceTestConfig) == 0x000198, "Wrong size on URaceTestConfig");
static_assert(offsetof(URaceTestConfig, RaceType) == 0x000030, "Member 'URaceTestConfig::RaceType' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, StageId) == 0x000038, "Member 'URaceTestConfig::StageId' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, TravelType) == 0x000048, "Member 'URaceTestConfig::TravelType' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, bPriorityMenuSettingForFreeRunStageId) == 0x000049, "Member 'URaceTestConfig::bPriorityMenuSettingForFreeRunStageId' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, Players) == 0x000050, "Member 'URaceTestConfig::Players' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, COMs) == 0x000060, "Member 'URaceTestConfig::COMs' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, bIsGhostMachineDisable) == 0x000070, "Member 'URaceTestConfig::bIsGhostMachineDisable' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, bOverrideCamera) == 0x000071, "Member 'URaceTestConfig::bOverrideCamera' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, OverrideCameraVFov) == 0x000074, "Member 'URaceTestConfig::OverrideCameraVFov' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, OverrideCameraOffset) == 0x000078, "Member 'URaceTestConfig::OverrideCameraOffset' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, OverrideCameraTargetY) == 0x00007C, "Member 'URaceTestConfig::OverrideCameraTargetY' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, OverrideCameraTargetZ) == 0x000080, "Member 'URaceTestConfig::OverrideCameraTargetZ' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, OverrideCameraElevation) == 0x000084, "Member 'URaceTestConfig::OverrideCameraElevation' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, SpeedClass) == 0x000088, "Member 'URaceTestConfig::SpeedClass' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, RaceGroupType) == 0x000089, "Member 'URaceTestConfig::RaceGroupType' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, RaceGroupRule) == 0x00008A, "Member 'URaceTestConfig::RaceGroupRule' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, RaceGroupColor) == 0x000090, "Member 'URaceTestConfig::RaceGroupColor' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, ConsoleCommandList) == 0x0000E0, "Member 'URaceTestConfig::ConsoleCommandList' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, FixedFps) == 0x0000F0, "Member 'URaceTestConfig::FixedFps' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, FixedRandomSeed) == 0x0000F8, "Member 'URaceTestConfig::FixedRandomSeed' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, bDisabledGameHighLoading) == 0x000100, "Member 'URaceTestConfig::bDisabledGameHighLoading' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, bNoHud) == 0x000101, "Member 'URaceTestConfig::bNoHud' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, bNoBgm) == 0x000102, "Member 'URaceTestConfig::bNoBgm' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, bEnableFootCut) == 0x000103, "Member 'URaceTestConfig::bEnableFootCut' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, TagNameToDestroyActor) == 0x000108, "Member 'URaceTestConfig::TagNameToDestroyActor' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, LimitedLogCategory) == 0x000118, "Member 'URaceTestConfig::LimitedLogCategory' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, bNoDebugText) == 0x000128, "Member 'URaceTestConfig::bNoDebugText' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, bNoCourseObject) == 0x000129, "Member 'URaceTestConfig::bNoCourseObject' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, bNoGimmickObject) == 0x00012A, "Member 'URaceTestConfig::bNoGimmickObject' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, RacerRingNum) == 0x00012C, "Member 'URaceTestConfig::RacerRingNum' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, bNoRingObject) == 0x000130, "Member 'URaceTestConfig::bNoRingObject' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, ItemSettingTable) == 0x000138, "Member 'URaceTestConfig::ItemSettingTable' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, bDisableItemTableSynchro) == 0x000140, "Member 'URaceTestConfig::bDisableItemTableSynchro' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, bNoItemBox) == 0x000141, "Member 'URaceTestConfig::bNoItemBox' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, ItemLotteryRouletteTime) == 0x000144, "Member 'URaceTestConfig::ItemLotteryRouletteTime' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, FixedLotteryItem) == 0x000148, "Member 'URaceTestConfig::FixedLotteryItem' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, bItemNoHitLayerMachine) == 0x000149, "Member 'URaceTestConfig::bItemNoHitLayerMachine' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, bItemNoHitLayerItem) == 0x00014A, "Member 'URaceTestConfig::bItemNoHitLayerItem' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, ItemCapacityMaxNum) == 0x00014C, "Member 'URaceTestConfig::ItemCapacityMaxNum' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, bDisableItemCountDownPerformance) == 0x000150, "Member 'URaceTestConfig::bDisableItemCountDownPerformance' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, bItemRocketPuntchForceNoReflect) == 0x000151, "Member 'URaceTestConfig::bItemRocketPuntchForceNoReflect' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, bItemSlimeAutoUserInput) == 0x000152, "Member 'URaceTestConfig::bItemSlimeAutoUserInput' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, RaceLoadTestMode) == 0x000153, "Member 'URaceTestConfig::RaceLoadTestMode' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, PathSelectTypes) == 0x000158, "Member 'URaceTestConfig::PathSelectTypes' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, bOverridePathCamera) == 0x000168, "Member 'URaceTestConfig::bOverridePathCamera' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, OverridePathCameraVFov) == 0x00016C, "Member 'URaceTestConfig::OverridePathCameraVFov' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, OverridePathCameraOffset) == 0x000170, "Member 'URaceTestConfig::OverridePathCameraOffset' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, OverridePathCameraTargetY) == 0x000174, "Member 'URaceTestConfig::OverridePathCameraTargetY' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, OverridePathCameraTargetZ) == 0x000178, "Member 'URaceTestConfig::OverridePathCameraTargetZ' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, OverridePathCameraElevation) == 0x00017C, "Member 'URaceTestConfig::OverridePathCameraElevation' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, RaceLoadTestCount) == 0x000180, "Member 'URaceTestConfig::RaceLoadTestCount' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, bAutoKibana) == 0x000184, "Member 'URaceTestConfig::bAutoKibana' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, bAutoDetailKibana) == 0x000185, "Member 'URaceTestConfig::bAutoDetailKibana' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, bAutoDebugKibana) == 0x000186, "Member 'URaceTestConfig::bAutoDebugKibana' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, bOutputLogForRaceLoadTest) == 0x000187, "Member 'URaceTestConfig::bOutputLogForRaceLoadTest' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, bOutputLogFileForRaceLoadTest) == 0x000188, "Member 'URaceTestConfig::bOutputLogFileForRaceLoadTest' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, bAutoUnrealInsights) == 0x000189, "Member 'URaceTestConfig::bAutoUnrealInsights' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, bAutoProfileGpu) == 0x00018A, "Member 'URaceTestConfig::bAutoProfileGpu' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, AutoProfileGpuInterval) == 0x00018C, "Member 'URaceTestConfig::AutoProfileGpuInterval' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, AutoProfileGpuThreshold) == 0x000190, "Member 'URaceTestConfig::AutoProfileGpuThreshold' has a wrong offset!");
static_assert(offsetof(URaceTestConfig, bAutoCsvProfile) == 0x000194, "Member 'URaceTestConfig::bAutoCsvProfile' has a wrong offset!");

// Class UnionRun.GadgetAddSplash
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetAddSplash final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetAddSplash">();
	}
	static class UGadgetAddSplash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetAddSplash>();
	}
};
static_assert(alignof(UGadgetAddSplash) == 0x000008, "Wrong alignment on UGadgetAddSplash");
static_assert(sizeof(UGadgetAddSplash) == 0x0000A0, "Wrong size on UGadgetAddSplash");

// Class UnionRun.GadgetAddWarp
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetAddWarp final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetAddWarp">();
	}
	static class UGadgetAddWarp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetAddWarp>();
	}
};
static_assert(alignof(UGadgetAddWarp) == 0x000008, "Wrong alignment on UGadgetAddWarp");
static_assert(sizeof(UGadgetAddWarp) == 0x0000A0, "Wrong size on UGadgetAddWarp");

// Class UnionRun.GimmickManipulatedPlane
// 0x0120 (0x06D0 - 0x05B0)
class alignas(0x10) AGimmickManipulatedPlane final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ERacerDamageType                              DamageType;                                        // 0x05B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B9[0x3];                                      // 0x05B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotateSpeed;                                       // 0x05BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RotateDirection;                                   // 0x05C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C1[0x3];                                      // 0x05C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageMoveTime;                                    // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageMoveLength;                                  // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5CC[0x4];                                      // 0x05CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DamageMoveCurve;                                   // 0x05D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isDebugDamageCheck;                                // 0x05D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D9[0x7];                                      // 0x05D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              BodyStatickMeshComponent;                          // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    IdleSoundComponent;                                // 0x05E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    MoveUpSoundComponent;                              // 0x05F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            m_MainStaticBodyComponent;                         // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            m_Wing1StaticBodyComponent;                        // 0x0600(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            m_Wing2StaticBodyComponent;                        // 0x0608(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_610[0xC0];                                     // 0x0610(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickManipulatedPlane">();
	}
	static class AGimmickManipulatedPlane* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickManipulatedPlane>();
	}
};
static_assert(alignof(AGimmickManipulatedPlane) == 0x000010, "Wrong alignment on AGimmickManipulatedPlane");
static_assert(sizeof(AGimmickManipulatedPlane) == 0x0006D0, "Wrong size on AGimmickManipulatedPlane");
static_assert(offsetof(AGimmickManipulatedPlane, DamageType) == 0x0005B8, "Member 'AGimmickManipulatedPlane::DamageType' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedPlane, RotateSpeed) == 0x0005BC, "Member 'AGimmickManipulatedPlane::RotateSpeed' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedPlane, RotateDirection) == 0x0005C0, "Member 'AGimmickManipulatedPlane::RotateDirection' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedPlane, DamageMoveTime) == 0x0005C4, "Member 'AGimmickManipulatedPlane::DamageMoveTime' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedPlane, DamageMoveLength) == 0x0005C8, "Member 'AGimmickManipulatedPlane::DamageMoveLength' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedPlane, DamageMoveCurve) == 0x0005D0, "Member 'AGimmickManipulatedPlane::DamageMoveCurve' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedPlane, isDebugDamageCheck) == 0x0005D8, "Member 'AGimmickManipulatedPlane::isDebugDamageCheck' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedPlane, BodyStatickMeshComponent) == 0x0005E0, "Member 'AGimmickManipulatedPlane::BodyStatickMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedPlane, IdleSoundComponent) == 0x0005E8, "Member 'AGimmickManipulatedPlane::IdleSoundComponent' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedPlane, MoveUpSoundComponent) == 0x0005F0, "Member 'AGimmickManipulatedPlane::MoveUpSoundComponent' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedPlane, m_MainStaticBodyComponent) == 0x0005F8, "Member 'AGimmickManipulatedPlane::m_MainStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedPlane, m_Wing1StaticBodyComponent) == 0x000600, "Member 'AGimmickManipulatedPlane::m_Wing1StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedPlane, m_Wing2StaticBodyComponent) == 0x000608, "Member 'AGimmickManipulatedPlane::m_Wing2StaticBodyComponent' has a wrong offset!");

// Class UnionRun.GadgetBoatChargeJumpUp
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetBoatChargeJumpUp final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetBoatChargeJumpUp">();
	}
	static class UGadgetBoatChargeJumpUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetBoatChargeJumpUp>();
	}
};
static_assert(alignof(UGadgetBoatChargeJumpUp) == 0x000008, "Wrong alignment on UGadgetBoatChargeJumpUp");
static_assert(sizeof(UGadgetBoatChargeJumpUp) == 0x0000A0, "Wrong size on UGadgetBoatChargeJumpUp");

// Class UnionRun.GadgetBoatFormParamUP
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetBoatFormParamUP final : public UGadgetMachineTuneBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetBoatFormParamUP">();
	}
	static class UGadgetBoatFormParamUP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetBoatFormParamUP>();
	}
};
static_assert(alignof(UGadgetBoatFormParamUP) == 0x000008, "Wrong alignment on UGadgetBoatFormParamUP");
static_assert(sizeof(UGadgetBoatFormParamUP) == 0x0000A0, "Wrong size on UGadgetBoatFormParamUP");

// Class UnionRun.GadgetParameterDataAsset
// 0x10D0 (0x1100 - 0x0030)
class UGadgetParameterDataAsset final : public UDataAsset
{
public:
	float                                         ChargeRateMax;                                     // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMaxChargeRate;                                 // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AirTrickPlayRateMax;                               // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FGadgetRingPerformanceInfo> RingPerformanceInfoMap;                     // 0x0040(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   RingPerformanceObjectClass;                        // 0x0090(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EGadgetId>                             VariousUICheckExcludeMap;                          // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetTradeStockInfo> TradeStockMap;                                   // 0x00C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetEnhanceRocketPunchInfo> EnhanceRocketPunch;                      // 0x0118(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetEnhanceThornBallInfo> EnhanceThornBallMap;                       // 0x0168(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetEnhanceBombInfo> EnhanceBombMap;                                 // 0x01B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetMachineTuneInfo> DoubleItemMap;                                  // 0x0208(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetDoubleItemOccasionallyInfo> DoubleItemOccasionallyMap;           // 0x0258(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetSimpleRingBonusInfo> CreateItemMap;                              // 0x02A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetUltimateDriftInfo> UltimateDriftMap;                             // 0x02F8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          QuickAirTrick_bMultiplyParameter;                  // 0x0348(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_349[0x7];                                      // 0x0349(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FGadgetQuickAirtrickInfo> QuickAirTrickMap;                             // 0x0350(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetSkateDriftInfo> SkateDriftMap;                                   // 0x03A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetJustDashInfo> JustDashMap;                                       // 0x03F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetLevelChargeInfo> FirstFastChargeMap;                             // 0x0440(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetLevelChargeInfo> SecondFastChargeMap;                            // 0x0490(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetLevelChargeInfo> ThirdFastChargeMap;                             // 0x04E0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetSwitchDriftQuickChargeInfo> SwitchDriftQuickChargeMap;           // 0x0530(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetHyperChargeInfo> HyperChargeMap;                                 // 0x0580(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetSpinDriftInfo> SpinDriftMap;                                     // 0x05D0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetShortenDamageMotionInfo> ShortenDamageMotionMap;                 // 0x0620(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetMachineTuneInfo> SpeedTuneMap;                                   // 0x0670(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetMachineTuneInfo> AccelTuneMap;                                   // 0x06C0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetMachineTuneInfo> HandlingTuneMap;                                // 0x0710(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetMachineTuneInfo> PowerTuneMap;                                   // 0x0760(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetMachineTuneInfo> DashTuneMap;                                    // 0x07B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetMachineTuneInfo> StarterMap;                                     // 0x0800(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetMachineTuneInfo> SlowterMap;                                     // 0x0850(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetImmuneItemDamageOnceInfo> ImmuneItemDamageOnceMap;               // 0x08A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetTouchDashInfo> TouchDashInfoMap;                                 // 0x08F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetEnforceSlipstreamInfo> EnforceSlipstreamMap;                     // 0x0940(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetEnhanceHookTurnInfo> EnhanceHookTurnMap;                         // 0x0990(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetBoatChargeJumpUpInfo> BoatChargeJumpUpMap;                       // 0x09E0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetDashUpInfo>   RingDashUpMap;                                     // 0x0A30(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetGuardInfo>    RingGuardMap;                                      // 0x0A80(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetUpperLimitInfo> RingUpperLimitMap;                               // 0x0AD0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetStoleInfo>    RingStoleMap;                                      // 0x0B20(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetBoostRingBonusInfo> BonusDashPanelMap;                           // 0x0B70(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetBonusDashPanelComboInfo> BonusDashPanelComboMap;                 // 0x0BC0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetIntervalRingInfo> RunoffNegateBonusMap;                          // 0x0C10(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetExpandGetRingRangeInfo> ExpandGetRingRangeMap;                   // 0x0C60(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetSimpleRingBonusInfo> BonusRotateRingMap;                         // 0x0CB0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetIntervalRingInfo> SlipstreamBonusMap;                            // 0x0D00(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetSimpleRingBonusInfo> ItemAttackRingBonusMap;                     // 0x0D50(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetBoostRingBonusInfo> BonusDriftJustMap;                           // 0x0DA0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetBoostRingBonusInfo> BonusStartDashSucceedMap;                    // 0x0DF0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetSimpleRingBonusInfo> BonusTravelRingMap;                         // 0x0E40(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetSimpleRingBonusInfo> BonusTransformActionMap;                    // 0x0E90(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetSimpleRingBonusInfo> DriftDashRingBonusMap;                      // 0x0EE0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetSuppressRunoffInfo> SuppressRunoffMap;                           // 0x0F30(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetMachineTuneInfo> PlaneFormParamUPMap;                            // 0x0F80(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetMachineTuneInfo> BoatFormParamUPMap;                             // 0x0FD0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetItemNumInfo>  SecondLapGetItemMap;                               // 0x1020(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FName, struct FGadgetItemNumInfo>  ThirdLapGetItemMap;                                // 0x1070(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FGadgetShortenDamagetTimeInfo>  ShortenDamagetTime;                                // 0x10C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FGadgetLowRankRingBonusInfo            LowRankRingBonus;                                  // 0x10D0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, AdvancedDisplay, NativeAccessSpecifierPublic)
	TArray<float>                                 ShortenItemSlotTime;                               // 0x10F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditFixedSize, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetParameterDataAsset">();
	}
	static class UGadgetParameterDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetParameterDataAsset>();
	}
};
static_assert(alignof(UGadgetParameterDataAsset) == 0x000008, "Wrong alignment on UGadgetParameterDataAsset");
static_assert(sizeof(UGadgetParameterDataAsset) == 0x001100, "Wrong size on UGadgetParameterDataAsset");
static_assert(offsetof(UGadgetParameterDataAsset, ChargeRateMax) == 0x000030, "Member 'UGadgetParameterDataAsset::ChargeRateMax' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, bUseMaxChargeRate) == 0x000034, "Member 'UGadgetParameterDataAsset::bUseMaxChargeRate' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, AirTrickPlayRateMax) == 0x000038, "Member 'UGadgetParameterDataAsset::AirTrickPlayRateMax' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, RingPerformanceInfoMap) == 0x000040, "Member 'UGadgetParameterDataAsset::RingPerformanceInfoMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, RingPerformanceObjectClass) == 0x000090, "Member 'UGadgetParameterDataAsset::RingPerformanceObjectClass' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, VariousUICheckExcludeMap) == 0x0000B8, "Member 'UGadgetParameterDataAsset::VariousUICheckExcludeMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, TradeStockMap) == 0x0000C8, "Member 'UGadgetParameterDataAsset::TradeStockMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, EnhanceRocketPunch) == 0x000118, "Member 'UGadgetParameterDataAsset::EnhanceRocketPunch' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, EnhanceThornBallMap) == 0x000168, "Member 'UGadgetParameterDataAsset::EnhanceThornBallMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, EnhanceBombMap) == 0x0001B8, "Member 'UGadgetParameterDataAsset::EnhanceBombMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, DoubleItemMap) == 0x000208, "Member 'UGadgetParameterDataAsset::DoubleItemMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, DoubleItemOccasionallyMap) == 0x000258, "Member 'UGadgetParameterDataAsset::DoubleItemOccasionallyMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, CreateItemMap) == 0x0002A8, "Member 'UGadgetParameterDataAsset::CreateItemMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, UltimateDriftMap) == 0x0002F8, "Member 'UGadgetParameterDataAsset::UltimateDriftMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, QuickAirTrick_bMultiplyParameter) == 0x000348, "Member 'UGadgetParameterDataAsset::QuickAirTrick_bMultiplyParameter' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, QuickAirTrickMap) == 0x000350, "Member 'UGadgetParameterDataAsset::QuickAirTrickMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, SkateDriftMap) == 0x0003A0, "Member 'UGadgetParameterDataAsset::SkateDriftMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, JustDashMap) == 0x0003F0, "Member 'UGadgetParameterDataAsset::JustDashMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, FirstFastChargeMap) == 0x000440, "Member 'UGadgetParameterDataAsset::FirstFastChargeMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, SecondFastChargeMap) == 0x000490, "Member 'UGadgetParameterDataAsset::SecondFastChargeMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, ThirdFastChargeMap) == 0x0004E0, "Member 'UGadgetParameterDataAsset::ThirdFastChargeMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, SwitchDriftQuickChargeMap) == 0x000530, "Member 'UGadgetParameterDataAsset::SwitchDriftQuickChargeMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, HyperChargeMap) == 0x000580, "Member 'UGadgetParameterDataAsset::HyperChargeMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, SpinDriftMap) == 0x0005D0, "Member 'UGadgetParameterDataAsset::SpinDriftMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, ShortenDamageMotionMap) == 0x000620, "Member 'UGadgetParameterDataAsset::ShortenDamageMotionMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, SpeedTuneMap) == 0x000670, "Member 'UGadgetParameterDataAsset::SpeedTuneMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, AccelTuneMap) == 0x0006C0, "Member 'UGadgetParameterDataAsset::AccelTuneMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, HandlingTuneMap) == 0x000710, "Member 'UGadgetParameterDataAsset::HandlingTuneMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, PowerTuneMap) == 0x000760, "Member 'UGadgetParameterDataAsset::PowerTuneMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, DashTuneMap) == 0x0007B0, "Member 'UGadgetParameterDataAsset::DashTuneMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, StarterMap) == 0x000800, "Member 'UGadgetParameterDataAsset::StarterMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, SlowterMap) == 0x000850, "Member 'UGadgetParameterDataAsset::SlowterMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, ImmuneItemDamageOnceMap) == 0x0008A0, "Member 'UGadgetParameterDataAsset::ImmuneItemDamageOnceMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, TouchDashInfoMap) == 0x0008F0, "Member 'UGadgetParameterDataAsset::TouchDashInfoMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, EnforceSlipstreamMap) == 0x000940, "Member 'UGadgetParameterDataAsset::EnforceSlipstreamMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, EnhanceHookTurnMap) == 0x000990, "Member 'UGadgetParameterDataAsset::EnhanceHookTurnMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, BoatChargeJumpUpMap) == 0x0009E0, "Member 'UGadgetParameterDataAsset::BoatChargeJumpUpMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, RingDashUpMap) == 0x000A30, "Member 'UGadgetParameterDataAsset::RingDashUpMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, RingGuardMap) == 0x000A80, "Member 'UGadgetParameterDataAsset::RingGuardMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, RingUpperLimitMap) == 0x000AD0, "Member 'UGadgetParameterDataAsset::RingUpperLimitMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, RingStoleMap) == 0x000B20, "Member 'UGadgetParameterDataAsset::RingStoleMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, BonusDashPanelMap) == 0x000B70, "Member 'UGadgetParameterDataAsset::BonusDashPanelMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, BonusDashPanelComboMap) == 0x000BC0, "Member 'UGadgetParameterDataAsset::BonusDashPanelComboMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, RunoffNegateBonusMap) == 0x000C10, "Member 'UGadgetParameterDataAsset::RunoffNegateBonusMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, ExpandGetRingRangeMap) == 0x000C60, "Member 'UGadgetParameterDataAsset::ExpandGetRingRangeMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, BonusRotateRingMap) == 0x000CB0, "Member 'UGadgetParameterDataAsset::BonusRotateRingMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, SlipstreamBonusMap) == 0x000D00, "Member 'UGadgetParameterDataAsset::SlipstreamBonusMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, ItemAttackRingBonusMap) == 0x000D50, "Member 'UGadgetParameterDataAsset::ItemAttackRingBonusMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, BonusDriftJustMap) == 0x000DA0, "Member 'UGadgetParameterDataAsset::BonusDriftJustMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, BonusStartDashSucceedMap) == 0x000DF0, "Member 'UGadgetParameterDataAsset::BonusStartDashSucceedMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, BonusTravelRingMap) == 0x000E40, "Member 'UGadgetParameterDataAsset::BonusTravelRingMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, BonusTransformActionMap) == 0x000E90, "Member 'UGadgetParameterDataAsset::BonusTransformActionMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, DriftDashRingBonusMap) == 0x000EE0, "Member 'UGadgetParameterDataAsset::DriftDashRingBonusMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, SuppressRunoffMap) == 0x000F30, "Member 'UGadgetParameterDataAsset::SuppressRunoffMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, PlaneFormParamUPMap) == 0x000F80, "Member 'UGadgetParameterDataAsset::PlaneFormParamUPMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, BoatFormParamUPMap) == 0x000FD0, "Member 'UGadgetParameterDataAsset::BoatFormParamUPMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, SecondLapGetItemMap) == 0x001020, "Member 'UGadgetParameterDataAsset::SecondLapGetItemMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, ThirdLapGetItemMap) == 0x001070, "Member 'UGadgetParameterDataAsset::ThirdLapGetItemMap' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, ShortenDamagetTime) == 0x0010C0, "Member 'UGadgetParameterDataAsset::ShortenDamagetTime' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, LowRankRingBonus) == 0x0010D0, "Member 'UGadgetParameterDataAsset::LowRankRingBonus' has a wrong offset!");
static_assert(offsetof(UGadgetParameterDataAsset, ShortenItemSlotTime) == 0x0010F0, "Member 'UGadgetParameterDataAsset::ShortenItemSlotTime' has a wrong offset!");

// Class UnionRun.ItemTeamWarpRingObject
// 0x0210 (0x0780 - 0x0570)
class AItemTeamWarpRingObject : public AItemObjectBase
{
public:
	uint8                                         Pad_568[0x18];                                     // 0x0568(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Root;                                              // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        PerformanceObjectRoot;                             // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGOCMovement*                           Movement;                                          // 0x0590(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    SEWarping;                                         // 0x0598(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    SEWarpingLocal;                                    // 0x05A0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FItemWarpRingRankBaseParam>     RankBaseParam;                                     // 0x05A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MinLifeTimeNoTarget;                               // 0x05B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndDistanceToTarget;                               // 0x05BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveToPathMaxTime;                                 // 0x05C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveToPathAdjustDistanceTime;                      // 0x05C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveToPathAdjustDistance;                          // 0x05C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveToPathAdjustDistanceCanceled;                  // 0x05CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallAcceleration;                                  // 0x05D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFallSpeed;                                      // 0x05D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateSpeed;                                       // 0x05D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        CommonMoveSpeed;                                   // 0x05DC(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        PerformanceMoveSpeed;                              // 0x05EC(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        NoTargetMoveSpeed;                                 // 0x05FC(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        AvoidedMoveSpeed;                                  // 0x060C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseWarpCamera;                                    // 0x061C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61D[0x3];                                      // 0x061D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        UseEndCameraType;                                  // 0x0620(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndCameraRemoveTiming;                             // 0x0624(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDraw;                                        // 0x0628(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceEnd;                                         // 0x0629(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceEndImm;                                      // 0x062A(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInfinityWarp;                                     // 0x062B(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62C[0x4];                                      // 0x062C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AUnionCameraFocusOnTarget>  StartCameraClass;                                  // 0x0630(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AUnionCameraFocusOnTarget>  WarpCameraClass;                                   // 0x0638(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AUnionCameraFocusOnTarget>  EndCameraLookDownClass;                            // 0x0640(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AUnionCameraFocusOnTarget>  EndCameraLookUpClass;                              // 0x0648(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AUnionCameraFocusOnTarget*              StartCameraObject;                                 // 0x0650(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUnionCameraFocusOnTarget*              WarpCameraObject;                                  // 0x0658(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUnionCameraFocusOnTarget*              EndCameraObject;                                   // 0x0660(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_668[0x118];                                    // 0x0668(0x0118)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemTeamWarpRingObject">();
	}
	static class AItemTeamWarpRingObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemTeamWarpRingObject>();
	}
};
static_assert(alignof(AItemTeamWarpRingObject) == 0x000010, "Wrong alignment on AItemTeamWarpRingObject");
static_assert(sizeof(AItemTeamWarpRingObject) == 0x000780, "Wrong size on AItemTeamWarpRingObject");
static_assert(offsetof(AItemTeamWarpRingObject, Root) == 0x000580, "Member 'AItemTeamWarpRingObject::Root' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, PerformanceObjectRoot) == 0x000588, "Member 'AItemTeamWarpRingObject::PerformanceObjectRoot' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, Movement) == 0x000590, "Member 'AItemTeamWarpRingObject::Movement' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, SEWarping) == 0x000598, "Member 'AItemTeamWarpRingObject::SEWarping' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, SEWarpingLocal) == 0x0005A0, "Member 'AItemTeamWarpRingObject::SEWarpingLocal' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, RankBaseParam) == 0x0005A8, "Member 'AItemTeamWarpRingObject::RankBaseParam' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, MinLifeTimeNoTarget) == 0x0005B8, "Member 'AItemTeamWarpRingObject::MinLifeTimeNoTarget' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, EndDistanceToTarget) == 0x0005BC, "Member 'AItemTeamWarpRingObject::EndDistanceToTarget' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, MoveToPathMaxTime) == 0x0005C0, "Member 'AItemTeamWarpRingObject::MoveToPathMaxTime' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, MoveToPathAdjustDistanceTime) == 0x0005C4, "Member 'AItemTeamWarpRingObject::MoveToPathAdjustDistanceTime' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, MoveToPathAdjustDistance) == 0x0005C8, "Member 'AItemTeamWarpRingObject::MoveToPathAdjustDistance' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, MoveToPathAdjustDistanceCanceled) == 0x0005CC, "Member 'AItemTeamWarpRingObject::MoveToPathAdjustDistanceCanceled' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, FallAcceleration) == 0x0005D0, "Member 'AItemTeamWarpRingObject::FallAcceleration' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, MaxFallSpeed) == 0x0005D4, "Member 'AItemTeamWarpRingObject::MaxFallSpeed' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, RotateSpeed) == 0x0005D8, "Member 'AItemTeamWarpRingObject::RotateSpeed' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, CommonMoveSpeed) == 0x0005DC, "Member 'AItemTeamWarpRingObject::CommonMoveSpeed' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, PerformanceMoveSpeed) == 0x0005EC, "Member 'AItemTeamWarpRingObject::PerformanceMoveSpeed' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, NoTargetMoveSpeed) == 0x0005FC, "Member 'AItemTeamWarpRingObject::NoTargetMoveSpeed' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, AvoidedMoveSpeed) == 0x00060C, "Member 'AItemTeamWarpRingObject::AvoidedMoveSpeed' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, bUseWarpCamera) == 0x00061C, "Member 'AItemTeamWarpRingObject::bUseWarpCamera' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, UseEndCameraType) == 0x000620, "Member 'AItemTeamWarpRingObject::UseEndCameraType' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, EndCameraRemoveTiming) == 0x000624, "Member 'AItemTeamWarpRingObject::EndCameraRemoveTiming' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, bDebugDraw) == 0x000628, "Member 'AItemTeamWarpRingObject::bDebugDraw' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, bForceEnd) == 0x000629, "Member 'AItemTeamWarpRingObject::bForceEnd' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, bForceEndImm) == 0x00062A, "Member 'AItemTeamWarpRingObject::bForceEndImm' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, bInfinityWarp) == 0x00062B, "Member 'AItemTeamWarpRingObject::bInfinityWarp' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, StartCameraClass) == 0x000630, "Member 'AItemTeamWarpRingObject::StartCameraClass' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, WarpCameraClass) == 0x000638, "Member 'AItemTeamWarpRingObject::WarpCameraClass' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, EndCameraLookDownClass) == 0x000640, "Member 'AItemTeamWarpRingObject::EndCameraLookDownClass' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, EndCameraLookUpClass) == 0x000648, "Member 'AItemTeamWarpRingObject::EndCameraLookUpClass' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, StartCameraObject) == 0x000650, "Member 'AItemTeamWarpRingObject::StartCameraObject' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, WarpCameraObject) == 0x000658, "Member 'AItemTeamWarpRingObject::WarpCameraObject' has a wrong offset!");
static_assert(offsetof(AItemTeamWarpRingObject, EndCameraObject) == 0x000660, "Member 'AItemTeamWarpRingObject::EndCameraObject' has a wrong offset!");

// Class UnionRun.GadgetBoatJumpSplash
// 0x0008 (0x00A8 - 0x00A0)
class UGadgetBoatJumpSplash final : public UGadgetBase
{
public:
	class AGadgetBoatJumpSplashPeformance*        m_performanceObject;                               // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetBoatJumpSplash">();
	}
	static class UGadgetBoatJumpSplash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetBoatJumpSplash>();
	}
};
static_assert(alignof(UGadgetBoatJumpSplash) == 0x000008, "Wrong alignment on UGadgetBoatJumpSplash");
static_assert(sizeof(UGadgetBoatJumpSplash) == 0x0000A8, "Wrong size on UGadgetBoatJumpSplash");
static_assert(offsetof(UGadgetBoatJumpSplash, m_performanceObject) == 0x0000A0, "Member 'UGadgetBoatJumpSplash::m_performanceObject' has a wrong offset!");

// Class UnionRun.GadgetBoatJumpSplashPeformance
// 0x00A8 (0x0338 - 0x0290)
class AGadgetBoatJumpSplashPeformance final : public AActor
{
public:
	class UTriggerComponent*                      DamageTrigger;                                     // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      DamageEffect;                                      // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    ExplosionSound;                                    // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    ExplosionSoundLocal;                               // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionLifeTime;                                 // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionRadius;                                   // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionHeight;                                   // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RacerIndex;                                        // 0x02BC(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0[0x78];                                     // 0x02C0(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTriggerColliderConflict(const struct FHitTriggerInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetBoatJumpSplashPeformance">();
	}
	static class AGadgetBoatJumpSplashPeformance* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGadgetBoatJumpSplashPeformance>();
	}
};
static_assert(alignof(AGadgetBoatJumpSplashPeformance) == 0x000008, "Wrong alignment on AGadgetBoatJumpSplashPeformance");
static_assert(sizeof(AGadgetBoatJumpSplashPeformance) == 0x000338, "Wrong size on AGadgetBoatJumpSplashPeformance");
static_assert(offsetof(AGadgetBoatJumpSplashPeformance, DamageTrigger) == 0x000290, "Member 'AGadgetBoatJumpSplashPeformance::DamageTrigger' has a wrong offset!");
static_assert(offsetof(AGadgetBoatJumpSplashPeformance, DamageEffect) == 0x000298, "Member 'AGadgetBoatJumpSplashPeformance::DamageEffect' has a wrong offset!");
static_assert(offsetof(AGadgetBoatJumpSplashPeformance, ExplosionSound) == 0x0002A0, "Member 'AGadgetBoatJumpSplashPeformance::ExplosionSound' has a wrong offset!");
static_assert(offsetof(AGadgetBoatJumpSplashPeformance, ExplosionSoundLocal) == 0x0002A8, "Member 'AGadgetBoatJumpSplashPeformance::ExplosionSoundLocal' has a wrong offset!");
static_assert(offsetof(AGadgetBoatJumpSplashPeformance, ExplosionLifeTime) == 0x0002B0, "Member 'AGadgetBoatJumpSplashPeformance::ExplosionLifeTime' has a wrong offset!");
static_assert(offsetof(AGadgetBoatJumpSplashPeformance, ExplosionRadius) == 0x0002B4, "Member 'AGadgetBoatJumpSplashPeformance::ExplosionRadius' has a wrong offset!");
static_assert(offsetof(AGadgetBoatJumpSplashPeformance, ExplosionHeight) == 0x0002B8, "Member 'AGadgetBoatJumpSplashPeformance::ExplosionHeight' has a wrong offset!");
static_assert(offsetof(AGadgetBoatJumpSplashPeformance, RacerIndex) == 0x0002BC, "Member 'AGadgetBoatJumpSplashPeformance::RacerIndex' has a wrong offset!");

// Class UnionRun.GimmickTableSet
// 0x0090 (0x0640 - 0x05B0)
class alignas(0x10) AGimmickTableSet final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BreakActionTime;                                   // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERacerDamageType                              DamageType;                                        // 0x05BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5BD[0x3];                                      // 0x05BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              BodyStatickMeshComponent;                          // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              MainModelMeshComponent;                            // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            MainStaticBodyComponent;                           // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      CarHitEffect;                                      // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    HitSoundComponent;                                 // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E8[0x58];                                     // 0x05E8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickTableSet">();
	}
	static class AGimmickTableSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickTableSet>();
	}
};
static_assert(alignof(AGimmickTableSet) == 0x000010, "Wrong alignment on AGimmickTableSet");
static_assert(sizeof(AGimmickTableSet) == 0x000640, "Wrong size on AGimmickTableSet");
static_assert(offsetof(AGimmickTableSet, BreakActionTime) == 0x0005B8, "Member 'AGimmickTableSet::BreakActionTime' has a wrong offset!");
static_assert(offsetof(AGimmickTableSet, DamageType) == 0x0005BC, "Member 'AGimmickTableSet::DamageType' has a wrong offset!");
static_assert(offsetof(AGimmickTableSet, BodyStatickMeshComponent) == 0x0005C0, "Member 'AGimmickTableSet::BodyStatickMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickTableSet, MainModelMeshComponent) == 0x0005C8, "Member 'AGimmickTableSet::MainModelMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickTableSet, MainStaticBodyComponent) == 0x0005D0, "Member 'AGimmickTableSet::MainStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickTableSet, CarHitEffect) == 0x0005D8, "Member 'AGimmickTableSet::CarHitEffect' has a wrong offset!");
static_assert(offsetof(AGimmickTableSet, HitSoundComponent) == 0x0005E0, "Member 'AGimmickTableSet::HitSoundComponent' has a wrong offset!");

// Class UnionRun.GadgetBonusDashPanel
// 0x0010 (0x00B0 - 0x00A0)
class UGadgetBonusDashPanel final : public UGadgetBase
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetBonusDashPanel">();
	}
	static class UGadgetBonusDashPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetBonusDashPanel>();
	}
};
static_assert(alignof(UGadgetBonusDashPanel) == 0x000008, "Wrong alignment on UGadgetBonusDashPanel");
static_assert(sizeof(UGadgetBonusDashPanel) == 0x0000B0, "Wrong size on UGadgetBonusDashPanel");

// Class UnionRun.Gimmick_Extnd06_Gate
// 0x0070 (0x0620 - 0x05B0)
class alignas(0x10) AGimmick_Extnd06_Gate final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EAGimmick_Extnd06_Gate_Type                   Type;                                              // 0x05B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B9[0x7];                                      // 0x05B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGimmickStaticBodyComponent*            CollisionComponent;                                // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C8[0x58];                                     // 0x05C8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd06_Gate">();
	}
	static class AGimmick_Extnd06_Gate* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd06_Gate>();
	}
};
static_assert(alignof(AGimmick_Extnd06_Gate) == 0x000010, "Wrong alignment on AGimmick_Extnd06_Gate");
static_assert(sizeof(AGimmick_Extnd06_Gate) == 0x000620, "Wrong size on AGimmick_Extnd06_Gate");
static_assert(offsetof(AGimmick_Extnd06_Gate, Type) == 0x0005B8, "Member 'AGimmick_Extnd06_Gate::Type' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd06_Gate, CollisionComponent) == 0x0005C0, "Member 'AGimmick_Extnd06_Gate::CollisionComponent' has a wrong offset!");

// Class UnionRun.GadgetBonusDriftJust
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetBonusDriftJust final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetBonusDriftJust">();
	}
	static class UGadgetBonusDriftJust* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetBonusDriftJust>();
	}
};
static_assert(alignof(UGadgetBonusDriftJust) == 0x000008, "Wrong alignment on UGadgetBonusDriftJust");
static_assert(sizeof(UGadgetBonusDriftJust) == 0x0000A0, "Wrong size on UGadgetBonusDriftJust");

// Class UnionRun.GadgetBonusRotateRing
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetBonusRotateRing final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetBonusRotateRing">();
	}
	static class UGadgetBonusRotateRing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetBonusRotateRing>();
	}
};
static_assert(alignof(UGadgetBonusRotateRing) == 0x000008, "Wrong alignment on UGadgetBonusRotateRing");
static_assert(sizeof(UGadgetBonusRotateRing) == 0x0000A0, "Wrong size on UGadgetBonusRotateRing");

// Class UnionRun.GadgetBonusStartDashSecced
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetBonusStartDashSecced final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetBonusStartDashSecced">();
	}
	static class UGadgetBonusStartDashSecced* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetBonusStartDashSecced>();
	}
};
static_assert(alignof(UGadgetBonusStartDashSecced) == 0x000008, "Wrong alignment on UGadgetBonusStartDashSecced");
static_assert(sizeof(UGadgetBonusStartDashSecced) == 0x0000A0, "Wrong size on UGadgetBonusStartDashSecced");

// Class UnionRun.Gimmick_Extnd05_EnemyWarning
// 0x0010 (0x05C0 - 0x05B0)
class alignas(0x10) AGimmick_Extnd05_EnemyWarning final : public AUnionGimmickObjectBase
{
public:
	class UNiagaraComponent*                      AttackEffect;                                      // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WarningRadius;                                     // 0x05B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5BC[0x4];                                      // 0x05BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd05_EnemyWarning">();
	}
	static class AGimmick_Extnd05_EnemyWarning* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd05_EnemyWarning>();
	}
};
static_assert(alignof(AGimmick_Extnd05_EnemyWarning) == 0x000010, "Wrong alignment on AGimmick_Extnd05_EnemyWarning");
static_assert(sizeof(AGimmick_Extnd05_EnemyWarning) == 0x0005C0, "Wrong size on AGimmick_Extnd05_EnemyWarning");
static_assert(offsetof(AGimmick_Extnd05_EnemyWarning, AttackEffect) == 0x0005B0, "Member 'AGimmick_Extnd05_EnemyWarning::AttackEffect' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_EnemyWarning, WarningRadius) == 0x0005B8, "Member 'AGimmick_Extnd05_EnemyWarning::WarningRadius' has a wrong offset!");

// Class UnionRun.GadgetBonusTransformAction
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetBonusTransformAction final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetBonusTransformAction">();
	}
	static class UGadgetBonusTransformAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetBonusTransformAction>();
	}
};
static_assert(alignof(UGadgetBonusTransformAction) == 0x000008, "Wrong alignment on UGadgetBonusTransformAction");
static_assert(sizeof(UGadgetBonusTransformAction) == 0x0000A0, "Wrong size on UGadgetBonusTransformAction");

// Class UnionRun.UnionFloating
// 0x0038 (0x0070 - 0x0038)
class UUnionFloating final : public UMoveController
{
public:
	uint8                                         Pad_38[0x38];                                      // 0x0038(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionFloating">();
	}
	static class UUnionFloating* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionFloating>();
	}
};
static_assert(alignof(UUnionFloating) == 0x000008, "Wrong alignment on UUnionFloating");
static_assert(sizeof(UUnionFloating) == 0x000070, "Wrong size on UUnionFloating");

// Class UnionRun.GadgetBonusTravelRing
// 0x0008 (0x00A8 - 0x00A0)
class UGadgetBonusTravelRing final : public UGadgetBase
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetBonusTravelRing">();
	}
	static class UGadgetBonusTravelRing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetBonusTravelRing>();
	}
};
static_assert(alignof(UGadgetBonusTravelRing) == 0x000008, "Wrong alignment on UGadgetBonusTravelRing");
static_assert(sizeof(UGadgetBonusTravelRing) == 0x0000A8, "Wrong size on UGadgetBonusTravelRing");

// Class UnionRun.UnionHitWall
// 0x0030 (0x0068 - 0x0038)
class UUnionHitWall final : public UMoveController
{
public:
	uint8                                         Pad_38[0x30];                                      // 0x0038(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionHitWall">();
	}
	static class UUnionHitWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionHitWall>();
	}
};
static_assert(alignof(UUnionHitWall) == 0x000008, "Wrong alignment on UUnionHitWall");
static_assert(sizeof(UUnionHitWall) == 0x000068, "Wrong size on UUnionHitWall");

// Class UnionRun.ItemWhiteBoostObject
// 0x0060 (0x05D0 - 0x0570)
class AItemWhiteBoostObject : public AItemObjectBase
{
public:
	float                                         m_IntervalTile;                                    // 0x0568(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_WaitInput;                                       // 0x056C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_570[0x60];                                     // 0x0570(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayUsedItemSound();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemWhiteBoostObject">();
	}
	static class AItemWhiteBoostObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemWhiteBoostObject>();
	}
};
static_assert(alignof(AItemWhiteBoostObject) == 0x000010, "Wrong alignment on AItemWhiteBoostObject");
static_assert(sizeof(AItemWhiteBoostObject) == 0x0005D0, "Wrong size on AItemWhiteBoostObject");
static_assert(offsetof(AItemWhiteBoostObject, m_IntervalTile) == 0x000568, "Member 'AItemWhiteBoostObject::m_IntervalTile' has a wrong offset!");
static_assert(offsetof(AItemWhiteBoostObject, m_WaitInput) == 0x00056C, "Member 'AItemWhiteBoostObject::m_WaitInput' has a wrong offset!");

// Class UnionRun.GadgetComponent
// 0x0048 (0x00E8 - 0x00A0)
class UGadgetComponent final : public UActorComponent
{
public:
	int32                                         RacerIndex;                                        // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdate;                                           // 0x00A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDraw;                                        // 0x00A5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A6[0x2];                                       // 0x00A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              DebugScreenLocate;                                 // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGadgetBase*>                    m_equippedGadget;                                  // 0x00B8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class AGadgetRingPerformance*                 m_ringObject;                                      // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetComponent">();
	}
	static class UGadgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetComponent>();
	}
};
static_assert(alignof(UGadgetComponent) == 0x000008, "Wrong alignment on UGadgetComponent");
static_assert(sizeof(UGadgetComponent) == 0x0000E8, "Wrong size on UGadgetComponent");
static_assert(offsetof(UGadgetComponent, RacerIndex) == 0x0000A0, "Member 'UGadgetComponent::RacerIndex' has a wrong offset!");
static_assert(offsetof(UGadgetComponent, bUpdate) == 0x0000A4, "Member 'UGadgetComponent::bUpdate' has a wrong offset!");
static_assert(offsetof(UGadgetComponent, bDebugDraw) == 0x0000A5, "Member 'UGadgetComponent::bDebugDraw' has a wrong offset!");
static_assert(offsetof(UGadgetComponent, DebugScreenLocate) == 0x0000A8, "Member 'UGadgetComponent::DebugScreenLocate' has a wrong offset!");
static_assert(offsetof(UGadgetComponent, m_equippedGadget) == 0x0000B8, "Member 'UGadgetComponent::m_equippedGadget' has a wrong offset!");
static_assert(offsetof(UGadgetComponent, m_ringObject) == 0x0000C8, "Member 'UGadgetComponent::m_ringObject' has a wrong offset!");

// Class UnionRun.GadgetCourseOutGetWisp
// 0x0008 (0x00A8 - 0x00A0)
class UGadgetCourseOutGetWisp final : public UGadgetBase
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetCourseOutGetWisp">();
	}
	static class UGadgetCourseOutGetWisp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetCourseOutGetWisp>();
	}
};
static_assert(alignof(UGadgetCourseOutGetWisp) == 0x000008, "Wrong alignment on UGadgetCourseOutGetWisp");
static_assert(sizeof(UGadgetCourseOutGetWisp) == 0x0000A8, "Wrong size on UGadgetCourseOutGetWisp");

// Class UnionRun.GimmickTriggerMotionBase
// 0x0070 (0x0620 - 0x05B0)
#pragma pack(push, 0x1)
class alignas(0x10) AGimmickTriggerMotionBase : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _IntervalSec;                                      // 0x05B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETriggerMotionType                            _TriggerMotionType;                                // 0x05BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5BD[0x3];                                      // 0x05BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETriggerMotionState, float>              _PlayRateMap;                                      // 0x05C0(0x0050)(Edit, EditFixedSize, NativeAccessSpecifierPrivate)
	bool                                          _bIsTriggered;                                     // 0x0610(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bIsPlayIdle;                                      // 0x0611(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bIsPlayOneShot;                                   // 0x0612(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_613[0x1];                                      // 0x0613(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _TimeAfterTriggerSec;                              // 0x0614(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	float GetPlayRate(ETriggerMotionState State) const;
	ETriggerMotionType GetTriggerMotionType() const;
	bool IsPlayIdle() const;
	bool IsPlayOneShot() const;
	bool IsTriggered() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickTriggerMotionBase">();
	}
	static class AGimmickTriggerMotionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickTriggerMotionBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(AGimmickTriggerMotionBase) == 0x000010, "Wrong alignment on AGimmickTriggerMotionBase");
static_assert(sizeof(AGimmickTriggerMotionBase) == 0x000620, "Wrong size on AGimmickTriggerMotionBase");
static_assert(offsetof(AGimmickTriggerMotionBase, _IntervalSec) == 0x0005B8, "Member 'AGimmickTriggerMotionBase::_IntervalSec' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerMotionBase, _TriggerMotionType) == 0x0005BC, "Member 'AGimmickTriggerMotionBase::_TriggerMotionType' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerMotionBase, _PlayRateMap) == 0x0005C0, "Member 'AGimmickTriggerMotionBase::_PlayRateMap' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerMotionBase, _bIsTriggered) == 0x000610, "Member 'AGimmickTriggerMotionBase::_bIsTriggered' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerMotionBase, _bIsPlayIdle) == 0x000611, "Member 'AGimmickTriggerMotionBase::_bIsPlayIdle' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerMotionBase, _bIsPlayOneShot) == 0x000612, "Member 'AGimmickTriggerMotionBase::_bIsPlayOneShot' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerMotionBase, _TimeAfterTriggerSec) == 0x000614, "Member 'AGimmickTriggerMotionBase::_TimeAfterTriggerSec' has a wrong offset!");

// Class UnionRun.GimmickTriggerMotionVAT
// 0x0060 (0x0680 - 0x0620)
class AGimmickTriggerMotionVAT final : public AGimmickTriggerMotionBase
{
public:
	class UUnionVATMeshComponent*                 _VATMeshComponent;                                 // 0x0618(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<ETriggerMotionState, int32>              _AnimationIndexMap;                                // 0x0620(0x0050)(Edit, EditFixedSize, NativeAccessSpecifierPrivate)
	bool                                          _bUseNoTriggerState;                               // 0x0670(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bUseEndState;                                     // 0x0671(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bIsPlaying;                                       // 0x0672(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_673[0x1];                                      // 0x0673(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _PrevPosition;                                     // 0x0674(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETriggerMotionState                           _TriggerMotionState;                               // 0x0678(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETriggerMotionState                           _PrevTriggerMotionState;                           // 0x0679(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_67A[0x6];                                      // 0x067A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnVATSequence(class UUnionVATMeshComponent* VATMeshComponent, const struct FUnionVATSequenceInfo& SequenceInfo);
	void UpdateState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickTriggerMotionVAT">();
	}
	static class AGimmickTriggerMotionVAT* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickTriggerMotionVAT>();
	}
};
static_assert(alignof(AGimmickTriggerMotionVAT) == 0x000010, "Wrong alignment on AGimmickTriggerMotionVAT");
static_assert(sizeof(AGimmickTriggerMotionVAT) == 0x000680, "Wrong size on AGimmickTriggerMotionVAT");
static_assert(offsetof(AGimmickTriggerMotionVAT, _VATMeshComponent) == 0x000618, "Member 'AGimmickTriggerMotionVAT::_VATMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerMotionVAT, _AnimationIndexMap) == 0x000620, "Member 'AGimmickTriggerMotionVAT::_AnimationIndexMap' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerMotionVAT, _bUseNoTriggerState) == 0x000670, "Member 'AGimmickTriggerMotionVAT::_bUseNoTriggerState' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerMotionVAT, _bUseEndState) == 0x000671, "Member 'AGimmickTriggerMotionVAT::_bUseEndState' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerMotionVAT, _bIsPlaying) == 0x000672, "Member 'AGimmickTriggerMotionVAT::_bIsPlaying' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerMotionVAT, _PrevPosition) == 0x000674, "Member 'AGimmickTriggerMotionVAT::_PrevPosition' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerMotionVAT, _TriggerMotionState) == 0x000678, "Member 'AGimmickTriggerMotionVAT::_TriggerMotionState' has a wrong offset!");
static_assert(offsetof(AGimmickTriggerMotionVAT, _PrevTriggerMotionState) == 0x000679, "Member 'AGimmickTriggerMotionVAT::_PrevTriggerMotionState' has a wrong offset!");

// Class UnionRun.GadgetCreateItem
// 0x00F0 (0x0190 - 0x00A0)
class UGadgetCreateItem final : public UGadgetBase
{
public:
	uint8                                         Pad_A0[0xF0];                                      // 0x00A0(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetCreateItem">();
	}
	static class UGadgetCreateItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetCreateItem>();
	}
};
static_assert(alignof(UGadgetCreateItem) == 0x000008, "Wrong alignment on UGadgetCreateItem");
static_assert(sizeof(UGadgetCreateItem) == 0x000190, "Wrong size on UGadgetCreateItem");

// Class UnionRun.GimmickRollerCoaster
// 0x00E0 (0x0690 - 0x05B0)
class alignas(0x10) AGimmickRollerCoaster final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              _StaticMeshComponent;                              // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            _GimmickStaticBodyComponent;                       // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    _UnionAtomComponent;                               // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _JumpHeight;                                       // 0x05D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _JumpDuration;                                     // 0x05D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _HoveringDuration;                                 // 0x05D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _FallDuration;                                     // 0x05DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _NumberOfBounces;                                  // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _RestitutionCoefficient;                           // 0x05E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _RotationPitchDeg;                                 // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _RotationRollDeg;                                  // 0x05EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F0[0xA0];                                     // 0x05F0(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickRollerCoaster">();
	}
	static class AGimmickRollerCoaster* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickRollerCoaster>();
	}
};
static_assert(alignof(AGimmickRollerCoaster) == 0x000010, "Wrong alignment on AGimmickRollerCoaster");
static_assert(sizeof(AGimmickRollerCoaster) == 0x000690, "Wrong size on AGimmickRollerCoaster");
static_assert(offsetof(AGimmickRollerCoaster, _StaticMeshComponent) == 0x0005B8, "Member 'AGimmickRollerCoaster::_StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickRollerCoaster, _GimmickStaticBodyComponent) == 0x0005C0, "Member 'AGimmickRollerCoaster::_GimmickStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickRollerCoaster, _UnionAtomComponent) == 0x0005C8, "Member 'AGimmickRollerCoaster::_UnionAtomComponent' has a wrong offset!");
static_assert(offsetof(AGimmickRollerCoaster, _JumpHeight) == 0x0005D0, "Member 'AGimmickRollerCoaster::_JumpHeight' has a wrong offset!");
static_assert(offsetof(AGimmickRollerCoaster, _JumpDuration) == 0x0005D4, "Member 'AGimmickRollerCoaster::_JumpDuration' has a wrong offset!");
static_assert(offsetof(AGimmickRollerCoaster, _HoveringDuration) == 0x0005D8, "Member 'AGimmickRollerCoaster::_HoveringDuration' has a wrong offset!");
static_assert(offsetof(AGimmickRollerCoaster, _FallDuration) == 0x0005DC, "Member 'AGimmickRollerCoaster::_FallDuration' has a wrong offset!");
static_assert(offsetof(AGimmickRollerCoaster, _NumberOfBounces) == 0x0005E0, "Member 'AGimmickRollerCoaster::_NumberOfBounces' has a wrong offset!");
static_assert(offsetof(AGimmickRollerCoaster, _RestitutionCoefficient) == 0x0005E4, "Member 'AGimmickRollerCoaster::_RestitutionCoefficient' has a wrong offset!");
static_assert(offsetof(AGimmickRollerCoaster, _RotationPitchDeg) == 0x0005E8, "Member 'AGimmickRollerCoaster::_RotationPitchDeg' has a wrong offset!");
static_assert(offsetof(AGimmickRollerCoaster, _RotationRollDeg) == 0x0005EC, "Member 'AGimmickRollerCoaster::_RotationRollDeg' has a wrong offset!");

// Class UnionRun.GadgetDashTune
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetDashTune final : public UGadgetMachineTuneBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetDashTune">();
	}
	static class UGadgetDashTune* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetDashTune>();
	}
};
static_assert(alignof(UGadgetDashTune) == 0x000008, "Wrong alignment on UGadgetDashTune");
static_assert(sizeof(UGadgetDashTune) == 0x0000A0, "Wrong size on UGadgetDashTune");

// Class UnionRun.GadgetDashUp
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetDashUp final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetDashUp">();
	}
	static class UGadgetDashUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetDashUp>();
	}
};
static_assert(alignof(UGadgetDashUp) == 0x000008, "Wrong alignment on UGadgetDashUp");
static_assert(sizeof(UGadgetDashUp) == 0x0000A0, "Wrong size on UGadgetDashUp");

// Class UnionRun.GadgetDoubleItem
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetDoubleItem final : public UGadgetMachineTuneBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetDoubleItem">();
	}
	static class UGadgetDoubleItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetDoubleItem>();
	}
};
static_assert(alignof(UGadgetDoubleItem) == 0x000008, "Wrong alignment on UGadgetDoubleItem");
static_assert(sizeof(UGadgetDoubleItem) == 0x0000A0, "Wrong size on UGadgetDoubleItem");

// Class UnionRun.Gimmick_Extnd06_Barricade
// 0x00C0 (0x0670 - 0x05B0)
class alignas(0x10) AGimmick_Extnd06_Barricade final : public AUnionGimmickObjectBase
{
public:
	TMap<EGimmick_Extnd06_Barricade_Type, class UStaticMesh*> ModelByType;                           // 0x05B0(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<EGimmick_Extnd06_Barricade_Type, struct FGimmick_Extnd06_Barricade_Size> CollisionExtentsByType; // 0x0600(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	EGimmick_Extnd06_Barricade_Type               Type;                                              // 0x0650(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_651[0x7];                                      // 0x0651(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              ModelComponent;                                    // 0x0658(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            CollisionComponent;                                // 0x0660(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_668[0x8];                                      // 0x0668(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd06_Barricade">();
	}
	static class AGimmick_Extnd06_Barricade* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd06_Barricade>();
	}
};
static_assert(alignof(AGimmick_Extnd06_Barricade) == 0x000010, "Wrong alignment on AGimmick_Extnd06_Barricade");
static_assert(sizeof(AGimmick_Extnd06_Barricade) == 0x000670, "Wrong size on AGimmick_Extnd06_Barricade");
static_assert(offsetof(AGimmick_Extnd06_Barricade, ModelByType) == 0x0005B0, "Member 'AGimmick_Extnd06_Barricade::ModelByType' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd06_Barricade, CollisionExtentsByType) == 0x000600, "Member 'AGimmick_Extnd06_Barricade::CollisionExtentsByType' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd06_Barricade, Type) == 0x000650, "Member 'AGimmick_Extnd06_Barricade::Type' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd06_Barricade, ModelComponent) == 0x000658, "Member 'AGimmick_Extnd06_Barricade::ModelComponent' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd06_Barricade, CollisionComponent) == 0x000660, "Member 'AGimmick_Extnd06_Barricade::CollisionComponent' has a wrong offset!");

// Class UnionRun.GadgetDoubleItemOccasionally
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetDoubleItemOccasionally final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetDoubleItemOccasionally">();
	}
	static class UGadgetDoubleItemOccasionally* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetDoubleItemOccasionally>();
	}
};
static_assert(alignof(UGadgetDoubleItemOccasionally) == 0x000008, "Wrong alignment on UGadgetDoubleItemOccasionally");
static_assert(sizeof(UGadgetDoubleItemOccasionally) == 0x0000A0, "Wrong size on UGadgetDoubleItemOccasionally");

// Class UnionRun.UnionHitSlide
// 0x0030 (0x0068 - 0x0038)
class UUnionHitSlide final : public UMoveController
{
public:
	uint8                                         Pad_38[0x30];                                      // 0x0038(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionHitSlide">();
	}
	static class UUnionHitSlide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionHitSlide>();
	}
};
static_assert(alignof(UUnionHitSlide) == 0x000008, "Wrong alignment on UUnionHitSlide");
static_assert(sizeof(UUnionHitSlide) == 0x000068, "Wrong size on UUnionHitSlide");

// Class UnionRun.GadgetDoubleRing
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetDoubleRing final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetDoubleRing">();
	}
	static class UGadgetDoubleRing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetDoubleRing>();
	}
};
static_assert(alignof(UGadgetDoubleRing) == 0x000008, "Wrong alignment on UGadgetDoubleRing");
static_assert(sizeof(UGadgetDoubleRing) == 0x0000A0, "Wrong size on UGadgetDoubleRing");

// Class UnionRun.UnionItemSystemManager
// 0x1498 (0x14C0 - 0x0028)
class UUnionItemSystemManager final : public UObject
{
public:
	uint8                                         Pad_28[0x240];                                     // 0x0028(0x0240)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EItemId, class UItemObjectLayer*>        m_itemObjLayers;                                   // 0x0268(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FCreateItemInfo>                m_createItemQueueList;                             // 0x02B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EItemId, int32>                          m_exclusiveCreateItemMap;                          // 0x02D0(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_320[0xC0];                                     // 0x0320(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	class AItemLotteryObject*                     m_lotteryObject;                                   // 0x03E0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AItemBootDataObject*                    m_bootDataObject;                                  // 0x03E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0xFC0];                                    // 0x03F0(0x0FC0)(Fixing Size After Last Property [ Dumper-7 ])
	class ADroppedItemBoxFactory*                 m_droppedItemBoxFactory;                           // 0x13B0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class UObject*>                          m_attackItemObjects;                               // 0x13B8(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1408[0x30];                                    // 0x1408(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UDebugItemMenu*                         m_dbgMenu;                                         // 0x1438(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1440[0x80];                                    // 0x1440(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DbgDrawSwitch();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionItemSystemManager">();
	}
	static class UUnionItemSystemManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionItemSystemManager>();
	}
};
static_assert(alignof(UUnionItemSystemManager) == 0x000008, "Wrong alignment on UUnionItemSystemManager");
static_assert(sizeof(UUnionItemSystemManager) == 0x0014C0, "Wrong size on UUnionItemSystemManager");
static_assert(offsetof(UUnionItemSystemManager, m_itemObjLayers) == 0x000268, "Member 'UUnionItemSystemManager::m_itemObjLayers' has a wrong offset!");
static_assert(offsetof(UUnionItemSystemManager, m_createItemQueueList) == 0x0002B8, "Member 'UUnionItemSystemManager::m_createItemQueueList' has a wrong offset!");
static_assert(offsetof(UUnionItemSystemManager, m_exclusiveCreateItemMap) == 0x0002D0, "Member 'UUnionItemSystemManager::m_exclusiveCreateItemMap' has a wrong offset!");
static_assert(offsetof(UUnionItemSystemManager, m_lotteryObject) == 0x0003E0, "Member 'UUnionItemSystemManager::m_lotteryObject' has a wrong offset!");
static_assert(offsetof(UUnionItemSystemManager, m_bootDataObject) == 0x0003E8, "Member 'UUnionItemSystemManager::m_bootDataObject' has a wrong offset!");
static_assert(offsetof(UUnionItemSystemManager, m_droppedItemBoxFactory) == 0x0013B0, "Member 'UUnionItemSystemManager::m_droppedItemBoxFactory' has a wrong offset!");
static_assert(offsetof(UUnionItemSystemManager, m_attackItemObjects) == 0x0013B8, "Member 'UUnionItemSystemManager::m_attackItemObjects' has a wrong offset!");
static_assert(offsetof(UUnionItemSystemManager, m_dbgMenu) == 0x001438, "Member 'UUnionItemSystemManager::m_dbgMenu' has a wrong offset!");

// Class UnionRun.NalAnimInstance
// 0x0000 (0x0370 - 0x0370)
class UNalAnimInstance final : public UEnemyAnimInstance
{
public:
	bool IsTakeDamageMotion() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NalAnimInstance">();
	}
	static class UNalAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNalAnimInstance>();
	}
};
static_assert(alignof(UNalAnimInstance) == 0x000010, "Wrong alignment on UNalAnimInstance");
static_assert(sizeof(UNalAnimInstance) == 0x000370, "Wrong size on UNalAnimInstance");

// Class UnionRun.GadgetDriftDashBonus
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetDriftDashBonus final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetDriftDashBonus">();
	}
	static class UGadgetDriftDashBonus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetDriftDashBonus>();
	}
};
static_assert(alignof(UGadgetDriftDashBonus) == 0x000008, "Wrong alignment on UGadgetDriftDashBonus");
static_assert(sizeof(UGadgetDriftDashBonus) == 0x0000A0, "Wrong size on UGadgetDriftDashBonus");

// Class UnionRun.UnionFlightCourseDebugDisp
// 0x0038 (0x02C8 - 0x0290)
class AUnionFlightCourseDebugDisp final : public AActor
{
public:
	class AActor*                                 SplineActor;                                       // 0x0290(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProceduralMeshComponent*               DispMesh;                                          // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSplinePointParam>              PointParam;                                        // 0x02A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         CylinderSplitNum;                                  // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterial*                              Material;                                          // 0x02B8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseAssistLength;                                  // 0x02C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AssistLength;                                      // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetUseAssistLength(bool flag);
	void UpdateDispMesh();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionFlightCourseDebugDisp">();
	}
	static class AUnionFlightCourseDebugDisp* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnionFlightCourseDebugDisp>();
	}
};
static_assert(alignof(AUnionFlightCourseDebugDisp) == 0x000008, "Wrong alignment on AUnionFlightCourseDebugDisp");
static_assert(sizeof(AUnionFlightCourseDebugDisp) == 0x0002C8, "Wrong size on AUnionFlightCourseDebugDisp");
static_assert(offsetof(AUnionFlightCourseDebugDisp, SplineActor) == 0x000290, "Member 'AUnionFlightCourseDebugDisp::SplineActor' has a wrong offset!");
static_assert(offsetof(AUnionFlightCourseDebugDisp, DispMesh) == 0x000298, "Member 'AUnionFlightCourseDebugDisp::DispMesh' has a wrong offset!");
static_assert(offsetof(AUnionFlightCourseDebugDisp, PointParam) == 0x0002A0, "Member 'AUnionFlightCourseDebugDisp::PointParam' has a wrong offset!");
static_assert(offsetof(AUnionFlightCourseDebugDisp, CylinderSplitNum) == 0x0002B0, "Member 'AUnionFlightCourseDebugDisp::CylinderSplitNum' has a wrong offset!");
static_assert(offsetof(AUnionFlightCourseDebugDisp, Material) == 0x0002B8, "Member 'AUnionFlightCourseDebugDisp::Material' has a wrong offset!");
static_assert(offsetof(AUnionFlightCourseDebugDisp, bUseAssistLength) == 0x0002C0, "Member 'AUnionFlightCourseDebugDisp::bUseAssistLength' has a wrong offset!");
static_assert(offsetof(AUnionFlightCourseDebugDisp, AssistLength) == 0x0002C4, "Member 'AUnionFlightCourseDebugDisp::AssistLength' has a wrong offset!");

// Class UnionRun.GadgetEnforceSlipstream
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetEnforceSlipstream final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetEnforceSlipstream">();
	}
	static class UGadgetEnforceSlipstream* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetEnforceSlipstream>();
	}
};
static_assert(alignof(UGadgetEnforceSlipstream) == 0x000008, "Wrong alignment on UGadgetEnforceSlipstream");
static_assert(sizeof(UGadgetEnforceSlipstream) == 0x0000A0, "Wrong size on UGadgetEnforceSlipstream");

// Class UnionRun.ItemPackageRingObject
// 0x0060 (0x05D0 - 0x0570)
class AItemPackageRingObject : public AItemObjectBase
{
public:
	int32                                         SoundPlayCount;                                    // 0x0568(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitStartSound;                                    // 0x056C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoundInterval;                                     // 0x0570(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_574[0x5C];                                     // 0x0574(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemPackageRingObject">();
	}
	static class AItemPackageRingObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemPackageRingObject>();
	}
};
static_assert(alignof(AItemPackageRingObject) == 0x000010, "Wrong alignment on AItemPackageRingObject");
static_assert(sizeof(AItemPackageRingObject) == 0x0005D0, "Wrong size on AItemPackageRingObject");
static_assert(offsetof(AItemPackageRingObject, SoundPlayCount) == 0x000568, "Member 'AItemPackageRingObject::SoundPlayCount' has a wrong offset!");
static_assert(offsetof(AItemPackageRingObject, WaitStartSound) == 0x00056C, "Member 'AItemPackageRingObject::WaitStartSound' has a wrong offset!");
static_assert(offsetof(AItemPackageRingObject, SoundInterval) == 0x000570, "Member 'AItemPackageRingObject::SoundInterval' has a wrong offset!");

// Class UnionRun.GadgetEnhanceBomb
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetEnhanceBomb final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetEnhanceBomb">();
	}
	static class UGadgetEnhanceBomb* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetEnhanceBomb>();
	}
};
static_assert(alignof(UGadgetEnhanceBomb) == 0x000008, "Wrong alignment on UGadgetEnhanceBomb");
static_assert(sizeof(UGadgetEnhanceBomb) == 0x0000A0, "Wrong size on UGadgetEnhanceBomb");

// Class UnionRun.GimmickStartDoor
// 0x0120 (0x06D0 - 0x05B0)
class alignas(0x10) AGimmickStartDoor final : public AUnionGimmickObjectBase
{
public:
	class USceneComponent*                        Root;                                              // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              DoorGateMesh;                                      // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              DoorGearMesh;                                      // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              DoorLeftMesh;                                      // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              DoorRightMesh;                                     // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    Sound;                                             // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Opened;                                            // 0x05E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E1[0x3];                                      // 0x05E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayTime;                                         // 0x05E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpenTime;                                          // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5EC[0x4];                                      // 0x05EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LeftDoorTargetRot;                                 // 0x05F0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightDoorTargetRot;                                // 0x0608(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GearTargetRot;                                     // 0x0620(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveTable*                            OpenCurveTable;                                    // 0x0638(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DoorMarkMaterialIndex;                             // 0x0640(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloseDoorMarkValue;                                // 0x0644(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpenDoorMarkValue;                                 // 0x0648(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChangeOpenDoorMarkThreshold;                       // 0x064C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_650[0x80];                                     // 0x0650(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickStartDoor">();
	}
	static class AGimmickStartDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickStartDoor>();
	}
};
static_assert(alignof(AGimmickStartDoor) == 0x000010, "Wrong alignment on AGimmickStartDoor");
static_assert(sizeof(AGimmickStartDoor) == 0x0006D0, "Wrong size on AGimmickStartDoor");
static_assert(offsetof(AGimmickStartDoor, Root) == 0x0005B0, "Member 'AGimmickStartDoor::Root' has a wrong offset!");
static_assert(offsetof(AGimmickStartDoor, DoorGateMesh) == 0x0005B8, "Member 'AGimmickStartDoor::DoorGateMesh' has a wrong offset!");
static_assert(offsetof(AGimmickStartDoor, DoorGearMesh) == 0x0005C0, "Member 'AGimmickStartDoor::DoorGearMesh' has a wrong offset!");
static_assert(offsetof(AGimmickStartDoor, DoorLeftMesh) == 0x0005C8, "Member 'AGimmickStartDoor::DoorLeftMesh' has a wrong offset!");
static_assert(offsetof(AGimmickStartDoor, DoorRightMesh) == 0x0005D0, "Member 'AGimmickStartDoor::DoorRightMesh' has a wrong offset!");
static_assert(offsetof(AGimmickStartDoor, Sound) == 0x0005D8, "Member 'AGimmickStartDoor::Sound' has a wrong offset!");
static_assert(offsetof(AGimmickStartDoor, Opened) == 0x0005E0, "Member 'AGimmickStartDoor::Opened' has a wrong offset!");
static_assert(offsetof(AGimmickStartDoor, DelayTime) == 0x0005E4, "Member 'AGimmickStartDoor::DelayTime' has a wrong offset!");
static_assert(offsetof(AGimmickStartDoor, OpenTime) == 0x0005E8, "Member 'AGimmickStartDoor::OpenTime' has a wrong offset!");
static_assert(offsetof(AGimmickStartDoor, LeftDoorTargetRot) == 0x0005F0, "Member 'AGimmickStartDoor::LeftDoorTargetRot' has a wrong offset!");
static_assert(offsetof(AGimmickStartDoor, RightDoorTargetRot) == 0x000608, "Member 'AGimmickStartDoor::RightDoorTargetRot' has a wrong offset!");
static_assert(offsetof(AGimmickStartDoor, GearTargetRot) == 0x000620, "Member 'AGimmickStartDoor::GearTargetRot' has a wrong offset!");
static_assert(offsetof(AGimmickStartDoor, OpenCurveTable) == 0x000638, "Member 'AGimmickStartDoor::OpenCurveTable' has a wrong offset!");
static_assert(offsetof(AGimmickStartDoor, DoorMarkMaterialIndex) == 0x000640, "Member 'AGimmickStartDoor::DoorMarkMaterialIndex' has a wrong offset!");
static_assert(offsetof(AGimmickStartDoor, CloseDoorMarkValue) == 0x000644, "Member 'AGimmickStartDoor::CloseDoorMarkValue' has a wrong offset!");
static_assert(offsetof(AGimmickStartDoor, OpenDoorMarkValue) == 0x000648, "Member 'AGimmickStartDoor::OpenDoorMarkValue' has a wrong offset!");
static_assert(offsetof(AGimmickStartDoor, ChangeOpenDoorMarkThreshold) == 0x00064C, "Member 'AGimmickStartDoor::ChangeOpenDoorMarkThreshold' has a wrong offset!");

// Class UnionRun.GadgetEnhanceHookTurn
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetEnhanceHookTurn final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetEnhanceHookTurn">();
	}
	static class UGadgetEnhanceHookTurn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetEnhanceHookTurn>();
	}
};
static_assert(alignof(UGadgetEnhanceHookTurn) == 0x000008, "Wrong alignment on UGadgetEnhanceHookTurn");
static_assert(sizeof(UGadgetEnhanceHookTurn) == 0x0000A0, "Wrong size on UGadgetEnhanceHookTurn");

// Class UnionRun.GadgetEnhanceRocketPuntch
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetEnhanceRocketPuntch final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetEnhanceRocketPuntch">();
	}
	static class UGadgetEnhanceRocketPuntch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetEnhanceRocketPuntch>();
	}
};
static_assert(alignof(UGadgetEnhanceRocketPuntch) == 0x000008, "Wrong alignment on UGadgetEnhanceRocketPuntch");
static_assert(sizeof(UGadgetEnhanceRocketPuntch) == 0x0000A0, "Wrong size on UGadgetEnhanceRocketPuntch");

// Class UnionRun.GadgetEnhanceThornBall
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetEnhanceThornBall final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetEnhanceThornBall">();
	}
	static class UGadgetEnhanceThornBall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetEnhanceThornBall>();
	}
};
static_assert(alignof(UGadgetEnhanceThornBall) == 0x000008, "Wrong alignment on UGadgetEnhanceThornBall");
static_assert(sizeof(UGadgetEnhanceThornBall) == 0x0000A0, "Wrong size on UGadgetEnhanceThornBall");

// Class UnionRun.GuidedJumpStandObject
// 0x0030 (0x05E0 - 0x05B0)
class alignas(0x10) AGuidedJumpStandObject final : public AUnionGimmickObjectBase
{
public:
	class UUnionStaticMeshComponent*              DrawStaticMeshComponent;                           // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_bNoCollision;                                    // 0x05B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_bCollisionOnly;                                  // 0x05B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5BA[0x6];                                      // 0x05BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            StaticBodyComponent;                               // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        ParamId;                                           // 0x05D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D4[0xC];                                      // 0x05D4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuidedJumpStandObject">();
	}
	static class AGuidedJumpStandObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGuidedJumpStandObject>();
	}
};
static_assert(alignof(AGuidedJumpStandObject) == 0x000010, "Wrong alignment on AGuidedJumpStandObject");
static_assert(sizeof(AGuidedJumpStandObject) == 0x0005E0, "Wrong size on AGuidedJumpStandObject");
static_assert(offsetof(AGuidedJumpStandObject, DrawStaticMeshComponent) == 0x0005B0, "Member 'AGuidedJumpStandObject::DrawStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGuidedJumpStandObject, m_bNoCollision) == 0x0005B8, "Member 'AGuidedJumpStandObject::m_bNoCollision' has a wrong offset!");
static_assert(offsetof(AGuidedJumpStandObject, m_bCollisionOnly) == 0x0005B9, "Member 'AGuidedJumpStandObject::m_bCollisionOnly' has a wrong offset!");
static_assert(offsetof(AGuidedJumpStandObject, DefaultSceneRoot) == 0x0005C0, "Member 'AGuidedJumpStandObject::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AGuidedJumpStandObject, StaticBodyComponent) == 0x0005C8, "Member 'AGuidedJumpStandObject::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGuidedJumpStandObject, ParamId) == 0x0005D0, "Member 'AGuidedJumpStandObject::ParamId' has a wrong offset!");

// Class UnionRun.GadgetExpandGetRingRange
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetExpandGetRingRange final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetExpandGetRingRange">();
	}
	static class UGadgetExpandGetRingRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetExpandGetRingRange>();
	}
};
static_assert(alignof(UGadgetExpandGetRingRange) == 0x000008, "Wrong alignment on UGadgetExpandGetRingRange");
static_assert(sizeof(UGadgetExpandGetRingRange) == 0x0000A0, "Wrong size on UGadgetExpandGetRingRange");

// Class UnionRun.ItemLockOnDataAsset
// 0x0148 (0x0178 - 0x0030)
class UItemLockOnDataAsset final : public UDataAsset
{
public:
	float                                         AfterShotUICoolTime;                               // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckAheadDistance;                                // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSnapLockOnToTarget;                               // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LockOnChangeTime;                                  // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLockOnParamMachineForm                LockOnParam_Car;                                   // 0x0040(0x0068)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FLockOnParamMachineForm                LockOnParam_Boat;                                  // 0x00A8(0x0068)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FLockOnParamMachineForm                LockOnParam_Plane;                                 // 0x0110(0x0068)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemLockOnDataAsset">();
	}
	static class UItemLockOnDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemLockOnDataAsset>();
	}
};
static_assert(alignof(UItemLockOnDataAsset) == 0x000008, "Wrong alignment on UItemLockOnDataAsset");
static_assert(sizeof(UItemLockOnDataAsset) == 0x000178, "Wrong size on UItemLockOnDataAsset");
static_assert(offsetof(UItemLockOnDataAsset, AfterShotUICoolTime) == 0x000030, "Member 'UItemLockOnDataAsset::AfterShotUICoolTime' has a wrong offset!");
static_assert(offsetof(UItemLockOnDataAsset, CheckAheadDistance) == 0x000034, "Member 'UItemLockOnDataAsset::CheckAheadDistance' has a wrong offset!");
static_assert(offsetof(UItemLockOnDataAsset, bSnapLockOnToTarget) == 0x000038, "Member 'UItemLockOnDataAsset::bSnapLockOnToTarget' has a wrong offset!");
static_assert(offsetof(UItemLockOnDataAsset, LockOnChangeTime) == 0x00003C, "Member 'UItemLockOnDataAsset::LockOnChangeTime' has a wrong offset!");
static_assert(offsetof(UItemLockOnDataAsset, LockOnParam_Car) == 0x000040, "Member 'UItemLockOnDataAsset::LockOnParam_Car' has a wrong offset!");
static_assert(offsetof(UItemLockOnDataAsset, LockOnParam_Boat) == 0x0000A8, "Member 'UItemLockOnDataAsset::LockOnParam_Boat' has a wrong offset!");
static_assert(offsetof(UItemLockOnDataAsset, LockOnParam_Plane) == 0x000110, "Member 'UItemLockOnDataAsset::LockOnParam_Plane' has a wrong offset!");

// Class UnionRun.GadgetFirstFastCharge
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetFirstFastCharge final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetFirstFastCharge">();
	}
	static class UGadgetFirstFastCharge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetFirstFastCharge>();
	}
};
static_assert(alignof(UGadgetFirstFastCharge) == 0x000008, "Wrong alignment on UGadgetFirstFastCharge");
static_assert(sizeof(UGadgetFirstFastCharge) == 0x0000A0, "Wrong size on UGadgetFirstFastCharge");

// Class UnionRun.UnionNavigationBinaryDataAsset
// 0x0018 (0x0040 - 0x0028)
class UUnionNavigationBinaryDataAsset final : public UObject
{
public:
	struct FUnionNavigationBinaryParameter        Parameter;                                         // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionNavigationBinaryDataAsset">();
	}
	static class UUnionNavigationBinaryDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionNavigationBinaryDataAsset>();
	}
};
static_assert(alignof(UUnionNavigationBinaryDataAsset) == 0x000008, "Wrong alignment on UUnionNavigationBinaryDataAsset");
static_assert(sizeof(UUnionNavigationBinaryDataAsset) == 0x000040, "Wrong size on UUnionNavigationBinaryDataAsset");
static_assert(offsetof(UUnionNavigationBinaryDataAsset, Parameter) == 0x000028, "Member 'UUnionNavigationBinaryDataAsset::Parameter' has a wrong offset!");

// Class UnionRun.ItemAnchorObject
// 0x0420 (0x0990 - 0x0570)
class AItemAnchorObject final : public AItemObjectBase
{
public:
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        m_Root;                                            // 0x0570(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        m_anchorRoot;                                      // 0x0578(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   m_anchor;                                          // 0x0580(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChildActorComponent*                   M_Ring;                                            // 0x0588(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemStaticBodyComponent*               m_staticBody;                                      // 0x0590(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_swoopSound;                                      // 0x0598(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_connectedSound;                                  // 0x05A0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_disconnectedSound;                               // 0x05A8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_landingSound;                                    // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_ringMaxSize;                                     // 0x05B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_appearTime;                                      // 0x05BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_ringWaitTime;                                    // 0x05C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_disappearTime;                                   // 0x05C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           m_appearCurve;                                     // 0x05C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_anchorThrowTime;                                 // 0x05D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_anchorThrowOverDistance;                         // 0x05D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_dropDownTime;                                    // 0x05D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5DC[0x4];                                      // 0x05DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           m_dropDownCurve;                                   // 0x05E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                m_anchorDropDownStartOffset;                       // 0x05E8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                m_anchorDropDownStartRotationEular;                // 0x0600(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_swoopSoundDelayTime;                             // 0x0618(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_dropDownDelayTime;                               // 0x061C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_maxScaleHeightThreashold;                        // 0x0620(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnchorPhysicsParameter                m_groundPhysicsParam;                              // 0x0624(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAnchorPhysicsParameter                m_waterPhysicsParam;                               // 0x0640(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAnchorPhysicsParameter                m_airPhysicsParam;                                 // 0x065C(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         m_failedObjectRemainTime;                          // 0x0678(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_failedCalcPostureTime;                           // 0x067C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_failedFallRaycastLength;                         // 0x0680(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_playEffectMoveSpeedThreshold;                    // 0x0684(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                m_defaultBoxBodyExtents;                           // 0x0688(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                m_bodyOffset;                                      // 0x06A0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          m_landingGroundSoundCue;                           // 0x06B8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          m_landingWaterSoundCue;                            // 0x06C0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          m_landingAirSoundCue;                              // 0x06C8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugSelfTarget;                                  // 0x06D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawCollider;                                // 0x06D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D2[0x2BE];                                    // 0x06D2(0x02BE)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAnchorObject">();
	}
	static class AItemAnchorObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemAnchorObject>();
	}
};
static_assert(alignof(AItemAnchorObject) == 0x000010, "Wrong alignment on AItemAnchorObject");
static_assert(sizeof(AItemAnchorObject) == 0x000990, "Wrong size on AItemAnchorObject");
static_assert(offsetof(AItemAnchorObject, m_Root) == 0x000570, "Member 'AItemAnchorObject::m_Root' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_anchorRoot) == 0x000578, "Member 'AItemAnchorObject::m_anchorRoot' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_anchor) == 0x000580, "Member 'AItemAnchorObject::m_anchor' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, M_Ring) == 0x000588, "Member 'AItemAnchorObject::M_Ring' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_staticBody) == 0x000590, "Member 'AItemAnchorObject::m_staticBody' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_swoopSound) == 0x000598, "Member 'AItemAnchorObject::m_swoopSound' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_connectedSound) == 0x0005A0, "Member 'AItemAnchorObject::m_connectedSound' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_disconnectedSound) == 0x0005A8, "Member 'AItemAnchorObject::m_disconnectedSound' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_landingSound) == 0x0005B0, "Member 'AItemAnchorObject::m_landingSound' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_ringMaxSize) == 0x0005B8, "Member 'AItemAnchorObject::m_ringMaxSize' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_appearTime) == 0x0005BC, "Member 'AItemAnchorObject::m_appearTime' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_ringWaitTime) == 0x0005C0, "Member 'AItemAnchorObject::m_ringWaitTime' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_disappearTime) == 0x0005C4, "Member 'AItemAnchorObject::m_disappearTime' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_appearCurve) == 0x0005C8, "Member 'AItemAnchorObject::m_appearCurve' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_anchorThrowTime) == 0x0005D0, "Member 'AItemAnchorObject::m_anchorThrowTime' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_anchorThrowOverDistance) == 0x0005D4, "Member 'AItemAnchorObject::m_anchorThrowOverDistance' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_dropDownTime) == 0x0005D8, "Member 'AItemAnchorObject::m_dropDownTime' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_dropDownCurve) == 0x0005E0, "Member 'AItemAnchorObject::m_dropDownCurve' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_anchorDropDownStartOffset) == 0x0005E8, "Member 'AItemAnchorObject::m_anchorDropDownStartOffset' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_anchorDropDownStartRotationEular) == 0x000600, "Member 'AItemAnchorObject::m_anchorDropDownStartRotationEular' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_swoopSoundDelayTime) == 0x000618, "Member 'AItemAnchorObject::m_swoopSoundDelayTime' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_dropDownDelayTime) == 0x00061C, "Member 'AItemAnchorObject::m_dropDownDelayTime' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_maxScaleHeightThreashold) == 0x000620, "Member 'AItemAnchorObject::m_maxScaleHeightThreashold' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_groundPhysicsParam) == 0x000624, "Member 'AItemAnchorObject::m_groundPhysicsParam' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_waterPhysicsParam) == 0x000640, "Member 'AItemAnchorObject::m_waterPhysicsParam' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_airPhysicsParam) == 0x00065C, "Member 'AItemAnchorObject::m_airPhysicsParam' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_failedObjectRemainTime) == 0x000678, "Member 'AItemAnchorObject::m_failedObjectRemainTime' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_failedCalcPostureTime) == 0x00067C, "Member 'AItemAnchorObject::m_failedCalcPostureTime' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_failedFallRaycastLength) == 0x000680, "Member 'AItemAnchorObject::m_failedFallRaycastLength' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_playEffectMoveSpeedThreshold) == 0x000684, "Member 'AItemAnchorObject::m_playEffectMoveSpeedThreshold' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_defaultBoxBodyExtents) == 0x000688, "Member 'AItemAnchorObject::m_defaultBoxBodyExtents' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_bodyOffset) == 0x0006A0, "Member 'AItemAnchorObject::m_bodyOffset' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_landingGroundSoundCue) == 0x0006B8, "Member 'AItemAnchorObject::m_landingGroundSoundCue' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_landingWaterSoundCue) == 0x0006C0, "Member 'AItemAnchorObject::m_landingWaterSoundCue' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, m_landingAirSoundCue) == 0x0006C8, "Member 'AItemAnchorObject::m_landingAirSoundCue' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, bDebugSelfTarget) == 0x0006D0, "Member 'AItemAnchorObject::bDebugSelfTarget' has a wrong offset!");
static_assert(offsetof(AItemAnchorObject, bDebugDrawCollider) == 0x0006D1, "Member 'AItemAnchorObject::bDebugDrawCollider' has a wrong offset!");

// Class UnionRun.UnionDroneInfoInterface
// 0x0000 (0x0000 - 0x0000)
class IUnionDroneInfoInterface final
{
public:
	void NotifyCallDroneEvent(const struct FCallDroneInfo& Info);
	void NotifyDroneVisibilityEvent(bool Visibility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionDroneInfoInterface">();
	}
	static class IUnionDroneInfoInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUnionDroneInfoInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IUnionDroneInfoInterface) == 0x000001, "Wrong alignment on IUnionDroneInfoInterface");
static_assert(sizeof(IUnionDroneInfoInterface) == 0x000001, "Wrong size on IUnionDroneInfoInterface");

// Class UnionRun.GadgetGuard
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetGuard final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetGuard">();
	}
	static class UGadgetGuard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetGuard>();
	}
};
static_assert(alignof(UGadgetGuard) == 0x000008, "Wrong alignment on UGadgetGuard");
static_assert(sizeof(UGadgetGuard) == 0x0000A0, "Wrong size on UGadgetGuard");

// Class UnionRun.UnionHitReflect
// 0x0040 (0x0078 - 0x0038)
class UUnionHitReflect final : public UMoveController
{
public:
	uint8                                         Pad_38[0x40];                                      // 0x0038(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionHitReflect">();
	}
	static class UUnionHitReflect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionHitReflect>();
	}
};
static_assert(alignof(UUnionHitReflect) == 0x000008, "Wrong alignment on UUnionHitReflect");
static_assert(sizeof(UUnionHitReflect) == 0x000078, "Wrong size on UUnionHitReflect");

// Class UnionRun.GadgetHandlingTune
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetHandlingTune final : public UGadgetMachineTuneBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetHandlingTune">();
	}
	static class UGadgetHandlingTune* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetHandlingTune>();
	}
};
static_assert(alignof(UGadgetHandlingTune) == 0x000008, "Wrong alignment on UGadgetHandlingTune");
static_assert(sizeof(UGadgetHandlingTune) == 0x0000A0, "Wrong size on UGadgetHandlingTune");

// Class UnionRun.ItemSplashProjectile
// 0x0380 (0x0610 - 0x0290)
class alignas(0x10) AItemSplashProjectile : public AActor
{
public:
	uint8                                         Pad_290[0x28];                                     // 0x0290(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGOCMovement*                           Movement;                                          // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTriggerComponent*                      HitTrigger;                                        // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTriggerComponent*                      DamageTrigger;                                     // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemStaticBodyComponent*               StaticBody;                                        // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      DamageEffect;                                      // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    ExplosionSound;                                    // 0x02E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    ExplosionSoundAir;                                 // 0x02F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTime;                                          // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WaterBallScale;                                    // 0x0300(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VioletVoidAbsorbTargetScale;                       // 0x0318(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleDisappearTime;                                // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HolderInvencibleTime;                              // 0x0334(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FThrowingFrontParameter                MaxFrontJumpParam;                                 // 0x0338(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FThrowingFrontParameter                MinFrontJumpParam;                                 // 0x0348(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FallingDetectingOffsetFront;                       // 0x0358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingDetectingOffsetFront_ToFlight;              // 0x035C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionLifeTime;                                 // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionRadius;                                   // 0x0364(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionHeight;                                   // 0x0368(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36C[0x4];                                      // 0x036C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ExplosionOffset;                                   // 0x0370(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RacerIndex;                                        // 0x0388(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDomainNumber                                 DomainNumber;                                      // 0x038C(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38D[0x283];                                    // 0x038D(0x0283)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTriggerColliderConflict(const struct FHitTriggerInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSplashProjectile">();
	}
	static class AItemSplashProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemSplashProjectile>();
	}
};
static_assert(alignof(AItemSplashProjectile) == 0x000010, "Wrong alignment on AItemSplashProjectile");
static_assert(sizeof(AItemSplashProjectile) == 0x000610, "Wrong size on AItemSplashProjectile");
static_assert(offsetof(AItemSplashProjectile, StaticMesh) == 0x0002B8, "Member 'AItemSplashProjectile::StaticMesh' has a wrong offset!");
static_assert(offsetof(AItemSplashProjectile, Movement) == 0x0002C0, "Member 'AItemSplashProjectile::Movement' has a wrong offset!");
static_assert(offsetof(AItemSplashProjectile, HitTrigger) == 0x0002C8, "Member 'AItemSplashProjectile::HitTrigger' has a wrong offset!");
static_assert(offsetof(AItemSplashProjectile, DamageTrigger) == 0x0002D0, "Member 'AItemSplashProjectile::DamageTrigger' has a wrong offset!");
static_assert(offsetof(AItemSplashProjectile, StaticBody) == 0x0002D8, "Member 'AItemSplashProjectile::StaticBody' has a wrong offset!");
static_assert(offsetof(AItemSplashProjectile, DamageEffect) == 0x0002E0, "Member 'AItemSplashProjectile::DamageEffect' has a wrong offset!");
static_assert(offsetof(AItemSplashProjectile, ExplosionSound) == 0x0002E8, "Member 'AItemSplashProjectile::ExplosionSound' has a wrong offset!");
static_assert(offsetof(AItemSplashProjectile, ExplosionSoundAir) == 0x0002F0, "Member 'AItemSplashProjectile::ExplosionSoundAir' has a wrong offset!");
static_assert(offsetof(AItemSplashProjectile, LifeTime) == 0x0002F8, "Member 'AItemSplashProjectile::LifeTime' has a wrong offset!");
static_assert(offsetof(AItemSplashProjectile, WaterBallScale) == 0x000300, "Member 'AItemSplashProjectile::WaterBallScale' has a wrong offset!");
static_assert(offsetof(AItemSplashProjectile, VioletVoidAbsorbTargetScale) == 0x000318, "Member 'AItemSplashProjectile::VioletVoidAbsorbTargetScale' has a wrong offset!");
static_assert(offsetof(AItemSplashProjectile, ScaleDisappearTime) == 0x000330, "Member 'AItemSplashProjectile::ScaleDisappearTime' has a wrong offset!");
static_assert(offsetof(AItemSplashProjectile, HolderInvencibleTime) == 0x000334, "Member 'AItemSplashProjectile::HolderInvencibleTime' has a wrong offset!");
static_assert(offsetof(AItemSplashProjectile, MaxFrontJumpParam) == 0x000338, "Member 'AItemSplashProjectile::MaxFrontJumpParam' has a wrong offset!");
static_assert(offsetof(AItemSplashProjectile, MinFrontJumpParam) == 0x000348, "Member 'AItemSplashProjectile::MinFrontJumpParam' has a wrong offset!");
static_assert(offsetof(AItemSplashProjectile, FallingDetectingOffsetFront) == 0x000358, "Member 'AItemSplashProjectile::FallingDetectingOffsetFront' has a wrong offset!");
static_assert(offsetof(AItemSplashProjectile, FallingDetectingOffsetFront_ToFlight) == 0x00035C, "Member 'AItemSplashProjectile::FallingDetectingOffsetFront_ToFlight' has a wrong offset!");
static_assert(offsetof(AItemSplashProjectile, ExplosionLifeTime) == 0x000360, "Member 'AItemSplashProjectile::ExplosionLifeTime' has a wrong offset!");
static_assert(offsetof(AItemSplashProjectile, ExplosionRadius) == 0x000364, "Member 'AItemSplashProjectile::ExplosionRadius' has a wrong offset!");
static_assert(offsetof(AItemSplashProjectile, ExplosionHeight) == 0x000368, "Member 'AItemSplashProjectile::ExplosionHeight' has a wrong offset!");
static_assert(offsetof(AItemSplashProjectile, ExplosionOffset) == 0x000370, "Member 'AItemSplashProjectile::ExplosionOffset' has a wrong offset!");
static_assert(offsetof(AItemSplashProjectile, RacerIndex) == 0x000388, "Member 'AItemSplashProjectile::RacerIndex' has a wrong offset!");
static_assert(offsetof(AItemSplashProjectile, DomainNumber) == 0x00038C, "Member 'AItemSplashProjectile::DomainNumber' has a wrong offset!");

// Class UnionRun.GadgetHyperChargeDrift
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetHyperChargeDrift final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetHyperChargeDrift">();
	}
	static class UGadgetHyperChargeDrift* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetHyperChargeDrift>();
	}
};
static_assert(alignof(UGadgetHyperChargeDrift) == 0x000008, "Wrong alignment on UGadgetHyperChargeDrift");
static_assert(sizeof(UGadgetHyperChargeDrift) == 0x0000A0, "Wrong size on UGadgetHyperChargeDrift");

// Class UnionRun.GimmickSweetsShipCannonBall
// 0x0120 (0x06D0 - 0x05B0)
class alignas(0x10) AGimmickSweetsShipCannonBall final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              BallMesh;                                          // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            BallBody;                                          // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      BreakEffect;                                       // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    BreakSound;                                        // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BallRotSpeed;                                      // 0x05D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERacerDamageType                              DamageType;                                        // 0x05DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5DD[0x3];                                      // 0x05DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               BreakEffectRotOffset;                              // 0x05E0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F8[0xD8];                                     // 0x05F8(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickSweetsShipCannonBall">();
	}
	static class AGimmickSweetsShipCannonBall* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickSweetsShipCannonBall>();
	}
};
static_assert(alignof(AGimmickSweetsShipCannonBall) == 0x000010, "Wrong alignment on AGimmickSweetsShipCannonBall");
static_assert(sizeof(AGimmickSweetsShipCannonBall) == 0x0006D0, "Wrong size on AGimmickSweetsShipCannonBall");
static_assert(offsetof(AGimmickSweetsShipCannonBall, BallMesh) == 0x0005B8, "Member 'AGimmickSweetsShipCannonBall::BallMesh' has a wrong offset!");
static_assert(offsetof(AGimmickSweetsShipCannonBall, BallBody) == 0x0005C0, "Member 'AGimmickSweetsShipCannonBall::BallBody' has a wrong offset!");
static_assert(offsetof(AGimmickSweetsShipCannonBall, BreakEffect) == 0x0005C8, "Member 'AGimmickSweetsShipCannonBall::BreakEffect' has a wrong offset!");
static_assert(offsetof(AGimmickSweetsShipCannonBall, BreakSound) == 0x0005D0, "Member 'AGimmickSweetsShipCannonBall::BreakSound' has a wrong offset!");
static_assert(offsetof(AGimmickSweetsShipCannonBall, BallRotSpeed) == 0x0005D8, "Member 'AGimmickSweetsShipCannonBall::BallRotSpeed' has a wrong offset!");
static_assert(offsetof(AGimmickSweetsShipCannonBall, DamageType) == 0x0005DC, "Member 'AGimmickSweetsShipCannonBall::DamageType' has a wrong offset!");
static_assert(offsetof(AGimmickSweetsShipCannonBall, BreakEffectRotOffset) == 0x0005E0, "Member 'AGimmickSweetsShipCannonBall::BreakEffectRotOffset' has a wrong offset!");

// Class UnionRun.GadgetImmuneItemDamageOnce
// 0x0008 (0x00A8 - 0x00A0)
class UGadgetImmuneItemDamageOnce final : public UGadgetBase
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetImmuneItemDamageOnce">();
	}
	static class UGadgetImmuneItemDamageOnce* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetImmuneItemDamageOnce>();
	}
};
static_assert(alignof(UGadgetImmuneItemDamageOnce) == 0x000008, "Wrong alignment on UGadgetImmuneItemDamageOnce");
static_assert(sizeof(UGadgetImmuneItemDamageOnce) == 0x0000A8, "Wrong size on UGadgetImmuneItemDamageOnce");

// Class UnionRun.GadgetInitialEquipItem
// 0x0008 (0x00A8 - 0x00A0)
class UGadgetInitialEquipItem final : public UGadgetBase
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetInitialEquipItem">();
	}
	static class UGadgetInitialEquipItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetInitialEquipItem>();
	}
};
static_assert(alignof(UGadgetInitialEquipItem) == 0x000008, "Wrong alignment on UGadgetInitialEquipItem");
static_assert(sizeof(UGadgetInitialEquipItem) == 0x0000A8, "Wrong size on UGadgetInitialEquipItem");

// Class UnionRun.GadgetItemAttackRingBonus
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetItemAttackRingBonus final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetItemAttackRingBonus">();
	}
	static class UGadgetItemAttackRingBonus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetItemAttackRingBonus>();
	}
};
static_assert(alignof(UGadgetItemAttackRingBonus) == 0x000008, "Wrong alignment on UGadgetItemAttackRingBonus");
static_assert(sizeof(UGadgetItemAttackRingBonus) == 0x0000A0, "Wrong size on UGadgetItemAttackRingBonus");

// Class UnionRun.GimmickSpaceShip
// 0x0060 (0x0610 - 0x05B0)
class alignas(0x10) AGimmickSpaceShip final : public AUnionGimmickObjectBase
{
public:
	float                                         MoveLimitLength;                                   // 0x05B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeed;                                         // 0x05B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveResetValue;                                    // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveStartOffsetTime;                               // 0x05BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              Ship_A;                                            // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              Ship_B;                                            // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              Ship_C;                                            // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              Ship_D;                                            // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              Ship_E;                                            // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              Ship_F;                                            // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      WarpMoveEffect;                                    // 0x05F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_600[0x10];                                     // 0x0600(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickSpaceShip">();
	}
	static class AGimmickSpaceShip* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickSpaceShip>();
	}
};
static_assert(alignof(AGimmickSpaceShip) == 0x000010, "Wrong alignment on AGimmickSpaceShip");
static_assert(sizeof(AGimmickSpaceShip) == 0x000610, "Wrong size on AGimmickSpaceShip");
static_assert(offsetof(AGimmickSpaceShip, MoveLimitLength) == 0x0005B0, "Member 'AGimmickSpaceShip::MoveLimitLength' has a wrong offset!");
static_assert(offsetof(AGimmickSpaceShip, MoveSpeed) == 0x0005B4, "Member 'AGimmickSpaceShip::MoveSpeed' has a wrong offset!");
static_assert(offsetof(AGimmickSpaceShip, MoveResetValue) == 0x0005B8, "Member 'AGimmickSpaceShip::MoveResetValue' has a wrong offset!");
static_assert(offsetof(AGimmickSpaceShip, MoveStartOffsetTime) == 0x0005BC, "Member 'AGimmickSpaceShip::MoveStartOffsetTime' has a wrong offset!");
static_assert(offsetof(AGimmickSpaceShip, Ship_A) == 0x0005C0, "Member 'AGimmickSpaceShip::Ship_A' has a wrong offset!");
static_assert(offsetof(AGimmickSpaceShip, Ship_B) == 0x0005C8, "Member 'AGimmickSpaceShip::Ship_B' has a wrong offset!");
static_assert(offsetof(AGimmickSpaceShip, Ship_C) == 0x0005D0, "Member 'AGimmickSpaceShip::Ship_C' has a wrong offset!");
static_assert(offsetof(AGimmickSpaceShip, Ship_D) == 0x0005D8, "Member 'AGimmickSpaceShip::Ship_D' has a wrong offset!");
static_assert(offsetof(AGimmickSpaceShip, Ship_E) == 0x0005E0, "Member 'AGimmickSpaceShip::Ship_E' has a wrong offset!");
static_assert(offsetof(AGimmickSpaceShip, Ship_F) == 0x0005E8, "Member 'AGimmickSpaceShip::Ship_F' has a wrong offset!");
static_assert(offsetof(AGimmickSpaceShip, WarpMoveEffect) == 0x0005F0, "Member 'AGimmickSpaceShip::WarpMoveEffect' has a wrong offset!");
static_assert(offsetof(AGimmickSpaceShip, DefaultSceneRoot) == 0x0005F8, "Member 'AGimmickSpaceShip::DefaultSceneRoot' has a wrong offset!");

// Class UnionRun.GadgetJustDash
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetJustDash final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetJustDash">();
	}
	static class UGadgetJustDash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetJustDash>();
	}
};
static_assert(alignof(UGadgetJustDash) == 0x000008, "Wrong alignment on UGadgetJustDash");
static_assert(sizeof(UGadgetJustDash) == 0x0000A0, "Wrong size on UGadgetJustDash");

// Class UnionRun.UnionMoveTowardsPlane
// 0x0000 (0x0090 - 0x0090)
class UUnionMoveTowardsPlane final : public UMoveTowardsPlane
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionMoveTowardsPlane">();
	}
	static class UUnionMoveTowardsPlane* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionMoveTowardsPlane>();
	}
};
static_assert(alignof(UUnionMoveTowardsPlane) == 0x000008, "Wrong alignment on UUnionMoveTowardsPlane");
static_assert(sizeof(UUnionMoveTowardsPlane) == 0x000090, "Wrong size on UUnionMoveTowardsPlane");

// Class UnionRun.GimmickStatueBeam
// 0x0040 (0x05F0 - 0x05B0)
class alignas(0x10) AGimmickStatueBeam final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BeamScaleCurve;                                    // 0x05B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERacerDamageType                              DamageType;                                        // 0x05C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C1[0x3];                                      // 0x05C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BeamScaleTime;                                     // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_AttackEffect;                                    // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            m_AttackStaticBodyComponent;                       // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D8[0x18];                                     // 0x05D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAttackEnable(bool IsEnable);
	void StartBeamScaleTimer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickStatueBeam">();
	}
	static class AGimmickStatueBeam* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickStatueBeam>();
	}
};
static_assert(alignof(AGimmickStatueBeam) == 0x000010, "Wrong alignment on AGimmickStatueBeam");
static_assert(sizeof(AGimmickStatueBeam) == 0x0005F0, "Wrong size on AGimmickStatueBeam");
static_assert(offsetof(AGimmickStatueBeam, BeamScaleCurve) == 0x0005B8, "Member 'AGimmickStatueBeam::BeamScaleCurve' has a wrong offset!");
static_assert(offsetof(AGimmickStatueBeam, DamageType) == 0x0005C0, "Member 'AGimmickStatueBeam::DamageType' has a wrong offset!");
static_assert(offsetof(AGimmickStatueBeam, BeamScaleTime) == 0x0005C4, "Member 'AGimmickStatueBeam::BeamScaleTime' has a wrong offset!");
static_assert(offsetof(AGimmickStatueBeam, m_AttackEffect) == 0x0005C8, "Member 'AGimmickStatueBeam::m_AttackEffect' has a wrong offset!");
static_assert(offsetof(AGimmickStatueBeam, m_AttackStaticBodyComponent) == 0x0005D0, "Member 'AGimmickStatueBeam::m_AttackStaticBodyComponent' has a wrong offset!");

// Class UnionRun.GadgetLostSpeed
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetLostSpeed final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetLostSpeed">();
	}
	static class UGadgetLostSpeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetLostSpeed>();
	}
};
static_assert(alignof(UGadgetLostSpeed) == 0x000008, "Wrong alignment on UGadgetLostSpeed");
static_assert(sizeof(UGadgetLostSpeed) == 0x0000A0, "Wrong size on UGadgetLostSpeed");

// Class UnionRun.GadgetLowRankRingBonus
// 0x0018 (0x00B8 - 0x00A0)
class UGadgetLowRankRingBonus final : public UGadgetBase
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetLowRankRingBonus">();
	}
	static class UGadgetLowRankRingBonus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetLowRankRingBonus>();
	}
};
static_assert(alignof(UGadgetLowRankRingBonus) == 0x000008, "Wrong alignment on UGadgetLowRankRingBonus");
static_assert(sizeof(UGadgetLowRankRingBonus) == 0x0000B8, "Wrong size on UGadgetLowRankRingBonus");

// Class UnionRun.GadgetMessageInterface
// 0x0000 (0x0000 - 0x0000)
class IGadgetMessageInterface final
{
public:
	void GadgetNotifyAttack(const struct FGadgetNotifyAttackInfo& Info);
	void GadgetNotifyMessage(const class FName Message);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetMessageInterface">();
	}
	static class IGadgetMessageInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGadgetMessageInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGadgetMessageInterface) == 0x000001, "Wrong alignment on IGadgetMessageInterface");
static_assert(sizeof(IGadgetMessageInterface) == 0x000001, "Wrong size on IGadgetMessageInterface");

// Class UnionRun.Gimmick_Extnd05_VolcanoErupting
// 0x0060 (0x0610 - 0x05B0)
class alignas(0x10) AGimmick_Extnd05_VolcanoErupting final : public AUnionGimmickObjectBase
{
public:
	class UUnionStaticMeshComponent*              MeshA;                                             // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionStaticMeshComponent*              MeshB;                                             // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      SmokeEffect;                                       // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionVATMeshComponent*                 VatMeshEffect;                                     // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionStaticMeshComponent*              StaticMeshEffectA;                                 // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionStaticMeshComponent*              StaticMeshEffectB;                                 // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGimmick_Extnd05_HouseB*                HouseB;                                            // 0x05E0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AGimmick_Extnd05_VolcanoRock*>   VolcanoRocks;                                      // 0x05E8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    EruptingSound;                                     // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_600[0x10];                                     // 0x0600(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd05_VolcanoErupting">();
	}
	static class AGimmick_Extnd05_VolcanoErupting* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd05_VolcanoErupting>();
	}
};
static_assert(alignof(AGimmick_Extnd05_VolcanoErupting) == 0x000010, "Wrong alignment on AGimmick_Extnd05_VolcanoErupting");
static_assert(sizeof(AGimmick_Extnd05_VolcanoErupting) == 0x000610, "Wrong size on AGimmick_Extnd05_VolcanoErupting");
static_assert(offsetof(AGimmick_Extnd05_VolcanoErupting, MeshA) == 0x0005B0, "Member 'AGimmick_Extnd05_VolcanoErupting::MeshA' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_VolcanoErupting, MeshB) == 0x0005B8, "Member 'AGimmick_Extnd05_VolcanoErupting::MeshB' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_VolcanoErupting, SmokeEffect) == 0x0005C0, "Member 'AGimmick_Extnd05_VolcanoErupting::SmokeEffect' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_VolcanoErupting, VatMeshEffect) == 0x0005C8, "Member 'AGimmick_Extnd05_VolcanoErupting::VatMeshEffect' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_VolcanoErupting, StaticMeshEffectA) == 0x0005D0, "Member 'AGimmick_Extnd05_VolcanoErupting::StaticMeshEffectA' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_VolcanoErupting, StaticMeshEffectB) == 0x0005D8, "Member 'AGimmick_Extnd05_VolcanoErupting::StaticMeshEffectB' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_VolcanoErupting, HouseB) == 0x0005E0, "Member 'AGimmick_Extnd05_VolcanoErupting::HouseB' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_VolcanoErupting, VolcanoRocks) == 0x0005E8, "Member 'AGimmick_Extnd05_VolcanoErupting::VolcanoRocks' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_VolcanoErupting, EruptingSound) == 0x0005F8, "Member 'AGimmick_Extnd05_VolcanoErupting::EruptingSound' has a wrong offset!");

// Class UnionRun.GadgetPlaneFormParamUP
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetPlaneFormParamUP final : public UGadgetMachineTuneBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetPlaneFormParamUP">();
	}
	static class UGadgetPlaneFormParamUP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetPlaneFormParamUP>();
	}
};
static_assert(alignof(UGadgetPlaneFormParamUP) == 0x000008, "Wrong alignment on UGadgetPlaneFormParamUP");
static_assert(sizeof(UGadgetPlaneFormParamUP) == 0x0000A0, "Wrong size on UGadgetPlaneFormParamUP");

// Class UnionRun.GimmickElevatorDoor
// 0x0080 (0x0630 - 0x05B0)
class alignas(0x10) AGimmickElevatorDoor final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              DoorFrame;                                         // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              DoorLeft;                                          // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              DoorRight;                                         // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            Body;                                              // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    Sound;                                             // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DoorMoveTime;                                      // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E4[0x4];                                      // 0x05E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LeftOpenOffset;                                    // 0x05E8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightOpenOffset;                                   // 0x0600(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MoveCurve;                                         // 0x0618(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_620[0x10];                                     // 0x0620(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickElevatorDoor">();
	}
	static class AGimmickElevatorDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickElevatorDoor>();
	}
};
static_assert(alignof(AGimmickElevatorDoor) == 0x000010, "Wrong alignment on AGimmickElevatorDoor");
static_assert(sizeof(AGimmickElevatorDoor) == 0x000630, "Wrong size on AGimmickElevatorDoor");
static_assert(offsetof(AGimmickElevatorDoor, DoorFrame) == 0x0005B8, "Member 'AGimmickElevatorDoor::DoorFrame' has a wrong offset!");
static_assert(offsetof(AGimmickElevatorDoor, DoorLeft) == 0x0005C0, "Member 'AGimmickElevatorDoor::DoorLeft' has a wrong offset!");
static_assert(offsetof(AGimmickElevatorDoor, DoorRight) == 0x0005C8, "Member 'AGimmickElevatorDoor::DoorRight' has a wrong offset!");
static_assert(offsetof(AGimmickElevatorDoor, Body) == 0x0005D0, "Member 'AGimmickElevatorDoor::Body' has a wrong offset!");
static_assert(offsetof(AGimmickElevatorDoor, Sound) == 0x0005D8, "Member 'AGimmickElevatorDoor::Sound' has a wrong offset!");
static_assert(offsetof(AGimmickElevatorDoor, DoorMoveTime) == 0x0005E0, "Member 'AGimmickElevatorDoor::DoorMoveTime' has a wrong offset!");
static_assert(offsetof(AGimmickElevatorDoor, LeftOpenOffset) == 0x0005E8, "Member 'AGimmickElevatorDoor::LeftOpenOffset' has a wrong offset!");
static_assert(offsetof(AGimmickElevatorDoor, RightOpenOffset) == 0x000600, "Member 'AGimmickElevatorDoor::RightOpenOffset' has a wrong offset!");
static_assert(offsetof(AGimmickElevatorDoor, MoveCurve) == 0x000618, "Member 'AGimmickElevatorDoor::MoveCurve' has a wrong offset!");

// Class UnionRun.GadgetPlusStock
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetPlusStock final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetPlusStock">();
	}
	static class UGadgetPlusStock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetPlusStock>();
	}
};
static_assert(alignof(UGadgetPlusStock) == 0x000008, "Wrong alignment on UGadgetPlusStock");
static_assert(sizeof(UGadgetPlusStock) == 0x0000A0, "Wrong size on UGadgetPlusStock");

// Class UnionRun.GadgetPowerTune
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetPowerTune final : public UGadgetMachineTuneBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetPowerTune">();
	}
	static class UGadgetPowerTune* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetPowerTune>();
	}
};
static_assert(alignof(UGadgetPowerTune) == 0x000008, "Wrong alignment on UGadgetPowerTune");
static_assert(sizeof(UGadgetPowerTune) == 0x0000A0, "Wrong size on UGadgetPowerTune");

// Class UnionRun.GadgetQuickAirtrick
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetQuickAirtrick final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetQuickAirtrick">();
	}
	static class UGadgetQuickAirtrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetQuickAirtrick>();
	}
};
static_assert(alignof(UGadgetQuickAirtrick) == 0x000008, "Wrong alignment on UGadgetQuickAirtrick");
static_assert(sizeof(UGadgetQuickAirtrick) == 0x0000A0, "Wrong size on UGadgetQuickAirtrick");

// Class UnionRun.GimmickCannon
// 0x0050 (0x0600 - 0x05B0)
class alignas(0x10) AGimmickCannon final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            JumpStaticBodyComponent;                           // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticBodyComponent*                   EffectStaticBodyComponent;                         // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionStaticMeshComponent*              CannonStaticMeshComponent;                         // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      NiagaraCannonFire;                                 // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E0[0x20];                                     // 0x05E0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickCannon">();
	}
	static class AGimmickCannon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickCannon>();
	}
};
static_assert(alignof(AGimmickCannon) == 0x000010, "Wrong alignment on AGimmickCannon");
static_assert(sizeof(AGimmickCannon) == 0x000600, "Wrong size on AGimmickCannon");
static_assert(offsetof(AGimmickCannon, DefaultSceneRoot) == 0x0005B8, "Member 'AGimmickCannon::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AGimmickCannon, JumpStaticBodyComponent) == 0x0005C0, "Member 'AGimmickCannon::JumpStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickCannon, EffectStaticBodyComponent) == 0x0005C8, "Member 'AGimmickCannon::EffectStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickCannon, CannonStaticMeshComponent) == 0x0005D0, "Member 'AGimmickCannon::CannonStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickCannon, NiagaraCannonFire) == 0x0005D8, "Member 'AGimmickCannon::NiagaraCannonFire' has a wrong offset!");

// Class UnionRun.GadgetRingPerformance
// 0x00A8 (0x0338 - 0x0290)
class AGadgetRingPerformance : public AActor
{
public:
	class USceneComponent*                        Root;                                              // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RingMesh;                                          // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RingNum;                                           // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RacerIndex;                                        // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RotateCurve;                                       // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8[0x80];                                     // 0x02B8(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetRingPerformance">();
	}
	static class AGadgetRingPerformance* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGadgetRingPerformance>();
	}
};
static_assert(alignof(AGadgetRingPerformance) == 0x000008, "Wrong alignment on AGadgetRingPerformance");
static_assert(sizeof(AGadgetRingPerformance) == 0x000338, "Wrong size on AGadgetRingPerformance");
static_assert(offsetof(AGadgetRingPerformance, Root) == 0x000290, "Member 'AGadgetRingPerformance::Root' has a wrong offset!");
static_assert(offsetof(AGadgetRingPerformance, RingMesh) == 0x000298, "Member 'AGadgetRingPerformance::RingMesh' has a wrong offset!");
static_assert(offsetof(AGadgetRingPerformance, RingNum) == 0x0002A0, "Member 'AGadgetRingPerformance::RingNum' has a wrong offset!");
static_assert(offsetof(AGadgetRingPerformance, RacerIndex) == 0x0002A8, "Member 'AGadgetRingPerformance::RacerIndex' has a wrong offset!");
static_assert(offsetof(AGadgetRingPerformance, RotateCurve) == 0x0002B0, "Member 'AGadgetRingPerformance::RotateCurve' has a wrong offset!");

// Class UnionRun.GimmickTestObject
// 0x0040 (0x05F0 - 0x05B0)
class alignas(0x10) AGimmickTestObject final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionSkeletalMeshComponent*            SkeletalMeshComponent;                             // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              StaticMeshComponent;                               // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDamage;                                         // 0x05C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERacerDamageType                              DamageType;                                        // 0x05C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5CA[0x2];                                      // 0x05CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CollisionSocketName;                               // 0x05CC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D4[0x4];                                      // 0x05D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticBodyComponent*                   StaticBodyComponent;                               // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E8[0x8];                                      // 0x05E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickTestObject">();
	}
	static class AGimmickTestObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickTestObject>();
	}
};
static_assert(alignof(AGimmickTestObject) == 0x000010, "Wrong alignment on AGimmickTestObject");
static_assert(sizeof(AGimmickTestObject) == 0x0005F0, "Wrong size on AGimmickTestObject");
static_assert(offsetof(AGimmickTestObject, SkeletalMeshComponent) == 0x0005B8, "Member 'AGimmickTestObject::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickTestObject, StaticMeshComponent) == 0x0005C0, "Member 'AGimmickTestObject::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickTestObject, bIsDamage) == 0x0005C8, "Member 'AGimmickTestObject::bIsDamage' has a wrong offset!");
static_assert(offsetof(AGimmickTestObject, DamageType) == 0x0005C9, "Member 'AGimmickTestObject::DamageType' has a wrong offset!");
static_assert(offsetof(AGimmickTestObject, CollisionSocketName) == 0x0005CC, "Member 'AGimmickTestObject::CollisionSocketName' has a wrong offset!");
static_assert(offsetof(AGimmickTestObject, DefaultSceneRoot) == 0x0005D8, "Member 'AGimmickTestObject::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AGimmickTestObject, StaticBodyComponent) == 0x0005E0, "Member 'AGimmickTestObject::StaticBodyComponent' has a wrong offset!");

// Class UnionRun.GadgetRunoffNegateBonus
// 0x0008 (0x00A8 - 0x00A0)
class UGadgetRunoffNegateBonus final : public UGadgetBase
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetRunoffNegateBonus">();
	}
	static class UGadgetRunoffNegateBonus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetRunoffNegateBonus>();
	}
};
static_assert(alignof(UGadgetRunoffNegateBonus) == 0x000008, "Wrong alignment on UGadgetRunoffNegateBonus");
static_assert(sizeof(UGadgetRunoffNegateBonus) == 0x0000A8, "Wrong size on UGadgetRunoffNegateBonus");

// Class UnionRun.GadgetSecondFastCharge
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetSecondFastCharge final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetSecondFastCharge">();
	}
	static class UGadgetSecondFastCharge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetSecondFastCharge>();
	}
};
static_assert(alignof(UGadgetSecondFastCharge) == 0x000008, "Wrong alignment on UGadgetSecondFastCharge");
static_assert(sizeof(UGadgetSecondFastCharge) == 0x0000A0, "Wrong size on UGadgetSecondFastCharge");

// Class UnionRun.GadgetShortenDamageMotion
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetShortenDamageMotion final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetShortenDamageMotion">();
	}
	static class UGadgetShortenDamageMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetShortenDamageMotion>();
	}
};
static_assert(alignof(UGadgetShortenDamageMotion) == 0x000008, "Wrong alignment on UGadgetShortenDamageMotion");
static_assert(sizeof(UGadgetShortenDamageMotion) == 0x0000A0, "Wrong size on UGadgetShortenDamageMotion");

// Class UnionRun.Gimmick_Extnd07_JumpStand
// 0x0010 (0x05C0 - 0x05B0)
class AGimmick_Extnd07_JumpStand final : public AUnionGimmickObjectBase
{
public:
	EExtnd07Area                                  Area;                                              // 0x05B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B1[0xF];                                      // 0x05B1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd07_JumpStand">();
	}
	static class AGimmick_Extnd07_JumpStand* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd07_JumpStand>();
	}
};
static_assert(alignof(AGimmick_Extnd07_JumpStand) == 0x000008, "Wrong alignment on AGimmick_Extnd07_JumpStand");
static_assert(sizeof(AGimmick_Extnd07_JumpStand) == 0x0005C0, "Wrong size on AGimmick_Extnd07_JumpStand");
static_assert(offsetof(AGimmick_Extnd07_JumpStand, Area) == 0x0005B0, "Member 'AGimmick_Extnd07_JumpStand::Area' has a wrong offset!");

// Class UnionRun.GadgetShortenDamageTime
// 0x0008 (0x00A8 - 0x00A0)
class UGadgetShortenDamageTime final : public UGadgetBase
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetShortenDamageTime">();
	}
	static class UGadgetShortenDamageTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetShortenDamageTime>();
	}
};
static_assert(alignof(UGadgetShortenDamageTime) == 0x000008, "Wrong alignment on UGadgetShortenDamageTime");
static_assert(sizeof(UGadgetShortenDamageTime) == 0x0000A8, "Wrong size on UGadgetShortenDamageTime");

// Class UnionRun.GimmickWhale
// 0x0060 (0x0610 - 0x05B0)
class alignas(0x10) AGimmickWhale final : public AUnionGimmickObjectBase
{
public:
	bool                                          bIsJampTwist;                                      // 0x05B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B1[0x3];                                      // 0x05B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TremorHighDistance;                                // 0x05B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TremorMiddleDistance;                              // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TremorLowDistance;                                 // 0x05BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionSkeletalMeshComponent*            SkeletalMeshComponent;                             // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AGimmickBigWave*>                WaveActorArray;                                    // 0x05C8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class AGimmickBigWave*>                WaveActorArrayRoute2;                              // 0x05D8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<float>                                 WaveSpawnTimeArray;                                // 0x05E8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UWhaleAnimInstance*                     AnimInstance;                                      // 0x05F8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_600[0x10];                                     // 0x0600(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTremorEvent();
	void StartWaveObject();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickWhale">();
	}
	static class AGimmickWhale* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickWhale>();
	}
};
static_assert(alignof(AGimmickWhale) == 0x000010, "Wrong alignment on AGimmickWhale");
static_assert(sizeof(AGimmickWhale) == 0x000610, "Wrong size on AGimmickWhale");
static_assert(offsetof(AGimmickWhale, bIsJampTwist) == 0x0005B0, "Member 'AGimmickWhale::bIsJampTwist' has a wrong offset!");
static_assert(offsetof(AGimmickWhale, TremorHighDistance) == 0x0005B4, "Member 'AGimmickWhale::TremorHighDistance' has a wrong offset!");
static_assert(offsetof(AGimmickWhale, TremorMiddleDistance) == 0x0005B8, "Member 'AGimmickWhale::TremorMiddleDistance' has a wrong offset!");
static_assert(offsetof(AGimmickWhale, TremorLowDistance) == 0x0005BC, "Member 'AGimmickWhale::TremorLowDistance' has a wrong offset!");
static_assert(offsetof(AGimmickWhale, SkeletalMeshComponent) == 0x0005C0, "Member 'AGimmickWhale::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickWhale, WaveActorArray) == 0x0005C8, "Member 'AGimmickWhale::WaveActorArray' has a wrong offset!");
static_assert(offsetof(AGimmickWhale, WaveActorArrayRoute2) == 0x0005D8, "Member 'AGimmickWhale::WaveActorArrayRoute2' has a wrong offset!");
static_assert(offsetof(AGimmickWhale, WaveSpawnTimeArray) == 0x0005E8, "Member 'AGimmickWhale::WaveSpawnTimeArray' has a wrong offset!");
static_assert(offsetof(AGimmickWhale, AnimInstance) == 0x0005F8, "Member 'AGimmickWhale::AnimInstance' has a wrong offset!");

// Class UnionRun.GadgetShortenItemSlotTime
// 0x0010 (0x00B0 - 0x00A0)
class UGadgetShortenItemSlotTime final : public UGadgetBase
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetShortenItemSlotTime">();
	}
	static class UGadgetShortenItemSlotTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetShortenItemSlotTime>();
	}
};
static_assert(alignof(UGadgetShortenItemSlotTime) == 0x000008, "Wrong alignment on UGadgetShortenItemSlotTime");
static_assert(sizeof(UGadgetShortenItemSlotTime) == 0x0000B0, "Wrong size on UGadgetShortenItemSlotTime");

// Class UnionRun.GadgetSkateDrift
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetSkateDrift final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetSkateDrift">();
	}
	static class UGadgetSkateDrift* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetSkateDrift>();
	}
};
static_assert(alignof(UGadgetSkateDrift) == 0x000008, "Wrong alignment on UGadgetSkateDrift");
static_assert(sizeof(UGadgetSkateDrift) == 0x0000A0, "Wrong size on UGadgetSkateDrift");

// Class UnionRun.GadgetSlipstreamBonus
// 0x0008 (0x00A8 - 0x00A0)
class UGadgetSlipstreamBonus final : public UGadgetBase
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetSlipstreamBonus">();
	}
	static class UGadgetSlipstreamBonus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetSlipstreamBonus>();
	}
};
static_assert(alignof(UGadgetSlipstreamBonus) == 0x000008, "Wrong alignment on UGadgetSlipstreamBonus");
static_assert(sizeof(UGadgetSlipstreamBonus) == 0x0000A8, "Wrong size on UGadgetSlipstreamBonus");

// Class UnionRun.GimmickDragonHead
// 0x0050 (0x0600 - 0x05B0)
class alignas(0x10) AGimmickDragonHead final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotateSpeed;                                       // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateMax;                                         // 0x05BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    OpenSoundComponent;                                // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              HeadMesh;                                          // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              HeadMeshJaw;                                       // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D8[0x28];                                     // 0x05D8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickDragonHead">();
	}
	static class AGimmickDragonHead* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickDragonHead>();
	}
};
static_assert(alignof(AGimmickDragonHead) == 0x000010, "Wrong alignment on AGimmickDragonHead");
static_assert(sizeof(AGimmickDragonHead) == 0x000600, "Wrong size on AGimmickDragonHead");
static_assert(offsetof(AGimmickDragonHead, RotateSpeed) == 0x0005B8, "Member 'AGimmickDragonHead::RotateSpeed' has a wrong offset!");
static_assert(offsetof(AGimmickDragonHead, RotateMax) == 0x0005BC, "Member 'AGimmickDragonHead::RotateMax' has a wrong offset!");
static_assert(offsetof(AGimmickDragonHead, OpenSoundComponent) == 0x0005C0, "Member 'AGimmickDragonHead::OpenSoundComponent' has a wrong offset!");
static_assert(offsetof(AGimmickDragonHead, HeadMesh) == 0x0005C8, "Member 'AGimmickDragonHead::HeadMesh' has a wrong offset!");
static_assert(offsetof(AGimmickDragonHead, HeadMeshJaw) == 0x0005D0, "Member 'AGimmickDragonHead::HeadMeshJaw' has a wrong offset!");

// Class UnionRun.GadgetSlowter
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetSlowter final : public UGadgetMachineTuneBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetSlowter">();
	}
	static class UGadgetSlowter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetSlowter>();
	}
};
static_assert(alignof(UGadgetSlowter) == 0x000008, "Wrong alignment on UGadgetSlowter");
static_assert(sizeof(UGadgetSlowter) == 0x0000A0, "Wrong size on UGadgetSlowter");

// Class UnionRun.GimmickUpdraft
// 0x0020 (0x05D0 - 0x05B0)
class alignas(0x10) AGimmickUpdraft final : public AUnionGimmickObjectBase
{
public:
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            StaticBodyComponent;                               // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C0[0x10];                                     // 0x05C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickUpdraft">();
	}
	static class AGimmickUpdraft* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickUpdraft>();
	}
};
static_assert(alignof(AGimmickUpdraft) == 0x000010, "Wrong alignment on AGimmickUpdraft");
static_assert(sizeof(AGimmickUpdraft) == 0x0005D0, "Wrong size on AGimmickUpdraft");
static_assert(offsetof(AGimmickUpdraft, DefaultSceneRoot) == 0x0005B0, "Member 'AGimmickUpdraft::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AGimmickUpdraft, StaticBodyComponent) == 0x0005B8, "Member 'AGimmickUpdraft::StaticBodyComponent' has a wrong offset!");

// Class UnionRun.GadgetSpeedTune
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetSpeedTune final : public UGadgetMachineTuneBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetSpeedTune">();
	}
	static class UGadgetSpeedTune* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetSpeedTune>();
	}
};
static_assert(alignof(UGadgetSpeedTune) == 0x000008, "Wrong alignment on UGadgetSpeedTune");
static_assert(sizeof(UGadgetSpeedTune) == 0x0000A0, "Wrong size on UGadgetSpeedTune");

// Class UnionRun.GadgetSpinDrift
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetSpinDrift final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetSpinDrift">();
	}
	static class UGadgetSpinDrift* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetSpinDrift>();
	}
};
static_assert(alignof(UGadgetSpinDrift) == 0x000008, "Wrong alignment on UGadgetSpinDrift");
static_assert(sizeof(UGadgetSpinDrift) == 0x0000A0, "Wrong size on UGadgetSpinDrift");

// Class UnionRun.GadgetStarter
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetStarter final : public UGadgetMachineTuneBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetStarter">();
	}
	static class UGadgetStarter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetStarter>();
	}
};
static_assert(alignof(UGadgetStarter) == 0x000008, "Wrong alignment on UGadgetStarter");
static_assert(sizeof(UGadgetStarter) == 0x0000A0, "Wrong size on UGadgetStarter");

// Class UnionRun.GimmickRollnigSpike
// 0x00B0 (0x0660 - 0x05B0)
class alignas(0x10) AGimmickRollnigSpike final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              BodyStatickMeshComponent;                          // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERacerDamageType                              DamageType;                                        // 0x05C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C1[0x3];                                      // 0x05C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotateSpeed;                                       // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RandomDirection;                                   // 0x05C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RotateDirection;                                   // 0x05C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5CA[0x6];                                      // 0x05CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UGimmickStaticBodyComponent*            m_MainStaticBodyComponent;                         // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            m_Main2StaticBodyComponent;                        // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E0[0x80];                                     // 0x05E0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickRollnigSpike">();
	}
	static class AGimmickRollnigSpike* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickRollnigSpike>();
	}
};
static_assert(alignof(AGimmickRollnigSpike) == 0x000010, "Wrong alignment on AGimmickRollnigSpike");
static_assert(sizeof(AGimmickRollnigSpike) == 0x000660, "Wrong size on AGimmickRollnigSpike");
static_assert(offsetof(AGimmickRollnigSpike, BodyStatickMeshComponent) == 0x0005B8, "Member 'AGimmickRollnigSpike::BodyStatickMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickRollnigSpike, DamageType) == 0x0005C0, "Member 'AGimmickRollnigSpike::DamageType' has a wrong offset!");
static_assert(offsetof(AGimmickRollnigSpike, RotateSpeed) == 0x0005C4, "Member 'AGimmickRollnigSpike::RotateSpeed' has a wrong offset!");
static_assert(offsetof(AGimmickRollnigSpike, RandomDirection) == 0x0005C8, "Member 'AGimmickRollnigSpike::RandomDirection' has a wrong offset!");
static_assert(offsetof(AGimmickRollnigSpike, RotateDirection) == 0x0005C9, "Member 'AGimmickRollnigSpike::RotateDirection' has a wrong offset!");
static_assert(offsetof(AGimmickRollnigSpike, m_MainStaticBodyComponent) == 0x0005D0, "Member 'AGimmickRollnigSpike::m_MainStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickRollnigSpike, m_Main2StaticBodyComponent) == 0x0005D8, "Member 'AGimmickRollnigSpike::m_Main2StaticBodyComponent' has a wrong offset!");

// Class UnionRun.GadgetStole
// 0x0018 (0x00B8 - 0x00A0)
class UGadgetStole final : public UGadgetBase
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetStole">();
	}
	static class UGadgetStole* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetStole>();
	}
};
static_assert(alignof(UGadgetStole) == 0x000008, "Wrong alignment on UGadgetStole");
static_assert(sizeof(UGadgetStole) == 0x0000B8, "Wrong size on UGadgetStole");

// Class UnionRun.Gimmick_Extnd04_LavaField
// 0x0020 (0x05D0 - 0x05B0)
class alignas(0x10) AGimmick_Extnd04_LavaField final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGimmickStaticBodyComponent*            StaticBody;                                        // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERacerDamageType                              DamageType;                                        // 0x05C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C1[0xF];                                      // 0x05C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd04_LavaField">();
	}
	static class AGimmick_Extnd04_LavaField* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd04_LavaField>();
	}
};
static_assert(alignof(AGimmick_Extnd04_LavaField) == 0x000010, "Wrong alignment on AGimmick_Extnd04_LavaField");
static_assert(sizeof(AGimmick_Extnd04_LavaField) == 0x0005D0, "Wrong size on AGimmick_Extnd04_LavaField");
static_assert(offsetof(AGimmick_Extnd04_LavaField, StaticBody) == 0x0005B8, "Member 'AGimmick_Extnd04_LavaField::StaticBody' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_LavaField, DamageType) == 0x0005C0, "Member 'AGimmick_Extnd04_LavaField::DamageType' has a wrong offset!");

// Class UnionRun.GadgetSuppressRunoff
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetSuppressRunoff final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetSuppressRunoff">();
	}
	static class UGadgetSuppressRunoff* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetSuppressRunoff>();
	}
};
static_assert(alignof(UGadgetSuppressRunoff) == 0x000008, "Wrong alignment on UGadgetSuppressRunoff");
static_assert(sizeof(UGadgetSuppressRunoff) == 0x0000A0, "Wrong size on UGadgetSuppressRunoff");

// Class UnionRun.GadgetSwitchDriftQuickCharge
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetSwitchDriftQuickCharge final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetSwitchDriftQuickCharge">();
	}
	static class UGadgetSwitchDriftQuickCharge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetSwitchDriftQuickCharge>();
	}
};
static_assert(alignof(UGadgetSwitchDriftQuickCharge) == 0x000008, "Wrong alignment on UGadgetSwitchDriftQuickCharge");
static_assert(sizeof(UGadgetSwitchDriftQuickCharge) == 0x0000A0, "Wrong size on UGadgetSwitchDriftQuickCharge");

// Class UnionRun.GadgetTeamEnforceSlipstream
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetTeamEnforceSlipstream final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetTeamEnforceSlipstream">();
	}
	static class UGadgetTeamEnforceSlipstream* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetTeamEnforceSlipstream>();
	}
};
static_assert(alignof(UGadgetTeamEnforceSlipstream) == 0x000008, "Wrong alignment on UGadgetTeamEnforceSlipstream");
static_assert(sizeof(UGadgetTeamEnforceSlipstream) == 0x0000A0, "Wrong size on UGadgetTeamEnforceSlipstream");

// Class UnionRun.GimmickFlyingBounceObject
// 0x0040 (0x05F0 - 0x05B0)
class alignas(0x10) AGimmickFlyingBounceObject final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsWide;                                           // 0x05B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B9[0x7];                                      // 0x05B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              StaticMeshComponent;                               // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            StaticBodyComponent;                               // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FStaticBodyCapsuleParam                BaseCapsuleParam;                                  // 0x05D8(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FStaticBodyCapsuleParam                WideCapsuleParam;                                  // 0x05E0(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	ESpecialObjGroup                              m_SpecialGroup;                                    // 0x05E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E9[0x7];                                      // 0x05E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHitAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickFlyingBounceObject">();
	}
	static class AGimmickFlyingBounceObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickFlyingBounceObject>();
	}
};
static_assert(alignof(AGimmickFlyingBounceObject) == 0x000010, "Wrong alignment on AGimmickFlyingBounceObject");
static_assert(sizeof(AGimmickFlyingBounceObject) == 0x0005F0, "Wrong size on AGimmickFlyingBounceObject");
static_assert(offsetof(AGimmickFlyingBounceObject, bIsWide) == 0x0005B8, "Member 'AGimmickFlyingBounceObject::bIsWide' has a wrong offset!");
static_assert(offsetof(AGimmickFlyingBounceObject, StaticMeshComponent) == 0x0005C0, "Member 'AGimmickFlyingBounceObject::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickFlyingBounceObject, DefaultSceneRoot) == 0x0005C8, "Member 'AGimmickFlyingBounceObject::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AGimmickFlyingBounceObject, StaticBodyComponent) == 0x0005D0, "Member 'AGimmickFlyingBounceObject::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickFlyingBounceObject, BaseCapsuleParam) == 0x0005D8, "Member 'AGimmickFlyingBounceObject::BaseCapsuleParam' has a wrong offset!");
static_assert(offsetof(AGimmickFlyingBounceObject, WideCapsuleParam) == 0x0005E0, "Member 'AGimmickFlyingBounceObject::WideCapsuleParam' has a wrong offset!");
static_assert(offsetof(AGimmickFlyingBounceObject, m_SpecialGroup) == 0x0005E8, "Member 'AGimmickFlyingBounceObject::m_SpecialGroup' has a wrong offset!");

// Class UnionRun.GadgetTeamFriendDash
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetTeamFriendDash final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetTeamFriendDash">();
	}
	static class UGadgetTeamFriendDash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetTeamFriendDash>();
	}
};
static_assert(alignof(UGadgetTeamFriendDash) == 0x000008, "Wrong alignment on UGadgetTeamFriendDash");
static_assert(sizeof(UGadgetTeamFriendDash) == 0x0000A0, "Wrong size on UGadgetTeamFriendDash");

// Class UnionRun.ItemRocketPunchObject
// 0x0320 (0x0890 - 0x0570)
class AItemRocketPunchObject : public AItemObjectBase
{
public:
	uint8                                         Pad_568[0x20];                                     // 0x0568(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Root;                                              // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGOCMovement*                           Movement;                                          // 0x0590(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemStaticBodyComponent*               StaticBody;                                        // 0x0598(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTriggerComponent*                      HitTrigger;                                        // 0x05A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTriggerComponent*                      WallHitTrigger;                                    // 0x05A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NiagaraJet;                                        // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NiagaraHit;                                        // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    MoveSoundComponent;                                // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    HitSoundComponent;                                 // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    ReflectSoundComponent;                             // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLifetime;                                       // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MaxReflectNumForward;                              // 0x05E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        MaxReflectNumBackward;                             // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightAbovePath;                                   // 0x05EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HolderInvencibleTime;                              // 0x05F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableReflect;                                   // 0x05F4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F5[0x3];                                      // 0x05F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThrowFrontMoveCorrectionDistance;                  // 0x05F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRelativeMoveBackParameter             m_relativeMoveParamBack;                           // 0x05FC(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MoveControllerMeshRadius;                          // 0x0614(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshHeightOffset;                                  // 0x0618(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        ForwardSpeed;                                      // 0x061C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        BackwardSpeed;                                     // 0x062C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        FallSpeed;                                         // 0x063C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        FallAcceleration;                                  // 0x064C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeakHomingParam                       WeakHomingParam;                                   // 0x065C(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeakHomingParam                       WeakHomingAirParam;                                // 0x0668(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FWeakHomingParam                       WeakHomingLockOnParam;                             // 0x0674(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         IgnoreGravityDistance;                             // 0x0680(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IgnoreGravityDistancePath;                         // 0x0684(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InfinityMaxLifeTime;                               // 0x0688(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        InfinityMaxReflectNumForward;                      // 0x068C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        InfinityMaxReflectNumBackward;                     // 0x0690(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDraw;                                        // 0x0694(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugOverrideLockOn;                              // 0x0695(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_696[0x2];                                      // 0x0696(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         bDebugOverrideLockOnRacerIndex;                    // 0x0698(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugForceComLockOn;                              // 0x069C(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69D[0x1F3];                                    // 0x069D(0x01F3)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTriggerColliderConflict(const struct FHitTriggerInfo& HitInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemRocketPunchObject">();
	}
	static class AItemRocketPunchObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemRocketPunchObject>();
	}
};
static_assert(alignof(AItemRocketPunchObject) == 0x000010, "Wrong alignment on AItemRocketPunchObject");
static_assert(sizeof(AItemRocketPunchObject) == 0x000890, "Wrong size on AItemRocketPunchObject");
static_assert(offsetof(AItemRocketPunchObject, Root) == 0x000588, "Member 'AItemRocketPunchObject::Root' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, Movement) == 0x000590, "Member 'AItemRocketPunchObject::Movement' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, StaticBody) == 0x000598, "Member 'AItemRocketPunchObject::StaticBody' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, HitTrigger) == 0x0005A0, "Member 'AItemRocketPunchObject::HitTrigger' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, WallHitTrigger) == 0x0005A8, "Member 'AItemRocketPunchObject::WallHitTrigger' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, StaticMeshComponent) == 0x0005B0, "Member 'AItemRocketPunchObject::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, NiagaraJet) == 0x0005B8, "Member 'AItemRocketPunchObject::NiagaraJet' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, NiagaraHit) == 0x0005C0, "Member 'AItemRocketPunchObject::NiagaraHit' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, MoveSoundComponent) == 0x0005C8, "Member 'AItemRocketPunchObject::MoveSoundComponent' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, HitSoundComponent) == 0x0005D0, "Member 'AItemRocketPunchObject::HitSoundComponent' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, ReflectSoundComponent) == 0x0005D8, "Member 'AItemRocketPunchObject::ReflectSoundComponent' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, MaxLifetime) == 0x0005E0, "Member 'AItemRocketPunchObject::MaxLifetime' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, MaxReflectNumForward) == 0x0005E4, "Member 'AItemRocketPunchObject::MaxReflectNumForward' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, MaxReflectNumBackward) == 0x0005E8, "Member 'AItemRocketPunchObject::MaxReflectNumBackward' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, HeightAbovePath) == 0x0005EC, "Member 'AItemRocketPunchObject::HeightAbovePath' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, HolderInvencibleTime) == 0x0005F0, "Member 'AItemRocketPunchObject::HolderInvencibleTime' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, bDisableReflect) == 0x0005F4, "Member 'AItemRocketPunchObject::bDisableReflect' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, ThrowFrontMoveCorrectionDistance) == 0x0005F8, "Member 'AItemRocketPunchObject::ThrowFrontMoveCorrectionDistance' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, m_relativeMoveParamBack) == 0x0005FC, "Member 'AItemRocketPunchObject::m_relativeMoveParamBack' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, MoveControllerMeshRadius) == 0x000614, "Member 'AItemRocketPunchObject::MoveControllerMeshRadius' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, MeshHeightOffset) == 0x000618, "Member 'AItemRocketPunchObject::MeshHeightOffset' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, ForwardSpeed) == 0x00061C, "Member 'AItemRocketPunchObject::ForwardSpeed' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, BackwardSpeed) == 0x00062C, "Member 'AItemRocketPunchObject::BackwardSpeed' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, FallSpeed) == 0x00063C, "Member 'AItemRocketPunchObject::FallSpeed' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, FallAcceleration) == 0x00064C, "Member 'AItemRocketPunchObject::FallAcceleration' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, WeakHomingParam) == 0x00065C, "Member 'AItemRocketPunchObject::WeakHomingParam' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, WeakHomingAirParam) == 0x000668, "Member 'AItemRocketPunchObject::WeakHomingAirParam' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, WeakHomingLockOnParam) == 0x000674, "Member 'AItemRocketPunchObject::WeakHomingLockOnParam' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, IgnoreGravityDistance) == 0x000680, "Member 'AItemRocketPunchObject::IgnoreGravityDistance' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, IgnoreGravityDistancePath) == 0x000684, "Member 'AItemRocketPunchObject::IgnoreGravityDistancePath' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, InfinityMaxLifeTime) == 0x000688, "Member 'AItemRocketPunchObject::InfinityMaxLifeTime' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, InfinityMaxReflectNumForward) == 0x00068C, "Member 'AItemRocketPunchObject::InfinityMaxReflectNumForward' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, InfinityMaxReflectNumBackward) == 0x000690, "Member 'AItemRocketPunchObject::InfinityMaxReflectNumBackward' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, bDebugDraw) == 0x000694, "Member 'AItemRocketPunchObject::bDebugDraw' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, bDebugOverrideLockOn) == 0x000695, "Member 'AItemRocketPunchObject::bDebugOverrideLockOn' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, bDebugOverrideLockOnRacerIndex) == 0x000698, "Member 'AItemRocketPunchObject::bDebugOverrideLockOnRacerIndex' has a wrong offset!");
static_assert(offsetof(AItemRocketPunchObject, bDebugForceComLockOn) == 0x00069C, "Member 'AItemRocketPunchObject::bDebugForceComLockOn' has a wrong offset!");

// Class UnionRun.GadgetTeamTouchDash
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetTeamTouchDash final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetTeamTouchDash">();
	}
	static class UGadgetTeamTouchDash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetTeamTouchDash>();
	}
};
static_assert(alignof(UGadgetTeamTouchDash) == 0x000008, "Wrong alignment on UGadgetTeamTouchDash");
static_assert(sizeof(UGadgetTeamTouchDash) == 0x0000A0, "Wrong size on UGadgetTeamTouchDash");

// Class UnionRun.GadgetThirdFastCharge
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetThirdFastCharge final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetThirdFastCharge">();
	}
	static class UGadgetThirdFastCharge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetThirdFastCharge>();
	}
};
static_assert(alignof(UGadgetThirdFastCharge) == 0x000008, "Wrong alignment on UGadgetThirdFastCharge");
static_assert(sizeof(UGadgetThirdFastCharge) == 0x0000A0, "Wrong size on UGadgetThirdFastCharge");

// Class UnionRun.GadgetTouchDash
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetTouchDash final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetTouchDash">();
	}
	static class UGadgetTouchDash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetTouchDash>();
	}
};
static_assert(alignof(UGadgetTouchDash) == 0x000008, "Wrong alignment on UGadgetTouchDash");
static_assert(sizeof(UGadgetTouchDash) == 0x0000A0, "Wrong size on UGadgetTouchDash");

// Class UnionRun.StaticBodyComponent
// 0x0010 (0x0360 - 0x0350)
#pragma pack(push, 0x1)
class alignas(0x10) UStaticBodyComponent : public UCollisionBaseComponent
{
public:
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticBodyComponent">();
	}
	static class UStaticBodyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStaticBodyComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UStaticBodyComponent) == 0x000010, "Wrong alignment on UStaticBodyComponent");
static_assert(sizeof(UStaticBodyComponent) == 0x000360, "Wrong size on UStaticBodyComponent");

// Class UnionRun.GimmickStaticBodyComponent
// 0x0040 (0x03A0 - 0x0360)
#pragma pack(push, 0x1)
class alignas(0x10) UGimmickStaticBodyComponent : public UStaticBodyComponent
{
public:
	bool                                          bIgnoreItemInvincibleWall;                         // 0x0358(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIgnoreAggressiveInvincibleWall;                   // 0x0359(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIgnoreDefensiveInvincibleWall;                    // 0x035A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIgnoreAutopilotItemEndInvincibleWall;             // 0x035B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseSurfaceSetting;                                // 0x035C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FUnionSurfaceFlag                      EditSurfaceFlag;                                   // 0x035D(0x001F)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	EUnionSurfaceType                             EditSurfaceType;                                   // 0x037C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_37D[0x3];                                      // 0x037D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        CameraId;                                          // 0x0380(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        ParamId;                                           // 0x0384(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EUnionRacePostProcessEffectType               EffectType;                                        // 0x0388(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EResultCameraProductionType                   ResultCameraType;                                  // 0x0389(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38A[0xE];                                      // 0x038A(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCameraId(int32 ID);
	void SetIgnoreItemInvincibleWall(bool flag);
	void SetParamId(int32 ID);
	void SetPostProcessEffectType(EUnionRacePostProcessEffectType Type);
	void SetResultCameraType(EResultCameraProductionType Type);
	void SetSurfaceFlag(const struct FUnionSurfaceFlag& flag);
	void SetSurfaceType(EUnionSurfaceType Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickStaticBodyComponent">();
	}
	static class UGimmickStaticBodyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGimmickStaticBodyComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UGimmickStaticBodyComponent) == 0x000010, "Wrong alignment on UGimmickStaticBodyComponent");
static_assert(sizeof(UGimmickStaticBodyComponent) == 0x0003A0, "Wrong size on UGimmickStaticBodyComponent");
static_assert(offsetof(UGimmickStaticBodyComponent, bIgnoreItemInvincibleWall) == 0x000358, "Member 'UGimmickStaticBodyComponent::bIgnoreItemInvincibleWall' has a wrong offset!");
static_assert(offsetof(UGimmickStaticBodyComponent, bIgnoreAggressiveInvincibleWall) == 0x000359, "Member 'UGimmickStaticBodyComponent::bIgnoreAggressiveInvincibleWall' has a wrong offset!");
static_assert(offsetof(UGimmickStaticBodyComponent, bIgnoreDefensiveInvincibleWall) == 0x00035A, "Member 'UGimmickStaticBodyComponent::bIgnoreDefensiveInvincibleWall' has a wrong offset!");
static_assert(offsetof(UGimmickStaticBodyComponent, bIgnoreAutopilotItemEndInvincibleWall) == 0x00035B, "Member 'UGimmickStaticBodyComponent::bIgnoreAutopilotItemEndInvincibleWall' has a wrong offset!");
static_assert(offsetof(UGimmickStaticBodyComponent, bUseSurfaceSetting) == 0x00035C, "Member 'UGimmickStaticBodyComponent::bUseSurfaceSetting' has a wrong offset!");
static_assert(offsetof(UGimmickStaticBodyComponent, EditSurfaceFlag) == 0x00035D, "Member 'UGimmickStaticBodyComponent::EditSurfaceFlag' has a wrong offset!");
static_assert(offsetof(UGimmickStaticBodyComponent, EditSurfaceType) == 0x00037C, "Member 'UGimmickStaticBodyComponent::EditSurfaceType' has a wrong offset!");
static_assert(offsetof(UGimmickStaticBodyComponent, CameraId) == 0x000380, "Member 'UGimmickStaticBodyComponent::CameraId' has a wrong offset!");
static_assert(offsetof(UGimmickStaticBodyComponent, ParamId) == 0x000384, "Member 'UGimmickStaticBodyComponent::ParamId' has a wrong offset!");
static_assert(offsetof(UGimmickStaticBodyComponent, EffectType) == 0x000388, "Member 'UGimmickStaticBodyComponent::EffectType' has a wrong offset!");
static_assert(offsetof(UGimmickStaticBodyComponent, ResultCameraType) == 0x000389, "Member 'UGimmickStaticBodyComponent::ResultCameraType' has a wrong offset!");

// Class UnionRun.GadgetTradeStock
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetTradeStock final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetTradeStock">();
	}
	static class UGadgetTradeStock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetTradeStock>();
	}
};
static_assert(alignof(UGadgetTradeStock) == 0x000008, "Wrong alignment on UGadgetTradeStock");
static_assert(sizeof(UGadgetTradeStock) == 0x0000A0, "Wrong size on UGadgetTradeStock");

// Class UnionRun.Gimmick_Extnd05_HouseB
// 0x0040 (0x05F0 - 0x05B0)
class alignas(0x10) AGimmick_Extnd05_HouseB final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              HouseMesh;                                         // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      WaterEffect;                                       // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    MoveSound;                                         // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    EndSound;                                          // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DelayTime;                                         // 0x05D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5DC[0x14];                                     // 0x05DC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd05_HouseB">();
	}
	static class AGimmick_Extnd05_HouseB* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd05_HouseB>();
	}
};
static_assert(alignof(AGimmick_Extnd05_HouseB) == 0x000010, "Wrong alignment on AGimmick_Extnd05_HouseB");
static_assert(sizeof(AGimmick_Extnd05_HouseB) == 0x0005F0, "Wrong size on AGimmick_Extnd05_HouseB");
static_assert(offsetof(AGimmick_Extnd05_HouseB, HouseMesh) == 0x0005B8, "Member 'AGimmick_Extnd05_HouseB::HouseMesh' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_HouseB, WaterEffect) == 0x0005C0, "Member 'AGimmick_Extnd05_HouseB::WaterEffect' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_HouseB, MoveSound) == 0x0005C8, "Member 'AGimmick_Extnd05_HouseB::MoveSound' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_HouseB, EndSound) == 0x0005D0, "Member 'AGimmick_Extnd05_HouseB::EndSound' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_HouseB, DelayTime) == 0x0005D8, "Member 'AGimmick_Extnd05_HouseB::DelayTime' has a wrong offset!");

// Class UnionRun.GadgetUltimateDrift
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetUltimateDrift final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetUltimateDrift">();
	}
	static class UGadgetUltimateDrift* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetUltimateDrift>();
	}
};
static_assert(alignof(UGadgetUltimateDrift) == 0x000008, "Wrong alignment on UGadgetUltimateDrift");
static_assert(sizeof(UGadgetUltimateDrift) == 0x0000A0, "Wrong size on UGadgetUltimateDrift");

// Class UnionRun.GadgetUpLuck
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetUpLuck final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetUpLuck">();
	}
	static class UGadgetUpLuck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetUpLuck>();
	}
};
static_assert(alignof(UGadgetUpLuck) == 0x000008, "Wrong alignment on UGadgetUpLuck");
static_assert(sizeof(UGadgetUpLuck) == 0x0000A0, "Wrong size on UGadgetUpLuck");

// Class UnionRun.GadgetUpperLimit
// 0x0000 (0x00A0 - 0x00A0)
class UGadgetUpperLimit final : public UGadgetBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetUpperLimit">();
	}
	static class UGadgetUpperLimit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetUpperLimit>();
	}
};
static_assert(alignof(UGadgetUpperLimit) == 0x000008, "Wrong alignment on UGadgetUpperLimit");
static_assert(sizeof(UGadgetUpperLimit) == 0x0000A0, "Wrong size on UGadgetUpperLimit");

// Class UnionRun.Gimmick_Extnd04_FadePillar
// 0x0020 (0x05D0 - 0x05B0)
class alignas(0x10) AGimmick_Extnd04_FadePillar final : public AUnionGimmickObjectBase
{
public:
	class UStaticMeshComponent*                   m_staticMeshComponent;                             // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_niagaraComponent;                                // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C8[0x8];                                      // 0x05C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd04_FadePillar">();
	}
	static class AGimmick_Extnd04_FadePillar* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd04_FadePillar>();
	}
};
static_assert(alignof(AGimmick_Extnd04_FadePillar) == 0x000010, "Wrong alignment on AGimmick_Extnd04_FadePillar");
static_assert(sizeof(AGimmick_Extnd04_FadePillar) == 0x0005D0, "Wrong size on AGimmick_Extnd04_FadePillar");
static_assert(offsetof(AGimmick_Extnd04_FadePillar, m_staticMeshComponent) == 0x0005B0, "Member 'AGimmick_Extnd04_FadePillar::m_staticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_FadePillar, m_niagaraComponent) == 0x0005B8, "Member 'AGimmick_Extnd04_FadePillar::m_niagaraComponent' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_FadePillar, DefaultSceneRoot) == 0x0005C0, "Member 'AGimmick_Extnd04_FadePillar::DefaultSceneRoot' has a wrong offset!");

// Class UnionRun.GadgetVariousBase
// 0x0010 (0x00B0 - 0x00A0)
class UGadgetVariousBase final : public UGadgetBase
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GadgetVariousBase">();
	}
	static class UGadgetVariousBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGadgetVariousBase>();
	}
};
static_assert(alignof(UGadgetVariousBase) == 0x000008, "Wrong alignment on UGadgetVariousBase");
static_assert(sizeof(UGadgetVariousBase) == 0x0000B0, "Wrong size on UGadgetVariousBase");

// Class UnionRun.GearObject
// 0x0010 (0x02A0 - 0x0290)
class AGearObject final : public AActor
{
public:
	class UUnionStaticMeshComponent*              StaticMeshComponent;                               // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotZ;                                              // 0x0298(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GearObject">();
	}
	static class AGearObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGearObject>();
	}
};
static_assert(alignof(AGearObject) == 0x000008, "Wrong alignment on AGearObject");
static_assert(sizeof(AGearObject) == 0x0002A0, "Wrong size on AGearObject");
static_assert(offsetof(AGearObject, StaticMeshComponent) == 0x000290, "Member 'AGearObject::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGearObject, RotZ) == 0x000298, "Member 'AGearObject::RotZ' has a wrong offset!");

// Class UnionRun.GimmickAsteroid
// 0x0090 (0x0640 - 0x05B0)
class alignas(0x10) AGimmickAsteroid final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ERacerDamageType                              DamageType;                                        // 0x05B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B9[0x7];                                      // 0x05B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              BodyStatickMeshComponent;                          // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    CarHitSoundComponent;                              // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    IdleSoundComponent;                                // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            m_MainStaticBodyComponent;                         // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            m_Main2StaticBodyComponent;                        // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            m_Main3StaticBodyComponent;                        // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            m_Main4StaticBodyComponent;                        // 0x05F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            m_Main5StaticBodyComponent;                        // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            m_Main6StaticBodyComponent;                        // 0x0600(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_608[0x38];                                     // 0x0608(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickAsteroid">();
	}
	static class AGimmickAsteroid* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickAsteroid>();
	}
};
static_assert(alignof(AGimmickAsteroid) == 0x000010, "Wrong alignment on AGimmickAsteroid");
static_assert(sizeof(AGimmickAsteroid) == 0x000640, "Wrong size on AGimmickAsteroid");
static_assert(offsetof(AGimmickAsteroid, DamageType) == 0x0005B8, "Member 'AGimmickAsteroid::DamageType' has a wrong offset!");
static_assert(offsetof(AGimmickAsteroid, BodyStatickMeshComponent) == 0x0005C0, "Member 'AGimmickAsteroid::BodyStatickMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickAsteroid, CarHitSoundComponent) == 0x0005C8, "Member 'AGimmickAsteroid::CarHitSoundComponent' has a wrong offset!");
static_assert(offsetof(AGimmickAsteroid, IdleSoundComponent) == 0x0005D0, "Member 'AGimmickAsteroid::IdleSoundComponent' has a wrong offset!");
static_assert(offsetof(AGimmickAsteroid, m_MainStaticBodyComponent) == 0x0005D8, "Member 'AGimmickAsteroid::m_MainStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickAsteroid, m_Main2StaticBodyComponent) == 0x0005E0, "Member 'AGimmickAsteroid::m_Main2StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickAsteroid, m_Main3StaticBodyComponent) == 0x0005E8, "Member 'AGimmickAsteroid::m_Main3StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickAsteroid, m_Main4StaticBodyComponent) == 0x0005F0, "Member 'AGimmickAsteroid::m_Main4StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickAsteroid, m_Main5StaticBodyComponent) == 0x0005F8, "Member 'AGimmickAsteroid::m_Main5StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickAsteroid, m_Main6StaticBodyComponent) == 0x000600, "Member 'AGimmickAsteroid::m_Main6StaticBodyComponent' has a wrong offset!");

// Class UnionRun.GimmickBalloon
// 0x0040 (0x05F0 - 0x05B0)
class alignas(0x10) AGimmickBalloon final : public AUnionGimmickObjectBase
{
public:
	class UUnionSkeletalMeshComponent*            SkeletalMeshComponent;                             // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            JumpStaticBodyComponent;                           // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            WallStaticBodyComponent;                           // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationInitialPosition;                          // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayAnimation;                                    // 0x05CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5CD[0x13];                                     // 0x05CD(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          AnimSequence;                                      // 0x05E0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E8[0x8];                                      // 0x05E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickBalloon">();
	}
	static class AGimmickBalloon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickBalloon>();
	}
};
static_assert(alignof(AGimmickBalloon) == 0x000010, "Wrong alignment on AGimmickBalloon");
static_assert(sizeof(AGimmickBalloon) == 0x0005F0, "Wrong size on AGimmickBalloon");
static_assert(offsetof(AGimmickBalloon, SkeletalMeshComponent) == 0x0005B0, "Member 'AGimmickBalloon::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickBalloon, JumpStaticBodyComponent) == 0x0005B8, "Member 'AGimmickBalloon::JumpStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickBalloon, WallStaticBodyComponent) == 0x0005C0, "Member 'AGimmickBalloon::WallStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickBalloon, AnimationInitialPosition) == 0x0005C8, "Member 'AGimmickBalloon::AnimationInitialPosition' has a wrong offset!");
static_assert(offsetof(AGimmickBalloon, bPlayAnimation) == 0x0005CC, "Member 'AGimmickBalloon::bPlayAnimation' has a wrong offset!");
static_assert(offsetof(AGimmickBalloon, AnimSequence) == 0x0005E0, "Member 'AGimmickBalloon::AnimSequence' has a wrong offset!");

// Class UnionRun.GimmickBigDrill
// 0x0040 (0x05F0 - 0x05B0)
class alignas(0x10) AGimmickBigDrill final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionStaticMeshComponent*              StaticMeshComponent;                               // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    AtomComponent;                                     // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            UpperStaticBodyComponent;                          // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            MiddleStaticBodyComponent;                         // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            LowerStaticBodyComponent;                          // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         YawRotSpeed;                                       // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERacerDamageType                              DamageType;                                        // 0x05EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5ED[0x3];                                      // 0x05ED(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickBigDrill">();
	}
	static class AGimmickBigDrill* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickBigDrill>();
	}
};
static_assert(alignof(AGimmickBigDrill) == 0x000010, "Wrong alignment on AGimmickBigDrill");
static_assert(sizeof(AGimmickBigDrill) == 0x0005F0, "Wrong size on AGimmickBigDrill");
static_assert(offsetof(AGimmickBigDrill, DefaultSceneRoot) == 0x0005B8, "Member 'AGimmickBigDrill::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AGimmickBigDrill, StaticMeshComponent) == 0x0005C0, "Member 'AGimmickBigDrill::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickBigDrill, AtomComponent) == 0x0005C8, "Member 'AGimmickBigDrill::AtomComponent' has a wrong offset!");
static_assert(offsetof(AGimmickBigDrill, UpperStaticBodyComponent) == 0x0005D0, "Member 'AGimmickBigDrill::UpperStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickBigDrill, MiddleStaticBodyComponent) == 0x0005D8, "Member 'AGimmickBigDrill::MiddleStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickBigDrill, LowerStaticBodyComponent) == 0x0005E0, "Member 'AGimmickBigDrill::LowerStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickBigDrill, YawRotSpeed) == 0x0005E8, "Member 'AGimmickBigDrill::YawRotSpeed' has a wrong offset!");
static_assert(offsetof(AGimmickBigDrill, DamageType) == 0x0005EC, "Member 'AGimmickBigDrill::DamageType' has a wrong offset!");

// Class UnionRun.GimmickBingoBall
// 0x0040 (0x05F0 - 0x05B0)
class alignas(0x10) AGimmickBingoBall final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionSkeletalMeshComponent*            SkeletalMeshComponent;                             // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionStaticMeshComponent*              StaticMeshComponent;                               // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticBodyComponent*                   BallStaticBodyComponent;                           // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          AnimSequence;                                      // 0x05D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERacerDamageType                              DamageType;                                        // 0x05D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D9[0x17];                                     // 0x05D9(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCollisionSocketName(class FName NewName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickBingoBall">();
	}
	static class AGimmickBingoBall* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickBingoBall>();
	}
};
static_assert(alignof(AGimmickBingoBall) == 0x000010, "Wrong alignment on AGimmickBingoBall");
static_assert(sizeof(AGimmickBingoBall) == 0x0005F0, "Wrong size on AGimmickBingoBall");
static_assert(offsetof(AGimmickBingoBall, SkeletalMeshComponent) == 0x0005B8, "Member 'AGimmickBingoBall::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickBingoBall, StaticMeshComponent) == 0x0005C0, "Member 'AGimmickBingoBall::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickBingoBall, BallStaticBodyComponent) == 0x0005C8, "Member 'AGimmickBingoBall::BallStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickBingoBall, AnimSequence) == 0x0005D0, "Member 'AGimmickBingoBall::AnimSequence' has a wrong offset!");
static_assert(offsetof(AGimmickBingoBall, DamageType) == 0x0005D8, "Member 'AGimmickBingoBall::DamageType' has a wrong offset!");

// Class UnionRun.GimmickBollard
// 0x0190 (0x0740 - 0x05B0)
class alignas(0x10) AGimmickBollard final : public AUnionGimmickObjectBase
{
public:
	class UUnionVATMeshComponent*                 BollardVATMesh;                                    // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTriggerComponent*                      BollardBodyCylinderTrigger;                        // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTriggerComponent*                      BollardAirBoxTrigger;                              // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        RotatePitchRoot;                                   // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallDownSpeedRate;                                 // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeepLyingDownTime;                                 // 0x05D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GetUpSpeedRate;                                    // 0x05D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateSpeed;                                       // 0x05DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGimmickBollardType                           Type;                                              // 0x05E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E1[0x7];                                      // 0x05E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EGimmickBollardType, class UStaticMesh*> ModelByType;                                       // 0x05E8(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<EGimmickBollardType, class UAnimToTextureDataAsset*> AnimationByType;                       // 0x0638(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_688[0xB8];                                     // 0x0688(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTriggerColliderConflict(const struct FHitTriggerInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickBollard">();
	}
	static class AGimmickBollard* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickBollard>();
	}
};
static_assert(alignof(AGimmickBollard) == 0x000010, "Wrong alignment on AGimmickBollard");
static_assert(sizeof(AGimmickBollard) == 0x000740, "Wrong size on AGimmickBollard");
static_assert(offsetof(AGimmickBollard, BollardVATMesh) == 0x0005B0, "Member 'AGimmickBollard::BollardVATMesh' has a wrong offset!");
static_assert(offsetof(AGimmickBollard, BollardBodyCylinderTrigger) == 0x0005B8, "Member 'AGimmickBollard::BollardBodyCylinderTrigger' has a wrong offset!");
static_assert(offsetof(AGimmickBollard, BollardAirBoxTrigger) == 0x0005C0, "Member 'AGimmickBollard::BollardAirBoxTrigger' has a wrong offset!");
static_assert(offsetof(AGimmickBollard, RotatePitchRoot) == 0x0005C8, "Member 'AGimmickBollard::RotatePitchRoot' has a wrong offset!");
static_assert(offsetof(AGimmickBollard, FallDownSpeedRate) == 0x0005D0, "Member 'AGimmickBollard::FallDownSpeedRate' has a wrong offset!");
static_assert(offsetof(AGimmickBollard, KeepLyingDownTime) == 0x0005D4, "Member 'AGimmickBollard::KeepLyingDownTime' has a wrong offset!");
static_assert(offsetof(AGimmickBollard, GetUpSpeedRate) == 0x0005D8, "Member 'AGimmickBollard::GetUpSpeedRate' has a wrong offset!");
static_assert(offsetof(AGimmickBollard, RotateSpeed) == 0x0005DC, "Member 'AGimmickBollard::RotateSpeed' has a wrong offset!");
static_assert(offsetof(AGimmickBollard, Type) == 0x0005E0, "Member 'AGimmickBollard::Type' has a wrong offset!");
static_assert(offsetof(AGimmickBollard, ModelByType) == 0x0005E8, "Member 'AGimmickBollard::ModelByType' has a wrong offset!");
static_assert(offsetof(AGimmickBollard, AnimationByType) == 0x000638, "Member 'AGimmickBollard::AnimationByType' has a wrong offset!");

// Class UnionRun.GimmickBreakablePumpkin
// 0x0000 (0x06A0 - 0x06A0)
class AGimmickBreakablePumpkin final : public AVATBreakObjectBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickBreakablePumpkin">();
	}
	static class AGimmickBreakablePumpkin* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickBreakablePumpkin>();
	}
};
static_assert(alignof(AGimmickBreakablePumpkin) == 0x000010, "Wrong alignment on AGimmickBreakablePumpkin");
static_assert(sizeof(AGimmickBreakablePumpkin) == 0x0006A0, "Wrong size on AGimmickBreakablePumpkin");

// Class UnionRun.GimmickBucketWheel
// 0x00C0 (0x0670 - 0x05B0)
class alignas(0x10) AGimmickBucketWheel final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionSkeletalMeshComponent*            m_skeletalMesh;                                    // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGimmickStaticBodyComponent*>    m_bodyList;                                        // 0x05C0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	ERacerDamageType                              DamageType;                                        // 0x05D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D1[0x7];                                      // 0x05D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    AtomComponent;                                     // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E8[0x88];                                     // 0x05E8(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickBucketWheel">();
	}
	static class AGimmickBucketWheel* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickBucketWheel>();
	}
};
static_assert(alignof(AGimmickBucketWheel) == 0x000010, "Wrong alignment on AGimmickBucketWheel");
static_assert(sizeof(AGimmickBucketWheel) == 0x000670, "Wrong size on AGimmickBucketWheel");
static_assert(offsetof(AGimmickBucketWheel, m_skeletalMesh) == 0x0005B8, "Member 'AGimmickBucketWheel::m_skeletalMesh' has a wrong offset!");
static_assert(offsetof(AGimmickBucketWheel, m_bodyList) == 0x0005C0, "Member 'AGimmickBucketWheel::m_bodyList' has a wrong offset!");
static_assert(offsetof(AGimmickBucketWheel, DamageType) == 0x0005D0, "Member 'AGimmickBucketWheel::DamageType' has a wrong offset!");
static_assert(offsetof(AGimmickBucketWheel, DefaultSceneRoot) == 0x0005D8, "Member 'AGimmickBucketWheel::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AGimmickBucketWheel, AtomComponent) == 0x0005E0, "Member 'AGimmickBucketWheel::AtomComponent' has a wrong offset!");

// Class UnionRun.GimmickCannonBoo
// 0x0040 (0x05F0 - 0x05B0)
class alignas(0x10) AGimmickCannonBoo final : public AUnionGimmickObjectBase
{
public:
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionVATMeshComponent*                 BulletBooVATMeshComponent;                         // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionVATMeshComponent*                 GunnerBooVATMeshComponent;                         // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionStaticMeshComponent*              CannonStaticMeshComponent;                         // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      NiagaraCannon;                                     // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AnimStartFrame;                                    // 0x05D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         EffectSpawnFrame;                                  // 0x05DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          UseBallet;                                         // 0x05E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E1[0x3];                                      // 0x05E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LoadingSoundFrame;                                 // 0x05E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         FireSoundFrame;                                    // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5EC[0x4];                                      // 0x05EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnVATFrameFunction(class UUnionVATMeshComponent* VATMeshComponent, const struct FUnionVATSequenceInfo& SequenceInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickCannonBoo">();
	}
	static class AGimmickCannonBoo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickCannonBoo>();
	}
};
static_assert(alignof(AGimmickCannonBoo) == 0x000010, "Wrong alignment on AGimmickCannonBoo");
static_assert(sizeof(AGimmickCannonBoo) == 0x0005F0, "Wrong size on AGimmickCannonBoo");
static_assert(offsetof(AGimmickCannonBoo, DefaultSceneRoot) == 0x0005B0, "Member 'AGimmickCannonBoo::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AGimmickCannonBoo, BulletBooVATMeshComponent) == 0x0005B8, "Member 'AGimmickCannonBoo::BulletBooVATMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickCannonBoo, GunnerBooVATMeshComponent) == 0x0005C0, "Member 'AGimmickCannonBoo::GunnerBooVATMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickCannonBoo, CannonStaticMeshComponent) == 0x0005C8, "Member 'AGimmickCannonBoo::CannonStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickCannonBoo, NiagaraCannon) == 0x0005D0, "Member 'AGimmickCannonBoo::NiagaraCannon' has a wrong offset!");
static_assert(offsetof(AGimmickCannonBoo, AnimStartFrame) == 0x0005D8, "Member 'AGimmickCannonBoo::AnimStartFrame' has a wrong offset!");
static_assert(offsetof(AGimmickCannonBoo, EffectSpawnFrame) == 0x0005DC, "Member 'AGimmickCannonBoo::EffectSpawnFrame' has a wrong offset!");
static_assert(offsetof(AGimmickCannonBoo, UseBallet) == 0x0005E0, "Member 'AGimmickCannonBoo::UseBallet' has a wrong offset!");
static_assert(offsetof(AGimmickCannonBoo, LoadingSoundFrame) == 0x0005E4, "Member 'AGimmickCannonBoo::LoadingSoundFrame' has a wrong offset!");
static_assert(offsetof(AGimmickCannonBoo, FireSoundFrame) == 0x0005E8, "Member 'AGimmickCannonBoo::FireSoundFrame' has a wrong offset!");

// Class UnionRun.GimmickCrab
// 0x0040 (0x05F0 - 0x05B0)
class alignas(0x10) AGimmickCrab final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionSkeletalMeshComponent*            SkeletalMeshComponent;                             // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            StaticBodyComponent;                               // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionStaticMeshComponent*              StaticMeshComponent;                               // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      DeadEffect;                                        // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    DeadSound;                                         // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERacerDamageType                              DamageType;                                        // 0x05E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E1[0xF];                                      // 0x05E1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsMovingLeft() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickCrab">();
	}
	static class AGimmickCrab* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickCrab>();
	}
};
static_assert(alignof(AGimmickCrab) == 0x000010, "Wrong alignment on AGimmickCrab");
static_assert(sizeof(AGimmickCrab) == 0x0005F0, "Wrong size on AGimmickCrab");
static_assert(offsetof(AGimmickCrab, SkeletalMeshComponent) == 0x0005B8, "Member 'AGimmickCrab::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickCrab, StaticBodyComponent) == 0x0005C0, "Member 'AGimmickCrab::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickCrab, StaticMeshComponent) == 0x0005C8, "Member 'AGimmickCrab::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickCrab, DeadEffect) == 0x0005D0, "Member 'AGimmickCrab::DeadEffect' has a wrong offset!");
static_assert(offsetof(AGimmickCrab, DeadSound) == 0x0005D8, "Member 'AGimmickCrab::DeadSound' has a wrong offset!");
static_assert(offsetof(AGimmickCrab, DamageType) == 0x0005E0, "Member 'AGimmickCrab::DamageType' has a wrong offset!");

// Class UnionRun.GimmickDisplayShip
// 0x0010 (0x05C0 - 0x05B0)
class alignas(0x10) AGimmickDisplayShip final : public AUnionGimmickObjectBase
{
public:
	class UUnionStaticMeshComponent*              BodyStatickMeshComponent;                          // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickDisplayShip">();
	}
	static class AGimmickDisplayShip* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickDisplayShip>();
	}
};
static_assert(alignof(AGimmickDisplayShip) == 0x000010, "Wrong alignment on AGimmickDisplayShip");
static_assert(sizeof(AGimmickDisplayShip) == 0x0005C0, "Wrong size on AGimmickDisplayShip");
static_assert(offsetof(AGimmickDisplayShip, BodyStatickMeshComponent) == 0x0005B0, "Member 'AGimmickDisplayShip::BodyStatickMeshComponent' has a wrong offset!");

// Class UnionRun.GimmickDonutRail
// 0x0060 (0x0610 - 0x05B0)
class alignas(0x10) AGimmickDonutRail final : public AUnionGimmickObjectBase
{
public:
	class UUnionStaticMeshComponent*              m_mesh;                                            // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOneDirectionComponent*                 m_direction;                                       // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        m_donutsRoot;                                      // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         m_donutNum;                                        // 0x05C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_donutSize;                                       // 0x05CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_carrySpeed;                                      // 0x05D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D4[0x4];                                      // 0x05D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AGimmickDonutHoop>          m_donutHoopReference;                              // 0x05D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDonutHoopParam>                m_paramList;                                       // 0x05E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F0[0x20];                                     // 0x05F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickDonutRail">();
	}
	static class AGimmickDonutRail* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickDonutRail>();
	}
};
static_assert(alignof(AGimmickDonutRail) == 0x000010, "Wrong alignment on AGimmickDonutRail");
static_assert(sizeof(AGimmickDonutRail) == 0x000610, "Wrong size on AGimmickDonutRail");
static_assert(offsetof(AGimmickDonutRail, m_mesh) == 0x0005B0, "Member 'AGimmickDonutRail::m_mesh' has a wrong offset!");
static_assert(offsetof(AGimmickDonutRail, m_direction) == 0x0005B8, "Member 'AGimmickDonutRail::m_direction' has a wrong offset!");
static_assert(offsetof(AGimmickDonutRail, m_donutsRoot) == 0x0005C0, "Member 'AGimmickDonutRail::m_donutsRoot' has a wrong offset!");
static_assert(offsetof(AGimmickDonutRail, m_donutNum) == 0x0005C8, "Member 'AGimmickDonutRail::m_donutNum' has a wrong offset!");
static_assert(offsetof(AGimmickDonutRail, m_donutSize) == 0x0005CC, "Member 'AGimmickDonutRail::m_donutSize' has a wrong offset!");
static_assert(offsetof(AGimmickDonutRail, m_carrySpeed) == 0x0005D0, "Member 'AGimmickDonutRail::m_carrySpeed' has a wrong offset!");
static_assert(offsetof(AGimmickDonutRail, m_donutHoopReference) == 0x0005D8, "Member 'AGimmickDonutRail::m_donutHoopReference' has a wrong offset!");
static_assert(offsetof(AGimmickDonutRail, m_paramList) == 0x0005E0, "Member 'AGimmickDonutRail::m_paramList' has a wrong offset!");

// Class UnionRun.GimmickEggChaserController
// 0x02B0 (0x0860 - 0x05B0)
class alignas(0x10) AGimmickEggChaserController final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGOCMovement*                           Movement;                                          // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateSpeed;                                       // 0x05C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetDistance;                                    // 0x05C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightOffset;                                      // 0x05C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChaseAttackStartTime;                              // 0x05CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChaseAttackIntervalTime;                           // 0x05D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopAttackIntervalTime;                            // 0x05D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChaseAttackingTime;                                // 0x05D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackWarningTime;                                 // 0x05DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceScale;                                     // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E4[0x4];                                      // 0x05E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F0[0x270];                                    // 0x05F0(0x0270)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateChaser();
	void StartAttack(bool isRightObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickEggChaserController">();
	}
	static class AGimmickEggChaserController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickEggChaserController>();
	}
};
static_assert(alignof(AGimmickEggChaserController) == 0x000010, "Wrong alignment on AGimmickEggChaserController");
static_assert(sizeof(AGimmickEggChaserController) == 0x000860, "Wrong size on AGimmickEggChaserController");
static_assert(offsetof(AGimmickEggChaserController, Movement) == 0x0005B8, "Member 'AGimmickEggChaserController::Movement' has a wrong offset!");
static_assert(offsetof(AGimmickEggChaserController, RotateSpeed) == 0x0005C0, "Member 'AGimmickEggChaserController::RotateSpeed' has a wrong offset!");
static_assert(offsetof(AGimmickEggChaserController, TargetDistance) == 0x0005C4, "Member 'AGimmickEggChaserController::TargetDistance' has a wrong offset!");
static_assert(offsetof(AGimmickEggChaserController, HeightOffset) == 0x0005C8, "Member 'AGimmickEggChaserController::HeightOffset' has a wrong offset!");
static_assert(offsetof(AGimmickEggChaserController, ChaseAttackStartTime) == 0x0005CC, "Member 'AGimmickEggChaserController::ChaseAttackStartTime' has a wrong offset!");
static_assert(offsetof(AGimmickEggChaserController, ChaseAttackIntervalTime) == 0x0005D0, "Member 'AGimmickEggChaserController::ChaseAttackIntervalTime' has a wrong offset!");
static_assert(offsetof(AGimmickEggChaserController, StopAttackIntervalTime) == 0x0005D4, "Member 'AGimmickEggChaserController::StopAttackIntervalTime' has a wrong offset!");
static_assert(offsetof(AGimmickEggChaserController, ChaseAttackingTime) == 0x0005D8, "Member 'AGimmickEggChaserController::ChaseAttackingTime' has a wrong offset!");
static_assert(offsetof(AGimmickEggChaserController, AttackWarningTime) == 0x0005DC, "Member 'AGimmickEggChaserController::AttackWarningTime' has a wrong offset!");
static_assert(offsetof(AGimmickEggChaserController, DistanceScale) == 0x0005E0, "Member 'AGimmickEggChaserController::DistanceScale' has a wrong offset!");
static_assert(offsetof(AGimmickEggChaserController, DefaultSceneRoot) == 0x0005E8, "Member 'AGimmickEggChaserController::DefaultSceneRoot' has a wrong offset!");

// Class UnionRun.GimmickFadeGround
// 0x0010 (0x05C0 - 0x05B0)
class alignas(0x10) AGimmickFadeGround final : public AUnionGimmickObjectBase
{
public:
	class UStaticMeshComponent*                   m_staticMeshComponent;                             // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickFadeGround">();
	}
	static class AGimmickFadeGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickFadeGround>();
	}
};
static_assert(alignof(AGimmickFadeGround) == 0x000010, "Wrong alignment on AGimmickFadeGround");
static_assert(sizeof(AGimmickFadeGround) == 0x0005C0, "Wrong size on AGimmickFadeGround");
static_assert(offsetof(AGimmickFadeGround, m_staticMeshComponent) == 0x0005B0, "Member 'AGimmickFadeGround::m_staticMeshComponent' has a wrong offset!");

// Class UnionRun.GimmickFieldLaser
// 0x0040 (0x05F0 - 0x05B0)
class alignas(0x10) AGimmickFieldLaser final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ERacerDamageType                              DamageType;                                        // 0x05B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B9[0x7];                                      // 0x05B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              m_bodyStaticMeshComponent;                         // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_hitEffect;                                       // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            m_attackMainStaticBodyComponent;                   // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    AttackSoundComponent;                              // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E0[0x10];                                     // 0x05E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickFieldLaser">();
	}
	static class AGimmickFieldLaser* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickFieldLaser>();
	}
};
static_assert(alignof(AGimmickFieldLaser) == 0x000010, "Wrong alignment on AGimmickFieldLaser");
static_assert(sizeof(AGimmickFieldLaser) == 0x0005F0, "Wrong size on AGimmickFieldLaser");
static_assert(offsetof(AGimmickFieldLaser, DamageType) == 0x0005B8, "Member 'AGimmickFieldLaser::DamageType' has a wrong offset!");
static_assert(offsetof(AGimmickFieldLaser, m_bodyStaticMeshComponent) == 0x0005C0, "Member 'AGimmickFieldLaser::m_bodyStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickFieldLaser, m_hitEffect) == 0x0005C8, "Member 'AGimmickFieldLaser::m_hitEffect' has a wrong offset!");
static_assert(offsetof(AGimmickFieldLaser, m_attackMainStaticBodyComponent) == 0x0005D0, "Member 'AGimmickFieldLaser::m_attackMainStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickFieldLaser, AttackSoundComponent) == 0x0005D8, "Member 'AGimmickFieldLaser::AttackSoundComponent' has a wrong offset!");

// Class UnionRun.GimmickFireworks
// 0x0028 (0x0368 - 0x0340)
class AGimmickFireworks final : public AUnionCourseObjectBase
{
public:
	class UNiagaraComponent*                      m_niagaraComponent;                                // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionAtomComponent*                    AtomComponent;                                     // 0x0348(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0350(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StartDelayTime;                                    // 0x0358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          NXIgnore;                                          // 0x035C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_35D[0xB];                                      // 0x035D(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickFireworks">();
	}
	static class AGimmickFireworks* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickFireworks>();
	}
};
static_assert(alignof(AGimmickFireworks) == 0x000008, "Wrong alignment on AGimmickFireworks");
static_assert(sizeof(AGimmickFireworks) == 0x000368, "Wrong size on AGimmickFireworks");
static_assert(offsetof(AGimmickFireworks, m_niagaraComponent) == 0x000340, "Member 'AGimmickFireworks::m_niagaraComponent' has a wrong offset!");
static_assert(offsetof(AGimmickFireworks, AtomComponent) == 0x000348, "Member 'AGimmickFireworks::AtomComponent' has a wrong offset!");
static_assert(offsetof(AGimmickFireworks, DefaultSceneRoot) == 0x000350, "Member 'AGimmickFireworks::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AGimmickFireworks, StartDelayTime) == 0x000358, "Member 'AGimmickFireworks::StartDelayTime' has a wrong offset!");
static_assert(offsetof(AGimmickFireworks, NXIgnore) == 0x00035C, "Member 'AGimmickFireworks::NXIgnore' has a wrong offset!");

// Class UnionRun.GimmickFracturedRock
// 0x0038 (0x0378 - 0x0340)
class AGimmickFracturedRock final : public AUnionCourseObjectBase
{
public:
	class UStaticMeshComponent*                   m_staticMeshComponent;                             // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_niagaraComponent;                                // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_animationEndFrame;                               // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_animationSpeed_fps;                              // 0x0354(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_meshHiddenTimer;                                 // 0x0358(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35C[0x4];                                      // 0x035C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0360(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_368[0x10];                                     // 0x0368(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayAnimation(float displayFram, float globalPieceScaleMultiplier);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickFracturedRock">();
	}
	static class AGimmickFracturedRock* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickFracturedRock>();
	}
};
static_assert(alignof(AGimmickFracturedRock) == 0x000008, "Wrong alignment on AGimmickFracturedRock");
static_assert(sizeof(AGimmickFracturedRock) == 0x000378, "Wrong size on AGimmickFracturedRock");
static_assert(offsetof(AGimmickFracturedRock, m_staticMeshComponent) == 0x000340, "Member 'AGimmickFracturedRock::m_staticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickFracturedRock, m_niagaraComponent) == 0x000348, "Member 'AGimmickFracturedRock::m_niagaraComponent' has a wrong offset!");
static_assert(offsetof(AGimmickFracturedRock, m_animationEndFrame) == 0x000350, "Member 'AGimmickFracturedRock::m_animationEndFrame' has a wrong offset!");
static_assert(offsetof(AGimmickFracturedRock, m_animationSpeed_fps) == 0x000354, "Member 'AGimmickFracturedRock::m_animationSpeed_fps' has a wrong offset!");
static_assert(offsetof(AGimmickFracturedRock, m_meshHiddenTimer) == 0x000358, "Member 'AGimmickFracturedRock::m_meshHiddenTimer' has a wrong offset!");
static_assert(offsetof(AGimmickFracturedRock, DefaultSceneRoot) == 0x000360, "Member 'AGimmickFracturedRock::DefaultSceneRoot' has a wrong offset!");

// Class UnionRun.GimmickGoalglow
// 0x0018 (0x0358 - 0x0340)
class AGimmickGoalglow final : public AUnionCourseObjectBase
{
public:
	class UUnionStaticMeshComponent*              m_laserStaticMesh;                                 // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0348(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlaySound();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickGoalglow">();
	}
	static class AGimmickGoalglow* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickGoalglow>();
	}
};
static_assert(alignof(AGimmickGoalglow) == 0x000008, "Wrong alignment on AGimmickGoalglow");
static_assert(sizeof(AGimmickGoalglow) == 0x000358, "Wrong size on AGimmickGoalglow");
static_assert(offsetof(AGimmickGoalglow, m_laserStaticMesh) == 0x000340, "Member 'AGimmickGoalglow::m_laserStaticMesh' has a wrong offset!");
static_assert(offsetof(AGimmickGoalglow, DefaultSceneRoot) == 0x000348, "Member 'AGimmickGoalglow::DefaultSceneRoot' has a wrong offset!");

// Class UnionRun.GimmickGUNHunter
// 0x0100 (0x06B0 - 0x05B0)
class alignas(0x10) AGimmickGUNHunter final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionSkeletalMeshComponent*            Mesh;                                              // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            Body;                                              // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      DeadEffect;                                        // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    HoverSound;                                        // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    DeadSound;                                         // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERacerDamageType                              DamageType;                                        // 0x05E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGUNHunterMotion                              MoveType;                                          // 0x05E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E2[0x2];                                      // 0x05E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlowawayTime;                                      // 0x05E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeadEffectDelayTime;                               // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeadWaitTime;                                      // 0x05EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespawnSearchRacerRange;                           // 0x05F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F4[0xBC];                                     // 0x05F4(0x00BC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartMove();
	void StopMove();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickGUNHunter">();
	}
	static class AGimmickGUNHunter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickGUNHunter>();
	}
};
static_assert(alignof(AGimmickGUNHunter) == 0x000010, "Wrong alignment on AGimmickGUNHunter");
static_assert(sizeof(AGimmickGUNHunter) == 0x0006B0, "Wrong size on AGimmickGUNHunter");
static_assert(offsetof(AGimmickGUNHunter, Mesh) == 0x0005B8, "Member 'AGimmickGUNHunter::Mesh' has a wrong offset!");
static_assert(offsetof(AGimmickGUNHunter, Body) == 0x0005C0, "Member 'AGimmickGUNHunter::Body' has a wrong offset!");
static_assert(offsetof(AGimmickGUNHunter, DeadEffect) == 0x0005C8, "Member 'AGimmickGUNHunter::DeadEffect' has a wrong offset!");
static_assert(offsetof(AGimmickGUNHunter, HoverSound) == 0x0005D0, "Member 'AGimmickGUNHunter::HoverSound' has a wrong offset!");
static_assert(offsetof(AGimmickGUNHunter, DeadSound) == 0x0005D8, "Member 'AGimmickGUNHunter::DeadSound' has a wrong offset!");
static_assert(offsetof(AGimmickGUNHunter, DamageType) == 0x0005E0, "Member 'AGimmickGUNHunter::DamageType' has a wrong offset!");
static_assert(offsetof(AGimmickGUNHunter, MoveType) == 0x0005E1, "Member 'AGimmickGUNHunter::MoveType' has a wrong offset!");
static_assert(offsetof(AGimmickGUNHunter, BlowawayTime) == 0x0005E4, "Member 'AGimmickGUNHunter::BlowawayTime' has a wrong offset!");
static_assert(offsetof(AGimmickGUNHunter, DeadEffectDelayTime) == 0x0005E8, "Member 'AGimmickGUNHunter::DeadEffectDelayTime' has a wrong offset!");
static_assert(offsetof(AGimmickGUNHunter, DeadWaitTime) == 0x0005EC, "Member 'AGimmickGUNHunter::DeadWaitTime' has a wrong offset!");
static_assert(offsetof(AGimmickGUNHunter, RespawnSearchRacerRange) == 0x0005F0, "Member 'AGimmickGUNHunter::RespawnSearchRacerRange' has a wrong offset!");

// Class UnionRun.GimmickLightBall
// 0x0080 (0x0630 - 0x05B0)
class alignas(0x10) AGimmickLightBall final : public AUnionGimmickObjectBase
{
public:
	float                                         IdleMoveTime;                                      // 0x05B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B4[0x4];                                      // 0x05B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BallMoveCurve;                                     // 0x05B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              MainMesh;                                          // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              LightRay_A;                                        // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              LightRay_B;                                        // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              LightRay_C;                                        // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              LightRay_D;                                        // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              LightRay_E;                                        // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              LightRay_F;                                        // 0x05F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTimelineComponent*                     BallRayTimelineComponent;                          // 0x05F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(float Output)>                 IdleMoveUpdateEvent;                               // 0x0600(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             IdleMoveFinishedEvent;                             // 0x0610(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_620[0xC];                                      // 0x0620(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurveFloat;                                        // 0x062C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void RayIdleMoveFinished();
	void RayIdleMoveUpdate(float Ratio);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickLightBall">();
	}
	static class AGimmickLightBall* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickLightBall>();
	}
};
static_assert(alignof(AGimmickLightBall) == 0x000010, "Wrong alignment on AGimmickLightBall");
static_assert(sizeof(AGimmickLightBall) == 0x000630, "Wrong size on AGimmickLightBall");
static_assert(offsetof(AGimmickLightBall, IdleMoveTime) == 0x0005B0, "Member 'AGimmickLightBall::IdleMoveTime' has a wrong offset!");
static_assert(offsetof(AGimmickLightBall, BallMoveCurve) == 0x0005B8, "Member 'AGimmickLightBall::BallMoveCurve' has a wrong offset!");
static_assert(offsetof(AGimmickLightBall, MainMesh) == 0x0005C0, "Member 'AGimmickLightBall::MainMesh' has a wrong offset!");
static_assert(offsetof(AGimmickLightBall, LightRay_A) == 0x0005C8, "Member 'AGimmickLightBall::LightRay_A' has a wrong offset!");
static_assert(offsetof(AGimmickLightBall, LightRay_B) == 0x0005D0, "Member 'AGimmickLightBall::LightRay_B' has a wrong offset!");
static_assert(offsetof(AGimmickLightBall, LightRay_C) == 0x0005D8, "Member 'AGimmickLightBall::LightRay_C' has a wrong offset!");
static_assert(offsetof(AGimmickLightBall, LightRay_D) == 0x0005E0, "Member 'AGimmickLightBall::LightRay_D' has a wrong offset!");
static_assert(offsetof(AGimmickLightBall, LightRay_E) == 0x0005E8, "Member 'AGimmickLightBall::LightRay_E' has a wrong offset!");
static_assert(offsetof(AGimmickLightBall, LightRay_F) == 0x0005F0, "Member 'AGimmickLightBall::LightRay_F' has a wrong offset!");
static_assert(offsetof(AGimmickLightBall, BallRayTimelineComponent) == 0x0005F8, "Member 'AGimmickLightBall::BallRayTimelineComponent' has a wrong offset!");
static_assert(offsetof(AGimmickLightBall, IdleMoveUpdateEvent) == 0x000600, "Member 'AGimmickLightBall::IdleMoveUpdateEvent' has a wrong offset!");
static_assert(offsetof(AGimmickLightBall, IdleMoveFinishedEvent) == 0x000610, "Member 'AGimmickLightBall::IdleMoveFinishedEvent' has a wrong offset!");
static_assert(offsetof(AGimmickLightBall, CurveFloat) == 0x00062C, "Member 'AGimmickLightBall::CurveFloat' has a wrong offset!");

// Class UnionRun.GimmickMagmaLaser
// 0x0040 (0x05F0 - 0x05B0)
class alignas(0x10) AGimmickMagmaLaser final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              StaticMeshComponent;                               // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            StaticBodyComponent;                               // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    AtomComponent;                                     // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERacerDamageType                              DamageType;                                        // 0x05D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsMove;                                            // 0x05D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsRoundTrip;                                       // 0x05D2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D3[0x1];                                      // 0x05D3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotRollSpeed;                                      // 0x05D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RoundTripAngle;                                    // 0x05D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         XYScale;                                           // 0x05DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ZScale;                                            // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E4[0xC];                                      // 0x05E4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickMagmaLaser">();
	}
	static class AGimmickMagmaLaser* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickMagmaLaser>();
	}
};
static_assert(alignof(AGimmickMagmaLaser) == 0x000010, "Wrong alignment on AGimmickMagmaLaser");
static_assert(sizeof(AGimmickMagmaLaser) == 0x0005F0, "Wrong size on AGimmickMagmaLaser");
static_assert(offsetof(AGimmickMagmaLaser, StaticMeshComponent) == 0x0005B8, "Member 'AGimmickMagmaLaser::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaLaser, StaticBodyComponent) == 0x0005C0, "Member 'AGimmickMagmaLaser::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaLaser, AtomComponent) == 0x0005C8, "Member 'AGimmickMagmaLaser::AtomComponent' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaLaser, DamageType) == 0x0005D0, "Member 'AGimmickMagmaLaser::DamageType' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaLaser, IsMove) == 0x0005D1, "Member 'AGimmickMagmaLaser::IsMove' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaLaser, IsRoundTrip) == 0x0005D2, "Member 'AGimmickMagmaLaser::IsRoundTrip' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaLaser, RotRollSpeed) == 0x0005D4, "Member 'AGimmickMagmaLaser::RotRollSpeed' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaLaser, RoundTripAngle) == 0x0005D8, "Member 'AGimmickMagmaLaser::RoundTripAngle' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaLaser, XYScale) == 0x0005DC, "Member 'AGimmickMagmaLaser::XYScale' has a wrong offset!");
static_assert(offsetof(AGimmickMagmaLaser, ZScale) == 0x0005E0, "Member 'AGimmickMagmaLaser::ZScale' has a wrong offset!");

// Class UnionRun.GimmickManipulatedShip
// 0x0070 (0x0620 - 0x05B0)
class alignas(0x10) AGimmickManipulatedShip final : public AUnionGimmickObjectBase
{
public:
	class UUnionStaticMeshComponent*              BodyStatickMeshComponent;                          // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USimpleMoveComponent*                   SimpleMoveComponent;                               // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    IdleMoveSoundComponent;                            // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D0[0x50];                                     // 0x05D0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickManipulatedShip">();
	}
	static class AGimmickManipulatedShip* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickManipulatedShip>();
	}
};
static_assert(alignof(AGimmickManipulatedShip) == 0x000010, "Wrong alignment on AGimmickManipulatedShip");
static_assert(sizeof(AGimmickManipulatedShip) == 0x000620, "Wrong size on AGimmickManipulatedShip");
static_assert(offsetof(AGimmickManipulatedShip, BodyStatickMeshComponent) == 0x0005B0, "Member 'AGimmickManipulatedShip::BodyStatickMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedShip, SimpleMoveComponent) == 0x0005B8, "Member 'AGimmickManipulatedShip::SimpleMoveComponent' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedShip, IdleMoveSoundComponent) == 0x0005C0, "Member 'AGimmickManipulatedShip::IdleMoveSoundComponent' has a wrong offset!");
static_assert(offsetof(AGimmickManipulatedShip, DefaultSceneRoot) == 0x0005C8, "Member 'AGimmickManipulatedShip::DefaultSceneRoot' has a wrong offset!");

// Class UnionRun.GimmickMessageInterface
// 0x0000 (0x0000 - 0x0000)
class IGimmickMessageInterface final
{
public:
	void NotifyStartGimmick();
	void NotifyStartGimmickEvent(EStageId StageId, int32 EventId, int32 RacerIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickMessageInterface">();
	}
	static class IGimmickMessageInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGimmickMessageInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGimmickMessageInterface) == 0x000001, "Wrong alignment on IGimmickMessageInterface");
static_assert(sizeof(IGimmickMessageInterface) == 0x000001, "Wrong size on IGimmickMessageInterface");

// Class UnionRun.GimmickMiningExcavator
// 0x0030 (0x05E0 - 0x05B0)
class alignas(0x10) AGimmickMiningExcavator final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              ExcavatorMesh;                                     // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            CollisionComponentTipPart;                         // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            CollisionComponentCenterPart;                      // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            CollisionComponentEndPart;                         // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D8[0x8];                                      // 0x05D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickMiningExcavator">();
	}
	static class AGimmickMiningExcavator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickMiningExcavator>();
	}
};
static_assert(alignof(AGimmickMiningExcavator) == 0x000010, "Wrong alignment on AGimmickMiningExcavator");
static_assert(sizeof(AGimmickMiningExcavator) == 0x0005E0, "Wrong size on AGimmickMiningExcavator");
static_assert(offsetof(AGimmickMiningExcavator, ExcavatorMesh) == 0x0005B8, "Member 'AGimmickMiningExcavator::ExcavatorMesh' has a wrong offset!");
static_assert(offsetof(AGimmickMiningExcavator, CollisionComponentTipPart) == 0x0005C0, "Member 'AGimmickMiningExcavator::CollisionComponentTipPart' has a wrong offset!");
static_assert(offsetof(AGimmickMiningExcavator, CollisionComponentCenterPart) == 0x0005C8, "Member 'AGimmickMiningExcavator::CollisionComponentCenterPart' has a wrong offset!");
static_assert(offsetof(AGimmickMiningExcavator, CollisionComponentEndPart) == 0x0005D0, "Member 'AGimmickMiningExcavator::CollisionComponentEndPart' has a wrong offset!");

// Class UnionRun.GimmickMoai
// 0x0010 (0x05C0 - 0x05B0)
class alignas(0x10) AGimmickMoai final : public AUnionGimmickObjectBase
{
public:
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickMoai">();
	}
	static class AGimmickMoai* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickMoai>();
	}
};
static_assert(alignof(AGimmickMoai) == 0x000010, "Wrong alignment on AGimmickMoai");
static_assert(sizeof(AGimmickMoai) == 0x0005C0, "Wrong size on AGimmickMoai");
static_assert(offsetof(AGimmickMoai, DefaultSceneRoot) == 0x0005B0, "Member 'AGimmickMoai::DefaultSceneRoot' has a wrong offset!");

// Class UnionRun.GimmickMoveFloatBoom
// 0x0020 (0x05D0 - 0x05B0)
class alignas(0x10) AGimmickMoveFloatBoom final : public AUnionGimmickObjectBase
{
public:
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionVATAnimEventComponent*            BooVATMeshComponent;                               // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AnimStartFrame;                                    // 0x05C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C4[0xC];                                      // 0x05C4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickMoveFloatBoom">();
	}
	static class AGimmickMoveFloatBoom* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickMoveFloatBoom>();
	}
};
static_assert(alignof(AGimmickMoveFloatBoom) == 0x000010, "Wrong alignment on AGimmickMoveFloatBoom");
static_assert(sizeof(AGimmickMoveFloatBoom) == 0x0005D0, "Wrong size on AGimmickMoveFloatBoom");
static_assert(offsetof(AGimmickMoveFloatBoom, DefaultSceneRoot) == 0x0005B0, "Member 'AGimmickMoveFloatBoom::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AGimmickMoveFloatBoom, BooVATMeshComponent) == 0x0005B8, "Member 'AGimmickMoveFloatBoom::BooVATMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickMoveFloatBoom, AnimStartFrame) == 0x0005C0, "Member 'AGimmickMoveFloatBoom::AnimStartFrame' has a wrong offset!");

// Class UnionRun.GimmickMoveRoadCube
// 0x0080 (0x0630 - 0x05B0)
class alignas(0x10) AGimmickMoveRoadCube final : public AUnionGimmickObjectBase
{
public:
	float                                         MovefinishRate;                                    // 0x05B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B4[0x4];                                      // 0x05B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CubeWarpLocation;                                  // 0x05B8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              BodyStatickMeshComponent;                          // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E0[0x50];                                     // 0x05E0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickMoveRoadCube">();
	}
	static class AGimmickMoveRoadCube* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickMoveRoadCube>();
	}
};
static_assert(alignof(AGimmickMoveRoadCube) == 0x000010, "Wrong alignment on AGimmickMoveRoadCube");
static_assert(sizeof(AGimmickMoveRoadCube) == 0x000630, "Wrong size on AGimmickMoveRoadCube");
static_assert(offsetof(AGimmickMoveRoadCube, MovefinishRate) == 0x0005B0, "Member 'AGimmickMoveRoadCube::MovefinishRate' has a wrong offset!");
static_assert(offsetof(AGimmickMoveRoadCube, CubeWarpLocation) == 0x0005B8, "Member 'AGimmickMoveRoadCube::CubeWarpLocation' has a wrong offset!");
static_assert(offsetof(AGimmickMoveRoadCube, BodyStatickMeshComponent) == 0x0005D0, "Member 'AGimmickMoveRoadCube::BodyStatickMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickMoveRoadCube, DefaultSceneRoot) == 0x0005D8, "Member 'AGimmickMoveRoadCube::DefaultSceneRoot' has a wrong offset!");

// Class UnionRun.GimmickMuseumBoo
// 0x0010 (0x05C0 - 0x05B0)
class alignas(0x10) AGimmickMuseumBoo final : public AUnionGimmickObjectBase
{
public:
	TArray<class UUnionVATAnimEventComponent*>    VATAnimEventList;                                  // 0x05B0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickMuseumBoo">();
	}
	static class AGimmickMuseumBoo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickMuseumBoo>();
	}
};
static_assert(alignof(AGimmickMuseumBoo) == 0x000010, "Wrong alignment on AGimmickMuseumBoo");
static_assert(sizeof(AGimmickMuseumBoo) == 0x0005C0, "Wrong size on AGimmickMuseumBoo");
static_assert(offsetof(AGimmickMuseumBoo, VATAnimEventList) == 0x0005B0, "Member 'AGimmickMuseumBoo::VATAnimEventList' has a wrong offset!");

// Class UnionRun.GimmickObakeFlameField
// 0x0120 (0x06D0 - 0x05B0)
class alignas(0x10) AGimmickObakeFlameField final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              BodyStatickMeshComponent1;                         // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              BodyStatickMeshComponent2;                         // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              BodyStatickMeshComponent3;                         // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              BodyStatickMeshComponent4;                         // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              BodyStatickMeshComponent5;                         // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              BodyStatickMeshComponent6;                         // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              BodyStatickMeshComponent7;                         // 0x05E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              BodyStatickMeshComponent8;                         // 0x05F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              BodyStatickMeshComponent9;                         // 0x05F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERacerDamageType                              DamageType;                                        // 0x0600(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_601[0x3];                                      // 0x0601(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ParticleIntParameterSetting;                       // 0x0604(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackContinueTime;                                // 0x0608(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60C[0x4];                                      // 0x060C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      m_FireEffect;                                      // 0x0610(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_SmokeEffect;                                     // 0x0618(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_SmokeEffect2;                                    // 0x0620(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_SmokeEffect3;                                    // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_SmokeEffect4;                                    // 0x0630(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_SmokeEffect5;                                    // 0x0638(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_SmokeEffect6;                                    // 0x0640(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_SmokeEffect7;                                    // 0x0648(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_SmokeEffect8;                                    // 0x0650(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_SmokeEffect9;                                    // 0x0658(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    FlameSoundComponent;                               // 0x0660(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            m_MainFireStaticBodyComponent;                     // 0x0668(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_670[0x60];                                     // 0x0670(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickObakeFlameField">();
	}
	static class AGimmickObakeFlameField* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickObakeFlameField>();
	}
};
static_assert(alignof(AGimmickObakeFlameField) == 0x000010, "Wrong alignment on AGimmickObakeFlameField");
static_assert(sizeof(AGimmickObakeFlameField) == 0x0006D0, "Wrong size on AGimmickObakeFlameField");
static_assert(offsetof(AGimmickObakeFlameField, BodyStatickMeshComponent1) == 0x0005B8, "Member 'AGimmickObakeFlameField::BodyStatickMeshComponent1' has a wrong offset!");
static_assert(offsetof(AGimmickObakeFlameField, BodyStatickMeshComponent2) == 0x0005C0, "Member 'AGimmickObakeFlameField::BodyStatickMeshComponent2' has a wrong offset!");
static_assert(offsetof(AGimmickObakeFlameField, BodyStatickMeshComponent3) == 0x0005C8, "Member 'AGimmickObakeFlameField::BodyStatickMeshComponent3' has a wrong offset!");
static_assert(offsetof(AGimmickObakeFlameField, BodyStatickMeshComponent4) == 0x0005D0, "Member 'AGimmickObakeFlameField::BodyStatickMeshComponent4' has a wrong offset!");
static_assert(offsetof(AGimmickObakeFlameField, BodyStatickMeshComponent5) == 0x0005D8, "Member 'AGimmickObakeFlameField::BodyStatickMeshComponent5' has a wrong offset!");
static_assert(offsetof(AGimmickObakeFlameField, BodyStatickMeshComponent6) == 0x0005E0, "Member 'AGimmickObakeFlameField::BodyStatickMeshComponent6' has a wrong offset!");
static_assert(offsetof(AGimmickObakeFlameField, BodyStatickMeshComponent7) == 0x0005E8, "Member 'AGimmickObakeFlameField::BodyStatickMeshComponent7' has a wrong offset!");
static_assert(offsetof(AGimmickObakeFlameField, BodyStatickMeshComponent8) == 0x0005F0, "Member 'AGimmickObakeFlameField::BodyStatickMeshComponent8' has a wrong offset!");
static_assert(offsetof(AGimmickObakeFlameField, BodyStatickMeshComponent9) == 0x0005F8, "Member 'AGimmickObakeFlameField::BodyStatickMeshComponent9' has a wrong offset!");
static_assert(offsetof(AGimmickObakeFlameField, DamageType) == 0x000600, "Member 'AGimmickObakeFlameField::DamageType' has a wrong offset!");
static_assert(offsetof(AGimmickObakeFlameField, ParticleIntParameterSetting) == 0x000604, "Member 'AGimmickObakeFlameField::ParticleIntParameterSetting' has a wrong offset!");
static_assert(offsetof(AGimmickObakeFlameField, AttackContinueTime) == 0x000608, "Member 'AGimmickObakeFlameField::AttackContinueTime' has a wrong offset!");
static_assert(offsetof(AGimmickObakeFlameField, m_FireEffect) == 0x000610, "Member 'AGimmickObakeFlameField::m_FireEffect' has a wrong offset!");
static_assert(offsetof(AGimmickObakeFlameField, m_SmokeEffect) == 0x000618, "Member 'AGimmickObakeFlameField::m_SmokeEffect' has a wrong offset!");
static_assert(offsetof(AGimmickObakeFlameField, m_SmokeEffect2) == 0x000620, "Member 'AGimmickObakeFlameField::m_SmokeEffect2' has a wrong offset!");
static_assert(offsetof(AGimmickObakeFlameField, m_SmokeEffect3) == 0x000628, "Member 'AGimmickObakeFlameField::m_SmokeEffect3' has a wrong offset!");
static_assert(offsetof(AGimmickObakeFlameField, m_SmokeEffect4) == 0x000630, "Member 'AGimmickObakeFlameField::m_SmokeEffect4' has a wrong offset!");
static_assert(offsetof(AGimmickObakeFlameField, m_SmokeEffect5) == 0x000638, "Member 'AGimmickObakeFlameField::m_SmokeEffect5' has a wrong offset!");
static_assert(offsetof(AGimmickObakeFlameField, m_SmokeEffect6) == 0x000640, "Member 'AGimmickObakeFlameField::m_SmokeEffect6' has a wrong offset!");
static_assert(offsetof(AGimmickObakeFlameField, m_SmokeEffect7) == 0x000648, "Member 'AGimmickObakeFlameField::m_SmokeEffect7' has a wrong offset!");
static_assert(offsetof(AGimmickObakeFlameField, m_SmokeEffect8) == 0x000650, "Member 'AGimmickObakeFlameField::m_SmokeEffect8' has a wrong offset!");
static_assert(offsetof(AGimmickObakeFlameField, m_SmokeEffect9) == 0x000658, "Member 'AGimmickObakeFlameField::m_SmokeEffect9' has a wrong offset!");
static_assert(offsetof(AGimmickObakeFlameField, FlameSoundComponent) == 0x000660, "Member 'AGimmickObakeFlameField::FlameSoundComponent' has a wrong offset!");
static_assert(offsetof(AGimmickObakeFlameField, m_MainFireStaticBodyComponent) == 0x000668, "Member 'AGimmickObakeFlameField::m_MainFireStaticBodyComponent' has a wrong offset!");

// Class UnionRun.GimmickPitfall
// 0x0030 (0x0610 - 0x05E0)
class AGimmickPitfall final : public AGimmickOnlyOwnerSeeBase
{
public:
	class UUnionStaticMeshComponent*              StaticMeshComponent;                               // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionVATMeshComponent*                 VATMeshComponent;                                  // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ImpactSoundFrame;                                  // 0x05F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SurpriseSoundFrame;                                // 0x05F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Dance01SoundFrame;                                 // 0x05F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Dance02SoundFrame;                                 // 0x05FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_600[0x10];                                     // 0x0600(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickPitfall">();
	}
	static class AGimmickPitfall* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickPitfall>();
	}
};
static_assert(alignof(AGimmickPitfall) == 0x000010, "Wrong alignment on AGimmickPitfall");
static_assert(sizeof(AGimmickPitfall) == 0x000610, "Wrong size on AGimmickPitfall");
static_assert(offsetof(AGimmickPitfall, StaticMeshComponent) == 0x0005E0, "Member 'AGimmickPitfall::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickPitfall, VATMeshComponent) == 0x0005E8, "Member 'AGimmickPitfall::VATMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickPitfall, ImpactSoundFrame) == 0x0005F0, "Member 'AGimmickPitfall::ImpactSoundFrame' has a wrong offset!");
static_assert(offsetof(AGimmickPitfall, SurpriseSoundFrame) == 0x0005F4, "Member 'AGimmickPitfall::SurpriseSoundFrame' has a wrong offset!");
static_assert(offsetof(AGimmickPitfall, Dance01SoundFrame) == 0x0005F8, "Member 'AGimmickPitfall::Dance01SoundFrame' has a wrong offset!");
static_assert(offsetof(AGimmickPitfall, Dance02SoundFrame) == 0x0005FC, "Member 'AGimmickPitfall::Dance02SoundFrame' has a wrong offset!");

// Class UnionRun.GimmickPopcorn
// 0x0070 (0x0620 - 0x05B0)
class alignas(0x10) AGimmickPopcorn final : public AUnionGimmickObjectBase
{
public:
	class UNiagaraComponent*                      PopcornEffect;                                     // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    PopcornSound;                                      // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstDelayTime;                                    // 0x05C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntervalTime;                                      // 0x05C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActiveCheckInterval;                               // 0x05C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActiveRange;                                       // 0x05CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D0[0x50];                                     // 0x05D0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickPopcorn">();
	}
	static class AGimmickPopcorn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickPopcorn>();
	}
};
static_assert(alignof(AGimmickPopcorn) == 0x000010, "Wrong alignment on AGimmickPopcorn");
static_assert(sizeof(AGimmickPopcorn) == 0x000620, "Wrong size on AGimmickPopcorn");
static_assert(offsetof(AGimmickPopcorn, PopcornEffect) == 0x0005B0, "Member 'AGimmickPopcorn::PopcornEffect' has a wrong offset!");
static_assert(offsetof(AGimmickPopcorn, PopcornSound) == 0x0005B8, "Member 'AGimmickPopcorn::PopcornSound' has a wrong offset!");
static_assert(offsetof(AGimmickPopcorn, FirstDelayTime) == 0x0005C0, "Member 'AGimmickPopcorn::FirstDelayTime' has a wrong offset!");
static_assert(offsetof(AGimmickPopcorn, IntervalTime) == 0x0005C4, "Member 'AGimmickPopcorn::IntervalTime' has a wrong offset!");
static_assert(offsetof(AGimmickPopcorn, ActiveCheckInterval) == 0x0005C8, "Member 'AGimmickPopcorn::ActiveCheckInterval' has a wrong offset!");
static_assert(offsetof(AGimmickPopcorn, ActiveRange) == 0x0005CC, "Member 'AGimmickPopcorn::ActiveRange' has a wrong offset!");

// Class UnionRun.GimmickPumpkinBoo
// 0x0040 (0x0620 - 0x05E0)
class AGimmickPumpkinBoo final : public AGimmickOnlyOwnerSeeBase
{
public:
	class UUnionStaticMeshComponent*              StaticMeshComponent;                               // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            StaticBodyComponent;                               // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      DisappearEffect;                                   // 0x05F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    DisappearSound;                                    // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<int32>                                 TargetRandomPatternIds;                            // 0x0600(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_610[0x10];                                     // 0x0610(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickPumpkinBoo">();
	}
	static class AGimmickPumpkinBoo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickPumpkinBoo>();
	}
};
static_assert(alignof(AGimmickPumpkinBoo) == 0x000010, "Wrong alignment on AGimmickPumpkinBoo");
static_assert(sizeof(AGimmickPumpkinBoo) == 0x000620, "Wrong size on AGimmickPumpkinBoo");
static_assert(offsetof(AGimmickPumpkinBoo, StaticMeshComponent) == 0x0005E0, "Member 'AGimmickPumpkinBoo::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickPumpkinBoo, StaticBodyComponent) == 0x0005E8, "Member 'AGimmickPumpkinBoo::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickPumpkinBoo, DisappearEffect) == 0x0005F0, "Member 'AGimmickPumpkinBoo::DisappearEffect' has a wrong offset!");
static_assert(offsetof(AGimmickPumpkinBoo, DisappearSound) == 0x0005F8, "Member 'AGimmickPumpkinBoo::DisappearSound' has a wrong offset!");
static_assert(offsetof(AGimmickPumpkinBoo, TargetRandomPatternIds) == 0x000600, "Member 'AGimmickPumpkinBoo::TargetRandomPatternIds' has a wrong offset!");

// Class UnionRun.GimmickRacerLocation
// 0x0080 (0x0630 - 0x05B0)
class alignas(0x10) AGimmickRacerLocation final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticBodyComponent*                   StaticBodyComponent;                               // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollectionInstance*   MPCI;                                              // 0x05C0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           MPC;                                               // 0x05C8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D0[0x60];                                     // 0x05D0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickRacerLocation">();
	}
	static class AGimmickRacerLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickRacerLocation>();
	}
};
static_assert(alignof(AGimmickRacerLocation) == 0x000010, "Wrong alignment on AGimmickRacerLocation");
static_assert(sizeof(AGimmickRacerLocation) == 0x000630, "Wrong size on AGimmickRacerLocation");
static_assert(offsetof(AGimmickRacerLocation, StaticBodyComponent) == 0x0005B8, "Member 'AGimmickRacerLocation::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickRacerLocation, MPCI) == 0x0005C0, "Member 'AGimmickRacerLocation::MPCI' has a wrong offset!");
static_assert(offsetof(AGimmickRacerLocation, MPC) == 0x0005C8, "Member 'AGimmickRacerLocation::MPC' has a wrong offset!");

// Class UnionRun.GimmickRingCircle
// 0x01B0 (0x0760 - 0x05B0)
class alignas(0x10) AGimmickRingCircle final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionSkeletalMeshComponent*            SkeletalMeshComponent;                             // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ARingObject>                RingObject;                                        // 0x05C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UChildActorComponent*>           ChildRings;                                        // 0x05C8(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         RingNum;                                           // 0x05D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CircleDiameter;                                    // 0x05DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticBodyComponent*                   StaticBodyComponent;                               // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BaseAngle;                                         // 0x05F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RingRespawnWaitTime;                               // 0x05F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CircleRespawnWaitTime;                             // 0x05F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEasingFunc                                   EasingFunc;                                        // 0x05FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5FD[0x3];                                      // 0x05FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FollowLength;                                      // 0x0600(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FollowTime;                                        // 0x0604(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SuckWaitTime;                                      // 0x0608(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SuckInterval;                                      // 0x060C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CircleNum;                                         // 0x0610(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESpecialObjGroup                              m_SpecialGroup;                                    // 0x0614(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_615[0x14B];                                    // 0x0615(0x014B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHitAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickRingCircle">();
	}
	static class AGimmickRingCircle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickRingCircle>();
	}
};
static_assert(alignof(AGimmickRingCircle) == 0x000010, "Wrong alignment on AGimmickRingCircle");
static_assert(sizeof(AGimmickRingCircle) == 0x000760, "Wrong size on AGimmickRingCircle");
static_assert(offsetof(AGimmickRingCircle, SkeletalMeshComponent) == 0x0005B8, "Member 'AGimmickRingCircle::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickRingCircle, RingObject) == 0x0005C0, "Member 'AGimmickRingCircle::RingObject' has a wrong offset!");
static_assert(offsetof(AGimmickRingCircle, ChildRings) == 0x0005C8, "Member 'AGimmickRingCircle::ChildRings' has a wrong offset!");
static_assert(offsetof(AGimmickRingCircle, RingNum) == 0x0005D8, "Member 'AGimmickRingCircle::RingNum' has a wrong offset!");
static_assert(offsetof(AGimmickRingCircle, CircleDiameter) == 0x0005DC, "Member 'AGimmickRingCircle::CircleDiameter' has a wrong offset!");
static_assert(offsetof(AGimmickRingCircle, DefaultSceneRoot) == 0x0005E0, "Member 'AGimmickRingCircle::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AGimmickRingCircle, StaticBodyComponent) == 0x0005E8, "Member 'AGimmickRingCircle::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickRingCircle, BaseAngle) == 0x0005F0, "Member 'AGimmickRingCircle::BaseAngle' has a wrong offset!");
static_assert(offsetof(AGimmickRingCircle, RingRespawnWaitTime) == 0x0005F4, "Member 'AGimmickRingCircle::RingRespawnWaitTime' has a wrong offset!");
static_assert(offsetof(AGimmickRingCircle, CircleRespawnWaitTime) == 0x0005F8, "Member 'AGimmickRingCircle::CircleRespawnWaitTime' has a wrong offset!");
static_assert(offsetof(AGimmickRingCircle, EasingFunc) == 0x0005FC, "Member 'AGimmickRingCircle::EasingFunc' has a wrong offset!");
static_assert(offsetof(AGimmickRingCircle, FollowLength) == 0x000600, "Member 'AGimmickRingCircle::FollowLength' has a wrong offset!");
static_assert(offsetof(AGimmickRingCircle, FollowTime) == 0x000604, "Member 'AGimmickRingCircle::FollowTime' has a wrong offset!");
static_assert(offsetof(AGimmickRingCircle, SuckWaitTime) == 0x000608, "Member 'AGimmickRingCircle::SuckWaitTime' has a wrong offset!");
static_assert(offsetof(AGimmickRingCircle, SuckInterval) == 0x00060C, "Member 'AGimmickRingCircle::SuckInterval' has a wrong offset!");
static_assert(offsetof(AGimmickRingCircle, CircleNum) == 0x000610, "Member 'AGimmickRingCircle::CircleNum' has a wrong offset!");
static_assert(offsetof(AGimmickRingCircle, m_SpecialGroup) == 0x000614, "Member 'AGimmickRingCircle::m_SpecialGroup' has a wrong offset!");

// Class UnionRun.GimmickRocket
// 0x0070 (0x0620 - 0x05B0)
class alignas(0x10) AGimmickRocket final : public AUnionGimmickObjectBase
{
public:
	class UUnionStaticMeshComponent*              RocketMesh;                                        // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      RocketFireEffect;                                  // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      RocketLaunchEffect;                                // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    WaitingFireSound;                                  // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    FlyingFireSound;                                   // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x05D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x05DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedChangeTime;                                   // 0x05E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E4[0x4];                                      // 0x05E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            LaunchingSpeedCurve;                               // 0x05E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F0[0x30];                                     // 0x05F0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickRocket">();
	}
	static class AGimmickRocket* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickRocket>();
	}
};
static_assert(alignof(AGimmickRocket) == 0x000010, "Wrong alignment on AGimmickRocket");
static_assert(sizeof(AGimmickRocket) == 0x000620, "Wrong size on AGimmickRocket");
static_assert(offsetof(AGimmickRocket, RocketMesh) == 0x0005B0, "Member 'AGimmickRocket::RocketMesh' has a wrong offset!");
static_assert(offsetof(AGimmickRocket, RocketFireEffect) == 0x0005B8, "Member 'AGimmickRocket::RocketFireEffect' has a wrong offset!");
static_assert(offsetof(AGimmickRocket, RocketLaunchEffect) == 0x0005C0, "Member 'AGimmickRocket::RocketLaunchEffect' has a wrong offset!");
static_assert(offsetof(AGimmickRocket, WaitingFireSound) == 0x0005C8, "Member 'AGimmickRocket::WaitingFireSound' has a wrong offset!");
static_assert(offsetof(AGimmickRocket, FlyingFireSound) == 0x0005D0, "Member 'AGimmickRocket::FlyingFireSound' has a wrong offset!");
static_assert(offsetof(AGimmickRocket, MaxDistance) == 0x0005D8, "Member 'AGimmickRocket::MaxDistance' has a wrong offset!");
static_assert(offsetof(AGimmickRocket, MaxSpeed) == 0x0005DC, "Member 'AGimmickRocket::MaxSpeed' has a wrong offset!");
static_assert(offsetof(AGimmickRocket, SpeedChangeTime) == 0x0005E0, "Member 'AGimmickRocket::SpeedChangeTime' has a wrong offset!");
static_assert(offsetof(AGimmickRocket, LaunchingSpeedCurve) == 0x0005E8, "Member 'AGimmickRocket::LaunchingSpeedCurve' has a wrong offset!");

// Class UnionRun.GimmickRollingRock
// 0x0060 (0x0610 - 0x05B0)
class alignas(0x10) AGimmickRollingRock final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGimmickStaticBodyComponent*            _GimmickStaticBodyComponent;                       // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionStaticMeshComponent*              _StaticMeshComponent;                              // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    _RollingSound;                                     // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    _BounceSound;                                      // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERacerDamageType                              _DamageType;                                       // 0x05D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D9[0x3];                                      // 0x05D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _RotationSpeedDeg;                                 // 0x05DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _JumpDuration;                                     // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _JumpHeight;                                       // 0x05E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _WorldOffsetHeight;                                // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RollAngleDeg;                                      // 0x05EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _BounceSplineRate;                                 // 0x05F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bOutputSplineRate;                                // 0x05F4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F5[0x3];                                      // 0x05F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _TremorHighDistance;                               // 0x05F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _TremorMiddleDistance;                             // 0x05FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _TremorLowDistance;                                // 0x0600(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_604[0xC];                                      // 0x0604(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool InitStaticBodyComponent(class UStaticBodyComponent* StaticBodyComponent);
	void OnTremorEvent();
	void UpdateRotation(const float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickRollingRock">();
	}
	static class AGimmickRollingRock* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickRollingRock>();
	}
};
static_assert(alignof(AGimmickRollingRock) == 0x000010, "Wrong alignment on AGimmickRollingRock");
static_assert(sizeof(AGimmickRollingRock) == 0x000610, "Wrong size on AGimmickRollingRock");
static_assert(offsetof(AGimmickRollingRock, _GimmickStaticBodyComponent) == 0x0005B8, "Member 'AGimmickRollingRock::_GimmickStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickRollingRock, _StaticMeshComponent) == 0x0005C0, "Member 'AGimmickRollingRock::_StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickRollingRock, _RollingSound) == 0x0005C8, "Member 'AGimmickRollingRock::_RollingSound' has a wrong offset!");
static_assert(offsetof(AGimmickRollingRock, _BounceSound) == 0x0005D0, "Member 'AGimmickRollingRock::_BounceSound' has a wrong offset!");
static_assert(offsetof(AGimmickRollingRock, _DamageType) == 0x0005D8, "Member 'AGimmickRollingRock::_DamageType' has a wrong offset!");
static_assert(offsetof(AGimmickRollingRock, _RotationSpeedDeg) == 0x0005DC, "Member 'AGimmickRollingRock::_RotationSpeedDeg' has a wrong offset!");
static_assert(offsetof(AGimmickRollingRock, _JumpDuration) == 0x0005E0, "Member 'AGimmickRollingRock::_JumpDuration' has a wrong offset!");
static_assert(offsetof(AGimmickRollingRock, _JumpHeight) == 0x0005E4, "Member 'AGimmickRollingRock::_JumpHeight' has a wrong offset!");
static_assert(offsetof(AGimmickRollingRock, _WorldOffsetHeight) == 0x0005E8, "Member 'AGimmickRollingRock::_WorldOffsetHeight' has a wrong offset!");
static_assert(offsetof(AGimmickRollingRock, RollAngleDeg) == 0x0005EC, "Member 'AGimmickRollingRock::RollAngleDeg' has a wrong offset!");
static_assert(offsetof(AGimmickRollingRock, _BounceSplineRate) == 0x0005F0, "Member 'AGimmickRollingRock::_BounceSplineRate' has a wrong offset!");
static_assert(offsetof(AGimmickRollingRock, _bOutputSplineRate) == 0x0005F4, "Member 'AGimmickRollingRock::_bOutputSplineRate' has a wrong offset!");
static_assert(offsetof(AGimmickRollingRock, _TremorHighDistance) == 0x0005F8, "Member 'AGimmickRollingRock::_TremorHighDistance' has a wrong offset!");
static_assert(offsetof(AGimmickRollingRock, _TremorMiddleDistance) == 0x0005FC, "Member 'AGimmickRollingRock::_TremorMiddleDistance' has a wrong offset!");
static_assert(offsetof(AGimmickRollingRock, _TremorLowDistance) == 0x000600, "Member 'AGimmickRollingRock::_TremorLowDistance' has a wrong offset!");

// Class UnionRun.GimmickRotationWater
// 0x0030 (0x05E0 - 0x05B0)
class alignas(0x10) AGimmickRotationWater final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ERacerDamageType                              _DamageType;                                       // 0x05B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B9[0x7];                                      // 0x05B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              _StaticMeshComponent;                              // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            _GimmickStaticBodyComponent;                       // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    _AtomComponent;                                    // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bIsInitialized;                                   // 0x05D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D9[0x7];                                      // 0x05D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickRotationWater">();
	}
	static class AGimmickRotationWater* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickRotationWater>();
	}
};
static_assert(alignof(AGimmickRotationWater) == 0x000010, "Wrong alignment on AGimmickRotationWater");
static_assert(sizeof(AGimmickRotationWater) == 0x0005E0, "Wrong size on AGimmickRotationWater");
static_assert(offsetof(AGimmickRotationWater, _DamageType) == 0x0005B8, "Member 'AGimmickRotationWater::_DamageType' has a wrong offset!");
static_assert(offsetof(AGimmickRotationWater, _StaticMeshComponent) == 0x0005C0, "Member 'AGimmickRotationWater::_StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickRotationWater, _GimmickStaticBodyComponent) == 0x0005C8, "Member 'AGimmickRotationWater::_GimmickStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickRotationWater, _AtomComponent) == 0x0005D0, "Member 'AGimmickRotationWater::_AtomComponent' has a wrong offset!");
static_assert(offsetof(AGimmickRotationWater, _bIsInitialized) == 0x0005D8, "Member 'AGimmickRotationWater::_bIsInitialized' has a wrong offset!");

// Class UnionRun.GimmickSmoke
// 0x00E0 (0x0690 - 0x05B0)
class alignas(0x10) AGimmickSmoke final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ERacerDamageType                              DamageType;                                        // 0x05B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B9[0x3];                                      // 0x05B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttackReadyTime;                                   // 0x05BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackContinueTime;                                // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackIntervalTime;                                // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivateWaitTime;                                  // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5CC[0x4];                                      // 0x05CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      m_AttackSmokeEffect;                               // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_AttackReadySmokeEffect;                          // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_AttackSoundComponent;                            // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_WarningSoundComponent;                           // 0x05E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            m_AttackStaticBodyComponent;                       // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionVATMeshComponent*                 ReadyEffectVatMeshComponent;                       // 0x0600(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_608[0x78];                                     // 0x0608(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               m_paramPlayrateMI;                                 // 0x0680(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_688[0x8];                                      // 0x0688(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickSmoke">();
	}
	static class AGimmickSmoke* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickSmoke>();
	}
};
static_assert(alignof(AGimmickSmoke) == 0x000010, "Wrong alignment on AGimmickSmoke");
static_assert(sizeof(AGimmickSmoke) == 0x000690, "Wrong size on AGimmickSmoke");
static_assert(offsetof(AGimmickSmoke, DamageType) == 0x0005B8, "Member 'AGimmickSmoke::DamageType' has a wrong offset!");
static_assert(offsetof(AGimmickSmoke, AttackReadyTime) == 0x0005BC, "Member 'AGimmickSmoke::AttackReadyTime' has a wrong offset!");
static_assert(offsetof(AGimmickSmoke, AttackContinueTime) == 0x0005C0, "Member 'AGimmickSmoke::AttackContinueTime' has a wrong offset!");
static_assert(offsetof(AGimmickSmoke, AttackIntervalTime) == 0x0005C4, "Member 'AGimmickSmoke::AttackIntervalTime' has a wrong offset!");
static_assert(offsetof(AGimmickSmoke, ActivateWaitTime) == 0x0005C8, "Member 'AGimmickSmoke::ActivateWaitTime' has a wrong offset!");
static_assert(offsetof(AGimmickSmoke, m_AttackSmokeEffect) == 0x0005D0, "Member 'AGimmickSmoke::m_AttackSmokeEffect' has a wrong offset!");
static_assert(offsetof(AGimmickSmoke, m_AttackReadySmokeEffect) == 0x0005D8, "Member 'AGimmickSmoke::m_AttackReadySmokeEffect' has a wrong offset!");
static_assert(offsetof(AGimmickSmoke, m_AttackSoundComponent) == 0x0005E0, "Member 'AGimmickSmoke::m_AttackSoundComponent' has a wrong offset!");
static_assert(offsetof(AGimmickSmoke, m_WarningSoundComponent) == 0x0005E8, "Member 'AGimmickSmoke::m_WarningSoundComponent' has a wrong offset!");
static_assert(offsetof(AGimmickSmoke, DefaultSceneRoot) == 0x0005F0, "Member 'AGimmickSmoke::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AGimmickSmoke, m_AttackStaticBodyComponent) == 0x0005F8, "Member 'AGimmickSmoke::m_AttackStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickSmoke, ReadyEffectVatMeshComponent) == 0x000600, "Member 'AGimmickSmoke::ReadyEffectVatMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickSmoke, m_paramPlayrateMI) == 0x000680, "Member 'AGimmickSmoke::m_paramPlayrateMI' has a wrong offset!");

// Class UnionRun.GimmickStalactite
// 0x0030 (0x05E0 - 0x05B0)
class alignas(0x10) AGimmickStalactite final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        m_locator;                                         // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionSkeletalMeshComponent*            m_skeletalMesh;                                    // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticBodyComponent*                   m_body;                                            // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionSkeletalMeshComponent*            m_landingMarker;                                   // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickStalactite">();
	}
	static class AGimmickStalactite* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickStalactite>();
	}
};
static_assert(alignof(AGimmickStalactite) == 0x000010, "Wrong alignment on AGimmickStalactite");
static_assert(sizeof(AGimmickStalactite) == 0x0005E0, "Wrong size on AGimmickStalactite");
static_assert(offsetof(AGimmickStalactite, m_locator) == 0x0005B8, "Member 'AGimmickStalactite::m_locator' has a wrong offset!");
static_assert(offsetof(AGimmickStalactite, m_skeletalMesh) == 0x0005C0, "Member 'AGimmickStalactite::m_skeletalMesh' has a wrong offset!");
static_assert(offsetof(AGimmickStalactite, m_body) == 0x0005C8, "Member 'AGimmickStalactite::m_body' has a wrong offset!");
static_assert(offsetof(AGimmickStalactite, m_landingMarker) == 0x0005D0, "Member 'AGimmickStalactite::m_landingMarker' has a wrong offset!");
static_assert(offsetof(AGimmickStalactite, DefaultSceneRoot) == 0x0005D8, "Member 'AGimmickStalactite::DefaultSceneRoot' has a wrong offset!");

// Class UnionRun.GimmickStaticWall
// 0x0020 (0x05D0 - 0x05B0)
class alignas(0x10) AGimmickStaticWall final : public AUnionGimmickObjectBase
{
public:
	class UUnionStaticMeshComponent*              StaticMeshComponent;                               // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGimmickStaticBodyComponent*            GimmickStaticBodyComponent;                        // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HideMeshInGame;                                    // 0x05C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C1[0xF];                                      // 0x05C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickStaticWall">();
	}
	static class AGimmickStaticWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickStaticWall>();
	}
};
static_assert(alignof(AGimmickStaticWall) == 0x000010, "Wrong alignment on AGimmickStaticWall");
static_assert(sizeof(AGimmickStaticWall) == 0x0005D0, "Wrong size on AGimmickStaticWall");
static_assert(offsetof(AGimmickStaticWall, StaticMeshComponent) == 0x0005B0, "Member 'AGimmickStaticWall::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickStaticWall, GimmickStaticBodyComponent) == 0x0005B8, "Member 'AGimmickStaticWall::GimmickStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickStaticWall, HideMeshInGame) == 0x0005C0, "Member 'AGimmickStaticWall::HideMeshInGame' has a wrong offset!");

// Class UnionRun.StruckoutBodyComponent
// 0x0000 (0x03A0 - 0x03A0)
class UStruckoutBodyComponent final : public UGimmickStaticBodyComponent
{
public:
	int32                                         RouteIndex;                                        // 0x0398(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StruckoutBodyComponent">();
	}
	static class UStruckoutBodyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStruckoutBodyComponent>();
	}
};
static_assert(alignof(UStruckoutBodyComponent) == 0x000010, "Wrong alignment on UStruckoutBodyComponent");
static_assert(sizeof(UStruckoutBodyComponent) == 0x0003A0, "Wrong size on UStruckoutBodyComponent");
static_assert(offsetof(UStruckoutBodyComponent, RouteIndex) == 0x000398, "Member 'UStruckoutBodyComponent::RouteIndex' has a wrong offset!");

// Class UnionRun.GimmickStruckout
// 0x0090 (0x0640 - 0x05B0)
class alignas(0x10) AGimmickStruckout final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              FrameMesh;                                         // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                Routes;                                            // 0x05C0(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UUnionStaticMeshComponent*>      PanelMeshes;                                       // 0x05D0(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UStruckoutBodyComponent*>        PanelBodies;                                       // 0x05E0(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FStruckoutRouteParam>           RouteParams;                                       // 0x05F0(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         PanelBonusDelayTime;                               // 0x0600(0x0004)(Edit, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_604[0x4];                                      // 0x0604(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AItemBoxObject>             ItemBoxReference;                                  // 0x0608(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APackageRingObject>         PackageRingReference;                              // 0x0610(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_618[0x28];                                     // 0x0618(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickStruckout">();
	}
	static class AGimmickStruckout* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickStruckout>();
	}
};
static_assert(alignof(AGimmickStruckout) == 0x000010, "Wrong alignment on AGimmickStruckout");
static_assert(sizeof(AGimmickStruckout) == 0x000640, "Wrong size on AGimmickStruckout");
static_assert(offsetof(AGimmickStruckout, FrameMesh) == 0x0005B8, "Member 'AGimmickStruckout::FrameMesh' has a wrong offset!");
static_assert(offsetof(AGimmickStruckout, Routes) == 0x0005C0, "Member 'AGimmickStruckout::Routes' has a wrong offset!");
static_assert(offsetof(AGimmickStruckout, PanelMeshes) == 0x0005D0, "Member 'AGimmickStruckout::PanelMeshes' has a wrong offset!");
static_assert(offsetof(AGimmickStruckout, PanelBodies) == 0x0005E0, "Member 'AGimmickStruckout::PanelBodies' has a wrong offset!");
static_assert(offsetof(AGimmickStruckout, RouteParams) == 0x0005F0, "Member 'AGimmickStruckout::RouteParams' has a wrong offset!");
static_assert(offsetof(AGimmickStruckout, PanelBonusDelayTime) == 0x000600, "Member 'AGimmickStruckout::PanelBonusDelayTime' has a wrong offset!");
static_assert(offsetof(AGimmickStruckout, ItemBoxReference) == 0x000608, "Member 'AGimmickStruckout::ItemBoxReference' has a wrong offset!");
static_assert(offsetof(AGimmickStruckout, PackageRingReference) == 0x000610, "Member 'AGimmickStruckout::PackageRingReference' has a wrong offset!");

// Class UnionRun.GimmickSweetsShipCannon
// 0x0080 (0x0630 - 0x05B0)
class alignas(0x10) AGimmickSweetsShipCannon final : public AUnionGimmickObjectBase
{
public:
	TArray<class UChildActorComponent*>           InstancedBalls;                                    // 0x05B0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	class UOneDirectionComponent*                 Direction;                                         // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    ShotSound;                                         // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      ShotEffect;                                        // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BallMeshNumber;                                    // 0x05D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x05DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstDelayTime;                                    // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShellingInterval;                                  // 0x05E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PoolNum;                                           // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5EC[0x4];                                      // 0x05EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AGimmickSweetsShipCannonBall> BallReference;                                   // 0x05F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStaticMesh*>                    BallMeshList;                                      // 0x05F8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FSweetsShipCannonBallData>      BallDataList;                                      // 0x0608(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0618(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_620[0x10];                                     // 0x0620(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickSweetsShipCannon">();
	}
	static class AGimmickSweetsShipCannon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickSweetsShipCannon>();
	}
};
static_assert(alignof(AGimmickSweetsShipCannon) == 0x000010, "Wrong alignment on AGimmickSweetsShipCannon");
static_assert(sizeof(AGimmickSweetsShipCannon) == 0x000630, "Wrong size on AGimmickSweetsShipCannon");
static_assert(offsetof(AGimmickSweetsShipCannon, InstancedBalls) == 0x0005B0, "Member 'AGimmickSweetsShipCannon::InstancedBalls' has a wrong offset!");
static_assert(offsetof(AGimmickSweetsShipCannon, Direction) == 0x0005C0, "Member 'AGimmickSweetsShipCannon::Direction' has a wrong offset!");
static_assert(offsetof(AGimmickSweetsShipCannon, ShotSound) == 0x0005C8, "Member 'AGimmickSweetsShipCannon::ShotSound' has a wrong offset!");
static_assert(offsetof(AGimmickSweetsShipCannon, ShotEffect) == 0x0005D0, "Member 'AGimmickSweetsShipCannon::ShotEffect' has a wrong offset!");
static_assert(offsetof(AGimmickSweetsShipCannon, BallMeshNumber) == 0x0005D8, "Member 'AGimmickSweetsShipCannon::BallMeshNumber' has a wrong offset!");
static_assert(offsetof(AGimmickSweetsShipCannon, Speed) == 0x0005DC, "Member 'AGimmickSweetsShipCannon::Speed' has a wrong offset!");
static_assert(offsetof(AGimmickSweetsShipCannon, FirstDelayTime) == 0x0005E0, "Member 'AGimmickSweetsShipCannon::FirstDelayTime' has a wrong offset!");
static_assert(offsetof(AGimmickSweetsShipCannon, ShellingInterval) == 0x0005E4, "Member 'AGimmickSweetsShipCannon::ShellingInterval' has a wrong offset!");
static_assert(offsetof(AGimmickSweetsShipCannon, PoolNum) == 0x0005E8, "Member 'AGimmickSweetsShipCannon::PoolNum' has a wrong offset!");
static_assert(offsetof(AGimmickSweetsShipCannon, BallReference) == 0x0005F0, "Member 'AGimmickSweetsShipCannon::BallReference' has a wrong offset!");
static_assert(offsetof(AGimmickSweetsShipCannon, BallMeshList) == 0x0005F8, "Member 'AGimmickSweetsShipCannon::BallMeshList' has a wrong offset!");
static_assert(offsetof(AGimmickSweetsShipCannon, BallDataList) == 0x000608, "Member 'AGimmickSweetsShipCannon::BallDataList' has a wrong offset!");
static_assert(offsetof(AGimmickSweetsShipCannon, DefaultSceneRoot) == 0x000618, "Member 'AGimmickSweetsShipCannon::DefaultSceneRoot' has a wrong offset!");

// Class UnionRun.GimmickSwingBall
// 0x0090 (0x0640 - 0x05B0)
class AGimmickSwingBall final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              _SwingBallStaticMesh;                              // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            _GimmickStaticBodyComponent;                       // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            _GimmickStaticBodyGapCoverComponent;               // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    _SwingSound;                                       // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERacerDamageType                              _DamageType;                                       // 0x05D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D9[0x3];                                      // 0x05D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _SwingAmplitude;                                   // 0x05DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _SwingInitialPhaseNormalized;                      // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _SwingPeriod;                                      // 0x05E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _HitSwingAmplitudeLimit;                           // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _HitSwingAmplitudePerHitSpeed;                     // 0x05EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _HitSwingDuration;                                 // 0x05F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoundDelay;                                        // 0x05F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _ActiveGapCoverCollision;                          // 0x05F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bInit;                                            // 0x05F9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5FA[0x2];                                      // 0x05FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _HitSwingAmplitude;                                // 0x05FC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _HitSwingPhase;                                    // 0x0600(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_604[0xC];                                      // 0x0604(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  _InitialRotation;                                  // 0x0610(0x0020)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _Time;                                             // 0x0630(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_634[0xC];                                      // 0x0634(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateRotation();

	struct FQuat CalcBaseSwingRotation(float Time, float SwingPeriod, float SwingInitialPhase) const;
	struct FQuat CalcHitSwingRotation(float HitSwingAmplitude, float HitSwingPhase) const;
	float CalcNewHitSwingPhase(float OldPhase, float OldAmplitude, float NewAmplitude) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickSwingBall">();
	}
	static class AGimmickSwingBall* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickSwingBall>();
	}
};
static_assert(alignof(AGimmickSwingBall) == 0x000010, "Wrong alignment on AGimmickSwingBall");
static_assert(sizeof(AGimmickSwingBall) == 0x000640, "Wrong size on AGimmickSwingBall");
static_assert(offsetof(AGimmickSwingBall, _SwingBallStaticMesh) == 0x0005B8, "Member 'AGimmickSwingBall::_SwingBallStaticMesh' has a wrong offset!");
static_assert(offsetof(AGimmickSwingBall, _GimmickStaticBodyComponent) == 0x0005C0, "Member 'AGimmickSwingBall::_GimmickStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickSwingBall, _GimmickStaticBodyGapCoverComponent) == 0x0005C8, "Member 'AGimmickSwingBall::_GimmickStaticBodyGapCoverComponent' has a wrong offset!");
static_assert(offsetof(AGimmickSwingBall, _SwingSound) == 0x0005D0, "Member 'AGimmickSwingBall::_SwingSound' has a wrong offset!");
static_assert(offsetof(AGimmickSwingBall, _DamageType) == 0x0005D8, "Member 'AGimmickSwingBall::_DamageType' has a wrong offset!");
static_assert(offsetof(AGimmickSwingBall, _SwingAmplitude) == 0x0005DC, "Member 'AGimmickSwingBall::_SwingAmplitude' has a wrong offset!");
static_assert(offsetof(AGimmickSwingBall, _SwingInitialPhaseNormalized) == 0x0005E0, "Member 'AGimmickSwingBall::_SwingInitialPhaseNormalized' has a wrong offset!");
static_assert(offsetof(AGimmickSwingBall, _SwingPeriod) == 0x0005E4, "Member 'AGimmickSwingBall::_SwingPeriod' has a wrong offset!");
static_assert(offsetof(AGimmickSwingBall, _HitSwingAmplitudeLimit) == 0x0005E8, "Member 'AGimmickSwingBall::_HitSwingAmplitudeLimit' has a wrong offset!");
static_assert(offsetof(AGimmickSwingBall, _HitSwingAmplitudePerHitSpeed) == 0x0005EC, "Member 'AGimmickSwingBall::_HitSwingAmplitudePerHitSpeed' has a wrong offset!");
static_assert(offsetof(AGimmickSwingBall, _HitSwingDuration) == 0x0005F0, "Member 'AGimmickSwingBall::_HitSwingDuration' has a wrong offset!");
static_assert(offsetof(AGimmickSwingBall, SoundDelay) == 0x0005F4, "Member 'AGimmickSwingBall::SoundDelay' has a wrong offset!");
static_assert(offsetof(AGimmickSwingBall, _ActiveGapCoverCollision) == 0x0005F8, "Member 'AGimmickSwingBall::_ActiveGapCoverCollision' has a wrong offset!");
static_assert(offsetof(AGimmickSwingBall, _bInit) == 0x0005F9, "Member 'AGimmickSwingBall::_bInit' has a wrong offset!");
static_assert(offsetof(AGimmickSwingBall, _HitSwingAmplitude) == 0x0005FC, "Member 'AGimmickSwingBall::_HitSwingAmplitude' has a wrong offset!");
static_assert(offsetof(AGimmickSwingBall, _HitSwingPhase) == 0x000600, "Member 'AGimmickSwingBall::_HitSwingPhase' has a wrong offset!");
static_assert(offsetof(AGimmickSwingBall, _InitialRotation) == 0x000610, "Member 'AGimmickSwingBall::_InitialRotation' has a wrong offset!");
static_assert(offsetof(AGimmickSwingBall, _Time) == 0x000630, "Member 'AGimmickSwingBall::_Time' has a wrong offset!");

// Class UnionRun.GimmickTentacle
// 0x0070 (0x0620 - 0x05B0)
class alignas(0x10) AGimmickTentacle final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionVATMeshComponent*                 VATMeshComponent;                                  // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C0[0x4C];                                     // 0x05C0(0x004C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         m_IdleEndFrame;                                    // 0x060C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         m_MoveEndFrame;                                    // 0x0610(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_614[0xC];                                      // 0x0614(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickTentacle">();
	}
	static class AGimmickTentacle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickTentacle>();
	}
};
static_assert(alignof(AGimmickTentacle) == 0x000010, "Wrong alignment on AGimmickTentacle");
static_assert(sizeof(AGimmickTentacle) == 0x000620, "Wrong size on AGimmickTentacle");
static_assert(offsetof(AGimmickTentacle, VATMeshComponent) == 0x0005B8, "Member 'AGimmickTentacle::VATMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickTentacle, m_IdleEndFrame) == 0x00060C, "Member 'AGimmickTentacle::m_IdleEndFrame' has a wrong offset!");
static_assert(offsetof(AGimmickTentacle, m_MoveEndFrame) == 0x000610, "Member 'AGimmickTentacle::m_MoveEndFrame' has a wrong offset!");

// Class UnionRun.GimmickThornBall
// 0x00A0 (0x0650 - 0x05B0)
class alignas(0x10) AGimmickThornBall final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              StaticMeshComponent;                               // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            GimmickStaticBodyComponent;                        // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERacerDamageType                              DamageType;                                        // 0x05C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C9[0x87];                                     // 0x05C9(0x0087)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetHitSpeedRatio();
	void OnPlayBreakEffect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickThornBall">();
	}
	static class AGimmickThornBall* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickThornBall>();
	}
};
static_assert(alignof(AGimmickThornBall) == 0x000010, "Wrong alignment on AGimmickThornBall");
static_assert(sizeof(AGimmickThornBall) == 0x000650, "Wrong size on AGimmickThornBall");
static_assert(offsetof(AGimmickThornBall, StaticMeshComponent) == 0x0005B8, "Member 'AGimmickThornBall::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickThornBall, GimmickStaticBodyComponent) == 0x0005C0, "Member 'AGimmickThornBall::GimmickStaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmickThornBall, DamageType) == 0x0005C8, "Member 'AGimmickThornBall::DamageType' has a wrong offset!");

// Class UnionRun.GimmickTombStone
// 0x0130 (0x06E0 - 0x05B0)
class AGimmickTombStone final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            _WallStaticBody;                                   // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            _PressStaticBody;                                  // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionStaticMeshComponent*              _StaticMeshComponent;                              // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      _NiagaraComponent;                                 // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    _FloatSound;                                       // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    _FloatingSound;                                    // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    _DropSound;                                        // 0x05F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERacerDamageType                              _DamageType;                                       // 0x05F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F9[0x3];                                      // 0x05F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _Interval;                                         // 0x05FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _StartTime;                                        // 0x0600(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _FloatingHeight;                                   // 0x0604(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _DropStopDuration;                                 // 0x0608(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _DroppingDuration;                                 // 0x060C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _DroppedDuration;                                  // 0x0610(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _RisingDuration;                                   // 0x0614(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _RisingMagnitude;                                  // 0x0618(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _RisingRotationMagnitude;                          // 0x061C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _DamageRisingDuration;                             // 0x0620(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _FloatingMagnitude;                                // 0x0624(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _FloatingRotationMagnitude;                        // 0x0628(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _FloatingTimeScale;                                // 0x062C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _IndicationDuration;                               // 0x0630(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _IndicationMagnitude;                              // 0x0634(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _IndicationRotationMagnitude;                      // 0x0638(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _IndicationTimeScale;                              // 0x063C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _IndicationLiftZ;                                  // 0x0640(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_644[0x4];                                      // 0x0644(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _InitialLocation;                                  // 0x0648(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FQuat                                  _InitialRotation;                                  // 0x0660(0x0020)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_680[0x60];                                     // 0x0680(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickTombStone">();
	}
	static class AGimmickTombStone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickTombStone>();
	}
};
static_assert(alignof(AGimmickTombStone) == 0x000010, "Wrong alignment on AGimmickTombStone");
static_assert(sizeof(AGimmickTombStone) == 0x0006E0, "Wrong size on AGimmickTombStone");
static_assert(offsetof(AGimmickTombStone, DefaultSceneRoot) == 0x0005B8, "Member 'AGimmickTombStone::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AGimmickTombStone, _WallStaticBody) == 0x0005C0, "Member 'AGimmickTombStone::_WallStaticBody' has a wrong offset!");
static_assert(offsetof(AGimmickTombStone, _PressStaticBody) == 0x0005C8, "Member 'AGimmickTombStone::_PressStaticBody' has a wrong offset!");
static_assert(offsetof(AGimmickTombStone, _StaticMeshComponent) == 0x0005D0, "Member 'AGimmickTombStone::_StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickTombStone, _NiagaraComponent) == 0x0005D8, "Member 'AGimmickTombStone::_NiagaraComponent' has a wrong offset!");
static_assert(offsetof(AGimmickTombStone, _FloatSound) == 0x0005E0, "Member 'AGimmickTombStone::_FloatSound' has a wrong offset!");
static_assert(offsetof(AGimmickTombStone, _FloatingSound) == 0x0005E8, "Member 'AGimmickTombStone::_FloatingSound' has a wrong offset!");
static_assert(offsetof(AGimmickTombStone, _DropSound) == 0x0005F0, "Member 'AGimmickTombStone::_DropSound' has a wrong offset!");
static_assert(offsetof(AGimmickTombStone, _DamageType) == 0x0005F8, "Member 'AGimmickTombStone::_DamageType' has a wrong offset!");
static_assert(offsetof(AGimmickTombStone, _Interval) == 0x0005FC, "Member 'AGimmickTombStone::_Interval' has a wrong offset!");
static_assert(offsetof(AGimmickTombStone, _StartTime) == 0x000600, "Member 'AGimmickTombStone::_StartTime' has a wrong offset!");
static_assert(offsetof(AGimmickTombStone, _FloatingHeight) == 0x000604, "Member 'AGimmickTombStone::_FloatingHeight' has a wrong offset!");
static_assert(offsetof(AGimmickTombStone, _DropStopDuration) == 0x000608, "Member 'AGimmickTombStone::_DropStopDuration' has a wrong offset!");
static_assert(offsetof(AGimmickTombStone, _DroppingDuration) == 0x00060C, "Member 'AGimmickTombStone::_DroppingDuration' has a wrong offset!");
static_assert(offsetof(AGimmickTombStone, _DroppedDuration) == 0x000610, "Member 'AGimmickTombStone::_DroppedDuration' has a wrong offset!");
static_assert(offsetof(AGimmickTombStone, _RisingDuration) == 0x000614, "Member 'AGimmickTombStone::_RisingDuration' has a wrong offset!");
static_assert(offsetof(AGimmickTombStone, _RisingMagnitude) == 0x000618, "Member 'AGimmickTombStone::_RisingMagnitude' has a wrong offset!");
static_assert(offsetof(AGimmickTombStone, _RisingRotationMagnitude) == 0x00061C, "Member 'AGimmickTombStone::_RisingRotationMagnitude' has a wrong offset!");
static_assert(offsetof(AGimmickTombStone, _DamageRisingDuration) == 0x000620, "Member 'AGimmickTombStone::_DamageRisingDuration' has a wrong offset!");
static_assert(offsetof(AGimmickTombStone, _FloatingMagnitude) == 0x000624, "Member 'AGimmickTombStone::_FloatingMagnitude' has a wrong offset!");
static_assert(offsetof(AGimmickTombStone, _FloatingRotationMagnitude) == 0x000628, "Member 'AGimmickTombStone::_FloatingRotationMagnitude' has a wrong offset!");
static_assert(offsetof(AGimmickTombStone, _FloatingTimeScale) == 0x00062C, "Member 'AGimmickTombStone::_FloatingTimeScale' has a wrong offset!");
static_assert(offsetof(AGimmickTombStone, _IndicationDuration) == 0x000630, "Member 'AGimmickTombStone::_IndicationDuration' has a wrong offset!");
static_assert(offsetof(AGimmickTombStone, _IndicationMagnitude) == 0x000634, "Member 'AGimmickTombStone::_IndicationMagnitude' has a wrong offset!");
static_assert(offsetof(AGimmickTombStone, _IndicationRotationMagnitude) == 0x000638, "Member 'AGimmickTombStone::_IndicationRotationMagnitude' has a wrong offset!");
static_assert(offsetof(AGimmickTombStone, _IndicationTimeScale) == 0x00063C, "Member 'AGimmickTombStone::_IndicationTimeScale' has a wrong offset!");
static_assert(offsetof(AGimmickTombStone, _IndicationLiftZ) == 0x000640, "Member 'AGimmickTombStone::_IndicationLiftZ' has a wrong offset!");
static_assert(offsetof(AGimmickTombStone, _InitialLocation) == 0x000648, "Member 'AGimmickTombStone::_InitialLocation' has a wrong offset!");
static_assert(offsetof(AGimmickTombStone, _InitialRotation) == 0x000660, "Member 'AGimmickTombStone::_InitialRotation' has a wrong offset!");

// Class UnionRun.GimmickTriggerMotionAnimInstance
// 0x0060 (0x03D0 - 0x0370)
class UGimmickTriggerMotionAnimInstance final : public UAnimInstance
{
public:
	bool                                          _bIsPlayOneShot;                                   // 0x0368(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _bIsPlayIdle;                                      // 0x0369(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36A[0x6];                                      // 0x036A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETriggerMotionState, float>              _PlayRateMap;                                      // 0x0370(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class AGimmickTriggerMotionBase*              _OwningGimmickActor;                               // 0x03C0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C8[0x8];                                      // 0x03C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NativeBeginPlay();
	void NativeUpdateAnimation(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickTriggerMotionAnimInstance">();
	}
	static class UGimmickTriggerMotionAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGimmickTriggerMotionAnimInstance>();
	}
};
static_assert(alignof(UGimmickTriggerMotionAnimInstance) == 0x000010, "Wrong alignment on UGimmickTriggerMotionAnimInstance");
static_assert(sizeof(UGimmickTriggerMotionAnimInstance) == 0x0003D0, "Wrong size on UGimmickTriggerMotionAnimInstance");
static_assert(offsetof(UGimmickTriggerMotionAnimInstance, _bIsPlayOneShot) == 0x000368, "Member 'UGimmickTriggerMotionAnimInstance::_bIsPlayOneShot' has a wrong offset!");
static_assert(offsetof(UGimmickTriggerMotionAnimInstance, _bIsPlayIdle) == 0x000369, "Member 'UGimmickTriggerMotionAnimInstance::_bIsPlayIdle' has a wrong offset!");
static_assert(offsetof(UGimmickTriggerMotionAnimInstance, _PlayRateMap) == 0x000370, "Member 'UGimmickTriggerMotionAnimInstance::_PlayRateMap' has a wrong offset!");
static_assert(offsetof(UGimmickTriggerMotionAnimInstance, _OwningGimmickActor) == 0x0003C0, "Member 'UGimmickTriggerMotionAnimInstance::_OwningGimmickActor' has a wrong offset!");

// Class UnionRun.GimmickTriggerMotionSkeletal
// 0x0000 (0x0620 - 0x0620)
class AGimmickTriggerMotionSkeletal final : public AGimmickTriggerMotionBase
{
public:
	class UUnionSkeletalMeshComponent*            _SkeletalMeshComponent;                            // 0x0618(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickTriggerMotionSkeletal">();
	}
	static class AGimmickTriggerMotionSkeletal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickTriggerMotionSkeletal>();
	}
};
static_assert(alignof(AGimmickTriggerMotionSkeletal) == 0x000010, "Wrong alignment on AGimmickTriggerMotionSkeletal");
static_assert(sizeof(AGimmickTriggerMotionSkeletal) == 0x000620, "Wrong size on AGimmickTriggerMotionSkeletal");
static_assert(offsetof(AGimmickTriggerMotionSkeletal, _SkeletalMeshComponent) == 0x000618, "Member 'AGimmickTriggerMotionSkeletal::_SkeletalMeshComponent' has a wrong offset!");

// Class UnionRun.GimmickTurbine
// 0x0010 (0x05C0 - 0x05B0)
class alignas(0x10) AGimmickTurbine final : public AUnionGimmickObjectBase
{
public:
	class UUnionStaticMeshComponent*              StaticMeshComponent;                               // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotZ;                                              // 0x05B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5BC[0x4];                                      // 0x05BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickTurbine">();
	}
	static class AGimmickTurbine* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickTurbine>();
	}
};
static_assert(alignof(AGimmickTurbine) == 0x000010, "Wrong alignment on AGimmickTurbine");
static_assert(sizeof(AGimmickTurbine) == 0x0005C0, "Wrong size on AGimmickTurbine");
static_assert(offsetof(AGimmickTurbine, StaticMeshComponent) == 0x0005B0, "Member 'AGimmickTurbine::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickTurbine, RotZ) == 0x0005B8, "Member 'AGimmickTurbine::RotZ' has a wrong offset!");

// Class UnionRun.GimmickVATBoo
// 0x0020 (0x05D0 - 0x05B0)
class alignas(0x10) AGimmickVATBoo final : public AUnionGimmickObjectBase
{
public:
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionVATAnimEventComponent*            BooVATMeshComponent;                               // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AnimStartFrame;                                    // 0x05C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C4[0xC];                                      // 0x05C4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickVATBoo">();
	}
	static class AGimmickVATBoo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickVATBoo>();
	}
};
static_assert(alignof(AGimmickVATBoo) == 0x000010, "Wrong alignment on AGimmickVATBoo");
static_assert(sizeof(AGimmickVATBoo) == 0x0005D0, "Wrong size on AGimmickVATBoo");
static_assert(offsetof(AGimmickVATBoo, DefaultSceneRoot) == 0x0005B0, "Member 'AGimmickVATBoo::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AGimmickVATBoo, BooVATMeshComponent) == 0x0005B8, "Member 'AGimmickVATBoo::BooVATMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickVATBoo, AnimStartFrame) == 0x0005C0, "Member 'AGimmickVATBoo::AnimStartFrame' has a wrong offset!");

// Class UnionRun.GimmickWaterfall
// 0x0070 (0x0620 - 0x05B0)
class alignas(0x10) AGimmickWaterfall final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AmbientSEComponentPosition;                        // 0x05B8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              BodyStatickMeshComponent;                          // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              SubStaticMeshComponent;                            // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    HitWaterSoundComponent;                            // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    FallWaterSoundComponent;                           // 0x05E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    WaterAmbientSoundComponent;                        // 0x05F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      CarHitEffect;                                      // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0600(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            m_MainStaticBodyComponent;                         // 0x0608(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_610[0x10];                                     // 0x0610(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCarHitEvent(const struct FVector& HitLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickWaterfall">();
	}
	static class AGimmickWaterfall* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickWaterfall>();
	}
};
static_assert(alignof(AGimmickWaterfall) == 0x000010, "Wrong alignment on AGimmickWaterfall");
static_assert(sizeof(AGimmickWaterfall) == 0x000620, "Wrong size on AGimmickWaterfall");
static_assert(offsetof(AGimmickWaterfall, AmbientSEComponentPosition) == 0x0005B8, "Member 'AGimmickWaterfall::AmbientSEComponentPosition' has a wrong offset!");
static_assert(offsetof(AGimmickWaterfall, BodyStatickMeshComponent) == 0x0005D0, "Member 'AGimmickWaterfall::BodyStatickMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickWaterfall, SubStaticMeshComponent) == 0x0005D8, "Member 'AGimmickWaterfall::SubStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickWaterfall, HitWaterSoundComponent) == 0x0005E0, "Member 'AGimmickWaterfall::HitWaterSoundComponent' has a wrong offset!");
static_assert(offsetof(AGimmickWaterfall, FallWaterSoundComponent) == 0x0005E8, "Member 'AGimmickWaterfall::FallWaterSoundComponent' has a wrong offset!");
static_assert(offsetof(AGimmickWaterfall, WaterAmbientSoundComponent) == 0x0005F0, "Member 'AGimmickWaterfall::WaterAmbientSoundComponent' has a wrong offset!");
static_assert(offsetof(AGimmickWaterfall, CarHitEffect) == 0x0005F8, "Member 'AGimmickWaterfall::CarHitEffect' has a wrong offset!");
static_assert(offsetof(AGimmickWaterfall, DefaultSceneRoot) == 0x000600, "Member 'AGimmickWaterfall::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AGimmickWaterfall, m_MainStaticBodyComponent) == 0x000608, "Member 'AGimmickWaterfall::m_MainStaticBodyComponent' has a wrong offset!");

// Class UnionRun.GimmickWave
// 0x0030 (0x05E0 - 0x05B0)
class alignas(0x10) AGimmickWave final : public AUnionGimmickObjectBase
{
public:
	class UUnionStaticMeshComponent*              StaticMeshComponent;                               // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            GimmickStaticBodyComponent01;                      // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            GimmickStaticBodyComponent02;                      // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            GimmickStaticBodyComponent03;                      // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    WaveSoundComponent;                                // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D8[0x8];                                      // 0x05D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GimmickWave">();
	}
	static class AGimmickWave* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmickWave>();
	}
};
static_assert(alignof(AGimmickWave) == 0x000010, "Wrong alignment on AGimmickWave");
static_assert(sizeof(AGimmickWave) == 0x0005E0, "Wrong size on AGimmickWave");
static_assert(offsetof(AGimmickWave, StaticMeshComponent) == 0x0005B0, "Member 'AGimmickWave::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmickWave, GimmickStaticBodyComponent01) == 0x0005B8, "Member 'AGimmickWave::GimmickStaticBodyComponent01' has a wrong offset!");
static_assert(offsetof(AGimmickWave, GimmickStaticBodyComponent02) == 0x0005C0, "Member 'AGimmickWave::GimmickStaticBodyComponent02' has a wrong offset!");
static_assert(offsetof(AGimmickWave, GimmickStaticBodyComponent03) == 0x0005C8, "Member 'AGimmickWave::GimmickStaticBodyComponent03' has a wrong offset!");
static_assert(offsetof(AGimmickWave, WaveSoundComponent) == 0x0005D0, "Member 'AGimmickWave::WaveSoundComponent' has a wrong offset!");

// Class UnionRun.Gimmick_Extnd04_Bomber
// 0x0010 (0x05C0 - 0x05B0)
class alignas(0x10) AGimmick_Extnd04_Bomber final : public AUnionGimmickObjectBase
{
public:
	class UUnionStaticMeshComponent*              BodyMesh;                                          // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionSkeletalMeshComponent*            ArmMesh;                                           // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd04_Bomber">();
	}
	static class AGimmick_Extnd04_Bomber* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd04_Bomber>();
	}
};
static_assert(alignof(AGimmick_Extnd04_Bomber) == 0x000010, "Wrong alignment on AGimmick_Extnd04_Bomber");
static_assert(sizeof(AGimmick_Extnd04_Bomber) == 0x0005C0, "Wrong size on AGimmick_Extnd04_Bomber");
static_assert(offsetof(AGimmick_Extnd04_Bomber, BodyMesh) == 0x0005B0, "Member 'AGimmick_Extnd04_Bomber::BodyMesh' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_Bomber, ArmMesh) == 0x0005B8, "Member 'AGimmick_Extnd04_Bomber::ArmMesh' has a wrong offset!");

// Class UnionRun.Gimmick_Extnd04_Character04003
// 0x0040 (0x05F0 - 0x05B0)
class alignas(0x10) AGimmick_Extnd04_Character04003 final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExplosionReadyTime;                                // 0x05B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5BC[0x4];                                      // 0x05BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionSkeletalMeshComponent*            ArmMesh;                                           // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      ExplodeEffect;                                     // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    AttackSoundComponent;                              // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D8[0x18];                                     // 0x05D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnExplosionEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd04_Character04003">();
	}
	static class AGimmick_Extnd04_Character04003* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd04_Character04003>();
	}
};
static_assert(alignof(AGimmick_Extnd04_Character04003) == 0x000010, "Wrong alignment on AGimmick_Extnd04_Character04003");
static_assert(sizeof(AGimmick_Extnd04_Character04003) == 0x0005F0, "Wrong size on AGimmick_Extnd04_Character04003");
static_assert(offsetof(AGimmick_Extnd04_Character04003, ExplosionReadyTime) == 0x0005B8, "Member 'AGimmick_Extnd04_Character04003::ExplosionReadyTime' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_Character04003, ArmMesh) == 0x0005C0, "Member 'AGimmick_Extnd04_Character04003::ArmMesh' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_Character04003, ExplodeEffect) == 0x0005C8, "Member 'AGimmick_Extnd04_Character04003::ExplodeEffect' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_Character04003, AttackSoundComponent) == 0x0005D0, "Member 'AGimmick_Extnd04_Character04003::AttackSoundComponent' has a wrong offset!");

// Class UnionRun.Gimmick_Extnd04_EaEntranceExit
// 0x0060 (0x0610 - 0x05B0)
class alignas(0x10) AGimmick_Extnd04_EaEntranceExit final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGimmickStaticBodyComponent*            Body;                                              // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNiagaraComponent*>              Effects;                                           // 0x05C0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    PassSound;                                         // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EffectOffset;                                      // 0x05D8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InWorld;                                           // 0x05F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F1[0x1F];                                     // 0x05F1(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd04_EaEntranceExit">();
	}
	static class AGimmick_Extnd04_EaEntranceExit* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd04_EaEntranceExit>();
	}
};
static_assert(alignof(AGimmick_Extnd04_EaEntranceExit) == 0x000010, "Wrong alignment on AGimmick_Extnd04_EaEntranceExit");
static_assert(sizeof(AGimmick_Extnd04_EaEntranceExit) == 0x000610, "Wrong size on AGimmick_Extnd04_EaEntranceExit");
static_assert(offsetof(AGimmick_Extnd04_EaEntranceExit, Body) == 0x0005B8, "Member 'AGimmick_Extnd04_EaEntranceExit::Body' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_EaEntranceExit, Effects) == 0x0005C0, "Member 'AGimmick_Extnd04_EaEntranceExit::Effects' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_EaEntranceExit, PassSound) == 0x0005D0, "Member 'AGimmick_Extnd04_EaEntranceExit::PassSound' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_EaEntranceExit, EffectOffset) == 0x0005D8, "Member 'AGimmick_Extnd04_EaEntranceExit::EffectOffset' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_EaEntranceExit, InWorld) == 0x0005F0, "Member 'AGimmick_Extnd04_EaEntranceExit::InWorld' has a wrong offset!");

// Class UnionRun.Gimmick_Extnd04_HugeBomb
// 0x00D0 (0x0680 - 0x05B0)
class alignas(0x10) AGimmick_Extnd04_HugeBomb final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x10];                                     // 0x05B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	ERacerDamageType                              DamageType;                                        // 0x05C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C1[0x3];                                      // 0x05C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttackingTime;                                     // 0x05C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableObjectBreak;                                 // 0x05C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableSlowObjectBreak;                             // 0x05C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5CA[0x6];                                      // 0x05CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              BombMesh;                                          // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      BreakEffect;                                       // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            BodyComponent;                                     // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            AttackBodyComponent;                               // 0x05E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    AttackSoundComponent;                              // 0x05F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F8[0x8];                                      // 0x05F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGimmick_Extnd04_BombFlame*>     FlameObjectArray;                                  // 0x0600(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class AGimmick_Extnd04_FadePillar*            BreakPillarObjectRef;                              // 0x0610(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AGimmickSlowNet*>                SlowObjectArray;                                   // 0x0618(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_628[0x58];                                     // 0x0628(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd04_HugeBomb">();
	}
	static class AGimmick_Extnd04_HugeBomb* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd04_HugeBomb>();
	}
};
static_assert(alignof(AGimmick_Extnd04_HugeBomb) == 0x000010, "Wrong alignment on AGimmick_Extnd04_HugeBomb");
static_assert(sizeof(AGimmick_Extnd04_HugeBomb) == 0x000680, "Wrong size on AGimmick_Extnd04_HugeBomb");
static_assert(offsetof(AGimmick_Extnd04_HugeBomb, DamageType) == 0x0005C0, "Member 'AGimmick_Extnd04_HugeBomb::DamageType' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_HugeBomb, AttackingTime) == 0x0005C4, "Member 'AGimmick_Extnd04_HugeBomb::AttackingTime' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_HugeBomb, EnableObjectBreak) == 0x0005C8, "Member 'AGimmick_Extnd04_HugeBomb::EnableObjectBreak' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_HugeBomb, EnableSlowObjectBreak) == 0x0005C9, "Member 'AGimmick_Extnd04_HugeBomb::EnableSlowObjectBreak' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_HugeBomb, BombMesh) == 0x0005D0, "Member 'AGimmick_Extnd04_HugeBomb::BombMesh' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_HugeBomb, BreakEffect) == 0x0005D8, "Member 'AGimmick_Extnd04_HugeBomb::BreakEffect' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_HugeBomb, BodyComponent) == 0x0005E0, "Member 'AGimmick_Extnd04_HugeBomb::BodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_HugeBomb, AttackBodyComponent) == 0x0005E8, "Member 'AGimmick_Extnd04_HugeBomb::AttackBodyComponent' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_HugeBomb, AttackSoundComponent) == 0x0005F0, "Member 'AGimmick_Extnd04_HugeBomb::AttackSoundComponent' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_HugeBomb, FlameObjectArray) == 0x000600, "Member 'AGimmick_Extnd04_HugeBomb::FlameObjectArray' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_HugeBomb, BreakPillarObjectRef) == 0x000610, "Member 'AGimmick_Extnd04_HugeBomb::BreakPillarObjectRef' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_HugeBomb, SlowObjectArray) == 0x000618, "Member 'AGimmick_Extnd04_HugeBomb::SlowObjectArray' has a wrong offset!");

// Class UnionRun.Gimmick_Extnd04_MobWithFX
// 0x0040 (0x05F0 - 0x05B0)
class alignas(0x10) AGimmick_Extnd04_MobWithFX final : public AUnionGimmickObjectBase
{
public:
	struct FVector                                EffectOffsetLocation;                              // 0x05B0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      ModelEffect;                                       // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionSkeletalMeshComponent*            ArmMesh;                                           // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionVATMeshComponent*                 VATModelMeshComponent;                             // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      MeshEffect;                                        // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E8[0x8];                                      // 0x05E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd04_MobWithFX">();
	}
	static class AGimmick_Extnd04_MobWithFX* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd04_MobWithFX>();
	}
};
static_assert(alignof(AGimmick_Extnd04_MobWithFX) == 0x000010, "Wrong alignment on AGimmick_Extnd04_MobWithFX");
static_assert(sizeof(AGimmick_Extnd04_MobWithFX) == 0x0005F0, "Wrong size on AGimmick_Extnd04_MobWithFX");
static_assert(offsetof(AGimmick_Extnd04_MobWithFX, EffectOffsetLocation) == 0x0005B0, "Member 'AGimmick_Extnd04_MobWithFX::EffectOffsetLocation' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_MobWithFX, ModelEffect) == 0x0005C8, "Member 'AGimmick_Extnd04_MobWithFX::ModelEffect' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_MobWithFX, ArmMesh) == 0x0005D0, "Member 'AGimmick_Extnd04_MobWithFX::ArmMesh' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_MobWithFX, VATModelMeshComponent) == 0x0005D8, "Member 'AGimmick_Extnd04_MobWithFX::VATModelMeshComponent' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd04_MobWithFX, MeshEffect) == 0x0005E0, "Member 'AGimmick_Extnd04_MobWithFX::MeshEffect' has a wrong offset!");

// Class UnionRun.Gimmick_Extnd05_Bubble
// 0x0010 (0x02C0 - 0x02B0)
class AGimmick_Extnd05_Bubble final : public AIntervalVATObject
{
public:
	class UNiagaraComponent*                      NiagaraEffect;                                     // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    AtomComponent;                                     // 0x02B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd05_Bubble">();
	}
	static class AGimmick_Extnd05_Bubble* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd05_Bubble>();
	}
};
static_assert(alignof(AGimmick_Extnd05_Bubble) == 0x000008, "Wrong alignment on AGimmick_Extnd05_Bubble");
static_assert(sizeof(AGimmick_Extnd05_Bubble) == 0x0002C0, "Wrong size on AGimmick_Extnd05_Bubble");
static_assert(offsetof(AGimmick_Extnd05_Bubble, NiagaraEffect) == 0x0002B0, "Member 'AGimmick_Extnd05_Bubble::NiagaraEffect' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_Bubble, AtomComponent) == 0x0002B8, "Member 'AGimmick_Extnd05_Bubble::AtomComponent' has a wrong offset!");

// Class UnionRun.Gimmick_Extnd05_EnemyLaser
// 0x0030 (0x05E0 - 0x05B0)
class alignas(0x10) AGimmick_Extnd05_EnemyLaser final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              StaticMesh;                                        // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            StaticBody;                                        // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    LaserSound;                                        // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D0[0x10];                                     // 0x05D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd05_EnemyLaser">();
	}
	static class AGimmick_Extnd05_EnemyLaser* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd05_EnemyLaser>();
	}
};
static_assert(alignof(AGimmick_Extnd05_EnemyLaser) == 0x000010, "Wrong alignment on AGimmick_Extnd05_EnemyLaser");
static_assert(sizeof(AGimmick_Extnd05_EnemyLaser) == 0x0005E0, "Wrong size on AGimmick_Extnd05_EnemyLaser");
static_assert(offsetof(AGimmick_Extnd05_EnemyLaser, StaticMesh) == 0x0005B8, "Member 'AGimmick_Extnd05_EnemyLaser::StaticMesh' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_EnemyLaser, StaticBody) == 0x0005C0, "Member 'AGimmick_Extnd05_EnemyLaser::StaticBody' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_EnemyLaser, LaserSound) == 0x0005C8, "Member 'AGimmick_Extnd05_EnemyLaser::LaserSound' has a wrong offset!");

// Class UnionRun.Gimmick_Extnd05_HouseA
// 0x0030 (0x05E0 - 0x05B0)
class alignas(0x10) AGimmick_Extnd05_HouseA final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              HouseMesh;                                         // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      WaterEffect;                                       // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    StartSound;                                        // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DelayTime;                                         // 0x05D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D4[0xC];                                      // 0x05D4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd05_HouseA">();
	}
	static class AGimmick_Extnd05_HouseA* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd05_HouseA>();
	}
};
static_assert(alignof(AGimmick_Extnd05_HouseA) == 0x000010, "Wrong alignment on AGimmick_Extnd05_HouseA");
static_assert(sizeof(AGimmick_Extnd05_HouseA) == 0x0005E0, "Wrong size on AGimmick_Extnd05_HouseA");
static_assert(offsetof(AGimmick_Extnd05_HouseA, HouseMesh) == 0x0005B8, "Member 'AGimmick_Extnd05_HouseA::HouseMesh' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_HouseA, WaterEffect) == 0x0005C0, "Member 'AGimmick_Extnd05_HouseA::WaterEffect' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_HouseA, StartSound) == 0x0005C8, "Member 'AGimmick_Extnd05_HouseA::StartSound' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_HouseA, DelayTime) == 0x0005D0, "Member 'AGimmick_Extnd05_HouseA::DelayTime' has a wrong offset!");

// Class UnionRun.Gimmick_Extnd05_ShopDoor
// 0x0060 (0x0610 - 0x05B0)
class alignas(0x10) AGimmick_Extnd05_ShopDoor final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimationLength;                                   // 0x05B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5BC[0x4];                                      // 0x05BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              DefaultStaticMesh;                                 // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionStaticMeshComponent*              BrokenStaticMesh;                                  // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            StaticBody;                                        // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            WoodStaticBodyLeft;                                // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            WoodStaticBodyRight;                               // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionVATMeshComponent*                 GlassVAT;                                          // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionVATMeshComponent*                 WoodVAT;                                           // 0x05F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      NiagaraEffect;                                     // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_600[0x10];                                     // 0x0600(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd05_ShopDoor">();
	}
	static class AGimmick_Extnd05_ShopDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd05_ShopDoor>();
	}
};
static_assert(alignof(AGimmick_Extnd05_ShopDoor) == 0x000010, "Wrong alignment on AGimmick_Extnd05_ShopDoor");
static_assert(sizeof(AGimmick_Extnd05_ShopDoor) == 0x000610, "Wrong size on AGimmick_Extnd05_ShopDoor");
static_assert(offsetof(AGimmick_Extnd05_ShopDoor, AnimationLength) == 0x0005B8, "Member 'AGimmick_Extnd05_ShopDoor::AnimationLength' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_ShopDoor, DefaultStaticMesh) == 0x0005C0, "Member 'AGimmick_Extnd05_ShopDoor::DefaultStaticMesh' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_ShopDoor, BrokenStaticMesh) == 0x0005C8, "Member 'AGimmick_Extnd05_ShopDoor::BrokenStaticMesh' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_ShopDoor, StaticBody) == 0x0005D0, "Member 'AGimmick_Extnd05_ShopDoor::StaticBody' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_ShopDoor, WoodStaticBodyLeft) == 0x0005D8, "Member 'AGimmick_Extnd05_ShopDoor::WoodStaticBodyLeft' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_ShopDoor, WoodStaticBodyRight) == 0x0005E0, "Member 'AGimmick_Extnd05_ShopDoor::WoodStaticBodyRight' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_ShopDoor, GlassVAT) == 0x0005E8, "Member 'AGimmick_Extnd05_ShopDoor::GlassVAT' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_ShopDoor, WoodVAT) == 0x0005F0, "Member 'AGimmick_Extnd05_ShopDoor::WoodVAT' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_ShopDoor, NiagaraEffect) == 0x0005F8, "Member 'AGimmick_Extnd05_ShopDoor::NiagaraEffect' has a wrong offset!");

// Class UnionRun.Gimmick_Extnd05_VolcanoRock
// 0x0050 (0x0600 - 0x05B0)
class alignas(0x10) AGimmick_Extnd05_VolcanoRock final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              RockMesh;                                          // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionStaticMeshComponent*              FireMesh;                                          // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            StaticBody;                                        // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    FallingSound;                                      // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERacerDamageType                              DamageType;                                        // 0x05D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D9[0x3];                                      // 0x05D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IntervalTime;                                      // 0x05DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E0[0x6];                                      // 0x05E0(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsAbsorbed;                                       // 0x05E6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E7[0x1];                                      // 0x05E7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitTriggerInfo>                HitInfos;                                          // 0x05E8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F8[0x8];                                      // 0x05F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd05_VolcanoRock">();
	}
	static class AGimmick_Extnd05_VolcanoRock* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd05_VolcanoRock>();
	}
};
static_assert(alignof(AGimmick_Extnd05_VolcanoRock) == 0x000010, "Wrong alignment on AGimmick_Extnd05_VolcanoRock");
static_assert(sizeof(AGimmick_Extnd05_VolcanoRock) == 0x000600, "Wrong size on AGimmick_Extnd05_VolcanoRock");
static_assert(offsetof(AGimmick_Extnd05_VolcanoRock, RockMesh) == 0x0005B8, "Member 'AGimmick_Extnd05_VolcanoRock::RockMesh' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_VolcanoRock, FireMesh) == 0x0005C0, "Member 'AGimmick_Extnd05_VolcanoRock::FireMesh' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_VolcanoRock, StaticBody) == 0x0005C8, "Member 'AGimmick_Extnd05_VolcanoRock::StaticBody' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_VolcanoRock, FallingSound) == 0x0005D0, "Member 'AGimmick_Extnd05_VolcanoRock::FallingSound' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_VolcanoRock, DamageType) == 0x0005D8, "Member 'AGimmick_Extnd05_VolcanoRock::DamageType' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_VolcanoRock, IntervalTime) == 0x0005DC, "Member 'AGimmick_Extnd05_VolcanoRock::IntervalTime' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_VolcanoRock, bIsAbsorbed) == 0x0005E6, "Member 'AGimmick_Extnd05_VolcanoRock::bIsAbsorbed' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_VolcanoRock, HitInfos) == 0x0005E8, "Member 'AGimmick_Extnd05_VolcanoRock::HitInfos' has a wrong offset!");

// Class UnionRun.Gimmick_Extnd05_WaterColumn
// 0x0050 (0x0600 - 0x05B0)
class alignas(0x10) AGimmick_Extnd05_WaterColumn final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              WaterMesh;                                         // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGimmick_Extnd05_HouseA*                HouseA;                                            // 0x05C0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    WaterSound;                                        // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxHeight;                                         // 0x05D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D4[0x2C];                                     // 0x05D4(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd05_WaterColumn">();
	}
	static class AGimmick_Extnd05_WaterColumn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd05_WaterColumn>();
	}
};
static_assert(alignof(AGimmick_Extnd05_WaterColumn) == 0x000010, "Wrong alignment on AGimmick_Extnd05_WaterColumn");
static_assert(sizeof(AGimmick_Extnd05_WaterColumn) == 0x000600, "Wrong size on AGimmick_Extnd05_WaterColumn");
static_assert(offsetof(AGimmick_Extnd05_WaterColumn, WaterMesh) == 0x0005B8, "Member 'AGimmick_Extnd05_WaterColumn::WaterMesh' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_WaterColumn, HouseA) == 0x0005C0, "Member 'AGimmick_Extnd05_WaterColumn::HouseA' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_WaterColumn, WaterSound) == 0x0005C8, "Member 'AGimmick_Extnd05_WaterColumn::WaterSound' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd05_WaterColumn, MaxHeight) == 0x0005D0, "Member 'AGimmick_Extnd05_WaterColumn::MaxHeight' has a wrong offset!");

// Class UnionRun.Gimmick_Extnd06_Enemy06002
// 0x0300 (0x08B0 - 0x05B0)
class alignas(0x10) AGimmick_Extnd06_Enemy06002 final : public AUnionGimmickObjectBase
{
public:
	TArray<class UStaticMesh*>                    score;                                             // 0x05B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          Animation;                                         // 0x05C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotateSpeed;                                       // 0x05C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsTurnRight;                                       // 0x05CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5CD[0x3];                                      // 0x05CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialRotation;                                   // 0x05D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DelayTime;                                         // 0x05D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StartScoreTime;                                    // 0x05D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         KeepScoreTime;                                     // 0x05DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EGimmick_Extnd06_Enemy06002_SpeedClassId, float> StandardSpeedByClass;                      // 0x05E0(0x0050)(Edit, NativeAccessSpecifierPrivate)
	float                                         KeepDifference;                                    // 0x0630(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnimationPlayRate;                                 // 0x0634(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionSkeletalMeshComponent*            ModelComponent;                                    // 0x0638(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            CollisionComponent;                                // 0x0640(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionStaticMeshComponent*              ScoreComponent;                                    // 0x0648(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_650[0x260];                                    // 0x0650(0x0260)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd06_Enemy06002">();
	}
	static class AGimmick_Extnd06_Enemy06002* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd06_Enemy06002>();
	}
};
static_assert(alignof(AGimmick_Extnd06_Enemy06002) == 0x000010, "Wrong alignment on AGimmick_Extnd06_Enemy06002");
static_assert(sizeof(AGimmick_Extnd06_Enemy06002) == 0x0008B0, "Wrong size on AGimmick_Extnd06_Enemy06002");
static_assert(offsetof(AGimmick_Extnd06_Enemy06002, score) == 0x0005B0, "Member 'AGimmick_Extnd06_Enemy06002::score' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd06_Enemy06002, Animation) == 0x0005C0, "Member 'AGimmick_Extnd06_Enemy06002::Animation' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd06_Enemy06002, RotateSpeed) == 0x0005C8, "Member 'AGimmick_Extnd06_Enemy06002::RotateSpeed' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd06_Enemy06002, IsTurnRight) == 0x0005CC, "Member 'AGimmick_Extnd06_Enemy06002::IsTurnRight' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd06_Enemy06002, InitialRotation) == 0x0005D0, "Member 'AGimmick_Extnd06_Enemy06002::InitialRotation' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd06_Enemy06002, DelayTime) == 0x0005D4, "Member 'AGimmick_Extnd06_Enemy06002::DelayTime' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd06_Enemy06002, StartScoreTime) == 0x0005D8, "Member 'AGimmick_Extnd06_Enemy06002::StartScoreTime' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd06_Enemy06002, KeepScoreTime) == 0x0005DC, "Member 'AGimmick_Extnd06_Enemy06002::KeepScoreTime' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd06_Enemy06002, StandardSpeedByClass) == 0x0005E0, "Member 'AGimmick_Extnd06_Enemy06002::StandardSpeedByClass' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd06_Enemy06002, KeepDifference) == 0x000630, "Member 'AGimmick_Extnd06_Enemy06002::KeepDifference' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd06_Enemy06002, AnimationPlayRate) == 0x000634, "Member 'AGimmick_Extnd06_Enemy06002::AnimationPlayRate' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd06_Enemy06002, ModelComponent) == 0x000638, "Member 'AGimmick_Extnd06_Enemy06002::ModelComponent' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd06_Enemy06002, CollisionComponent) == 0x000640, "Member 'AGimmick_Extnd06_Enemy06002::CollisionComponent' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd06_Enemy06002, ScoreComponent) == 0x000648, "Member 'AGimmick_Extnd06_Enemy06002::ScoreComponent' has a wrong offset!");

// Class UnionRun.Gimmick_Extnd07_DashRing
// 0x0010 (0x05C0 - 0x05B0)
class AGimmick_Extnd07_DashRing final : public AUnionGimmickObjectBase
{
public:
	EExtnd07Area                                  Area;                                              // 0x05B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B1[0xF];                                      // 0x05B1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd07_DashRing">();
	}
	static class AGimmick_Extnd07_DashRing* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd07_DashRing>();
	}
};
static_assert(alignof(AGimmick_Extnd07_DashRing) == 0x000008, "Wrong alignment on AGimmick_Extnd07_DashRing");
static_assert(sizeof(AGimmick_Extnd07_DashRing) == 0x0005C0, "Wrong size on AGimmick_Extnd07_DashRing");
static_assert(offsetof(AGimmick_Extnd07_DashRing, Area) == 0x0005B0, "Member 'AGimmick_Extnd07_DashRing::Area' has a wrong offset!");

// Class UnionRun.Gimmick_Extnd07_MagicGate
// 0x00E0 (0x0690 - 0x05B0)
class alignas(0x10) AGimmick_Extnd07_MagicGate final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              GateMesh;                                          // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      ThroughEffect;                                     // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticBodyComponent*                   Body;                                              // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExtnd07GateKind                              GateKind;                                          // 0x05D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExtnd07Area                                  GateArea;                                          // 0x05D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D2[0x6];                                      // 0x05D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EExtnd07GateKind, TSoftObjectPtr<class UStaticMesh>> GateMeshAssets;                        // 0x05D8(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<EExtnd07GateKind, TSoftObjectPtr<class UNiagaraSystem>> ThroughEffectAssets;                // 0x0628(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          DebugCanReuseTrigger;                              // 0x0678(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_679[0x17];                                     // 0x0679(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd07_MagicGate">();
	}
	static class AGimmick_Extnd07_MagicGate* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd07_MagicGate>();
	}
};
static_assert(alignof(AGimmick_Extnd07_MagicGate) == 0x000010, "Wrong alignment on AGimmick_Extnd07_MagicGate");
static_assert(sizeof(AGimmick_Extnd07_MagicGate) == 0x000690, "Wrong size on AGimmick_Extnd07_MagicGate");
static_assert(offsetof(AGimmick_Extnd07_MagicGate, GateMesh) == 0x0005B8, "Member 'AGimmick_Extnd07_MagicGate::GateMesh' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd07_MagicGate, ThroughEffect) == 0x0005C0, "Member 'AGimmick_Extnd07_MagicGate::ThroughEffect' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd07_MagicGate, Body) == 0x0005C8, "Member 'AGimmick_Extnd07_MagicGate::Body' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd07_MagicGate, GateKind) == 0x0005D0, "Member 'AGimmick_Extnd07_MagicGate::GateKind' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd07_MagicGate, GateArea) == 0x0005D1, "Member 'AGimmick_Extnd07_MagicGate::GateArea' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd07_MagicGate, GateMeshAssets) == 0x0005D8, "Member 'AGimmick_Extnd07_MagicGate::GateMeshAssets' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd07_MagicGate, ThroughEffectAssets) == 0x000628, "Member 'AGimmick_Extnd07_MagicGate::ThroughEffectAssets' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd07_MagicGate, DebugCanReuseTrigger) == 0x000678, "Member 'AGimmick_Extnd07_MagicGate::DebugCanReuseTrigger' has a wrong offset!");

// Class UnionRun.Gimmick_Extnd09_RespotEffect
// 0x0020 (0x05D0 - 0x05B0)
class alignas(0x10) AGimmick_Extnd09_RespotEffect final : public AUnionGimmickObjectBase
{
public:
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionAtomComponent*                    AtomComponent;                                     // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C0[0x10];                                     // 0x05C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gimmick_Extnd09_RespotEffect">();
	}
	static class AGimmick_Extnd09_RespotEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGimmick_Extnd09_RespotEffect>();
	}
};
static_assert(alignof(AGimmick_Extnd09_RespotEffect) == 0x000010, "Wrong alignment on AGimmick_Extnd09_RespotEffect");
static_assert(sizeof(AGimmick_Extnd09_RespotEffect) == 0x0005D0, "Wrong size on AGimmick_Extnd09_RespotEffect");
static_assert(offsetof(AGimmick_Extnd09_RespotEffect, NiagaraComponent) == 0x0005B0, "Member 'AGimmick_Extnd09_RespotEffect::NiagaraComponent' has a wrong offset!");
static_assert(offsetof(AGimmick_Extnd09_RespotEffect, AtomComponent) == 0x0005B8, "Member 'AGimmick_Extnd09_RespotEffect::AtomComponent' has a wrong offset!");

// Class UnionRun.UnionMoveAbovePath
// 0x01E8 (0x0220 - 0x0038)
class UUnionMoveAbovePath final : public UMoveController
{
public:
	uint8                                         Pad_38[0x1E8];                                     // 0x0038(0x01E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionMoveAbovePath">();
	}
	static class UUnionMoveAbovePath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionMoveAbovePath>();
	}
};
static_assert(alignof(UUnionMoveAbovePath) == 0x000008, "Wrong alignment on UUnionMoveAbovePath");
static_assert(sizeof(UUnionMoveAbovePath) == 0x000220, "Wrong size on UUnionMoveAbovePath");

// Class UnionRun.GUNHunterBullet
// 0x01B0 (0x0760 - 0x05B0)
class alignas(0x10) AGUNHunterBullet final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Root;                                              // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      BulletEffect;                                      // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      HitEffect;                                         // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGimmickStaticBodyComponent*            Body;                                              // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    HitSound;                                          // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERacerDamageType                              DamageType;                                        // 0x05E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E1[0x3];                                      // 0x05E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollisionDisableDelayTime;                         // 0x05E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundCheckRaycastLength;                          // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5EC[0x4];                                      // 0x05EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            AbsorbMesh;                                        // 0x05F0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F8[0x168];                                    // 0x05F8(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GUNHunterBullet">();
	}
	static class AGUNHunterBullet* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGUNHunterBullet>();
	}
};
static_assert(alignof(AGUNHunterBullet) == 0x000010, "Wrong alignment on AGUNHunterBullet");
static_assert(sizeof(AGUNHunterBullet) == 0x000760, "Wrong size on AGUNHunterBullet");
static_assert(offsetof(AGUNHunterBullet, Root) == 0x0005B8, "Member 'AGUNHunterBullet::Root' has a wrong offset!");
static_assert(offsetof(AGUNHunterBullet, BulletEffect) == 0x0005C0, "Member 'AGUNHunterBullet::BulletEffect' has a wrong offset!");
static_assert(offsetof(AGUNHunterBullet, HitEffect) == 0x0005C8, "Member 'AGUNHunterBullet::HitEffect' has a wrong offset!");
static_assert(offsetof(AGUNHunterBullet, Body) == 0x0005D0, "Member 'AGUNHunterBullet::Body' has a wrong offset!");
static_assert(offsetof(AGUNHunterBullet, HitSound) == 0x0005D8, "Member 'AGUNHunterBullet::HitSound' has a wrong offset!");
static_assert(offsetof(AGUNHunterBullet, DamageType) == 0x0005E0, "Member 'AGUNHunterBullet::DamageType' has a wrong offset!");
static_assert(offsetof(AGUNHunterBullet, CollisionDisableDelayTime) == 0x0005E4, "Member 'AGUNHunterBullet::CollisionDisableDelayTime' has a wrong offset!");
static_assert(offsetof(AGUNHunterBullet, GroundCheckRaycastLength) == 0x0005E8, "Member 'AGUNHunterBullet::GroundCheckRaycastLength' has a wrong offset!");
static_assert(offsetof(AGUNHunterBullet, AbsorbMesh) == 0x0005F0, "Member 'AGUNHunterBullet::AbsorbMesh' has a wrong offset!");

// Class UnionRun.HeadButtTrexAnimInstance
// 0x0000 (0x0370 - 0x0370)
class UHeadButtTrexAnimInstance final : public UEnemyAnimInstance
{
public:
	bool                                          bIsAppear;                                         // 0x0368(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAttack;                                         // 0x0369(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDamage;                                         // 0x036A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMirror;                                         // 0x036B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36C[0x4];                                      // 0x036C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetIsAppear();
	bool GetIsAttack();
	bool GetIsDamage();
	bool GetIsMirror();
	void SetIsAppear(bool flag);
	void SetIsAttack(bool flag);
	void SetIsDamage(bool flag);
	void SetIsMirror(bool flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeadButtTrexAnimInstance">();
	}
	static class UHeadButtTrexAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeadButtTrexAnimInstance>();
	}
};
static_assert(alignof(UHeadButtTrexAnimInstance) == 0x000010, "Wrong alignment on UHeadButtTrexAnimInstance");
static_assert(sizeof(UHeadButtTrexAnimInstance) == 0x000370, "Wrong size on UHeadButtTrexAnimInstance");
static_assert(offsetof(UHeadButtTrexAnimInstance, bIsAppear) == 0x000368, "Member 'UHeadButtTrexAnimInstance::bIsAppear' has a wrong offset!");
static_assert(offsetof(UHeadButtTrexAnimInstance, bIsAttack) == 0x000369, "Member 'UHeadButtTrexAnimInstance::bIsAttack' has a wrong offset!");
static_assert(offsetof(UHeadButtTrexAnimInstance, bIsDamage) == 0x00036A, "Member 'UHeadButtTrexAnimInstance::bIsDamage' has a wrong offset!");
static_assert(offsetof(UHeadButtTrexAnimInstance, bIsMirror) == 0x00036B, "Member 'UHeadButtTrexAnimInstance::bIsMirror' has a wrong offset!");

// Class UnionRun.SplineMoveObject
// 0x0080 (0x0310 - 0x0290)
class ASplineMoveObject : public AActor
{
public:
	struct FSplineMoveSettingParam                SettingParam;                                      // 0x0290(0x0068)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bInitTransform;                                    // 0x02F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F9[0x7];                                      // 0x02F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionSplineMoveComponent*              SplineMoveComponent;                               // 0x0300(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0308(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SplineMoveObject">();
	}
	static class ASplineMoveObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASplineMoveObject>();
	}
};
static_assert(alignof(ASplineMoveObject) == 0x000008, "Wrong alignment on ASplineMoveObject");
static_assert(sizeof(ASplineMoveObject) == 0x000310, "Wrong size on ASplineMoveObject");
static_assert(offsetof(ASplineMoveObject, SettingParam) == 0x000290, "Member 'ASplineMoveObject::SettingParam' has a wrong offset!");
static_assert(offsetof(ASplineMoveObject, bInitTransform) == 0x0002F8, "Member 'ASplineMoveObject::bInitTransform' has a wrong offset!");
static_assert(offsetof(ASplineMoveObject, SplineMoveComponent) == 0x000300, "Member 'ASplineMoveObject::SplineMoveComponent' has a wrong offset!");
static_assert(offsetof(ASplineMoveObject, DefaultSceneRoot) == 0x000308, "Member 'ASplineMoveObject::DefaultSceneRoot' has a wrong offset!");

// Class UnionRun.StaticSplineMoveObject
// 0x0008 (0x0318 - 0x0310)
class AStaticSplineMoveObject final : public ASplineMoveObject
{
public:
	class UUnionStaticMeshComponent*              StaticMeshComponent;                               // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticSplineMoveObject">();
	}
	static class AStaticSplineMoveObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStaticSplineMoveObject>();
	}
};
static_assert(alignof(AStaticSplineMoveObject) == 0x000008, "Wrong alignment on AStaticSplineMoveObject");
static_assert(sizeof(AStaticSplineMoveObject) == 0x000318, "Wrong size on AStaticSplineMoveObject");
static_assert(offsetof(AStaticSplineMoveObject, StaticMeshComponent) == 0x000310, "Member 'AStaticSplineMoveObject::StaticMeshComponent' has a wrong offset!");

// Class UnionRun.IgnoreGravityFallCollision
// 0x0010 (0x05C0 - 0x05B0)
class alignas(0x10) AIgnoreGravityFallCollision final : public AUnionGimmickObjectBase
{
public:
	class UGimmickStaticBodyComponent*            StaticBodyComponent;                               // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgnoreGravityFallCollision">();
	}
	static class AIgnoreGravityFallCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIgnoreGravityFallCollision>();
	}
};
static_assert(alignof(AIgnoreGravityFallCollision) == 0x000010, "Wrong alignment on AIgnoreGravityFallCollision");
static_assert(sizeof(AIgnoreGravityFallCollision) == 0x0005C0, "Wrong size on AIgnoreGravityFallCollision");
static_assert(offsetof(AIgnoreGravityFallCollision, StaticBodyComponent) == 0x0005B0, "Member 'AIgnoreGravityFallCollision::StaticBodyComponent' has a wrong offset!");

// Class UnionRun.ItemAnimInstance
// 0x0000 (0x0370 - 0x0370)
#pragma pack(push, 0x1)
class alignas(0x10) UItemAnimInstance : public UAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAnimInstance">();
	}
	static class UItemAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UItemAnimInstance) == 0x000010, "Wrong alignment on UItemAnimInstance");
static_assert(sizeof(UItemAnimInstance) == 0x000370, "Wrong size on UItemAnimInstance");

// Class UnionRun.UnionMiscFunction
// 0x0000 (0x0028 - 0x0028)
class UUnionMiscFunction final : public UBlueprintFunctionLibrary
{
public:
	static bool ContainsLevel(const class UObject* WorldContextObject, const class FString& LevelName);
	static class FString GetCourseEditorStageAssetDir(const class UObject* WorldContextObject);
	static class FString GetStageAssetDir(const class UObject* WorldContextObject);
	static class FString GetStageAssetFilenameTrunk(const class UObject* WorldContextObject);
	static class UUnionComPathBinaryDataAsset* LoadComPathAssetByFilePath(const class UObject* WorldContextObject, const class FString& FilePath);
	static class UUnionBtCollisionBinaryAsset* LoadCourseCollisionAssetByFilePath(const class UObject* WorldContextObject, const class FString& FilePath);
	static class UUnionNavigationBinaryDataAsset* LoadCourseNavigationAssetByFilePath(const class UObject* WorldContextObject, const class FString& FilePath);
	static class UUnionRunPathBinaryDataAsset* LoadRunPathAssetByFilePath(const class UObject* WorldContextObject, const class FString& FilePath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionMiscFunction">();
	}
	static class UUnionMiscFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionMiscFunction>();
	}
};
static_assert(alignof(UUnionMiscFunction) == 0x000008, "Wrong alignment on UUnionMiscFunction");
static_assert(sizeof(UUnionMiscFunction) == 0x000028, "Wrong size on UUnionMiscFunction");

// Class UnionRun.SnakeAnimInstance
// 0x0000 (0x0370 - 0x0370)
class USnakeAnimInstance final : public UEnemyAnimInstance
{
public:
	bool                                          bIsIdle;                                           // 0x0368(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAttack;                                         // 0x0369(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDamage;                                         // 0x036A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36B[0x5];                                      // 0x036B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetIsAttack();
	bool GetIsDamage();
	bool GetIsIdle();
	void SetIsAttack(bool flag);
	void SetIsDamage(bool flag);
	void SetIsIdle(bool flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SnakeAnimInstance">();
	}
	static class USnakeAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USnakeAnimInstance>();
	}
};
static_assert(alignof(USnakeAnimInstance) == 0x000010, "Wrong alignment on USnakeAnimInstance");
static_assert(sizeof(USnakeAnimInstance) == 0x000370, "Wrong size on USnakeAnimInstance");
static_assert(offsetof(USnakeAnimInstance, bIsIdle) == 0x000368, "Member 'USnakeAnimInstance::bIsIdle' has a wrong offset!");
static_assert(offsetof(USnakeAnimInstance, bIsAttack) == 0x000369, "Member 'USnakeAnimInstance::bIsAttack' has a wrong offset!");
static_assert(offsetof(USnakeAnimInstance, bIsDamage) == 0x00036A, "Member 'USnakeAnimInstance::bIsDamage' has a wrong offset!");

// Class UnionRun.ItemBlackBombLv2Object
// 0x0000 (0x09C0 - 0x09C0)
class AItemBlackBombLv2Object : public AItemBlackBombBaseObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemBlackBombLv2Object">();
	}
	static class AItemBlackBombLv2Object* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemBlackBombLv2Object>();
	}
};
static_assert(alignof(AItemBlackBombLv2Object) == 0x000010, "Wrong alignment on AItemBlackBombLv2Object");
static_assert(sizeof(AItemBlackBombLv2Object) == 0x0009C0, "Wrong size on AItemBlackBombLv2Object");

// Class UnionRun.ItemBlackBombLv3Object
// 0x0000 (0x09C0 - 0x09C0)
class AItemBlackBombLv3Object : public AItemBlackBombBaseObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemBlackBombLv3Object">();
	}
	static class AItemBlackBombLv3Object* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemBlackBombLv3Object>();
	}
};
static_assert(alignof(AItemBlackBombLv3Object) == 0x000010, "Wrong alignment on AItemBlackBombLv3Object");
static_assert(sizeof(AItemBlackBombLv3Object) == 0x0009C0, "Wrong size on AItemBlackBombLv3Object");

// Class UnionRun.TravelRingFloorObject
// 0x0028 (0x02B8 - 0x0290)
class ATravelRingFloorObject final : public AActor
{
public:
	class USceneComponent*                        RootScene_;                                        // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              MainFloor;                                         // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              AccelFloor;                                        // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              AnimFloor_Front;                                   // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUnionStaticMeshComponent*              AnimFloor_Back;                                    // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TravelRingFloorObject">();
	}
	static class ATravelRingFloorObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATravelRingFloorObject>();
	}
};
static_assert(alignof(ATravelRingFloorObject) == 0x000008, "Wrong alignment on ATravelRingFloorObject");
static_assert(sizeof(ATravelRingFloorObject) == 0x0002B8, "Wrong size on ATravelRingFloorObject");
static_assert(offsetof(ATravelRingFloorObject, RootScene_) == 0x000290, "Member 'ATravelRingFloorObject::RootScene_' has a wrong offset!");
static_assert(offsetof(ATravelRingFloorObject, MainFloor) == 0x000298, "Member 'ATravelRingFloorObject::MainFloor' has a wrong offset!");
static_assert(offsetof(ATravelRingFloorObject, AccelFloor) == 0x0002A0, "Member 'ATravelRingFloorObject::AccelFloor' has a wrong offset!");
static_assert(offsetof(ATravelRingFloorObject, AnimFloor_Front) == 0x0002A8, "Member 'ATravelRingFloorObject::AnimFloor_Front' has a wrong offset!");
static_assert(offsetof(ATravelRingFloorObject, AnimFloor_Back) == 0x0002B0, "Member 'ATravelRingFloorObject::AnimFloor_Back' has a wrong offset!");

// Class UnionRun.ItemBodyCutObject
// 0x03E0 (0x0950 - 0x0570)
class AItemBodyCutObject : public AItemObjectBase
{
public:
	uint8                                         Pad_568[0x30];                                     // 0x0568(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        m_Root;                                            // 0x0598(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        m_meshRoot;                                        // 0x05A0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   m_staticMesh;                                      // 0x05A8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 m_skeltal;                                         // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTriggerComponent*                      m_trigger;                                         // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemStaticBodyComponent*               m_body;                                            // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_rollEffect;                                      // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_sparkEffect;                                     // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_breakEffect;                                     // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_throwStartSound;                                 // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_cuttingSound;                                    // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_hitCarSound;                                     // 0x05F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_revertCarSound;                                  // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGOCMovement*                           m_movement;                                        // 0x0600(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        m_leftToRightCutAnim;                              // 0x0608(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          m_hitCue;                                          // 0x0610(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          m_hitLocalCue;                                     // 0x0618(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          m_hitCuttingCue;                                   // 0x0620(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          m_hitCuttingLocalCue;                              // 0x0628(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_homingLifeTime;                                  // 0x0630(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_keepHeight;                                      // 0x0634(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRelativeMoveBackParameter             m_relativeMoveParamBack;                           // 0x0638(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         m_throwFrontMoveCorrectionDistance;                // 0x0650(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_ignoreSelfTime;                                  // 0x0654(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        m_straightSpeed;                                   // 0x0658(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        m_movePathSpeed;                                   // 0x0668(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        m_homingSpeed;                                     // 0x0678(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        m_backSpeed;                                       // 0x0688(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         m_changeSpeedTimeToPathMove;                       // 0x0698(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_changeSpeedTimeToHoming;                         // 0x069C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_toPathMaxTime;                                   // 0x06A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_targetForwardDistance;                           // 0x06A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_targetForwardDistanceTime;                       // 0x06A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_targetForwardRotateAddSpeed;                     // 0x06AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_targetForwardRotateMaxSpeed;                     // 0x06B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_fallSpeed;                                       // 0x06B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_fallSpeedMax;                                    // 0x06B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_fallSpeedOnPath;                                 // 0x06BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_fallSpeedMaxOnPath;                              // 0x06C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_homingDistance;                                  // 0x06C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_HomingDistancePath;                              // 0x06C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_moveTargetHorizontalTime;                        // 0x06CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_moveTargetVerticalTime;                          // 0x06D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_keepAroundTime;                                  // 0x06D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                m_TargetRacerOffset;                               // 0x06D8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                m_TargetRacerOffsetHoverboard;                     // 0x06F0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               m_cuttingReadyRotOffset;                           // 0x0708(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               m_cuttingRotOffset;                                // 0x0720(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               m_startModelRot;                                   // 0x0738(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         m_moveRotSpeed;                                    // 0x0750(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_beforeCuttingRotSpeed;                           // 0x0754(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_canPlayBreakEffectTimeAfterCut;                  // 0x0758(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_rollEffectActivateThreshold;                     // 0x075C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                m_sparkOffset;                                     // 0x0760(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                m_sparkOffsetHoverboard;                           // 0x0778(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_playRecoverEffectRemainTime;                     // 0x0790(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_debugSelfTarget;                                 // 0x0794(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_795[0x1BB];                                    // 0x0795(0x01BB)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTriggerConflict(const struct FHitTriggerInfo& HitInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemBodyCutObject">();
	}
	static class AItemBodyCutObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemBodyCutObject>();
	}
};
static_assert(alignof(AItemBodyCutObject) == 0x000010, "Wrong alignment on AItemBodyCutObject");
static_assert(sizeof(AItemBodyCutObject) == 0x000950, "Wrong size on AItemBodyCutObject");
static_assert(offsetof(AItemBodyCutObject, m_Root) == 0x000598, "Member 'AItemBodyCutObject::m_Root' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_meshRoot) == 0x0005A0, "Member 'AItemBodyCutObject::m_meshRoot' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_staticMesh) == 0x0005A8, "Member 'AItemBodyCutObject::m_staticMesh' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_skeltal) == 0x0005B0, "Member 'AItemBodyCutObject::m_skeltal' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_trigger) == 0x0005B8, "Member 'AItemBodyCutObject::m_trigger' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_body) == 0x0005C0, "Member 'AItemBodyCutObject::m_body' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_rollEffect) == 0x0005C8, "Member 'AItemBodyCutObject::m_rollEffect' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_sparkEffect) == 0x0005D0, "Member 'AItemBodyCutObject::m_sparkEffect' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_breakEffect) == 0x0005D8, "Member 'AItemBodyCutObject::m_breakEffect' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_throwStartSound) == 0x0005E0, "Member 'AItemBodyCutObject::m_throwStartSound' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_cuttingSound) == 0x0005E8, "Member 'AItemBodyCutObject::m_cuttingSound' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_hitCarSound) == 0x0005F0, "Member 'AItemBodyCutObject::m_hitCarSound' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_revertCarSound) == 0x0005F8, "Member 'AItemBodyCutObject::m_revertCarSound' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_movement) == 0x000600, "Member 'AItemBodyCutObject::m_movement' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_leftToRightCutAnim) == 0x000608, "Member 'AItemBodyCutObject::m_leftToRightCutAnim' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_hitCue) == 0x000610, "Member 'AItemBodyCutObject::m_hitCue' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_hitLocalCue) == 0x000618, "Member 'AItemBodyCutObject::m_hitLocalCue' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_hitCuttingCue) == 0x000620, "Member 'AItemBodyCutObject::m_hitCuttingCue' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_hitCuttingLocalCue) == 0x000628, "Member 'AItemBodyCutObject::m_hitCuttingLocalCue' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_homingLifeTime) == 0x000630, "Member 'AItemBodyCutObject::m_homingLifeTime' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_keepHeight) == 0x000634, "Member 'AItemBodyCutObject::m_keepHeight' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_relativeMoveParamBack) == 0x000638, "Member 'AItemBodyCutObject::m_relativeMoveParamBack' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_throwFrontMoveCorrectionDistance) == 0x000650, "Member 'AItemBodyCutObject::m_throwFrontMoveCorrectionDistance' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_ignoreSelfTime) == 0x000654, "Member 'AItemBodyCutObject::m_ignoreSelfTime' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_straightSpeed) == 0x000658, "Member 'AItemBodyCutObject::m_straightSpeed' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_movePathSpeed) == 0x000668, "Member 'AItemBodyCutObject::m_movePathSpeed' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_homingSpeed) == 0x000678, "Member 'AItemBodyCutObject::m_homingSpeed' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_backSpeed) == 0x000688, "Member 'AItemBodyCutObject::m_backSpeed' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_changeSpeedTimeToPathMove) == 0x000698, "Member 'AItemBodyCutObject::m_changeSpeedTimeToPathMove' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_changeSpeedTimeToHoming) == 0x00069C, "Member 'AItemBodyCutObject::m_changeSpeedTimeToHoming' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_toPathMaxTime) == 0x0006A0, "Member 'AItemBodyCutObject::m_toPathMaxTime' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_targetForwardDistance) == 0x0006A4, "Member 'AItemBodyCutObject::m_targetForwardDistance' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_targetForwardDistanceTime) == 0x0006A8, "Member 'AItemBodyCutObject::m_targetForwardDistanceTime' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_targetForwardRotateAddSpeed) == 0x0006AC, "Member 'AItemBodyCutObject::m_targetForwardRotateAddSpeed' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_targetForwardRotateMaxSpeed) == 0x0006B0, "Member 'AItemBodyCutObject::m_targetForwardRotateMaxSpeed' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_fallSpeed) == 0x0006B4, "Member 'AItemBodyCutObject::m_fallSpeed' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_fallSpeedMax) == 0x0006B8, "Member 'AItemBodyCutObject::m_fallSpeedMax' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_fallSpeedOnPath) == 0x0006BC, "Member 'AItemBodyCutObject::m_fallSpeedOnPath' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_fallSpeedMaxOnPath) == 0x0006C0, "Member 'AItemBodyCutObject::m_fallSpeedMaxOnPath' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_homingDistance) == 0x0006C4, "Member 'AItemBodyCutObject::m_homingDistance' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_HomingDistancePath) == 0x0006C8, "Member 'AItemBodyCutObject::m_HomingDistancePath' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_moveTargetHorizontalTime) == 0x0006CC, "Member 'AItemBodyCutObject::m_moveTargetHorizontalTime' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_moveTargetVerticalTime) == 0x0006D0, "Member 'AItemBodyCutObject::m_moveTargetVerticalTime' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_keepAroundTime) == 0x0006D4, "Member 'AItemBodyCutObject::m_keepAroundTime' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_TargetRacerOffset) == 0x0006D8, "Member 'AItemBodyCutObject::m_TargetRacerOffset' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_TargetRacerOffsetHoverboard) == 0x0006F0, "Member 'AItemBodyCutObject::m_TargetRacerOffsetHoverboard' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_cuttingReadyRotOffset) == 0x000708, "Member 'AItemBodyCutObject::m_cuttingReadyRotOffset' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_cuttingRotOffset) == 0x000720, "Member 'AItemBodyCutObject::m_cuttingRotOffset' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_startModelRot) == 0x000738, "Member 'AItemBodyCutObject::m_startModelRot' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_moveRotSpeed) == 0x000750, "Member 'AItemBodyCutObject::m_moveRotSpeed' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_beforeCuttingRotSpeed) == 0x000754, "Member 'AItemBodyCutObject::m_beforeCuttingRotSpeed' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_canPlayBreakEffectTimeAfterCut) == 0x000758, "Member 'AItemBodyCutObject::m_canPlayBreakEffectTimeAfterCut' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_rollEffectActivateThreshold) == 0x00075C, "Member 'AItemBodyCutObject::m_rollEffectActivateThreshold' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_sparkOffset) == 0x000760, "Member 'AItemBodyCutObject::m_sparkOffset' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_sparkOffsetHoverboard) == 0x000778, "Member 'AItemBodyCutObject::m_sparkOffsetHoverboard' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_playRecoverEffectRemainTime) == 0x000790, "Member 'AItemBodyCutObject::m_playRecoverEffectRemainTime' has a wrong offset!");
static_assert(offsetof(AItemBodyCutObject, m_debugSelfTarget) == 0x000794, "Member 'AItemBodyCutObject::m_debugSelfTarget' has a wrong offset!");

// Class UnionRun.ItemBoo
// 0x0040 (0x05F0 - 0x05B0)
class alignas(0x10) AItemBoo final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGimmickStaticBodyComponent*            StaticBodyComponent;                               // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionStaticMeshComponent*              StaticMeshComponent;                               // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionVATMeshComponent*                 VATMeshComponent;                                  // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERacerDamageType                              _DamageType;                                       // 0x05D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D1[0x7];                                      // 0x05D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitTriggerInfo>                HitInfos;                                          // 0x05D8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E8[0x8];                                      // 0x05E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemBoo">();
	}
	static class AItemBoo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemBoo>();
	}
};
static_assert(alignof(AItemBoo) == 0x000010, "Wrong alignment on AItemBoo");
static_assert(sizeof(AItemBoo) == 0x0005F0, "Wrong size on AItemBoo");
static_assert(offsetof(AItemBoo, StaticBodyComponent) == 0x0005B8, "Member 'AItemBoo::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AItemBoo, StaticMeshComponent) == 0x0005C0, "Member 'AItemBoo::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AItemBoo, VATMeshComponent) == 0x0005C8, "Member 'AItemBoo::VATMeshComponent' has a wrong offset!");
static_assert(offsetof(AItemBoo, _DamageType) == 0x0005D0, "Member 'AItemBoo::_DamageType' has a wrong offset!");
static_assert(offsetof(AItemBoo, HitInfos) == 0x0005D8, "Member 'AItemBoo::HitInfos' has a wrong offset!");

// Class UnionRun.SummonRingAnimInstance
// 0x0000 (0x0370 - 0x0370)
class USummonRingAnimInstance : public UAnimInstance
{
public:
	bool                                          bIsStart;                                          // 0x0368(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsExit;                                           // 0x0369(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36A[0x6];                                      // 0x036A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetIsExit();
	bool GetIsStart();
	void SetIsExit(bool flag);
	void SetIsStart(bool flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SummonRingAnimInstance">();
	}
	static class USummonRingAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USummonRingAnimInstance>();
	}
};
static_assert(alignof(USummonRingAnimInstance) == 0x000010, "Wrong alignment on USummonRingAnimInstance");
static_assert(sizeof(USummonRingAnimInstance) == 0x000370, "Wrong size on USummonRingAnimInstance");
static_assert(offsetof(USummonRingAnimInstance, bIsStart) == 0x000368, "Member 'USummonRingAnimInstance::bIsStart' has a wrong offset!");
static_assert(offsetof(USummonRingAnimInstance, bIsExit) == 0x000369, "Member 'USummonRingAnimInstance::bIsExit' has a wrong offset!");

// Class UnionRun.ItemBootDataObject
// 0x00A0 (0x0330 - 0x0290)
class AItemBootDataObject : public AActor
{
public:
	class UDataTable*                             ItemBootDataTable;                                 // 0x0290(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_298[0x98];                                     // 0x0298(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemBootDataObject">();
	}
	static class AItemBootDataObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemBootDataObject>();
	}
};
static_assert(alignof(AItemBootDataObject) == 0x000008, "Wrong alignment on AItemBootDataObject");
static_assert(sizeof(AItemBootDataObject) == 0x000330, "Wrong size on AItemBootDataObject");
static_assert(offsetof(AItemBootDataObject, ItemBootDataTable) == 0x000290, "Member 'AItemBootDataObject::ItemBootDataTable' has a wrong offset!");

// Class UnionRun.ItemBoxEffectObject
// 0x00E8 (0x0428 - 0x0340)
class AItemBoxEffectObject : public AUnionCourseObjectBase
{
public:
	TArray<class UNiagaraComponent*>              EffectNormals;                                     // 0x0340(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UNiagaraComponent*>              EffectDoubles;                                     // 0x0350(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UNiagaraComponent*>              EffectSpecials;                                    // 0x0360(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         EffectiveRange;                                    // 0x0370(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_374[0x4];                                      // 0x0374(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0378(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UNiagaraComponent*>              m_normalEffectPoolList;                            // 0x0380(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UNiagaraComponent*>              m_doubleEffectPoolList;                            // 0x0390(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UNiagaraComponent*>              m_specialEffectPoolList;                           // 0x03A0(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UNiagaraComponent*>              m_normalEffectActiveList;                          // 0x03B0(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UNiagaraComponent*>              m_doubleEffectActiveList;                          // 0x03C0(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UNiagaraComponent*>              m_specialEffectActiveList;                         // 0x03D0(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E0[0x48];                                     // 0x03E0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemBoxEffectObject">();
	}
	static class AItemBoxEffectObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemBoxEffectObject>();
	}
};
static_assert(alignof(AItemBoxEffectObject) == 0x000008, "Wrong alignment on AItemBoxEffectObject");
static_assert(sizeof(AItemBoxEffectObject) == 0x000428, "Wrong size on AItemBoxEffectObject");
static_assert(offsetof(AItemBoxEffectObject, EffectNormals) == 0x000340, "Member 'AItemBoxEffectObject::EffectNormals' has a wrong offset!");
static_assert(offsetof(AItemBoxEffectObject, EffectDoubles) == 0x000350, "Member 'AItemBoxEffectObject::EffectDoubles' has a wrong offset!");
static_assert(offsetof(AItemBoxEffectObject, EffectSpecials) == 0x000360, "Member 'AItemBoxEffectObject::EffectSpecials' has a wrong offset!");
static_assert(offsetof(AItemBoxEffectObject, EffectiveRange) == 0x000370, "Member 'AItemBoxEffectObject::EffectiveRange' has a wrong offset!");
static_assert(offsetof(AItemBoxEffectObject, DefaultSceneRoot) == 0x000378, "Member 'AItemBoxEffectObject::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AItemBoxEffectObject, m_normalEffectPoolList) == 0x000380, "Member 'AItemBoxEffectObject::m_normalEffectPoolList' has a wrong offset!");
static_assert(offsetof(AItemBoxEffectObject, m_doubleEffectPoolList) == 0x000390, "Member 'AItemBoxEffectObject::m_doubleEffectPoolList' has a wrong offset!");
static_assert(offsetof(AItemBoxEffectObject, m_specialEffectPoolList) == 0x0003A0, "Member 'AItemBoxEffectObject::m_specialEffectPoolList' has a wrong offset!");
static_assert(offsetof(AItemBoxEffectObject, m_normalEffectActiveList) == 0x0003B0, "Member 'AItemBoxEffectObject::m_normalEffectActiveList' has a wrong offset!");
static_assert(offsetof(AItemBoxEffectObject, m_doubleEffectActiveList) == 0x0003C0, "Member 'AItemBoxEffectObject::m_doubleEffectActiveList' has a wrong offset!");
static_assert(offsetof(AItemBoxEffectObject, m_specialEffectActiveList) == 0x0003D0, "Member 'AItemBoxEffectObject::m_specialEffectActiveList' has a wrong offset!");

// Class UnionRun.ItemBoxInstanceObject
// 0x0130 (0x0470 - 0x0340)
class alignas(0x10) AItemBoxInstanceObject : public AUnionCourseObjectBase
{
public:
	EDomainNumber                                 m_domainNumber;                                    // 0x0340(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_341[0x7];                                      // 0x0341(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHierarchicalInstancedStaticMeshComponent* m_hismNormal;                                   // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHierarchicalInstancedStaticMeshComponent* m_hismDouble;                                   // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHierarchicalInstancedStaticMeshComponent* m_hismSpecail;                                  // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHierarchicalInstancedStaticMeshComponent* m_hismIrregular;                                // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHierarchicalInstancedStaticMeshComponent* m_hismShadow;                                   // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHierarchicalInstancedStaticMeshComponent* m_hismNormalTT;                                 // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHierarchicalInstancedStaticMeshComponent* m_hismDoubleTT;                                 // 0x0378(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHierarchicalInstancedStaticMeshComponent* m_hismSpecailTT;                                // 0x0380(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHierarchicalInstancedStaticMeshComponent* m_hismExtnd09;                                  // 0x0388(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0390(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_398[0xD8];                                     // 0x0398(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemBoxInstanceObject">();
	}
	static class AItemBoxInstanceObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemBoxInstanceObject>();
	}
};
static_assert(alignof(AItemBoxInstanceObject) == 0x000010, "Wrong alignment on AItemBoxInstanceObject");
static_assert(sizeof(AItemBoxInstanceObject) == 0x000470, "Wrong size on AItemBoxInstanceObject");
static_assert(offsetof(AItemBoxInstanceObject, m_domainNumber) == 0x000340, "Member 'AItemBoxInstanceObject::m_domainNumber' has a wrong offset!");
static_assert(offsetof(AItemBoxInstanceObject, m_hismNormal) == 0x000348, "Member 'AItemBoxInstanceObject::m_hismNormal' has a wrong offset!");
static_assert(offsetof(AItemBoxInstanceObject, m_hismDouble) == 0x000350, "Member 'AItemBoxInstanceObject::m_hismDouble' has a wrong offset!");
static_assert(offsetof(AItemBoxInstanceObject, m_hismSpecail) == 0x000358, "Member 'AItemBoxInstanceObject::m_hismSpecail' has a wrong offset!");
static_assert(offsetof(AItemBoxInstanceObject, m_hismIrregular) == 0x000360, "Member 'AItemBoxInstanceObject::m_hismIrregular' has a wrong offset!");
static_assert(offsetof(AItemBoxInstanceObject, m_hismShadow) == 0x000368, "Member 'AItemBoxInstanceObject::m_hismShadow' has a wrong offset!");
static_assert(offsetof(AItemBoxInstanceObject, m_hismNormalTT) == 0x000370, "Member 'AItemBoxInstanceObject::m_hismNormalTT' has a wrong offset!");
static_assert(offsetof(AItemBoxInstanceObject, m_hismDoubleTT) == 0x000378, "Member 'AItemBoxInstanceObject::m_hismDoubleTT' has a wrong offset!");
static_assert(offsetof(AItemBoxInstanceObject, m_hismSpecailTT) == 0x000380, "Member 'AItemBoxInstanceObject::m_hismSpecailTT' has a wrong offset!");
static_assert(offsetof(AItemBoxInstanceObject, m_hismExtnd09) == 0x000388, "Member 'AItemBoxInstanceObject::m_hismExtnd09' has a wrong offset!");
static_assert(offsetof(AItemBoxInstanceObject, DefaultSceneRoot) == 0x000390, "Member 'AItemBoxInstanceObject::DefaultSceneRoot' has a wrong offset!");

// Class UnionRun.TrainAnimInstance
// 0x0000 (0x0370 - 0x0370)
class UTrainAnimInstance final : public UEnemyAnimInstance
{
public:
	bool                                          bIsMove;                                           // 0x0368(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDamage;                                         // 0x0369(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36A[0x6];                                      // 0x036A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetIsDamage();
	bool GetIsMove();
	void SetIsDamage(bool flag);
	void SetIsMove(bool flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrainAnimInstance">();
	}
	static class UTrainAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrainAnimInstance>();
	}
};
static_assert(alignof(UTrainAnimInstance) == 0x000010, "Wrong alignment on UTrainAnimInstance");
static_assert(sizeof(UTrainAnimInstance) == 0x000370, "Wrong size on UTrainAnimInstance");
static_assert(offsetof(UTrainAnimInstance, bIsMove) == 0x000368, "Member 'UTrainAnimInstance::bIsMove' has a wrong offset!");
static_assert(offsetof(UTrainAnimInstance, bIsDamage) == 0x000369, "Member 'UTrainAnimInstance::bIsDamage' has a wrong offset!");

// Class UnionRun.ItemCountDownComponent
// 0x0030 (0x00D0 - 0x00A0)
class UItemCountDownComponent final : public UActorComponent
{
public:
	class UCurveFloat*                            ItemCountDownAnimCurve;                            // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x28];                                      // 0x00A8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeCountDown(class UActorComponent* Component, bool bReset);
	void ResetTargetParameter(class UActorComponent* Component);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemCountDownComponent">();
	}
	static class UItemCountDownComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemCountDownComponent>();
	}
};
static_assert(alignof(UItemCountDownComponent) == 0x000008, "Wrong alignment on UItemCountDownComponent");
static_assert(sizeof(UItemCountDownComponent) == 0x0000D0, "Wrong size on UItemCountDownComponent");
static_assert(offsetof(UItemCountDownComponent, ItemCountDownAnimCurve) == 0x0000A0, "Member 'UItemCountDownComponent::ItemCountDownAnimCurve' has a wrong offset!");

// Class UnionRun.UnionCameraFocusOnTarget
// 0x0108 (0x03E0 - 0x02D8)
class alignas(0x10) AUnionCameraFocusOnTarget : public AUnionCameraBase
{
public:
	class USceneComponent*                        CameraRoot;                                        // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        FocusTarget;                                       // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 FocusTargetActor;                                  // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepCameraAbovePath;                              // 0x02F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F1[0x3];                                      // 0x02F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CheckUnderPathDistance;                            // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeepAbovePathMerge;                                // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlendCamera;                                      // 0x02FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FD[0x3];                                      // 0x02FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendCameraSpring_Stiffness;                       // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendCameraSpring_TargetVelocityAmount;            // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_308[0xD8];                                     // 0x0308(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionCameraFocusOnTarget">();
	}
	static class AUnionCameraFocusOnTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnionCameraFocusOnTarget>();
	}
};
static_assert(alignof(AUnionCameraFocusOnTarget) == 0x000010, "Wrong alignment on AUnionCameraFocusOnTarget");
static_assert(sizeof(AUnionCameraFocusOnTarget) == 0x0003E0, "Wrong size on AUnionCameraFocusOnTarget");
static_assert(offsetof(AUnionCameraFocusOnTarget, CameraRoot) == 0x0002D8, "Member 'AUnionCameraFocusOnTarget::CameraRoot' has a wrong offset!");
static_assert(offsetof(AUnionCameraFocusOnTarget, FocusTarget) == 0x0002E0, "Member 'AUnionCameraFocusOnTarget::FocusTarget' has a wrong offset!");
static_assert(offsetof(AUnionCameraFocusOnTarget, FocusTargetActor) == 0x0002E8, "Member 'AUnionCameraFocusOnTarget::FocusTargetActor' has a wrong offset!");
static_assert(offsetof(AUnionCameraFocusOnTarget, bKeepCameraAbovePath) == 0x0002F0, "Member 'AUnionCameraFocusOnTarget::bKeepCameraAbovePath' has a wrong offset!");
static_assert(offsetof(AUnionCameraFocusOnTarget, CheckUnderPathDistance) == 0x0002F4, "Member 'AUnionCameraFocusOnTarget::CheckUnderPathDistance' has a wrong offset!");
static_assert(offsetof(AUnionCameraFocusOnTarget, KeepAbovePathMerge) == 0x0002F8, "Member 'AUnionCameraFocusOnTarget::KeepAbovePathMerge' has a wrong offset!");
static_assert(offsetof(AUnionCameraFocusOnTarget, bBlendCamera) == 0x0002FC, "Member 'AUnionCameraFocusOnTarget::bBlendCamera' has a wrong offset!");
static_assert(offsetof(AUnionCameraFocusOnTarget, BlendCameraSpring_Stiffness) == 0x000300, "Member 'AUnionCameraFocusOnTarget::BlendCameraSpring_Stiffness' has a wrong offset!");
static_assert(offsetof(AUnionCameraFocusOnTarget, BlendCameraSpring_TargetVelocityAmount) == 0x000304, "Member 'AUnionCameraFocusOnTarget::BlendCameraSpring_TargetVelocityAmount' has a wrong offset!");

// Class UnionRun.ItemDarkChaoAnimInstance
// 0x0010 (0x0380 - 0x0370)
class UItemDarkChaoAnimInstance : public UItemAnimInstance
{
public:
	bool                                          bIsIdle;                                           // 0x0368(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSteal;                                          // 0x0369(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsGift;                                           // 0x036A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsUse;                                            // 0x036B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsThrow;                                          // 0x036C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsThrowHit;                                       // 0x036D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsThrowMissFall;                                  // 0x036E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsThrowMissBound;                                 // 0x036F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowAnimController;                               // 0x0370(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_374[0xC];                                      // 0x0374(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetIsGift();
	bool GetIsIdle();
	bool GetIsSteal();
	bool GetIsThrow();
	bool GetIsThrowHit();
	bool GetIsThrowMissBound();
	bool GetIsThrowMissFall();
	bool GetIsUse();
	float GetThrowAnimController();
	void SetIsGift(bool flag);
	void SetIsIdle(bool flag);
	void SetIsSteal(bool flag);
	void SetIsThrow(bool flag);
	void SetIsThrowHit(bool flag);
	void SetIsThrowMissBound(bool flag);
	void SetIsThrowMissFall(bool flag);
	void SetIsUse(bool flag);
	void SetThrowAnimController(float NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemDarkChaoAnimInstance">();
	}
	static class UItemDarkChaoAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemDarkChaoAnimInstance>();
	}
};
static_assert(alignof(UItemDarkChaoAnimInstance) == 0x000010, "Wrong alignment on UItemDarkChaoAnimInstance");
static_assert(sizeof(UItemDarkChaoAnimInstance) == 0x000380, "Wrong size on UItemDarkChaoAnimInstance");
static_assert(offsetof(UItemDarkChaoAnimInstance, bIsIdle) == 0x000368, "Member 'UItemDarkChaoAnimInstance::bIsIdle' has a wrong offset!");
static_assert(offsetof(UItemDarkChaoAnimInstance, bIsSteal) == 0x000369, "Member 'UItemDarkChaoAnimInstance::bIsSteal' has a wrong offset!");
static_assert(offsetof(UItemDarkChaoAnimInstance, bIsGift) == 0x00036A, "Member 'UItemDarkChaoAnimInstance::bIsGift' has a wrong offset!");
static_assert(offsetof(UItemDarkChaoAnimInstance, bIsUse) == 0x00036B, "Member 'UItemDarkChaoAnimInstance::bIsUse' has a wrong offset!");
static_assert(offsetof(UItemDarkChaoAnimInstance, bIsThrow) == 0x00036C, "Member 'UItemDarkChaoAnimInstance::bIsThrow' has a wrong offset!");
static_assert(offsetof(UItemDarkChaoAnimInstance, bIsThrowHit) == 0x00036D, "Member 'UItemDarkChaoAnimInstance::bIsThrowHit' has a wrong offset!");
static_assert(offsetof(UItemDarkChaoAnimInstance, bIsThrowMissFall) == 0x00036E, "Member 'UItemDarkChaoAnimInstance::bIsThrowMissFall' has a wrong offset!");
static_assert(offsetof(UItemDarkChaoAnimInstance, bIsThrowMissBound) == 0x00036F, "Member 'UItemDarkChaoAnimInstance::bIsThrowMissBound' has a wrong offset!");
static_assert(offsetof(UItemDarkChaoAnimInstance, ThrowAnimController) == 0x000370, "Member 'UItemDarkChaoAnimInstance::ThrowAnimController' has a wrong offset!");

// Class UnionRun.ItemDarkChaoObject
// 0x0280 (0x07F0 - 0x0570)
class AItemDarkChaoObject : public AItemObjectBase
{
public:
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Root;                                              // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        ChaoRoot;                                          // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChildActorComponent*                   ChildActorRing;                                    // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemStaticBodyComponent*               DarckChaoAbsorbStaticBody;                         // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MeshModelScaleValue;                               // 0x0590(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionSkeletalMeshComponent*            m_SkeletalMeshComponent;                           // 0x05A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              m_ItemBoxMeshComponent;                            // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      ItemboxHitNiagaraComponent;                        // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    ItemboxHitSoundComponent;                          // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplayHudAllTime;                                 // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5CC[0x4];                                      // 0x05CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionAtomComponent*                    DarckChaoThrowSoundComponent;                      // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    DarckChaoLearveSoundComponent;                     // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RingAppearTime;                                    // 0x05E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DarkChaoMoveTime;                                  // 0x05E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RingDisappearTime;                                 // 0x05E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DarkChaoStealAlertTime;                            // 0x05EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DarckChaoStealCompleteTime;                        // 0x05F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DarckChaoStealTime;                                // 0x05F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeroChaoGiftTime;                                  // 0x05F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeroChaoDisappearTime;                             // 0x05FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DarckChaoGiftTime;                                 // 0x0600(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DarckChaoGiftCompleteTime;                         // 0x0604(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisappearTime;                                     // 0x0608(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetSelectFaliedRingNum;                         // 0x060C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemUserPerfomanceAllTime;                         // 0x0610(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemUserDamageTime;                                // 0x0614(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OtherPlayerPerfomanceAllTime;                      // 0x0618(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OtherPlayerDamageTime;                             // 0x061C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DarkChaoRingAlertTime;                             // 0x0620(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_ringMaxSize;                                     // 0x0624(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_appearTime;                                      // 0x0628(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_ringWaitTime;                                    // 0x062C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_disappearTime;                                   // 0x0630(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_634[0x4];                                      // 0x0634(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           m_appearCurve;                                     // 0x0638(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMachineFormOffset;                             // 0x0640(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_641[0x7];                                      // 0x0641(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MonsterTruckOffset;                                // 0x0648(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                YellowDrillOffset;                                 // 0x0660(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_678[0x170];                                    // 0x0678(0x0170)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemDarkChaoAnimInstance*              AnimInstance;                                      // 0x07E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void PlayLeaveSound();
	void PlayThrowSound();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemDarkChaoObject">();
	}
	static class AItemDarkChaoObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemDarkChaoObject>();
	}
};
static_assert(alignof(AItemDarkChaoObject) == 0x000010, "Wrong alignment on AItemDarkChaoObject");
static_assert(sizeof(AItemDarkChaoObject) == 0x0007F0, "Wrong size on AItemDarkChaoObject");
static_assert(offsetof(AItemDarkChaoObject, Root) == 0x000570, "Member 'AItemDarkChaoObject::Root' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, ChaoRoot) == 0x000578, "Member 'AItemDarkChaoObject::ChaoRoot' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, ChildActorRing) == 0x000580, "Member 'AItemDarkChaoObject::ChildActorRing' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, DarckChaoAbsorbStaticBody) == 0x000588, "Member 'AItemDarkChaoObject::DarckChaoAbsorbStaticBody' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, MeshModelScaleValue) == 0x000590, "Member 'AItemDarkChaoObject::MeshModelScaleValue' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, m_SkeletalMeshComponent) == 0x0005A8, "Member 'AItemDarkChaoObject::m_SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, m_ItemBoxMeshComponent) == 0x0005B0, "Member 'AItemDarkChaoObject::m_ItemBoxMeshComponent' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, ItemboxHitNiagaraComponent) == 0x0005B8, "Member 'AItemDarkChaoObject::ItemboxHitNiagaraComponent' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, ItemboxHitSoundComponent) == 0x0005C0, "Member 'AItemDarkChaoObject::ItemboxHitSoundComponent' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, DisplayHudAllTime) == 0x0005C8, "Member 'AItemDarkChaoObject::DisplayHudAllTime' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, DarckChaoThrowSoundComponent) == 0x0005D0, "Member 'AItemDarkChaoObject::DarckChaoThrowSoundComponent' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, DarckChaoLearveSoundComponent) == 0x0005D8, "Member 'AItemDarkChaoObject::DarckChaoLearveSoundComponent' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, RingAppearTime) == 0x0005E0, "Member 'AItemDarkChaoObject::RingAppearTime' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, DarkChaoMoveTime) == 0x0005E4, "Member 'AItemDarkChaoObject::DarkChaoMoveTime' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, RingDisappearTime) == 0x0005E8, "Member 'AItemDarkChaoObject::RingDisappearTime' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, DarkChaoStealAlertTime) == 0x0005EC, "Member 'AItemDarkChaoObject::DarkChaoStealAlertTime' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, DarckChaoStealCompleteTime) == 0x0005F0, "Member 'AItemDarkChaoObject::DarckChaoStealCompleteTime' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, DarckChaoStealTime) == 0x0005F4, "Member 'AItemDarkChaoObject::DarckChaoStealTime' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, HeroChaoGiftTime) == 0x0005F8, "Member 'AItemDarkChaoObject::HeroChaoGiftTime' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, HeroChaoDisappearTime) == 0x0005FC, "Member 'AItemDarkChaoObject::HeroChaoDisappearTime' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, DarckChaoGiftTime) == 0x000600, "Member 'AItemDarkChaoObject::DarckChaoGiftTime' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, DarckChaoGiftCompleteTime) == 0x000604, "Member 'AItemDarkChaoObject::DarckChaoGiftCompleteTime' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, DisappearTime) == 0x000608, "Member 'AItemDarkChaoObject::DisappearTime' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, TargetSelectFaliedRingNum) == 0x00060C, "Member 'AItemDarkChaoObject::TargetSelectFaliedRingNum' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, ItemUserPerfomanceAllTime) == 0x000610, "Member 'AItemDarkChaoObject::ItemUserPerfomanceAllTime' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, ItemUserDamageTime) == 0x000614, "Member 'AItemDarkChaoObject::ItemUserDamageTime' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, OtherPlayerPerfomanceAllTime) == 0x000618, "Member 'AItemDarkChaoObject::OtherPlayerPerfomanceAllTime' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, OtherPlayerDamageTime) == 0x00061C, "Member 'AItemDarkChaoObject::OtherPlayerDamageTime' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, DarkChaoRingAlertTime) == 0x000620, "Member 'AItemDarkChaoObject::DarkChaoRingAlertTime' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, m_ringMaxSize) == 0x000624, "Member 'AItemDarkChaoObject::m_ringMaxSize' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, m_appearTime) == 0x000628, "Member 'AItemDarkChaoObject::m_appearTime' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, m_ringWaitTime) == 0x00062C, "Member 'AItemDarkChaoObject::m_ringWaitTime' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, m_disappearTime) == 0x000630, "Member 'AItemDarkChaoObject::m_disappearTime' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, m_appearCurve) == 0x000638, "Member 'AItemDarkChaoObject::m_appearCurve' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, bUseMachineFormOffset) == 0x000640, "Member 'AItemDarkChaoObject::bUseMachineFormOffset' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, MonsterTruckOffset) == 0x000648, "Member 'AItemDarkChaoObject::MonsterTruckOffset' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, YellowDrillOffset) == 0x000660, "Member 'AItemDarkChaoObject::YellowDrillOffset' has a wrong offset!");
static_assert(offsetof(AItemDarkChaoObject, AnimInstance) == 0x0007E8, "Member 'AItemDarkChaoObject::AnimInstance' has a wrong offset!");

// Class UnionRun.TrexAnimInstance
// 0x0000 (0x0370 - 0x0370)
class UTrexAnimInstance final : public UEnemyAnimInstance
{
public:
	bool                                          bIsMove;                                           // 0x0368(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTurn;                                           // 0x0369(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDamage;                                         // 0x036A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAttack;                                         // 0x036B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsTurnEnd;                                        // 0x036C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36D[0x3];                                      // 0x036D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetIsAttack();
	bool GetIsDamage();
	bool GetIsMove();
	bool GetIsTurn();
	bool GetIsTurnEnd();
	void SetIsAttack(bool flag);
	void SetIsDamage(bool flag);
	void SetIsMove(bool flag);
	void SetIsTurn(bool flag);
	void SetIsTurnEnd(bool flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrexAnimInstance">();
	}
	static class UTrexAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrexAnimInstance>();
	}
};
static_assert(alignof(UTrexAnimInstance) == 0x000010, "Wrong alignment on UTrexAnimInstance");
static_assert(sizeof(UTrexAnimInstance) == 0x000370, "Wrong size on UTrexAnimInstance");
static_assert(offsetof(UTrexAnimInstance, bIsMove) == 0x000368, "Member 'UTrexAnimInstance::bIsMove' has a wrong offset!");
static_assert(offsetof(UTrexAnimInstance, bIsTurn) == 0x000369, "Member 'UTrexAnimInstance::bIsTurn' has a wrong offset!");
static_assert(offsetof(UTrexAnimInstance, bIsDamage) == 0x00036A, "Member 'UTrexAnimInstance::bIsDamage' has a wrong offset!");
static_assert(offsetof(UTrexAnimInstance, bIsAttack) == 0x00036B, "Member 'UTrexAnimInstance::bIsAttack' has a wrong offset!");
static_assert(offsetof(UTrexAnimInstance, bIsTurnEnd) == 0x00036C, "Member 'UTrexAnimInstance::bIsTurnEnd' has a wrong offset!");

// Class UnionRun.ItemExtnd09Object
// 0x0260 (0x07D0 - 0x0570)
class AItemExtnd09Object final : public AItemObjectBase
{
public:
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Root;                                              // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   BodyMeshComponent;                                 // 0x0578(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGOCMovement*                           Movement;                                          // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemCountDownComponent*                CountDown;                                         // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    AttackSound;                                       // 0x0590(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    ChargeAttackSound;                                 // 0x0598(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    ChargeStartSound;                                  // 0x05A0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    ChargeEndSound;                                    // 0x05A8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      ChargeStartEffect;                                 // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      ChargeEndEffect;                                   // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      AttackEffect;                                      // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      ChargeAttackEffect;                                // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      DisappearEffect;                                   // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlotEndDelayTime;                                  // 0x05D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxFireNum;                                        // 0x05DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireInterval;                                      // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxAliveNum;                                       // 0x05E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChargeStartTime;                                   // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChargingTime;                                      // 0x05EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ProjectileOffsetNormal;                            // 0x05F0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ProjectileOffsetsSpecial;                          // 0x0608(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireMotionTime;                                    // 0x0620(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_624[0x4];                                      // 0x0624(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            FireMotionCurveVertical;                           // 0x0628(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FireMotionCurveHorizontal;                         // 0x0630(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AItemExtnd09Projectile>     ProjectileNormalClass;                             // 0x0638(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AItemExtnd09Projectile>     ProjectileChargeClass;                             // 0x0640(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FExtnd09SoundCueAsset                  SoundCueLocal;                                     // 0x0648(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FExtnd09SoundCueAsset                  SoundCueOther;                                     // 0x0658(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_668[0x138];                                    // 0x0668(0x0138)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AItemExtnd09Projectile*>         m_projectileNormals;                               // 0x07A0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class AItemExtnd09Projectile*                 m_projectileCharge;                                // 0x07B0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7B8[0x18];                                     // 0x07B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemExtnd09Object">();
	}
	static class AItemExtnd09Object* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemExtnd09Object>();
	}
};
static_assert(alignof(AItemExtnd09Object) == 0x000010, "Wrong alignment on AItemExtnd09Object");
static_assert(sizeof(AItemExtnd09Object) == 0x0007D0, "Wrong size on AItemExtnd09Object");
static_assert(offsetof(AItemExtnd09Object, Root) == 0x000570, "Member 'AItemExtnd09Object::Root' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, BodyMeshComponent) == 0x000578, "Member 'AItemExtnd09Object::BodyMeshComponent' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, Movement) == 0x000580, "Member 'AItemExtnd09Object::Movement' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, CountDown) == 0x000588, "Member 'AItemExtnd09Object::CountDown' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, AttackSound) == 0x000590, "Member 'AItemExtnd09Object::AttackSound' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, ChargeAttackSound) == 0x000598, "Member 'AItemExtnd09Object::ChargeAttackSound' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, ChargeStartSound) == 0x0005A0, "Member 'AItemExtnd09Object::ChargeStartSound' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, ChargeEndSound) == 0x0005A8, "Member 'AItemExtnd09Object::ChargeEndSound' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, ChargeStartEffect) == 0x0005B0, "Member 'AItemExtnd09Object::ChargeStartEffect' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, ChargeEndEffect) == 0x0005B8, "Member 'AItemExtnd09Object::ChargeEndEffect' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, AttackEffect) == 0x0005C0, "Member 'AItemExtnd09Object::AttackEffect' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, ChargeAttackEffect) == 0x0005C8, "Member 'AItemExtnd09Object::ChargeAttackEffect' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, DisappearEffect) == 0x0005D0, "Member 'AItemExtnd09Object::DisappearEffect' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, SlotEndDelayTime) == 0x0005D8, "Member 'AItemExtnd09Object::SlotEndDelayTime' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, MaxFireNum) == 0x0005DC, "Member 'AItemExtnd09Object::MaxFireNum' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, FireInterval) == 0x0005E0, "Member 'AItemExtnd09Object::FireInterval' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, MaxAliveNum) == 0x0005E4, "Member 'AItemExtnd09Object::MaxAliveNum' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, ChargeStartTime) == 0x0005E8, "Member 'AItemExtnd09Object::ChargeStartTime' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, ChargingTime) == 0x0005EC, "Member 'AItemExtnd09Object::ChargingTime' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, ProjectileOffsetNormal) == 0x0005F0, "Member 'AItemExtnd09Object::ProjectileOffsetNormal' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, ProjectileOffsetsSpecial) == 0x000608, "Member 'AItemExtnd09Object::ProjectileOffsetsSpecial' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, FireMotionTime) == 0x000620, "Member 'AItemExtnd09Object::FireMotionTime' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, FireMotionCurveVertical) == 0x000628, "Member 'AItemExtnd09Object::FireMotionCurveVertical' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, FireMotionCurveHorizontal) == 0x000630, "Member 'AItemExtnd09Object::FireMotionCurveHorizontal' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, ProjectileNormalClass) == 0x000638, "Member 'AItemExtnd09Object::ProjectileNormalClass' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, ProjectileChargeClass) == 0x000640, "Member 'AItemExtnd09Object::ProjectileChargeClass' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, SoundCueLocal) == 0x000648, "Member 'AItemExtnd09Object::SoundCueLocal' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, SoundCueOther) == 0x000658, "Member 'AItemExtnd09Object::SoundCueOther' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, m_projectileNormals) == 0x0007A0, "Member 'AItemExtnd09Object::m_projectileNormals' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Object, m_projectileCharge) == 0x0007B0, "Member 'AItemExtnd09Object::m_projectileCharge' has a wrong offset!");

// Class UnionRun.ItemExtnd09Projectile
// 0x0370 (0x0600 - 0x0290)
class alignas(0x10) AItemExtnd09Projectile final : public AActor
{
public:
	uint8                                         Pad_290[0x30];                                     // 0x0290(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGOCMovement*                           Movement;                                          // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTriggerComponent*                      HitTrigger;                                        // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemStaticBodyComponent*               StaticBody;                                        // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      HitEffect;                                         // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      GuardEffect;                                       // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    HitSound;                                          // 0x02F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    GuardSound;                                        // 0x02F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChargeType;                                       // 0x0300(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_301[0x3];                                      // 0x0301(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActiveDelayTime;                                   // 0x0308(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActiveDelayTimeSpecial;                            // 0x030C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HolderInvincibleTime;                              // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VioletVoidAbsorbTargetScale;                       // 0x0318(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightAbovePath;                                   // 0x0330(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrontMoveCorrectionDistance;                       // 0x0334(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrontMoveCorrectionDistanceSpecial;                // 0x0338(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveControllerMeshRadius;                          // 0x033C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        ForwardSpeed;                                      // 0x0340(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        FallSpeed;                                         // 0x0350(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        FallAcceleration;                                  // 0x0360(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        AttackFailBounceSpeed;                             // 0x0370(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AttackFailedBounceAngle;                           // 0x0380(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackFailedDisappearStartTime;                    // 0x0384(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackFailedDisappearEndTime;                      // 0x0388(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RacerIndex;                                        // 0x038C(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDomainNumber                                 DomainNumber;                                      // 0x0390(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpecialHolder;                                    // 0x0391(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_392[0x26E];                                    // 0x0392(0x026E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTriggerColliderConflict(const struct FHitTriggerInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemExtnd09Projectile">();
	}
	static class AItemExtnd09Projectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemExtnd09Projectile>();
	}
};
static_assert(alignof(AItemExtnd09Projectile) == 0x000010, "Wrong alignment on AItemExtnd09Projectile");
static_assert(sizeof(AItemExtnd09Projectile) == 0x000600, "Wrong size on AItemExtnd09Projectile");
static_assert(offsetof(AItemExtnd09Projectile, StaticMesh) == 0x0002C0, "Member 'AItemExtnd09Projectile::StaticMesh' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Projectile, Movement) == 0x0002C8, "Member 'AItemExtnd09Projectile::Movement' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Projectile, HitTrigger) == 0x0002D0, "Member 'AItemExtnd09Projectile::HitTrigger' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Projectile, StaticBody) == 0x0002D8, "Member 'AItemExtnd09Projectile::StaticBody' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Projectile, HitEffect) == 0x0002E0, "Member 'AItemExtnd09Projectile::HitEffect' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Projectile, GuardEffect) == 0x0002E8, "Member 'AItemExtnd09Projectile::GuardEffect' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Projectile, HitSound) == 0x0002F0, "Member 'AItemExtnd09Projectile::HitSound' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Projectile, GuardSound) == 0x0002F8, "Member 'AItemExtnd09Projectile::GuardSound' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Projectile, bChargeType) == 0x000300, "Member 'AItemExtnd09Projectile::bChargeType' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Projectile, LifeTime) == 0x000304, "Member 'AItemExtnd09Projectile::LifeTime' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Projectile, ActiveDelayTime) == 0x000308, "Member 'AItemExtnd09Projectile::ActiveDelayTime' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Projectile, ActiveDelayTimeSpecial) == 0x00030C, "Member 'AItemExtnd09Projectile::ActiveDelayTimeSpecial' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Projectile, HolderInvincibleTime) == 0x000310, "Member 'AItemExtnd09Projectile::HolderInvincibleTime' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Projectile, VioletVoidAbsorbTargetScale) == 0x000318, "Member 'AItemExtnd09Projectile::VioletVoidAbsorbTargetScale' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Projectile, HeightAbovePath) == 0x000330, "Member 'AItemExtnd09Projectile::HeightAbovePath' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Projectile, FrontMoveCorrectionDistance) == 0x000334, "Member 'AItemExtnd09Projectile::FrontMoveCorrectionDistance' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Projectile, FrontMoveCorrectionDistanceSpecial) == 0x000338, "Member 'AItemExtnd09Projectile::FrontMoveCorrectionDistanceSpecial' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Projectile, MoveControllerMeshRadius) == 0x00033C, "Member 'AItemExtnd09Projectile::MoveControllerMeshRadius' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Projectile, ForwardSpeed) == 0x000340, "Member 'AItemExtnd09Projectile::ForwardSpeed' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Projectile, FallSpeed) == 0x000350, "Member 'AItemExtnd09Projectile::FallSpeed' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Projectile, FallAcceleration) == 0x000360, "Member 'AItemExtnd09Projectile::FallAcceleration' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Projectile, AttackFailBounceSpeed) == 0x000370, "Member 'AItemExtnd09Projectile::AttackFailBounceSpeed' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Projectile, AttackFailedBounceAngle) == 0x000380, "Member 'AItemExtnd09Projectile::AttackFailedBounceAngle' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Projectile, AttackFailedDisappearStartTime) == 0x000384, "Member 'AItemExtnd09Projectile::AttackFailedDisappearStartTime' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Projectile, AttackFailedDisappearEndTime) == 0x000388, "Member 'AItemExtnd09Projectile::AttackFailedDisappearEndTime' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Projectile, RacerIndex) == 0x00038C, "Member 'AItemExtnd09Projectile::RacerIndex' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Projectile, DomainNumber) == 0x000390, "Member 'AItemExtnd09Projectile::DomainNumber' has a wrong offset!");
static_assert(offsetof(AItemExtnd09Projectile, bSpecialHolder) == 0x000391, "Member 'AItemExtnd09Projectile::bSpecialHolder' has a wrong offset!");

// Class UnionRun.TireMark
// 0x9BF0 (0xA190 - 0x05A0)
class UTireMark final : public UProceduralMeshComponentEx
{
public:
	TArray<class UMaterialInterface*>             MaterialInterfaces_;                               // 0x05A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B0[0x9BE0];                                   // 0x05B0(0x9BE0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddPoint3D(const struct FVector& Position, const struct FVector& Normal, const struct FVector& Side, float Density, const struct FColor& Color, const struct FVector2D& OffsetUV);
	class UMaterialInterface* GetTireMarkMaterial();
	void SetTireMarkMaterial(class UMaterialInterface* MaterialInterface);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TireMark">();
	}
	static class UTireMark* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTireMark>();
	}
};
static_assert(alignof(UTireMark) == 0x000010, "Wrong alignment on UTireMark");
static_assert(sizeof(UTireMark) == 0x00A190, "Wrong size on UTireMark");
static_assert(offsetof(UTireMark, MaterialInterfaces_) == 0x0005A0, "Member 'UTireMark::MaterialInterfaces_' has a wrong offset!");

// Class UnionRun.ItemHomingPunchObject
// 0x0400 (0x0970 - 0x0570)
class AItemHomingPunchObject : public AItemObjectBase
{
public:
	uint8                                         Pad_568[0x30];                                     // 0x0568(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        m_DefaultSceneRoot;                                // 0x0598(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   m_staticMeshComponent;                             // 0x05A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemStaticBodyComponent*               m_staticBody;                                      // 0x05A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTriggerComponent*                      m_hitTrigger;                                      // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGOCMovement*                           m_movement;                                        // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_NiagaraJet;                                      // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_NiagaraHit;                                      // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_MoveSoundUnionAtom;                              // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_HitSoundUnionAtom;                               // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_lifeTime;                                        // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_MissTargetTime;                                  // 0x05E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_flyHeightUE;                                     // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        m_StartMoveSpeed;                                  // 0x05EC(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        m_PathMoveSpeed;                                   // 0x05FC(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        m_homingSpeed;                                     // 0x060C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        m_BackMoveSpeed;                                   // 0x061C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         m_ChangeToPathMoveTimer;                           // 0x062C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_ChangeToHomingTimer;                             // 0x0630(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_MoveToPathTime;                                  // 0x0634(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_targetForwardDistance;                           // 0x0638(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_targetForwardDistanceTime;                       // 0x063C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_targetForwardRotateAddSpeed;                     // 0x0640(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_targetForwardRotateMaxSpeed;                     // 0x0644(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_FallAcceleration;                                // 0x0648(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_MaxFallSpeed;                                    // 0x064C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_FallAccelerationOnPath;                          // 0x0650(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_MaxFallSpeedOnPath;                              // 0x0654(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_homingDistance;                                  // 0x0658(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_HomingDistancePath;                              // 0x065C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_collisionInvalidTime;                            // 0x0660(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRelativeMoveBackParameter             m_relativeMoveParamBack;                           // 0x0664(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_67C[0x2F4];                                    // 0x067C(0x02F4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EventHitRacer(int32 HitRacerIndex);
	void OnPlayDamegeSound(ESoundPan SoundPan);
	void OnPlayImpactSound();
	void OnTriggerColliderConflict(const struct FHitTriggerInfo& HitInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemHomingPunchObject">();
	}
	static class AItemHomingPunchObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemHomingPunchObject>();
	}
};
static_assert(alignof(AItemHomingPunchObject) == 0x000010, "Wrong alignment on AItemHomingPunchObject");
static_assert(sizeof(AItemHomingPunchObject) == 0x000970, "Wrong size on AItemHomingPunchObject");
static_assert(offsetof(AItemHomingPunchObject, m_DefaultSceneRoot) == 0x000598, "Member 'AItemHomingPunchObject::m_DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_staticMeshComponent) == 0x0005A0, "Member 'AItemHomingPunchObject::m_staticMeshComponent' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_staticBody) == 0x0005A8, "Member 'AItemHomingPunchObject::m_staticBody' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_hitTrigger) == 0x0005B0, "Member 'AItemHomingPunchObject::m_hitTrigger' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_movement) == 0x0005B8, "Member 'AItemHomingPunchObject::m_movement' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_NiagaraJet) == 0x0005C0, "Member 'AItemHomingPunchObject::m_NiagaraJet' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_NiagaraHit) == 0x0005C8, "Member 'AItemHomingPunchObject::m_NiagaraHit' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_MoveSoundUnionAtom) == 0x0005D0, "Member 'AItemHomingPunchObject::m_MoveSoundUnionAtom' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_HitSoundUnionAtom) == 0x0005D8, "Member 'AItemHomingPunchObject::m_HitSoundUnionAtom' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_lifeTime) == 0x0005E0, "Member 'AItemHomingPunchObject::m_lifeTime' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_MissTargetTime) == 0x0005E4, "Member 'AItemHomingPunchObject::m_MissTargetTime' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_flyHeightUE) == 0x0005E8, "Member 'AItemHomingPunchObject::m_flyHeightUE' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_StartMoveSpeed) == 0x0005EC, "Member 'AItemHomingPunchObject::m_StartMoveSpeed' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_PathMoveSpeed) == 0x0005FC, "Member 'AItemHomingPunchObject::m_PathMoveSpeed' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_homingSpeed) == 0x00060C, "Member 'AItemHomingPunchObject::m_homingSpeed' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_BackMoveSpeed) == 0x00061C, "Member 'AItemHomingPunchObject::m_BackMoveSpeed' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_ChangeToPathMoveTimer) == 0x00062C, "Member 'AItemHomingPunchObject::m_ChangeToPathMoveTimer' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_ChangeToHomingTimer) == 0x000630, "Member 'AItemHomingPunchObject::m_ChangeToHomingTimer' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_MoveToPathTime) == 0x000634, "Member 'AItemHomingPunchObject::m_MoveToPathTime' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_targetForwardDistance) == 0x000638, "Member 'AItemHomingPunchObject::m_targetForwardDistance' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_targetForwardDistanceTime) == 0x00063C, "Member 'AItemHomingPunchObject::m_targetForwardDistanceTime' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_targetForwardRotateAddSpeed) == 0x000640, "Member 'AItemHomingPunchObject::m_targetForwardRotateAddSpeed' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_targetForwardRotateMaxSpeed) == 0x000644, "Member 'AItemHomingPunchObject::m_targetForwardRotateMaxSpeed' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_FallAcceleration) == 0x000648, "Member 'AItemHomingPunchObject::m_FallAcceleration' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_MaxFallSpeed) == 0x00064C, "Member 'AItemHomingPunchObject::m_MaxFallSpeed' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_FallAccelerationOnPath) == 0x000650, "Member 'AItemHomingPunchObject::m_FallAccelerationOnPath' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_MaxFallSpeedOnPath) == 0x000654, "Member 'AItemHomingPunchObject::m_MaxFallSpeedOnPath' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_homingDistance) == 0x000658, "Member 'AItemHomingPunchObject::m_homingDistance' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_HomingDistancePath) == 0x00065C, "Member 'AItemHomingPunchObject::m_HomingDistancePath' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_collisionInvalidTime) == 0x000660, "Member 'AItemHomingPunchObject::m_collisionInvalidTime' has a wrong offset!");
static_assert(offsetof(AItemHomingPunchObject, m_relativeMoveParamBack) == 0x000664, "Member 'AItemHomingPunchObject::m_relativeMoveParamBack' has a wrong offset!");

// Class UnionRun.ItemJadeGhostObject
// 0x0070 (0x05E0 - 0x0570)
class AItemJadeGhostObject final : public AItemObjectBase
{
public:
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Root;                                              // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGOCMovement*                           MovementRoot;                                      // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CountDownTime;                                     // 0x0580(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_584[0x5C];                                     // 0x0584(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemJadeGhostObject">();
	}
	static class AItemJadeGhostObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemJadeGhostObject>();
	}
};
static_assert(alignof(AItemJadeGhostObject) == 0x000010, "Wrong alignment on AItemJadeGhostObject");
static_assert(sizeof(AItemJadeGhostObject) == 0x0005E0, "Wrong size on AItemJadeGhostObject");
static_assert(offsetof(AItemJadeGhostObject, Root) == 0x000570, "Member 'AItemJadeGhostObject::Root' has a wrong offset!");
static_assert(offsetof(AItemJadeGhostObject, MovementRoot) == 0x000578, "Member 'AItemJadeGhostObject::MovementRoot' has a wrong offset!");
static_assert(offsetof(AItemJadeGhostObject, CountDownTime) == 0x000580, "Member 'AItemJadeGhostObject::CountDownTime' has a wrong offset!");

// Class UnionRun.UnionBounceMoveComponent
// 0x0090 (0x0130 - 0x00A0)
class UUnionBounceMoveComponent final : public UActorComponent
{
public:
	float                                         BounceHeight;                                      // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BounceTime;                                        // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallTimingRatio;                                   // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BounceCurve;                                       // 0x00B0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnBounceFinished;                                  // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x68];                                      // 0x00C8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionBounceMoveComponent">();
	}
	static class UUnionBounceMoveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionBounceMoveComponent>();
	}
};
static_assert(alignof(UUnionBounceMoveComponent) == 0x000008, "Wrong alignment on UUnionBounceMoveComponent");
static_assert(sizeof(UUnionBounceMoveComponent) == 0x000130, "Wrong size on UUnionBounceMoveComponent");
static_assert(offsetof(UUnionBounceMoveComponent, BounceHeight) == 0x0000A0, "Member 'UUnionBounceMoveComponent::BounceHeight' has a wrong offset!");
static_assert(offsetof(UUnionBounceMoveComponent, BounceTime) == 0x0000A4, "Member 'UUnionBounceMoveComponent::BounceTime' has a wrong offset!");
static_assert(offsetof(UUnionBounceMoveComponent, FallTimingRatio) == 0x0000A8, "Member 'UUnionBounceMoveComponent::FallTimingRatio' has a wrong offset!");
static_assert(offsetof(UUnionBounceMoveComponent, BounceCurve) == 0x0000B0, "Member 'UUnionBounceMoveComponent::BounceCurve' has a wrong offset!");
static_assert(offsetof(UUnionBounceMoveComponent, OnBounceFinished) == 0x0000B8, "Member 'UUnionBounceMoveComponent::OnBounceFinished' has a wrong offset!");

// Class UnionRun.ItemKingBoomBooObject
// 0x0480 (0x09F0 - 0x0570)
class AItemKingBoomBooObject : public AItemObjectBase
{
public:
	class UUnionSkeletalMeshComponent*            BoomBooSkeletalMeshComponent;                      // 0x0568(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_570[0x50];                                     // 0x0570(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionSkeletalMeshComponent*            RingSkeletalMeshComponent;                         // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AKingBoomBooProjectile>     KingBoomBooProjectile;                             // 0x05D0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      AttackSignEffectComponent;                         // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraComponent*                      AttackBallEffectComponent;                         // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    MoveSoundComponent;                                // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    AvoidSoundComponent;                               // 0x05F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ActorScale;                                        // 0x05F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         m_StartFrontOffset;                                // 0x05FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveStraightDistance;                              // 0x0600(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveTargetRacerDistance;                           // 0x0604(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AttackTargetDistance;                              // 0x0608(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LifeTime;                                          // 0x060C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TargetFrontOffset;                                 // 0x0610(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveToPathTime;                                    // 0x0614(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HeightOffset;                                      // 0x0618(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TargetSearchTime;                                  // 0x061C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TargetLookAtSpeed;                                 // 0x0620(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ForceExitTime;                                     // 0x0624(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         NormalMoveSpeed;                                   // 0x0628(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PathMoveSpeed;                                     // 0x062C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HomingMoveSpeed;                                   // 0x0630(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AttackMoveSpeed;                                   // 0x0634(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SpeedRateNormal;                                   // 0x0638(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SpeedRateHigh;                                     // 0x063C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SpeedRateSonic;                                    // 0x0640(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SpeedRateSuperSonic;                               // 0x0644(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ChangeToPathMoveTimer;                             // 0x0648(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ChangeToHomingTimer;                               // 0x064C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PillarSpawnNum;                                    // 0x0650(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PillarSpawnTime;                                   // 0x0654(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PillarTrajectoryDistance;                          // 0x0658(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PillarSpawnOffset;                                 // 0x065C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PillarRadiusRate;                                  // 0x0660(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PillarHeightRate;                                  // 0x0664(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PillarPlayRate;                                    // 0x0668(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PillarLifeSpan;                                    // 0x066C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PillarAvoidFrame;                                  // 0x0670(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PillarAvoidTopOffset;                              // 0x0674(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AttackSignEffectStartTime;                         // 0x0678(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AttackBallEffectStartTime;                         // 0x067C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AttackSignEffectPlayTime;                          // 0x0680(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AttackBallEffectPlayTime;                          // 0x0684(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AttackEffectOffsetMin;                             // 0x0688(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AttackEffectOffsetMinSpeed;                        // 0x068C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AttackEffectOffsetMax;                             // 0x0690(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AttackEffectOffsetMaxInBoatDash;                   // 0x0694(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AttackEffectOffsetMaxSpeed;                        // 0x0698(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TopAttackSignEffectHeight;                         // 0x069C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TopAttackSignRaycastToWallStartHeight;             // 0x06A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TopAttackSignRaycastToWallOffset;                  // 0x06A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TopAttackSignRaycastToRoadLength;                  // 0x06A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FutureTimeAtTargetVelocity;                        // 0x06AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AttackStartTime;                                   // 0x06B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AttackAvoidStartTime;                              // 0x06B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AttackWaitTime;                                    // 0x06B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaterialChangeTime;                                // 0x06BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          DebugDrawTrajectory;                               // 0x06C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C1[0x3F];                                     // 0x06C1(0x003F)(Fixing Size After Last Property [ Dumper-7 ])
	class UKingBoomBooAnimInstance*               AnimInstance;                                      // 0x0700(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USummonRingAnimInstance*                RingAnimInstance;                                  // 0x0708(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_710[0x2E0];                                    // 0x0710(0x02E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemKingBoomBooObject">();
	}
	static class AItemKingBoomBooObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemKingBoomBooObject>();
	}
};
static_assert(alignof(AItemKingBoomBooObject) == 0x000010, "Wrong alignment on AItemKingBoomBooObject");
static_assert(sizeof(AItemKingBoomBooObject) == 0x0009F0, "Wrong size on AItemKingBoomBooObject");
static_assert(offsetof(AItemKingBoomBooObject, BoomBooSkeletalMeshComponent) == 0x000568, "Member 'AItemKingBoomBooObject::BoomBooSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, DefaultSceneRoot) == 0x0005C0, "Member 'AItemKingBoomBooObject::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, RingSkeletalMeshComponent) == 0x0005C8, "Member 'AItemKingBoomBooObject::RingSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, KingBoomBooProjectile) == 0x0005D0, "Member 'AItemKingBoomBooObject::KingBoomBooProjectile' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, AttackSignEffectComponent) == 0x0005D8, "Member 'AItemKingBoomBooObject::AttackSignEffectComponent' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, AttackBallEffectComponent) == 0x0005E0, "Member 'AItemKingBoomBooObject::AttackBallEffectComponent' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, MoveSoundComponent) == 0x0005E8, "Member 'AItemKingBoomBooObject::MoveSoundComponent' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, AvoidSoundComponent) == 0x0005F0, "Member 'AItemKingBoomBooObject::AvoidSoundComponent' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, ActorScale) == 0x0005F8, "Member 'AItemKingBoomBooObject::ActorScale' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, m_StartFrontOffset) == 0x0005FC, "Member 'AItemKingBoomBooObject::m_StartFrontOffset' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, MoveStraightDistance) == 0x000600, "Member 'AItemKingBoomBooObject::MoveStraightDistance' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, MoveTargetRacerDistance) == 0x000604, "Member 'AItemKingBoomBooObject::MoveTargetRacerDistance' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, AttackTargetDistance) == 0x000608, "Member 'AItemKingBoomBooObject::AttackTargetDistance' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, LifeTime) == 0x00060C, "Member 'AItemKingBoomBooObject::LifeTime' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, TargetFrontOffset) == 0x000610, "Member 'AItemKingBoomBooObject::TargetFrontOffset' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, MoveToPathTime) == 0x000614, "Member 'AItemKingBoomBooObject::MoveToPathTime' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, HeightOffset) == 0x000618, "Member 'AItemKingBoomBooObject::HeightOffset' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, TargetSearchTime) == 0x00061C, "Member 'AItemKingBoomBooObject::TargetSearchTime' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, TargetLookAtSpeed) == 0x000620, "Member 'AItemKingBoomBooObject::TargetLookAtSpeed' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, ForceExitTime) == 0x000624, "Member 'AItemKingBoomBooObject::ForceExitTime' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, NormalMoveSpeed) == 0x000628, "Member 'AItemKingBoomBooObject::NormalMoveSpeed' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, PathMoveSpeed) == 0x00062C, "Member 'AItemKingBoomBooObject::PathMoveSpeed' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, HomingMoveSpeed) == 0x000630, "Member 'AItemKingBoomBooObject::HomingMoveSpeed' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, AttackMoveSpeed) == 0x000634, "Member 'AItemKingBoomBooObject::AttackMoveSpeed' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, SpeedRateNormal) == 0x000638, "Member 'AItemKingBoomBooObject::SpeedRateNormal' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, SpeedRateHigh) == 0x00063C, "Member 'AItemKingBoomBooObject::SpeedRateHigh' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, SpeedRateSonic) == 0x000640, "Member 'AItemKingBoomBooObject::SpeedRateSonic' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, SpeedRateSuperSonic) == 0x000644, "Member 'AItemKingBoomBooObject::SpeedRateSuperSonic' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, ChangeToPathMoveTimer) == 0x000648, "Member 'AItemKingBoomBooObject::ChangeToPathMoveTimer' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, ChangeToHomingTimer) == 0x00064C, "Member 'AItemKingBoomBooObject::ChangeToHomingTimer' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, PillarSpawnNum) == 0x000650, "Member 'AItemKingBoomBooObject::PillarSpawnNum' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, PillarSpawnTime) == 0x000654, "Member 'AItemKingBoomBooObject::PillarSpawnTime' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, PillarTrajectoryDistance) == 0x000658, "Member 'AItemKingBoomBooObject::PillarTrajectoryDistance' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, PillarSpawnOffset) == 0x00065C, "Member 'AItemKingBoomBooObject::PillarSpawnOffset' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, PillarRadiusRate) == 0x000660, "Member 'AItemKingBoomBooObject::PillarRadiusRate' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, PillarHeightRate) == 0x000664, "Member 'AItemKingBoomBooObject::PillarHeightRate' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, PillarPlayRate) == 0x000668, "Member 'AItemKingBoomBooObject::PillarPlayRate' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, PillarLifeSpan) == 0x00066C, "Member 'AItemKingBoomBooObject::PillarLifeSpan' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, PillarAvoidFrame) == 0x000670, "Member 'AItemKingBoomBooObject::PillarAvoidFrame' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, PillarAvoidTopOffset) == 0x000674, "Member 'AItemKingBoomBooObject::PillarAvoidTopOffset' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, AttackSignEffectStartTime) == 0x000678, "Member 'AItemKingBoomBooObject::AttackSignEffectStartTime' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, AttackBallEffectStartTime) == 0x00067C, "Member 'AItemKingBoomBooObject::AttackBallEffectStartTime' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, AttackSignEffectPlayTime) == 0x000680, "Member 'AItemKingBoomBooObject::AttackSignEffectPlayTime' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, AttackBallEffectPlayTime) == 0x000684, "Member 'AItemKingBoomBooObject::AttackBallEffectPlayTime' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, AttackEffectOffsetMin) == 0x000688, "Member 'AItemKingBoomBooObject::AttackEffectOffsetMin' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, AttackEffectOffsetMinSpeed) == 0x00068C, "Member 'AItemKingBoomBooObject::AttackEffectOffsetMinSpeed' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, AttackEffectOffsetMax) == 0x000690, "Member 'AItemKingBoomBooObject::AttackEffectOffsetMax' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, AttackEffectOffsetMaxInBoatDash) == 0x000694, "Member 'AItemKingBoomBooObject::AttackEffectOffsetMaxInBoatDash' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, AttackEffectOffsetMaxSpeed) == 0x000698, "Member 'AItemKingBoomBooObject::AttackEffectOffsetMaxSpeed' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, TopAttackSignEffectHeight) == 0x00069C, "Member 'AItemKingBoomBooObject::TopAttackSignEffectHeight' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, TopAttackSignRaycastToWallStartHeight) == 0x0006A0, "Member 'AItemKingBoomBooObject::TopAttackSignRaycastToWallStartHeight' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, TopAttackSignRaycastToWallOffset) == 0x0006A4, "Member 'AItemKingBoomBooObject::TopAttackSignRaycastToWallOffset' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, TopAttackSignRaycastToRoadLength) == 0x0006A8, "Member 'AItemKingBoomBooObject::TopAttackSignRaycastToRoadLength' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, FutureTimeAtTargetVelocity) == 0x0006AC, "Member 'AItemKingBoomBooObject::FutureTimeAtTargetVelocity' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, AttackStartTime) == 0x0006B0, "Member 'AItemKingBoomBooObject::AttackStartTime' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, AttackAvoidStartTime) == 0x0006B4, "Member 'AItemKingBoomBooObject::AttackAvoidStartTime' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, AttackWaitTime) == 0x0006B8, "Member 'AItemKingBoomBooObject::AttackWaitTime' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, MaterialChangeTime) == 0x0006BC, "Member 'AItemKingBoomBooObject::MaterialChangeTime' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, DebugDrawTrajectory) == 0x0006C0, "Member 'AItemKingBoomBooObject::DebugDrawTrajectory' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, AnimInstance) == 0x000700, "Member 'AItemKingBoomBooObject::AnimInstance' has a wrong offset!");
static_assert(offsetof(AItemKingBoomBooObject, RingAnimInstance) == 0x000708, "Member 'AItemKingBoomBooObject::RingAnimInstance' has a wrong offset!");

// Class UnionRun.UnionCommonRunParam
// 0x0070 (0x00A0 - 0x0030)
class UUnionCommonRunParam final : public UDataAsset
{
public:
	float                                         TouchDashCoolSeconds;                              // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JustBoostInputFrameBefore;                         // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JustBoostInputFrameAfter;                          // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChargeSwitchDecreaseRate;                          // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpinTime;                                          // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpinAfterInvincibleTime;                           // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRacerDamagePropertyChangeGroupData    SpinSpeedLimitChange;                              // 0x0048(0x0034)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RespotGap;                                         // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespotAirSeconds;                                  // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespotStopSeconds;                                 // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespotBlockSeconds;                                // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespotMoveRate;                                    // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimeTrialItemBoxCount;                             // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChallengeAirTrickCount;                            // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuickChargeDelaySeconds;                           // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionCommonRunParam">();
	}
	static class UUnionCommonRunParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionCommonRunParam>();
	}
};
static_assert(alignof(UUnionCommonRunParam) == 0x000008, "Wrong alignment on UUnionCommonRunParam");
static_assert(sizeof(UUnionCommonRunParam) == 0x0000A0, "Wrong size on UUnionCommonRunParam");
static_assert(offsetof(UUnionCommonRunParam, TouchDashCoolSeconds) == 0x000030, "Member 'UUnionCommonRunParam::TouchDashCoolSeconds' has a wrong offset!");
static_assert(offsetof(UUnionCommonRunParam, JustBoostInputFrameBefore) == 0x000034, "Member 'UUnionCommonRunParam::JustBoostInputFrameBefore' has a wrong offset!");
static_assert(offsetof(UUnionCommonRunParam, JustBoostInputFrameAfter) == 0x000038, "Member 'UUnionCommonRunParam::JustBoostInputFrameAfter' has a wrong offset!");
static_assert(offsetof(UUnionCommonRunParam, ChargeSwitchDecreaseRate) == 0x00003C, "Member 'UUnionCommonRunParam::ChargeSwitchDecreaseRate' has a wrong offset!");
static_assert(offsetof(UUnionCommonRunParam, SpinTime) == 0x000040, "Member 'UUnionCommonRunParam::SpinTime' has a wrong offset!");
static_assert(offsetof(UUnionCommonRunParam, SpinAfterInvincibleTime) == 0x000044, "Member 'UUnionCommonRunParam::SpinAfterInvincibleTime' has a wrong offset!");
static_assert(offsetof(UUnionCommonRunParam, SpinSpeedLimitChange) == 0x000048, "Member 'UUnionCommonRunParam::SpinSpeedLimitChange' has a wrong offset!");
static_assert(offsetof(UUnionCommonRunParam, RespotGap) == 0x00007C, "Member 'UUnionCommonRunParam::RespotGap' has a wrong offset!");
static_assert(offsetof(UUnionCommonRunParam, RespotAirSeconds) == 0x000080, "Member 'UUnionCommonRunParam::RespotAirSeconds' has a wrong offset!");
static_assert(offsetof(UUnionCommonRunParam, RespotStopSeconds) == 0x000084, "Member 'UUnionCommonRunParam::RespotStopSeconds' has a wrong offset!");
static_assert(offsetof(UUnionCommonRunParam, RespotBlockSeconds) == 0x000088, "Member 'UUnionCommonRunParam::RespotBlockSeconds' has a wrong offset!");
static_assert(offsetof(UUnionCommonRunParam, RespotMoveRate) == 0x00008C, "Member 'UUnionCommonRunParam::RespotMoveRate' has a wrong offset!");
static_assert(offsetof(UUnionCommonRunParam, TimeTrialItemBoxCount) == 0x000090, "Member 'UUnionCommonRunParam::TimeTrialItemBoxCount' has a wrong offset!");
static_assert(offsetof(UUnionCommonRunParam, ChallengeAirTrickCount) == 0x000094, "Member 'UUnionCommonRunParam::ChallengeAirTrickCount' has a wrong offset!");
static_assert(offsetof(UUnionCommonRunParam, QuickChargeDelaySeconds) == 0x000098, "Member 'UUnionCommonRunParam::QuickChargeDelaySeconds' has a wrong offset!");

// Class UnionRun.ItemLotteryObject
// 0x1040 (0x12D0 - 0x0290)
class AItemLotteryObject : public AActor
{
public:
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             IrregularInfiniteDataTable;                        // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StockTime;                                         // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GracePeriodTime;                                   // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LotteryRouletteTime;                               // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IrregularInfiniteRouletteTime;                     // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LotteryRouletteSubAddTime;                         // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DisableRestrictionsThresholdCount;                 // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             PointDistanceDataTable;                            // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             PlayerPointDistanceDataTable;                      // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             ComPointDistanceDataTableList;                     // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             RankGroupLotteryRateDataTable;                     // 0x02D8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             DangerousRaceRankGroupLotteryRateDataTable;        // 0x02E0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             OtherPlayerRankGroupLotteryRateDataTable;          // 0x02E8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             ComPlayerRankGroupLotteryRateDataTableList;        // 0x02F0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             ExtremeRankGroupLotteryRateDataTableList;          // 0x02F8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             PartyRevengeRankGroupLotteryRateDataTable;         // 0x0300(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             GadgetLotteryRateDataDataTable;                    // 0x0308(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             GadgetLotteryRateMagnificationCorrectionDataTable; // 0x0310(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             GroupRaceRuleLotteryRateDataTable;                 // 0x0318(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             TeamBattleLotteryRateDataDataTable;                // 0x0320(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<EItemId>                               NoCandidatesList;                                  // 0x0328(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             PackageRingVariationRateDataTable;                 // 0x0338(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             LimitingFactorDataTable;                           // 0x0340(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLotteryItemBoxRateData                RankGroupLotteryItemBoxRateData_RankGroup1;        // 0x0348(0x000C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLotteryItemBoxRateData                RankGroupLotteryItemBoxRateData_RankGroup2;        // 0x0354(0x000C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLotteryItemBoxRateData                RankGroupLotteryItemBoxRateData_RankGroup3;        // 0x0360(0x000C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLotteryItemBoxRateData                RankGroupLotteryItemBoxRateData_RankGroup4;        // 0x036C(0x000C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLotteryItemBoxRateData                RankGroupLotteryItemBoxRateData_RankGroup5;        // 0x0378(0x000C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         ItemBoxUnavailableTime;                            // 0x0384(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsExcludingGroupRacers;                           // 0x0388(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_389[0xF47];                                    // 0x0389(0x0F47)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemLotteryObject">();
	}
	static class AItemLotteryObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemLotteryObject>();
	}
};
static_assert(alignof(AItemLotteryObject) == 0x000008, "Wrong alignment on AItemLotteryObject");
static_assert(sizeof(AItemLotteryObject) == 0x0012D0, "Wrong size on AItemLotteryObject");
static_assert(offsetof(AItemLotteryObject, IrregularInfiniteDataTable) == 0x0002A0, "Member 'AItemLotteryObject::IrregularInfiniteDataTable' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, StockTime) == 0x0002A8, "Member 'AItemLotteryObject::StockTime' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, GracePeriodTime) == 0x0002AC, "Member 'AItemLotteryObject::GracePeriodTime' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, LotteryRouletteTime) == 0x0002B0, "Member 'AItemLotteryObject::LotteryRouletteTime' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, IrregularInfiniteRouletteTime) == 0x0002B4, "Member 'AItemLotteryObject::IrregularInfiniteRouletteTime' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, LotteryRouletteSubAddTime) == 0x0002B8, "Member 'AItemLotteryObject::LotteryRouletteSubAddTime' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, DisableRestrictionsThresholdCount) == 0x0002BC, "Member 'AItemLotteryObject::DisableRestrictionsThresholdCount' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, PointDistanceDataTable) == 0x0002C0, "Member 'AItemLotteryObject::PointDistanceDataTable' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, PlayerPointDistanceDataTable) == 0x0002C8, "Member 'AItemLotteryObject::PlayerPointDistanceDataTable' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, ComPointDistanceDataTableList) == 0x0002D0, "Member 'AItemLotteryObject::ComPointDistanceDataTableList' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, RankGroupLotteryRateDataTable) == 0x0002D8, "Member 'AItemLotteryObject::RankGroupLotteryRateDataTable' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, DangerousRaceRankGroupLotteryRateDataTable) == 0x0002E0, "Member 'AItemLotteryObject::DangerousRaceRankGroupLotteryRateDataTable' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, OtherPlayerRankGroupLotteryRateDataTable) == 0x0002E8, "Member 'AItemLotteryObject::OtherPlayerRankGroupLotteryRateDataTable' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, ComPlayerRankGroupLotteryRateDataTableList) == 0x0002F0, "Member 'AItemLotteryObject::ComPlayerRankGroupLotteryRateDataTableList' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, ExtremeRankGroupLotteryRateDataTableList) == 0x0002F8, "Member 'AItemLotteryObject::ExtremeRankGroupLotteryRateDataTableList' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, PartyRevengeRankGroupLotteryRateDataTable) == 0x000300, "Member 'AItemLotteryObject::PartyRevengeRankGroupLotteryRateDataTable' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, GadgetLotteryRateDataDataTable) == 0x000308, "Member 'AItemLotteryObject::GadgetLotteryRateDataDataTable' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, GadgetLotteryRateMagnificationCorrectionDataTable) == 0x000310, "Member 'AItemLotteryObject::GadgetLotteryRateMagnificationCorrectionDataTable' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, GroupRaceRuleLotteryRateDataTable) == 0x000318, "Member 'AItemLotteryObject::GroupRaceRuleLotteryRateDataTable' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, TeamBattleLotteryRateDataDataTable) == 0x000320, "Member 'AItemLotteryObject::TeamBattleLotteryRateDataDataTable' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, NoCandidatesList) == 0x000328, "Member 'AItemLotteryObject::NoCandidatesList' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, PackageRingVariationRateDataTable) == 0x000338, "Member 'AItemLotteryObject::PackageRingVariationRateDataTable' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, LimitingFactorDataTable) == 0x000340, "Member 'AItemLotteryObject::LimitingFactorDataTable' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, RankGroupLotteryItemBoxRateData_RankGroup1) == 0x000348, "Member 'AItemLotteryObject::RankGroupLotteryItemBoxRateData_RankGroup1' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, RankGroupLotteryItemBoxRateData_RankGroup2) == 0x000354, "Member 'AItemLotteryObject::RankGroupLotteryItemBoxRateData_RankGroup2' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, RankGroupLotteryItemBoxRateData_RankGroup3) == 0x000360, "Member 'AItemLotteryObject::RankGroupLotteryItemBoxRateData_RankGroup3' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, RankGroupLotteryItemBoxRateData_RankGroup4) == 0x00036C, "Member 'AItemLotteryObject::RankGroupLotteryItemBoxRateData_RankGroup4' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, RankGroupLotteryItemBoxRateData_RankGroup5) == 0x000378, "Member 'AItemLotteryObject::RankGroupLotteryItemBoxRateData_RankGroup5' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, ItemBoxUnavailableTime) == 0x000384, "Member 'AItemLotteryObject::ItemBoxUnavailableTime' has a wrong offset!");
static_assert(offsetof(AItemLotteryObject, bIsExcludingGroupRacers) == 0x000388, "Member 'AItemLotteryObject::bIsExcludingGroupRacers' has a wrong offset!");

// Class UnionRun.ItemMagnetObject
// 0x03D0 (0x0940 - 0x0570)
class AItemMagnetObject : public AItemObjectBase
{
public:
	uint8                                         Pad_568[0x38];                                     // 0x0568(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        m_Root;                                            // 0x05A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        m_magnetMoveRoot;                                  // 0x05A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        m_attractDirectionRoot;                            // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   m_staticMeshComponent;                             // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   m_attractRangeMeshComponent;                       // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTriggerComponent*                      m_attractTrigger;                                  // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTriggerComponent*                      m_hitTrigger;                                      // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemStaticBodyComponent*               m_staticBody;                                      // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGOCMovement*                           m_movement;                                        // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_attractRangeEffect;                              // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_hitCollisionEffect;                              // 0x05F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_hitBreakEffect;                                  // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      m_hitAttachEffect;                                 // 0x0600(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, class UNiagaraComponent*>         m_attractDirectionEffects;                         // 0x0608(0x0050)(Edit, ExportObject, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_hitOnSurfaceSound;                               // 0x0658(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_hitBreakSound;                                   // 0x0660(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    m_hitAttachSound;                                  // 0x0668(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            m_attachCurve;                                     // 0x0670(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_attractionRadius;                                // 0x0678(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_holderInvencibleTime;                            // 0x067C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_attachMotionTime;                                // 0x0680(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_fallingDetectingOffsetFront;                     // 0x0684(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_fallingDetectingOffsetFront_ToFlight;            // 0x0688(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FThrowingFrontParameter                m_maxFrontJumpParam_new;                           // 0x068C(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FThrowingFrontParameter                m_minFrontJumpParam_new;                           // 0x069C(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FRelativeMoveFrontParameter            m_relativeMoveParamFront;                          // 0x06AC(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FThrowingBackParameter                 m_backJumpParam_new;                               // 0x06BC(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRelativeMoveBackParameter             m_relativeMoveParamBack;                           // 0x06C8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         m_attachFallDownTime;                              // 0x06E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_radius;                                          // 0x06E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_sinkLength;                                      // 0x06E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_landCalcUpRayLength;                             // 0x06EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_restitutionCoffi;                                // 0x06F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6F4[0x4];                                      // 0x06F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCue*                          SE_HitGroundNormal;                                // 0x06F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAtomCue*                          SE_HitGroundWater;                                 // 0x0700(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         Effect_AttractDirection;                           // 0x0708(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_710[0x230];                                    // 0x0710(0x0230)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTriggerColliderConflict(const struct FHitTriggerInfo& HitInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemMagnetObject">();
	}
	static class AItemMagnetObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemMagnetObject>();
	}
};
static_assert(alignof(AItemMagnetObject) == 0x000010, "Wrong alignment on AItemMagnetObject");
static_assert(sizeof(AItemMagnetObject) == 0x000940, "Wrong size on AItemMagnetObject");
static_assert(offsetof(AItemMagnetObject, m_Root) == 0x0005A0, "Member 'AItemMagnetObject::m_Root' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_magnetMoveRoot) == 0x0005A8, "Member 'AItemMagnetObject::m_magnetMoveRoot' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_attractDirectionRoot) == 0x0005B0, "Member 'AItemMagnetObject::m_attractDirectionRoot' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_staticMeshComponent) == 0x0005B8, "Member 'AItemMagnetObject::m_staticMeshComponent' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_attractRangeMeshComponent) == 0x0005C0, "Member 'AItemMagnetObject::m_attractRangeMeshComponent' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_attractTrigger) == 0x0005C8, "Member 'AItemMagnetObject::m_attractTrigger' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_hitTrigger) == 0x0005D0, "Member 'AItemMagnetObject::m_hitTrigger' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_staticBody) == 0x0005D8, "Member 'AItemMagnetObject::m_staticBody' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_movement) == 0x0005E0, "Member 'AItemMagnetObject::m_movement' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_attractRangeEffect) == 0x0005E8, "Member 'AItemMagnetObject::m_attractRangeEffect' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_hitCollisionEffect) == 0x0005F0, "Member 'AItemMagnetObject::m_hitCollisionEffect' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_hitBreakEffect) == 0x0005F8, "Member 'AItemMagnetObject::m_hitBreakEffect' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_hitAttachEffect) == 0x000600, "Member 'AItemMagnetObject::m_hitAttachEffect' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_attractDirectionEffects) == 0x000608, "Member 'AItemMagnetObject::m_attractDirectionEffects' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_hitOnSurfaceSound) == 0x000658, "Member 'AItemMagnetObject::m_hitOnSurfaceSound' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_hitBreakSound) == 0x000660, "Member 'AItemMagnetObject::m_hitBreakSound' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_hitAttachSound) == 0x000668, "Member 'AItemMagnetObject::m_hitAttachSound' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_attachCurve) == 0x000670, "Member 'AItemMagnetObject::m_attachCurve' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_attractionRadius) == 0x000678, "Member 'AItemMagnetObject::m_attractionRadius' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_holderInvencibleTime) == 0x00067C, "Member 'AItemMagnetObject::m_holderInvencibleTime' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_attachMotionTime) == 0x000680, "Member 'AItemMagnetObject::m_attachMotionTime' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_fallingDetectingOffsetFront) == 0x000684, "Member 'AItemMagnetObject::m_fallingDetectingOffsetFront' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_fallingDetectingOffsetFront_ToFlight) == 0x000688, "Member 'AItemMagnetObject::m_fallingDetectingOffsetFront_ToFlight' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_maxFrontJumpParam_new) == 0x00068C, "Member 'AItemMagnetObject::m_maxFrontJumpParam_new' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_minFrontJumpParam_new) == 0x00069C, "Member 'AItemMagnetObject::m_minFrontJumpParam_new' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_relativeMoveParamFront) == 0x0006AC, "Member 'AItemMagnetObject::m_relativeMoveParamFront' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_backJumpParam_new) == 0x0006BC, "Member 'AItemMagnetObject::m_backJumpParam_new' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_relativeMoveParamBack) == 0x0006C8, "Member 'AItemMagnetObject::m_relativeMoveParamBack' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_attachFallDownTime) == 0x0006E0, "Member 'AItemMagnetObject::m_attachFallDownTime' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_radius) == 0x0006E4, "Member 'AItemMagnetObject::m_radius' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_sinkLength) == 0x0006E8, "Member 'AItemMagnetObject::m_sinkLength' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_landCalcUpRayLength) == 0x0006EC, "Member 'AItemMagnetObject::m_landCalcUpRayLength' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, m_restitutionCoffi) == 0x0006F0, "Member 'AItemMagnetObject::m_restitutionCoffi' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, SE_HitGroundNormal) == 0x0006F8, "Member 'AItemMagnetObject::SE_HitGroundNormal' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, SE_HitGroundWater) == 0x000700, "Member 'AItemMagnetObject::SE_HitGroundWater' has a wrong offset!");
static_assert(offsetof(AItemMagnetObject, Effect_AttractDirection) == 0x000708, "Member 'AItemMagnetObject::Effect_AttractDirection' has a wrong offset!");

// Class UnionRun.UnionCameraManager
// 0x00C8 (0x00F0 - 0x0028)
class UUnionCameraManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCameraModifier>            CameraModiferPostEffectClass;                      // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0xB8];                                      // 0x0038(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionCameraManager">();
	}
	static class UUnionCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionCameraManager>();
	}
};
static_assert(alignof(UUnionCameraManager) == 0x000008, "Wrong alignment on UUnionCameraManager");
static_assert(sizeof(UUnionCameraManager) == 0x0000F0, "Wrong size on UUnionCameraManager");
static_assert(offsetof(UUnionCameraManager, CameraModiferPostEffectClass) == 0x000030, "Member 'UUnionCameraManager::CameraModiferPostEffectClass' has a wrong offset!");

// Class UnionRun.ItemMessageInterface
// 0x0000 (0x0000 - 0x0000)
class IItemMessageInterface final
{
public:
	bool CalIsInWithinPlaneArea(const struct FVector& Position);
	bool ConfirmAbsorbOject(const struct FAbsorbedObjectInfo& Info);
	float GetItemActiveTime();
	EDomainNumber GetItemDomainNumber();
	int32 GetItemHolderRacerIndex();
	struct FTransform GetItemPathTransform();
	EItemThrowDirection GetItemThrowDirection();
	EItemId GetItemType();
	int32 GetItemUniqueID();
	float GetTrapItemOnGroundTime();
	bool IsItemPathRouteForm(int32 Type);
	bool IsItemPathType(int32 Type);
	bool IsWarpTarget(int32 WarpRingAttacRacerIndex);
	void NotifyAbsorbFinished();
	void NotifyAbsorbOject(const struct FAbsorberInfo& Info);
	void NotifyCyanLaserMoveInfo(const struct FCyanLaserMoveInfo& Info);
	void NotifyWarpRingMoveInfo(const struct FWarpRingMoveInfo& Info);
	bool NotifyWarpTargetBegin(int32 WarpRingAttacRacerIndex);
	void NotifyWarpTargetEnd(int32 WarpRingAttacRacerIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemMessageInterface">();
	}
	static class IItemMessageInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IItemMessageInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IItemMessageInterface) == 0x000001, "Wrong alignment on IItemMessageInterface");
static_assert(sizeof(IItemMessageInterface) == 0x000001, "Wrong size on IItemMessageInterface");

// Class UnionRun.ItemMonsterTruckObject
// 0x00E0 (0x0650 - 0x0570)
class AItemMonsterTruckObject : public AItemObjectBase
{
public:
	float                                         m_UpperRate;                                       // 0x0568(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         m_MiddleRate;                                      // 0x056C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         m_UpperItemSeconds;                                // 0x0570(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         m_MiddleItemSeconds;                               // 0x0574(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         m_LowerItemSeconds;                                // 0x0578(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         m_MinKeepSeconds;                                  // 0x057C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         m_SignSeconds;                                     // 0x0580(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_584[0x4];                                      // 0x0584(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<float, float>                            m_ItemSecondsList;                                 // 0x0588(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	int32                                         m_OverTakeNumToForceFinish;                        // 0x05D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5DC[0x74];                                     // 0x05DC(0x0074)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemMonsterTruckObject">();
	}
	static class AItemMonsterTruckObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemMonsterTruckObject>();
	}
};
static_assert(alignof(AItemMonsterTruckObject) == 0x000010, "Wrong alignment on AItemMonsterTruckObject");
static_assert(sizeof(AItemMonsterTruckObject) == 0x000650, "Wrong size on AItemMonsterTruckObject");
static_assert(offsetof(AItemMonsterTruckObject, m_UpperRate) == 0x000568, "Member 'AItemMonsterTruckObject::m_UpperRate' has a wrong offset!");
static_assert(offsetof(AItemMonsterTruckObject, m_MiddleRate) == 0x00056C, "Member 'AItemMonsterTruckObject::m_MiddleRate' has a wrong offset!");
static_assert(offsetof(AItemMonsterTruckObject, m_UpperItemSeconds) == 0x000570, "Member 'AItemMonsterTruckObject::m_UpperItemSeconds' has a wrong offset!");
static_assert(offsetof(AItemMonsterTruckObject, m_MiddleItemSeconds) == 0x000574, "Member 'AItemMonsterTruckObject::m_MiddleItemSeconds' has a wrong offset!");
static_assert(offsetof(AItemMonsterTruckObject, m_LowerItemSeconds) == 0x000578, "Member 'AItemMonsterTruckObject::m_LowerItemSeconds' has a wrong offset!");
static_assert(offsetof(AItemMonsterTruckObject, m_MinKeepSeconds) == 0x00057C, "Member 'AItemMonsterTruckObject::m_MinKeepSeconds' has a wrong offset!");
static_assert(offsetof(AItemMonsterTruckObject, m_SignSeconds) == 0x000580, "Member 'AItemMonsterTruckObject::m_SignSeconds' has a wrong offset!");
static_assert(offsetof(AItemMonsterTruckObject, m_ItemSecondsList) == 0x000588, "Member 'AItemMonsterTruckObject::m_ItemSecondsList' has a wrong offset!");
static_assert(offsetof(AItemMonsterTruckObject, m_OverTakeNumToForceFinish) == 0x0005D8, "Member 'AItemMonsterTruckObject::m_OverTakeNumToForceFinish' has a wrong offset!");

// Class UnionRun.UnionAddGravity
// 0x0040 (0x0078 - 0x0038)
class UUnionAddGravity final : public UMoveController
{
public:
	uint8                                         Pad_38[0x40];                                      // 0x0038(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionAddGravity">();
	}
	static class UUnionAddGravity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionAddGravity>();
	}
};
static_assert(alignof(UUnionAddGravity) == 0x000008, "Wrong alignment on UUnionAddGravity");
static_assert(sizeof(UUnionAddGravity) == 0x000078, "Wrong size on UUnionAddGravity");

// Class UnionRun.ItemObjectLayer
// 0x07E8 (0x0810 - 0x0028)
class UItemObjectLayer final : public UObject
{
public:
	uint8                                         Pad_28[0x7E8];                                     // 0x0028(0x07E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemObjectLayer">();
	}
	static class UItemObjectLayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemObjectLayer>();
	}
};
static_assert(alignof(UItemObjectLayer) == 0x000008, "Wrong alignment on UItemObjectLayer");
static_assert(sizeof(UItemObjectLayer) == 0x000810, "Wrong size on UItemObjectLayer");

// Class UnionRun.ItemOmochaoAnimInstance
// 0x0010 (0x0380 - 0x0370)
class UItemOmochaoAnimInstance : public UAnimInstance
{
public:
	bool                                          bStartPerformanceFinished;                         // 0x0368(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPutRing;                                          // 0x0369(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFinishPerformanceStarted;                         // 0x036A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFinishPerformanceFinished;                        // 0x036B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReady;                                          // 0x036C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInSleep;                                          // 0x036D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36E[0x12];                                     // 0x036E(0x0012)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemOmochaoAnimInstance">();
	}
	static class UItemOmochaoAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemOmochaoAnimInstance>();
	}
};
static_assert(alignof(UItemOmochaoAnimInstance) == 0x000010, "Wrong alignment on UItemOmochaoAnimInstance");
static_assert(sizeof(UItemOmochaoAnimInstance) == 0x000380, "Wrong size on UItemOmochaoAnimInstance");
static_assert(offsetof(UItemOmochaoAnimInstance, bStartPerformanceFinished) == 0x000368, "Member 'UItemOmochaoAnimInstance::bStartPerformanceFinished' has a wrong offset!");
static_assert(offsetof(UItemOmochaoAnimInstance, bPutRing) == 0x000369, "Member 'UItemOmochaoAnimInstance::bPutRing' has a wrong offset!");
static_assert(offsetof(UItemOmochaoAnimInstance, bFinishPerformanceStarted) == 0x00036A, "Member 'UItemOmochaoAnimInstance::bFinishPerformanceStarted' has a wrong offset!");
static_assert(offsetof(UItemOmochaoAnimInstance, bFinishPerformanceFinished) == 0x00036B, "Member 'UItemOmochaoAnimInstance::bFinishPerformanceFinished' has a wrong offset!");
static_assert(offsetof(UItemOmochaoAnimInstance, bIsReady) == 0x00036C, "Member 'UItemOmochaoAnimInstance::bIsReady' has a wrong offset!");
static_assert(offsetof(UItemOmochaoAnimInstance, bInSleep) == 0x00036D, "Member 'UItemOmochaoAnimInstance::bInSleep' has a wrong offset!");

// Class UnionRun.ItemOmochaoDroppedRing
// 0x0140 (0x0480 - 0x0340)
class alignas(0x10) AItemOmochaoDroppedRing : public AUnionCourseObjectBase
{
public:
	uint8                                         Pad_340[0x18];                                     // 0x0340(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        MeshRoot;                                          // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticBodyComponent*                   StaticBodyComponent;                               // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGOCMovement*                           Movement;                                          // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USuckedMovement*                        SuckedMovement;                                    // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTime;                                          // 0x0378(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DropSpeed;                                         // 0x037C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RingRadius;                                        // 0x0380(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DropDistance;                                      // 0x0384(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RacerIndex;                                        // 0x0388(0x0004)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDraw;                                        // 0x038C(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38D[0x3];                                      // 0x038D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0390(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_398[0xE8];                                     // 0x0398(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemOmochaoDroppedRing">();
	}
	static class AItemOmochaoDroppedRing* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemOmochaoDroppedRing>();
	}
};
static_assert(alignof(AItemOmochaoDroppedRing) == 0x000010, "Wrong alignment on AItemOmochaoDroppedRing");
static_assert(sizeof(AItemOmochaoDroppedRing) == 0x000480, "Wrong size on AItemOmochaoDroppedRing");
static_assert(offsetof(AItemOmochaoDroppedRing, MeshRoot) == 0x000358, "Member 'AItemOmochaoDroppedRing::MeshRoot' has a wrong offset!");
static_assert(offsetof(AItemOmochaoDroppedRing, StaticBodyComponent) == 0x000360, "Member 'AItemOmochaoDroppedRing::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AItemOmochaoDroppedRing, Movement) == 0x000368, "Member 'AItemOmochaoDroppedRing::Movement' has a wrong offset!");
static_assert(offsetof(AItemOmochaoDroppedRing, SuckedMovement) == 0x000370, "Member 'AItemOmochaoDroppedRing::SuckedMovement' has a wrong offset!");
static_assert(offsetof(AItemOmochaoDroppedRing, LifeTime) == 0x000378, "Member 'AItemOmochaoDroppedRing::LifeTime' has a wrong offset!");
static_assert(offsetof(AItemOmochaoDroppedRing, DropSpeed) == 0x00037C, "Member 'AItemOmochaoDroppedRing::DropSpeed' has a wrong offset!");
static_assert(offsetof(AItemOmochaoDroppedRing, RingRadius) == 0x000380, "Member 'AItemOmochaoDroppedRing::RingRadius' has a wrong offset!");
static_assert(offsetof(AItemOmochaoDroppedRing, DropDistance) == 0x000384, "Member 'AItemOmochaoDroppedRing::DropDistance' has a wrong offset!");
static_assert(offsetof(AItemOmochaoDroppedRing, RacerIndex) == 0x000388, "Member 'AItemOmochaoDroppedRing::RacerIndex' has a wrong offset!");
static_assert(offsetof(AItemOmochaoDroppedRing, bDebugDraw) == 0x00038C, "Member 'AItemOmochaoDroppedRing::bDebugDraw' has a wrong offset!");
static_assert(offsetof(AItemOmochaoDroppedRing, DefaultSceneRoot) == 0x000390, "Member 'AItemOmochaoDroppedRing::DefaultSceneRoot' has a wrong offset!");

// Class UnionRun.ItemOmochaoObject
// 0x0210 (0x0780 - 0x0570)
class AItemOmochaoObject : public AItemObjectBase
{
public:
	uint8                                         Pad_568[0x10];                                     // 0x0568(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Root;                                              // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        RingRoot;                                          // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 OmochaoMesh;                                       // 0x0588(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChildActorComponent*                   ChildActorRing;                                    // 0x0590(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTriggerComponent*                      HitTrigger;                                        // 0x0598(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemCountDownComponent*                CountDown;                                         // 0x05A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGOCMovement*                           Movement;                                          // 0x05A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    AppearSE;                                          // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    ReturnSE;                                          // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CountDownTime;                                     // 0x05C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightAbovePath;                                   // 0x05C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartPerformanceTime;                              // 0x05C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        LeadRacerDistanceMin;                              // 0x05CC(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        LeadRacerDistanceMax;                              // 0x05DC(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        LeadRacerDistanceMinSpeed;                         // 0x05EC(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        LeadRacerDistanceMaxSpeed;                         // 0x05FC(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        AddMoveSpeed;                                      // 0x060C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        MinMoveSpeed;                                      // 0x061C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        MoveAcceleration;                                  // 0x062C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseCourseBoundary;                                // 0x063C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63D[0x3];                                      // 0x063D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DropRingColumn;                                    // 0x0640(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DropRingColumnInterval;                            // 0x0644(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DropRingIntervalTime;                              // 0x0648(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DropRingSkipDistance;                              // 0x064C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropRingMaxNum;                                    // 0x0650(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DropRingHiehtOffset;                               // 0x0654(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateSpeed;                                       // 0x0658(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InPauseDistance;                                   // 0x065C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InPauseTimer;                                      // 0x0660(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VehicleStopSpeedThreshold;                         // 0x0664(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExitRingPerformanceTime;                           // 0x0668(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopDropRingAnimTime;                              // 0x066C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FutureTimeInDrift;                                 // 0x0670(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDraw;                                        // 0x0674(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugForceCancel;                                 // 0x0675(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDropRingDraw;                                // 0x0676(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_677[0x1];                                      // 0x0677(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AItemOmochaoDroppedRing>    DroppedRingClass;                                  // 0x0678(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_680[0x100];                                    // 0x0680(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTriggerColliderConflict(const struct FHitTriggerInfo& HitInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemOmochaoObject">();
	}
	static class AItemOmochaoObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemOmochaoObject>();
	}
};
static_assert(alignof(AItemOmochaoObject) == 0x000010, "Wrong alignment on AItemOmochaoObject");
static_assert(sizeof(AItemOmochaoObject) == 0x000780, "Wrong size on AItemOmochaoObject");
static_assert(offsetof(AItemOmochaoObject, Root) == 0x000578, "Member 'AItemOmochaoObject::Root' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, RingRoot) == 0x000580, "Member 'AItemOmochaoObject::RingRoot' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, OmochaoMesh) == 0x000588, "Member 'AItemOmochaoObject::OmochaoMesh' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, ChildActorRing) == 0x000590, "Member 'AItemOmochaoObject::ChildActorRing' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, HitTrigger) == 0x000598, "Member 'AItemOmochaoObject::HitTrigger' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, CountDown) == 0x0005A0, "Member 'AItemOmochaoObject::CountDown' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, Movement) == 0x0005A8, "Member 'AItemOmochaoObject::Movement' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, AppearSE) == 0x0005B0, "Member 'AItemOmochaoObject::AppearSE' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, ReturnSE) == 0x0005B8, "Member 'AItemOmochaoObject::ReturnSE' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, CountDownTime) == 0x0005C0, "Member 'AItemOmochaoObject::CountDownTime' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, HeightAbovePath) == 0x0005C4, "Member 'AItemOmochaoObject::HeightAbovePath' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, StartPerformanceTime) == 0x0005C8, "Member 'AItemOmochaoObject::StartPerformanceTime' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, LeadRacerDistanceMin) == 0x0005CC, "Member 'AItemOmochaoObject::LeadRacerDistanceMin' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, LeadRacerDistanceMax) == 0x0005DC, "Member 'AItemOmochaoObject::LeadRacerDistanceMax' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, LeadRacerDistanceMinSpeed) == 0x0005EC, "Member 'AItemOmochaoObject::LeadRacerDistanceMinSpeed' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, LeadRacerDistanceMaxSpeed) == 0x0005FC, "Member 'AItemOmochaoObject::LeadRacerDistanceMaxSpeed' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, AddMoveSpeed) == 0x00060C, "Member 'AItemOmochaoObject::AddMoveSpeed' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, MinMoveSpeed) == 0x00061C, "Member 'AItemOmochaoObject::MinMoveSpeed' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, MoveAcceleration) == 0x00062C, "Member 'AItemOmochaoObject::MoveAcceleration' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, bUseCourseBoundary) == 0x00063C, "Member 'AItemOmochaoObject::bUseCourseBoundary' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, DropRingColumn) == 0x000640, "Member 'AItemOmochaoObject::DropRingColumn' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, DropRingColumnInterval) == 0x000644, "Member 'AItemOmochaoObject::DropRingColumnInterval' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, DropRingIntervalTime) == 0x000648, "Member 'AItemOmochaoObject::DropRingIntervalTime' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, DropRingSkipDistance) == 0x00064C, "Member 'AItemOmochaoObject::DropRingSkipDistance' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, DropRingMaxNum) == 0x000650, "Member 'AItemOmochaoObject::DropRingMaxNum' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, DropRingHiehtOffset) == 0x000654, "Member 'AItemOmochaoObject::DropRingHiehtOffset' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, RotateSpeed) == 0x000658, "Member 'AItemOmochaoObject::RotateSpeed' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, InPauseDistance) == 0x00065C, "Member 'AItemOmochaoObject::InPauseDistance' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, InPauseTimer) == 0x000660, "Member 'AItemOmochaoObject::InPauseTimer' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, VehicleStopSpeedThreshold) == 0x000664, "Member 'AItemOmochaoObject::VehicleStopSpeedThreshold' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, ExitRingPerformanceTime) == 0x000668, "Member 'AItemOmochaoObject::ExitRingPerformanceTime' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, StopDropRingAnimTime) == 0x00066C, "Member 'AItemOmochaoObject::StopDropRingAnimTime' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, FutureTimeInDrift) == 0x000670, "Member 'AItemOmochaoObject::FutureTimeInDrift' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, bDebugDraw) == 0x000674, "Member 'AItemOmochaoObject::bDebugDraw' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, bDebugForceCancel) == 0x000675, "Member 'AItemOmochaoObject::bDebugForceCancel' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, bDebugDropRingDraw) == 0x000676, "Member 'AItemOmochaoObject::bDebugDropRingDraw' has a wrong offset!");
static_assert(offsetof(AItemOmochaoObject, DroppedRingClass) == 0x000678, "Member 'AItemOmochaoObject::DroppedRingClass' has a wrong offset!");

// Class UnionRun.ItemPerformanceInterface
// 0x0000 (0x0000 - 0x0000)
class IItemPerformanceInterface final
{
public:
	int32 GetAttachedRacerIndex();
	EPerformanceObjectType GetPerformanceObjectType();
	class FName GetStatusInfoID();
	bool IsPerformanceObjectInAlart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemPerformanceInterface">();
	}
	static class IItemPerformanceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IItemPerformanceInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IItemPerformanceInterface) == 0x000001, "Wrong alignment on IItemPerformanceInterface");
static_assert(sizeof(IItemPerformanceInterface) == 0x000001, "Wrong size on IItemPerformanceInterface");

// Class UnionRun.ItemShieldObject
// 0x0070 (0x05E0 - 0x0570)
class AItemShieldObject : public AItemObjectBase
{
public:
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Root;                                              // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGOCMovement*                           MovementRoot;                                      // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CountDownTime;                                     // 0x0580(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_584[0x5C];                                     // 0x0584(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemShieldObject">();
	}
	static class AItemShieldObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemShieldObject>();
	}
};
static_assert(alignof(AItemShieldObject) == 0x000010, "Wrong alignment on AItemShieldObject");
static_assert(sizeof(AItemShieldObject) == 0x0005E0, "Wrong size on AItemShieldObject");
static_assert(offsetof(AItemShieldObject, Root) == 0x000570, "Member 'AItemShieldObject::Root' has a wrong offset!");
static_assert(offsetof(AItemShieldObject, MovementRoot) == 0x000578, "Member 'AItemShieldObject::MovementRoot' has a wrong offset!");
static_assert(offsetof(AItemShieldObject, CountDownTime) == 0x000580, "Member 'AItemShieldObject::CountDownTime' has a wrong offset!");

// Class UnionRun.ItemSlicerObject
// 0x00D0 (0x0640 - 0x0570)
class AItemSlicerObject : public AItemObjectBase
{
public:
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Root;                                              // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        CarCenter;                                         // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTriggerComponent*                      Trigger;                                           // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGOCMovement*                           Movement;                                          // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      EffectSlicer;                                      // 0x0590(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    SESlicer;                                          // 0x0598(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    SESlicerLocal;                                     // 0x05A0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    SESlicerDestroy;                                   // 0x05A8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetItemInvencibleTime;                          // 0x05B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackRadius;                                      // 0x05B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackHeight;                                      // 0x05B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectHeight;                                      // 0x05BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDraw;                                        // 0x05C0(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C1[0x7F];                                     // 0x05C1(0x007F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTriggerColliderConflict(const struct FHitTriggerInfo& HitInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSlicerObject">();
	}
	static class AItemSlicerObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemSlicerObject>();
	}
};
static_assert(alignof(AItemSlicerObject) == 0x000010, "Wrong alignment on AItemSlicerObject");
static_assert(sizeof(AItemSlicerObject) == 0x000640, "Wrong size on AItemSlicerObject");
static_assert(offsetof(AItemSlicerObject, Root) == 0x000570, "Member 'AItemSlicerObject::Root' has a wrong offset!");
static_assert(offsetof(AItemSlicerObject, CarCenter) == 0x000578, "Member 'AItemSlicerObject::CarCenter' has a wrong offset!");
static_assert(offsetof(AItemSlicerObject, Trigger) == 0x000580, "Member 'AItemSlicerObject::Trigger' has a wrong offset!");
static_assert(offsetof(AItemSlicerObject, Movement) == 0x000588, "Member 'AItemSlicerObject::Movement' has a wrong offset!");
static_assert(offsetof(AItemSlicerObject, EffectSlicer) == 0x000590, "Member 'AItemSlicerObject::EffectSlicer' has a wrong offset!");
static_assert(offsetof(AItemSlicerObject, SESlicer) == 0x000598, "Member 'AItemSlicerObject::SESlicer' has a wrong offset!");
static_assert(offsetof(AItemSlicerObject, SESlicerLocal) == 0x0005A0, "Member 'AItemSlicerObject::SESlicerLocal' has a wrong offset!");
static_assert(offsetof(AItemSlicerObject, SESlicerDestroy) == 0x0005A8, "Member 'AItemSlicerObject::SESlicerDestroy' has a wrong offset!");
static_assert(offsetof(AItemSlicerObject, TargetItemInvencibleTime) == 0x0005B0, "Member 'AItemSlicerObject::TargetItemInvencibleTime' has a wrong offset!");
static_assert(offsetof(AItemSlicerObject, AttackRadius) == 0x0005B4, "Member 'AItemSlicerObject::AttackRadius' has a wrong offset!");
static_assert(offsetof(AItemSlicerObject, AttackHeight) == 0x0005B8, "Member 'AItemSlicerObject::AttackHeight' has a wrong offset!");
static_assert(offsetof(AItemSlicerObject, EffectHeight) == 0x0005BC, "Member 'AItemSlicerObject::EffectHeight' has a wrong offset!");
static_assert(offsetof(AItemSlicerObject, bDebugDraw) == 0x0005C0, "Member 'AItemSlicerObject::bDebugDraw' has a wrong offset!");

// Class UnionRun.SlimeInputParameterDataAsset
// 0x0010 (0x0040 - 0x0030)
class USlimeInputParameterDataAsset final : public UDataAsset
{
public:
	float                                         StatusShortenTime;                                 // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeyInputInterval;                                  // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IngoreThreshold;                                   // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IngoreAngleThreshold;                              // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlimeInputParameterDataAsset">();
	}
	static class USlimeInputParameterDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlimeInputParameterDataAsset>();
	}
};
static_assert(alignof(USlimeInputParameterDataAsset) == 0x000008, "Wrong alignment on USlimeInputParameterDataAsset");
static_assert(sizeof(USlimeInputParameterDataAsset) == 0x000040, "Wrong size on USlimeInputParameterDataAsset");
static_assert(offsetof(USlimeInputParameterDataAsset, StatusShortenTime) == 0x000030, "Member 'USlimeInputParameterDataAsset::StatusShortenTime' has a wrong offset!");
static_assert(offsetof(USlimeInputParameterDataAsset, KeyInputInterval) == 0x000034, "Member 'USlimeInputParameterDataAsset::KeyInputInterval' has a wrong offset!");
static_assert(offsetof(USlimeInputParameterDataAsset, IngoreThreshold) == 0x000038, "Member 'USlimeInputParameterDataAsset::IngoreThreshold' has a wrong offset!");
static_assert(offsetof(USlimeInputParameterDataAsset, IngoreAngleThreshold) == 0x00003C, "Member 'USlimeInputParameterDataAsset::IngoreAngleThreshold' has a wrong offset!");

// Class UnionRun.UnionDetectingGround
// 0x0098 (0x00D0 - 0x0038)
class UUnionDetectingGround final : public UMoveController
{
public:
	uint8                                         Pad_38[0x98];                                      // 0x0038(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionDetectingGround">();
	}
	static class UUnionDetectingGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionDetectingGround>();
	}
};
static_assert(alignof(UUnionDetectingGround) == 0x000008, "Wrong alignment on UUnionDetectingGround");
static_assert(sizeof(UUnionDetectingGround) == 0x0000D0, "Wrong size on UUnionDetectingGround");

// Class UnionRun.ItemSlimeObject
// 0x0130 (0x06A0 - 0x0570)
class AItemSlimeObject : public AItemObjectBase
{
public:
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Root;                                              // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        RingRoot;                                          // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChildActorComponent*                   ChildActorRing;                                    // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   MeshSlime;                                         // 0x0588(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveVector*                           AppearCurve;                                       // 0x0590(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AppearTime;                                        // 0x0598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlimeMoveTime;                                     // 0x059C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisappearTime;                                     // 0x05A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowHitSelf;                                     // 0x05A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A5[0x3];                                      // 0x05A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, float>                            DebugInfo_RemainTime;                              // 0x05A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F8[0xA8];                                     // 0x05F8(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSlimeObject">();
	}
	static class AItemSlimeObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemSlimeObject>();
	}
};
static_assert(alignof(AItemSlimeObject) == 0x000010, "Wrong alignment on AItemSlimeObject");
static_assert(sizeof(AItemSlimeObject) == 0x0006A0, "Wrong size on AItemSlimeObject");
static_assert(offsetof(AItemSlimeObject, Root) == 0x000570, "Member 'AItemSlimeObject::Root' has a wrong offset!");
static_assert(offsetof(AItemSlimeObject, RingRoot) == 0x000578, "Member 'AItemSlimeObject::RingRoot' has a wrong offset!");
static_assert(offsetof(AItemSlimeObject, ChildActorRing) == 0x000580, "Member 'AItemSlimeObject::ChildActorRing' has a wrong offset!");
static_assert(offsetof(AItemSlimeObject, MeshSlime) == 0x000588, "Member 'AItemSlimeObject::MeshSlime' has a wrong offset!");
static_assert(offsetof(AItemSlimeObject, AppearCurve) == 0x000590, "Member 'AItemSlimeObject::AppearCurve' has a wrong offset!");
static_assert(offsetof(AItemSlimeObject, AppearTime) == 0x000598, "Member 'AItemSlimeObject::AppearTime' has a wrong offset!");
static_assert(offsetof(AItemSlimeObject, SlimeMoveTime) == 0x00059C, "Member 'AItemSlimeObject::SlimeMoveTime' has a wrong offset!");
static_assert(offsetof(AItemSlimeObject, DisappearTime) == 0x0005A0, "Member 'AItemSlimeObject::DisappearTime' has a wrong offset!");
static_assert(offsetof(AItemSlimeObject, bAllowHitSelf) == 0x0005A4, "Member 'AItemSlimeObject::bAllowHitSelf' has a wrong offset!");
static_assert(offsetof(AItemSlimeObject, DebugInfo_RemainTime) == 0x0005A8, "Member 'AItemSlimeObject::DebugInfo_RemainTime' has a wrong offset!");

// Class UnionRun.ItemSplashObject
// 0x01B0 (0x0720 - 0x0570)
class AItemSplashObject : public AItemObjectBase
{
public:
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Root;                                              // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   BodyMeshComponent;                                 // 0x0578(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGOCMovement*                           Movement;                                          // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemCountDownComponent*                CountDown;                                         // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    WaterAttackSound;                                  // 0x0590(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      SplashDisappearEffectComponent;                    // 0x0598(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxFireNum;                                        // 0x05A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireInterval;                                      // 0x05A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountDownFireNum;                                  // 0x05A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireMotionTime;                                    // 0x05AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireMotionRotateAngle;                             // 0x05B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B4[0x4];                                      // 0x05B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SplashOffsetPosition;                              // 0x05B8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FireMotionCurve;                                   // 0x05D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AItemSplashProjectile>      ProjectileClass;                                   // 0x05D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E0[0x140];                                    // 0x05E0(0x0140)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSplashObject">();
	}
	static class AItemSplashObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemSplashObject>();
	}
};
static_assert(alignof(AItemSplashObject) == 0x000010, "Wrong alignment on AItemSplashObject");
static_assert(sizeof(AItemSplashObject) == 0x000720, "Wrong size on AItemSplashObject");
static_assert(offsetof(AItemSplashObject, Root) == 0x000570, "Member 'AItemSplashObject::Root' has a wrong offset!");
static_assert(offsetof(AItemSplashObject, BodyMeshComponent) == 0x000578, "Member 'AItemSplashObject::BodyMeshComponent' has a wrong offset!");
static_assert(offsetof(AItemSplashObject, Movement) == 0x000580, "Member 'AItemSplashObject::Movement' has a wrong offset!");
static_assert(offsetof(AItemSplashObject, CountDown) == 0x000588, "Member 'AItemSplashObject::CountDown' has a wrong offset!");
static_assert(offsetof(AItemSplashObject, WaterAttackSound) == 0x000590, "Member 'AItemSplashObject::WaterAttackSound' has a wrong offset!");
static_assert(offsetof(AItemSplashObject, SplashDisappearEffectComponent) == 0x000598, "Member 'AItemSplashObject::SplashDisappearEffectComponent' has a wrong offset!");
static_assert(offsetof(AItemSplashObject, MaxFireNum) == 0x0005A0, "Member 'AItemSplashObject::MaxFireNum' has a wrong offset!");
static_assert(offsetof(AItemSplashObject, FireInterval) == 0x0005A4, "Member 'AItemSplashObject::FireInterval' has a wrong offset!");
static_assert(offsetof(AItemSplashObject, CountDownFireNum) == 0x0005A8, "Member 'AItemSplashObject::CountDownFireNum' has a wrong offset!");
static_assert(offsetof(AItemSplashObject, FireMotionTime) == 0x0005AC, "Member 'AItemSplashObject::FireMotionTime' has a wrong offset!");
static_assert(offsetof(AItemSplashObject, FireMotionRotateAngle) == 0x0005B0, "Member 'AItemSplashObject::FireMotionRotateAngle' has a wrong offset!");
static_assert(offsetof(AItemSplashObject, SplashOffsetPosition) == 0x0005B8, "Member 'AItemSplashObject::SplashOffsetPosition' has a wrong offset!");
static_assert(offsetof(AItemSplashObject, FireMotionCurve) == 0x0005D0, "Member 'AItemSplashObject::FireMotionCurve' has a wrong offset!");
static_assert(offsetof(AItemSplashObject, ProjectileClass) == 0x0005D8, "Member 'AItemSplashObject::ProjectileClass' has a wrong offset!");

// Class UnionRun.ItemStaticBodyComponent
// 0x0000 (0x0350 - 0x0350)
class UItemStaticBodyComponent final : public UCollisionBaseComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemStaticBodyComponent">();
	}
	static class UItemStaticBodyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemStaticBodyComponent>();
	}
};
static_assert(alignof(UItemStaticBodyComponent) == 0x000010, "Wrong alignment on UItemStaticBodyComponent");
static_assert(sizeof(UItemStaticBodyComponent) == 0x000350, "Wrong size on UItemStaticBodyComponent");

// Class UnionRun.ItemThornBallObject
// 0x01A0 (0x0710 - 0x0570)
class AItemThornBallObject : public AItemObjectBase
{
public:
	uint8                                         Pad_568[0x30];                                     // 0x0568(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   m_staticMeshComponent;                             // 0x0598(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGOCMovement*                           m_movement;                                        // 0x05A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTriggerComponent*                      m_triggerComponent;                                // 0x05A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemStaticBodyComponent*               m_staticBody;                                      // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_holderInvencibleTime;                            // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_largeTypeScale;                                  // 0x05BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_fallingDetectingOffsetFront;                     // 0x05C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_fallingDetectingOffsetFront_ToFlight;            // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FThrowingFrontParameter                m_maxFrontJumpParam_new;                           // 0x05C8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FThrowingFrontParameter                m_minFrontJumpParam_new;                           // 0x05D8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FRelativeMoveFrontParameter            m_relativeMoveParamFront;                          // 0x05E8(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FThrowingBackParameter                 m_backJumpParam_new;                               // 0x05F8(0x000C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRelativeMoveBackParameter             m_relativeMoveParamBack;                           // 0x0604(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         m_radius;                                          // 0x061C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_sinkLength;                                      // 0x0620(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_restitutionCoffi;                                // 0x0624(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_floatingHeight;                                  // 0x0628(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_floatingAngularSpeed;                            // 0x062C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_630[0xE0];                                     // 0x0630(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetHitSpeedRatio();
	void OnDeactiveBreakEffect();
	void OnPlayBreakEffect(float Scale);
	void OnPlayBreakSound();
	void OnPlayDamegeSound(ESoundPan SoundPan);
	void OnPlayLandingSound(bool waterFlag);
	void OnTriggerColliderConflict(const struct FHitTriggerInfo& HitInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemThornBallObject">();
	}
	static class AItemThornBallObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemThornBallObject>();
	}
};
static_assert(alignof(AItemThornBallObject) == 0x000010, "Wrong alignment on AItemThornBallObject");
static_assert(sizeof(AItemThornBallObject) == 0x000710, "Wrong size on AItemThornBallObject");
static_assert(offsetof(AItemThornBallObject, m_staticMeshComponent) == 0x000598, "Member 'AItemThornBallObject::m_staticMeshComponent' has a wrong offset!");
static_assert(offsetof(AItemThornBallObject, m_movement) == 0x0005A0, "Member 'AItemThornBallObject::m_movement' has a wrong offset!");
static_assert(offsetof(AItemThornBallObject, m_triggerComponent) == 0x0005A8, "Member 'AItemThornBallObject::m_triggerComponent' has a wrong offset!");
static_assert(offsetof(AItemThornBallObject, m_staticBody) == 0x0005B0, "Member 'AItemThornBallObject::m_staticBody' has a wrong offset!");
static_assert(offsetof(AItemThornBallObject, m_holderInvencibleTime) == 0x0005B8, "Member 'AItemThornBallObject::m_holderInvencibleTime' has a wrong offset!");
static_assert(offsetof(AItemThornBallObject, m_largeTypeScale) == 0x0005BC, "Member 'AItemThornBallObject::m_largeTypeScale' has a wrong offset!");
static_assert(offsetof(AItemThornBallObject, m_fallingDetectingOffsetFront) == 0x0005C0, "Member 'AItemThornBallObject::m_fallingDetectingOffsetFront' has a wrong offset!");
static_assert(offsetof(AItemThornBallObject, m_fallingDetectingOffsetFront_ToFlight) == 0x0005C4, "Member 'AItemThornBallObject::m_fallingDetectingOffsetFront_ToFlight' has a wrong offset!");
static_assert(offsetof(AItemThornBallObject, m_maxFrontJumpParam_new) == 0x0005C8, "Member 'AItemThornBallObject::m_maxFrontJumpParam_new' has a wrong offset!");
static_assert(offsetof(AItemThornBallObject, m_minFrontJumpParam_new) == 0x0005D8, "Member 'AItemThornBallObject::m_minFrontJumpParam_new' has a wrong offset!");
static_assert(offsetof(AItemThornBallObject, m_relativeMoveParamFront) == 0x0005E8, "Member 'AItemThornBallObject::m_relativeMoveParamFront' has a wrong offset!");
static_assert(offsetof(AItemThornBallObject, m_backJumpParam_new) == 0x0005F8, "Member 'AItemThornBallObject::m_backJumpParam_new' has a wrong offset!");
static_assert(offsetof(AItemThornBallObject, m_relativeMoveParamBack) == 0x000604, "Member 'AItemThornBallObject::m_relativeMoveParamBack' has a wrong offset!");
static_assert(offsetof(AItemThornBallObject, m_radius) == 0x00061C, "Member 'AItemThornBallObject::m_radius' has a wrong offset!");
static_assert(offsetof(AItemThornBallObject, m_sinkLength) == 0x000620, "Member 'AItemThornBallObject::m_sinkLength' has a wrong offset!");
static_assert(offsetof(AItemThornBallObject, m_restitutionCoffi) == 0x000624, "Member 'AItemThornBallObject::m_restitutionCoffi' has a wrong offset!");
static_assert(offsetof(AItemThornBallObject, m_floatingHeight) == 0x000628, "Member 'AItemThornBallObject::m_floatingHeight' has a wrong offset!");
static_assert(offsetof(AItemThornBallObject, m_floatingAngularSpeed) == 0x00062C, "Member 'AItemThornBallObject::m_floatingAngularSpeed' has a wrong offset!");

// Class UnionRun.UnionDamageManager
// 0x04D8 (0x0500 - 0x0028)
class UUnionDamageManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             DamageDataTable;                                   // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DamageReactionDataTable;                           // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x4C0];                                     // 0x0040(0x04C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionDamageManager">();
	}
	static class UUnionDamageManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionDamageManager>();
	}
};
static_assert(alignof(UUnionDamageManager) == 0x000008, "Wrong alignment on UUnionDamageManager");
static_assert(sizeof(UUnionDamageManager) == 0x000500, "Wrong size on UUnionDamageManager");
static_assert(offsetof(UUnionDamageManager, DamageDataTable) == 0x000030, "Member 'UUnionDamageManager::DamageDataTable' has a wrong offset!");
static_assert(offsetof(UUnionDamageManager, DamageReactionDataTable) == 0x000038, "Member 'UUnionDamageManager::DamageReactionDataTable' has a wrong offset!");

// Class UnionRun.ItemTimeBombObject
// 0x0050 (0x05C0 - 0x0570)
class AItemTimeBombObject : public AItemObjectBase
{
public:
	class UStaticMeshComponent*                   m_staticMeshComponent;                             // 0x0568(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_570[0x50];                                     // 0x0570(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemTimeBombObject">();
	}
	static class AItemTimeBombObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemTimeBombObject>();
	}
};
static_assert(alignof(AItemTimeBombObject) == 0x000010, "Wrong alignment on AItemTimeBombObject");
static_assert(sizeof(AItemTimeBombObject) == 0x0005C0, "Wrong size on AItemTimeBombObject");
static_assert(offsetof(AItemTimeBombObject, m_staticMeshComponent) == 0x000568, "Member 'AItemTimeBombObject::m_staticMeshComponent' has a wrong offset!");

// Class UnionRun.ItemTripleWhiteBoostObject
// 0x0060 (0x05D0 - 0x0570)
class AItemTripleWhiteBoostObject : public AItemObjectBase
{
public:
	float                                         m_IntervalTile;                                    // 0x0568(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_WaitInput;                                       // 0x056C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_570[0x60];                                     // 0x0570(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayUsedItemSound();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemTripleWhiteBoostObject">();
	}
	static class AItemTripleWhiteBoostObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemTripleWhiteBoostObject>();
	}
};
static_assert(alignof(AItemTripleWhiteBoostObject) == 0x000010, "Wrong alignment on AItemTripleWhiteBoostObject");
static_assert(sizeof(AItemTripleWhiteBoostObject) == 0x0005D0, "Wrong size on AItemTripleWhiteBoostObject");
static_assert(offsetof(AItemTripleWhiteBoostObject, m_IntervalTile) == 0x000568, "Member 'AItemTripleWhiteBoostObject::m_IntervalTile' has a wrong offset!");
static_assert(offsetof(AItemTripleWhiteBoostObject, m_WaitInput) == 0x00056C, "Member 'AItemTripleWhiteBoostObject::m_WaitInput' has a wrong offset!");

// Class UnionRun.UnionGroupInfoInterface
// 0x0000 (0x0000 - 0x0000)
class IUnionGroupInfoInterface final
{
public:
	void NoticeCompletedChargeGroupEvent(int32 RacerIndex, ETeamBoostType TeamBoostType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionGroupInfoInterface">();
	}
	static class IUnionGroupInfoInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUnionGroupInfoInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IUnionGroupInfoInterface) == 0x000001, "Wrong alignment on IUnionGroupInfoInterface");
static_assert(sizeof(IUnionGroupInfoInterface) == 0x000001, "Wrong size on IUnionGroupInfoInterface");

// Class UnionRun.ItemVioletVoidAbsorbedObject
// 0x0240 (0x04D0 - 0x0290)
class alignas(0x10) AItemVioletVoidAbsorbedObject : public AActor
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Root;                                              // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        MeshRoot;                                          // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              MeshComponent;                                     // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPrepairMoveSpeed;                               // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAbsorbTime;                                     // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveRotateMaxAngle;                                // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAbsorbTime;                                     // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveRotateAngularSpeed;                            // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshRotateSpeed;                                   // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveLocalPosZAmplitude;                            // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC[0x204];                                    // 0x02CC(0x0204)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemVioletVoidAbsorbedObject">();
	}
	static class AItemVioletVoidAbsorbedObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemVioletVoidAbsorbedObject>();
	}
};
static_assert(alignof(AItemVioletVoidAbsorbedObject) == 0x000010, "Wrong alignment on AItemVioletVoidAbsorbedObject");
static_assert(sizeof(AItemVioletVoidAbsorbedObject) == 0x0004D0, "Wrong size on AItemVioletVoidAbsorbedObject");
static_assert(offsetof(AItemVioletVoidAbsorbedObject, Root) == 0x000298, "Member 'AItemVioletVoidAbsorbedObject::Root' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidAbsorbedObject, MeshRoot) == 0x0002A0, "Member 'AItemVioletVoidAbsorbedObject::MeshRoot' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidAbsorbedObject, MeshComponent) == 0x0002A8, "Member 'AItemVioletVoidAbsorbedObject::MeshComponent' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidAbsorbedObject, MaxPrepairMoveSpeed) == 0x0002B0, "Member 'AItemVioletVoidAbsorbedObject::MaxPrepairMoveSpeed' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidAbsorbedObject, MaxAbsorbTime) == 0x0002B4, "Member 'AItemVioletVoidAbsorbedObject::MaxAbsorbTime' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidAbsorbedObject, MoveRotateMaxAngle) == 0x0002B8, "Member 'AItemVioletVoidAbsorbedObject::MoveRotateMaxAngle' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidAbsorbedObject, MinAbsorbTime) == 0x0002BC, "Member 'AItemVioletVoidAbsorbedObject::MinAbsorbTime' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidAbsorbedObject, MoveRotateAngularSpeed) == 0x0002C0, "Member 'AItemVioletVoidAbsorbedObject::MoveRotateAngularSpeed' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidAbsorbedObject, MeshRotateSpeed) == 0x0002C4, "Member 'AItemVioletVoidAbsorbedObject::MeshRotateSpeed' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidAbsorbedObject, MoveLocalPosZAmplitude) == 0x0002C8, "Member 'AItemVioletVoidAbsorbedObject::MoveLocalPosZAmplitude' has a wrong offset!");

// Class UnionRun.ItemVioletVoidObject
// 0x0170 (0x06E0 - 0x0570)
class AItemVioletVoidObject : public AItemObjectBase
{
public:
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Root;                                              // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        AbsorbCenter;                                      // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 VioletVoidMesh;                                    // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   VioletVoidAuraMesh;                                // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemStaticBodyComponent*               StaticBody;                                        // 0x0590(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTriggerComponent*                      Trigger;                                           // 0x0598(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    EatSound;                                          // 0x05A0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGOCMovement*                           MovementRoot;                                      // 0x05A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemCountDownComponent*                CountDown;                                         // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CountDownTime;                                     // 0x05B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectRadius;                                      // 0x05BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectHeight;                                      // 0x05C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C4[0x4];                                      // 0x05C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ConstantAbsorbLoactionA;                           // 0x05C8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConstantAbsorbStartTimeA;                          // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E4[0x4];                                      // 0x05E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ConstantAbsorbLoactionB;                           // 0x05E8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConstantAbsorbStartTimeB;                          // 0x0600(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConstantAbsorbInterval;                            // 0x0604(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ConstantAbsorbInitScale;                           // 0x0608(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ConstantAbsorbTargetScale;                         // 0x0620(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConstantAbsorbOnlyOwnerSee;                       // 0x0638(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_639[0x3];                                      // 0x0639(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DestroyEndPositionOffsetX;                         // 0x063C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestroyEndPositionOffsetZ;                         // 0x0640(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestroyWaitTime;                                   // 0x0644(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestroyWaitMoveOffset;                             // 0x0648(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64C[0x4];                                      // 0x064C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AItemVioletVoidAbsorbedObject> ItemVioletVoidAbsorbedObjectClass;              // 0x0650(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            ConstantAbsorbMesh;                                // 0x0658(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDraw;                                        // 0x0660(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugForcePlayMeshAnimation;                      // 0x0661(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_662[0x7E];                                     // 0x0662(0x007E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsMeshAnimEating();
	bool IsMeshAnimInSleep();
	void OnTriggerColliderConflict(const struct FHitTriggerInfo& HitInfo);
	void PlaySE(class FName SEName);
	void RequestMeshAnimAppearance(bool bAppearance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemVioletVoidObject">();
	}
	static class AItemVioletVoidObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemVioletVoidObject>();
	}
};
static_assert(alignof(AItemVioletVoidObject) == 0x000010, "Wrong alignment on AItemVioletVoidObject");
static_assert(sizeof(AItemVioletVoidObject) == 0x0006E0, "Wrong size on AItemVioletVoidObject");
static_assert(offsetof(AItemVioletVoidObject, Root) == 0x000570, "Member 'AItemVioletVoidObject::Root' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidObject, AbsorbCenter) == 0x000578, "Member 'AItemVioletVoidObject::AbsorbCenter' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidObject, VioletVoidMesh) == 0x000580, "Member 'AItemVioletVoidObject::VioletVoidMesh' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidObject, VioletVoidAuraMesh) == 0x000588, "Member 'AItemVioletVoidObject::VioletVoidAuraMesh' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidObject, StaticBody) == 0x000590, "Member 'AItemVioletVoidObject::StaticBody' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidObject, Trigger) == 0x000598, "Member 'AItemVioletVoidObject::Trigger' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidObject, EatSound) == 0x0005A0, "Member 'AItemVioletVoidObject::EatSound' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidObject, MovementRoot) == 0x0005A8, "Member 'AItemVioletVoidObject::MovementRoot' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidObject, CountDown) == 0x0005B0, "Member 'AItemVioletVoidObject::CountDown' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidObject, CountDownTime) == 0x0005B8, "Member 'AItemVioletVoidObject::CountDownTime' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidObject, EffectRadius) == 0x0005BC, "Member 'AItemVioletVoidObject::EffectRadius' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidObject, EffectHeight) == 0x0005C0, "Member 'AItemVioletVoidObject::EffectHeight' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidObject, ConstantAbsorbLoactionA) == 0x0005C8, "Member 'AItemVioletVoidObject::ConstantAbsorbLoactionA' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidObject, ConstantAbsorbStartTimeA) == 0x0005E0, "Member 'AItemVioletVoidObject::ConstantAbsorbStartTimeA' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidObject, ConstantAbsorbLoactionB) == 0x0005E8, "Member 'AItemVioletVoidObject::ConstantAbsorbLoactionB' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidObject, ConstantAbsorbStartTimeB) == 0x000600, "Member 'AItemVioletVoidObject::ConstantAbsorbStartTimeB' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidObject, ConstantAbsorbInterval) == 0x000604, "Member 'AItemVioletVoidObject::ConstantAbsorbInterval' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidObject, ConstantAbsorbInitScale) == 0x000608, "Member 'AItemVioletVoidObject::ConstantAbsorbInitScale' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidObject, ConstantAbsorbTargetScale) == 0x000620, "Member 'AItemVioletVoidObject::ConstantAbsorbTargetScale' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidObject, bConstantAbsorbOnlyOwnerSee) == 0x000638, "Member 'AItemVioletVoidObject::bConstantAbsorbOnlyOwnerSee' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidObject, DestroyEndPositionOffsetX) == 0x00063C, "Member 'AItemVioletVoidObject::DestroyEndPositionOffsetX' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidObject, DestroyEndPositionOffsetZ) == 0x000640, "Member 'AItemVioletVoidObject::DestroyEndPositionOffsetZ' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidObject, DestroyWaitTime) == 0x000644, "Member 'AItemVioletVoidObject::DestroyWaitTime' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidObject, DestroyWaitMoveOffset) == 0x000648, "Member 'AItemVioletVoidObject::DestroyWaitMoveOffset' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidObject, ItemVioletVoidAbsorbedObjectClass) == 0x000650, "Member 'AItemVioletVoidObject::ItemVioletVoidAbsorbedObjectClass' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidObject, ConstantAbsorbMesh) == 0x000658, "Member 'AItemVioletVoidObject::ConstantAbsorbMesh' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidObject, bDebugDraw) == 0x000660, "Member 'AItemVioletVoidObject::bDebugDraw' has a wrong offset!");
static_assert(offsetof(AItemVioletVoidObject, bDebugForcePlayMeshAnimation) == 0x000661, "Member 'AItemVioletVoidObject::bDebugForcePlayMeshAnimation' has a wrong offset!");

// Class UnionRun.UseItemUIDataAsset
// 0x0068 (0x0098 - 0x0030)
class UUseItemUIDataAsset final : public UDataAsset
{
public:
	float                                         DisableUIAdvancedTime;                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EItemId>                               TargetItemId_RunOff;                               // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EItemId>                               TargetItemId_PerformanceAlart;                     // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EItemId>                               TargetItemId_PerformanceAttack_Common;             // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EItemId>                               TargetItemId_PerformanceAttack_ExcludeWarpRing;    // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EItemId>                               TargetItemId_BodyCut;                              // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EItemId>                               TargetItemId_KingBoomBoo;                          // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UseItemUIDataAsset">();
	}
	static class UUseItemUIDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUseItemUIDataAsset>();
	}
};
static_assert(alignof(UUseItemUIDataAsset) == 0x000008, "Wrong alignment on UUseItemUIDataAsset");
static_assert(sizeof(UUseItemUIDataAsset) == 0x000098, "Wrong size on UUseItemUIDataAsset");
static_assert(offsetof(UUseItemUIDataAsset, DisableUIAdvancedTime) == 0x000030, "Member 'UUseItemUIDataAsset::DisableUIAdvancedTime' has a wrong offset!");
static_assert(offsetof(UUseItemUIDataAsset, TargetItemId_RunOff) == 0x000038, "Member 'UUseItemUIDataAsset::TargetItemId_RunOff' has a wrong offset!");
static_assert(offsetof(UUseItemUIDataAsset, TargetItemId_PerformanceAlart) == 0x000048, "Member 'UUseItemUIDataAsset::TargetItemId_PerformanceAlart' has a wrong offset!");
static_assert(offsetof(UUseItemUIDataAsset, TargetItemId_PerformanceAttack_Common) == 0x000058, "Member 'UUseItemUIDataAsset::TargetItemId_PerformanceAttack_Common' has a wrong offset!");
static_assert(offsetof(UUseItemUIDataAsset, TargetItemId_PerformanceAttack_ExcludeWarpRing) == 0x000068, "Member 'UUseItemUIDataAsset::TargetItemId_PerformanceAttack_ExcludeWarpRing' has a wrong offset!");
static_assert(offsetof(UUseItemUIDataAsset, TargetItemId_BodyCut) == 0x000078, "Member 'UUseItemUIDataAsset::TargetItemId_BodyCut' has a wrong offset!");
static_assert(offsetof(UUseItemUIDataAsset, TargetItemId_KingBoomBoo) == 0x000088, "Member 'UUseItemUIDataAsset::TargetItemId_KingBoomBoo' has a wrong offset!");

// Class UnionRun.ItemWarpRingObject
// 0x0230 (0x07A0 - 0x0570)
class AItemWarpRingObject : public AItemObjectBase
{
public:
	uint8                                         Pad_568[0x10];                                     // 0x0568(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Root;                                              // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        PerformanceObjectRoot;                             // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGOCMovement*                           Movement;                                          // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    SEWarping;                                         // 0x0590(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAtomComponent*                    SEWarpingLocal;                                    // 0x0598(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FItemWarpRingRankBaseParam>     RankBaseParam;                                     // 0x05A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MinLifeTimeNoTarget;                               // 0x05B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpLandingTime;                                   // 0x05B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpLandingTime_YellowDrill;                       // 0x05B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpLandingTime_MonsterTruck;                      // 0x05BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveToPathMaxTime;                                 // 0x05C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveToPathAdjustDistanceTime;                      // 0x05C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveToPathAdjustDistance;                          // 0x05C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveToPathAdjustDistanceAvoided;                   // 0x05CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveToPathAdjustDistanceCanceled;                  // 0x05D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveToPathRotateAddSpeed;                          // 0x05D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveToPathRotateMaxSpeed;                          // 0x05D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingDistance;                                    // 0x05DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingDistancePath;                                // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloseDistance;                                     // 0x05E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvailableTargetChaseMaxTime;                       // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallAcceleration;                                  // 0x05EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFallSpeed;                                      // 0x05F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateSpeed;                                       // 0x05F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackCancelTime;                                  // 0x05F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        CommonMoveSpeed;                                   // 0x05FC(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        PerformanceMoveSpeed;                              // 0x060C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        NoTargetMoveSpeed;                                 // 0x061C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        AvoidedMoveSpeed;                                  // 0x062C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         EndCameraRemoveTiming;                             // 0x063C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            JumpLandindCurve;                                  // 0x0640(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDraw;                                        // 0x0648(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceEnd;                                         // 0x0649(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceEndImm;                                      // 0x064A(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInfinityWarp;                                     // 0x064B(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64C[0x4];                                      // 0x064C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AUnionCameraWarpRing>       StartCameraClass;                                  // 0x0650(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AUnionCameraCarCamOffset>   EndCameraClass;                                    // 0x0658(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AUnionCameraFocusOnTarget>  EndAttackCameraClass;                              // 0x0660(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AUnionCameraWarpRing*                   StartCameraObject;                                 // 0x0668(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUnionCameraCarCamOffset*               EndCameraObject;                                   // 0x0670(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AUnionCameraFocusOnTarget*              EndAttackCameraObject;                             // 0x0678(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_680[0x120];                                    // 0x0680(0x0120)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHitTriggerColliderConflict(const struct FHitTriggerInfo& HitInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemWarpRingObject">();
	}
	static class AItemWarpRingObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemWarpRingObject>();
	}
};
static_assert(alignof(AItemWarpRingObject) == 0x000010, "Wrong alignment on AItemWarpRingObject");
static_assert(sizeof(AItemWarpRingObject) == 0x0007A0, "Wrong size on AItemWarpRingObject");
static_assert(offsetof(AItemWarpRingObject, Root) == 0x000578, "Member 'AItemWarpRingObject::Root' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, PerformanceObjectRoot) == 0x000580, "Member 'AItemWarpRingObject::PerformanceObjectRoot' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, Movement) == 0x000588, "Member 'AItemWarpRingObject::Movement' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, SEWarping) == 0x000590, "Member 'AItemWarpRingObject::SEWarping' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, SEWarpingLocal) == 0x000598, "Member 'AItemWarpRingObject::SEWarpingLocal' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, RankBaseParam) == 0x0005A0, "Member 'AItemWarpRingObject::RankBaseParam' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, MinLifeTimeNoTarget) == 0x0005B0, "Member 'AItemWarpRingObject::MinLifeTimeNoTarget' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, JumpLandingTime) == 0x0005B4, "Member 'AItemWarpRingObject::JumpLandingTime' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, JumpLandingTime_YellowDrill) == 0x0005B8, "Member 'AItemWarpRingObject::JumpLandingTime_YellowDrill' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, JumpLandingTime_MonsterTruck) == 0x0005BC, "Member 'AItemWarpRingObject::JumpLandingTime_MonsterTruck' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, MoveToPathMaxTime) == 0x0005C0, "Member 'AItemWarpRingObject::MoveToPathMaxTime' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, MoveToPathAdjustDistanceTime) == 0x0005C4, "Member 'AItemWarpRingObject::MoveToPathAdjustDistanceTime' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, MoveToPathAdjustDistance) == 0x0005C8, "Member 'AItemWarpRingObject::MoveToPathAdjustDistance' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, MoveToPathAdjustDistanceAvoided) == 0x0005CC, "Member 'AItemWarpRingObject::MoveToPathAdjustDistanceAvoided' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, MoveToPathAdjustDistanceCanceled) == 0x0005D0, "Member 'AItemWarpRingObject::MoveToPathAdjustDistanceCanceled' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, MoveToPathRotateAddSpeed) == 0x0005D4, "Member 'AItemWarpRingObject::MoveToPathRotateAddSpeed' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, MoveToPathRotateMaxSpeed) == 0x0005D8, "Member 'AItemWarpRingObject::MoveToPathRotateMaxSpeed' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, HomingDistance) == 0x0005DC, "Member 'AItemWarpRingObject::HomingDistance' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, HomingDistancePath) == 0x0005E0, "Member 'AItemWarpRingObject::HomingDistancePath' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, CloseDistance) == 0x0005E4, "Member 'AItemWarpRingObject::CloseDistance' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, AvailableTargetChaseMaxTime) == 0x0005E8, "Member 'AItemWarpRingObject::AvailableTargetChaseMaxTime' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, FallAcceleration) == 0x0005EC, "Member 'AItemWarpRingObject::FallAcceleration' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, MaxFallSpeed) == 0x0005F0, "Member 'AItemWarpRingObject::MaxFallSpeed' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, RotateSpeed) == 0x0005F4, "Member 'AItemWarpRingObject::RotateSpeed' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, AttackCancelTime) == 0x0005F8, "Member 'AItemWarpRingObject::AttackCancelTime' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, CommonMoveSpeed) == 0x0005FC, "Member 'AItemWarpRingObject::CommonMoveSpeed' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, PerformanceMoveSpeed) == 0x00060C, "Member 'AItemWarpRingObject::PerformanceMoveSpeed' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, NoTargetMoveSpeed) == 0x00061C, "Member 'AItemWarpRingObject::NoTargetMoveSpeed' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, AvoidedMoveSpeed) == 0x00062C, "Member 'AItemWarpRingObject::AvoidedMoveSpeed' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, EndCameraRemoveTiming) == 0x00063C, "Member 'AItemWarpRingObject::EndCameraRemoveTiming' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, JumpLandindCurve) == 0x000640, "Member 'AItemWarpRingObject::JumpLandindCurve' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, bDebugDraw) == 0x000648, "Member 'AItemWarpRingObject::bDebugDraw' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, bForceEnd) == 0x000649, "Member 'AItemWarpRingObject::bForceEnd' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, bForceEndImm) == 0x00064A, "Member 'AItemWarpRingObject::bForceEndImm' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, bInfinityWarp) == 0x00064B, "Member 'AItemWarpRingObject::bInfinityWarp' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, StartCameraClass) == 0x000650, "Member 'AItemWarpRingObject::StartCameraClass' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, EndCameraClass) == 0x000658, "Member 'AItemWarpRingObject::EndCameraClass' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, EndAttackCameraClass) == 0x000660, "Member 'AItemWarpRingObject::EndAttackCameraClass' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, StartCameraObject) == 0x000668, "Member 'AItemWarpRingObject::StartCameraObject' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, EndCameraObject) == 0x000670, "Member 'AItemWarpRingObject::EndCameraObject' has a wrong offset!");
static_assert(offsetof(AItemWarpRingObject, EndAttackCameraObject) == 0x000678, "Member 'AItemWarpRingObject::EndAttackCameraObject' has a wrong offset!");

// Class UnionRun.ItemWeightObject
// 0x0110 (0x0680 - 0x0570)
class AItemWeightObject : public AItemObjectBase
{
public:
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        Root;                                              // 0x0570(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   Mesh;                                              // 0x0578(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChildActorComponent*                   Ring;                                              // 0x0580(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowRingMaxScale;                                 // 0x0588(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowRingAppearTime;                               // 0x058C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowRingDisappearTime;                            // 0x0590(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowObjectMoveTime;                               // 0x0594(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowOverDistance;                                 // 0x0598(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59C[0x4];                                      // 0x059C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           ThrowCurve;                                        // 0x05A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A8[0xD8];                                     // 0x05A8(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemWeightObject">();
	}
	static class AItemWeightObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemWeightObject>();
	}
};
static_assert(alignof(AItemWeightObject) == 0x000010, "Wrong alignment on AItemWeightObject");
static_assert(sizeof(AItemWeightObject) == 0x000680, "Wrong size on AItemWeightObject");
static_assert(offsetof(AItemWeightObject, Root) == 0x000570, "Member 'AItemWeightObject::Root' has a wrong offset!");
static_assert(offsetof(AItemWeightObject, Mesh) == 0x000578, "Member 'AItemWeightObject::Mesh' has a wrong offset!");
static_assert(offsetof(AItemWeightObject, Ring) == 0x000580, "Member 'AItemWeightObject::Ring' has a wrong offset!");
static_assert(offsetof(AItemWeightObject, ThrowRingMaxScale) == 0x000588, "Member 'AItemWeightObject::ThrowRingMaxScale' has a wrong offset!");
static_assert(offsetof(AItemWeightObject, ThrowRingAppearTime) == 0x00058C, "Member 'AItemWeightObject::ThrowRingAppearTime' has a wrong offset!");
static_assert(offsetof(AItemWeightObject, ThrowRingDisappearTime) == 0x000590, "Member 'AItemWeightObject::ThrowRingDisappearTime' has a wrong offset!");
static_assert(offsetof(AItemWeightObject, ThrowObjectMoveTime) == 0x000594, "Member 'AItemWeightObject::ThrowObjectMoveTime' has a wrong offset!");
static_assert(offsetof(AItemWeightObject, ThrowOverDistance) == 0x000598, "Member 'AItemWeightObject::ThrowOverDistance' has a wrong offset!");
static_assert(offsetof(AItemWeightObject, ThrowCurve) == 0x0005A0, "Member 'AItemWeightObject::ThrowCurve' has a wrong offset!");

// Class UnionRun.ItemYellowDrillObject
// 0x00D0 (0x0640 - 0x0570)
class AItemYellowDrillObject : public AItemObjectBase
{
public:
	float                                         m_UpperRate;                                       // 0x0568(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         m_MiddleRate;                                      // 0x056C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         m_UpperItemSeconds;                                // 0x0570(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         m_MiddleItemSeconds;                               // 0x0574(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         m_LowerItemSeconds;                                // 0x0578(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         m_MinKeepSeconds;                                  // 0x057C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<float, float>                            m_ItemSecondsList;                                 // 0x0580(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	int32                                         m_OverTakeNumToForceFinish;                        // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         m_DecelerationSeconds;                             // 0x05D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D8[0x68];                                     // 0x05D8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlaySound();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemYellowDrillObject">();
	}
	static class AItemYellowDrillObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemYellowDrillObject>();
	}
};
static_assert(alignof(AItemYellowDrillObject) == 0x000010, "Wrong alignment on AItemYellowDrillObject");
static_assert(sizeof(AItemYellowDrillObject) == 0x000640, "Wrong size on AItemYellowDrillObject");
static_assert(offsetof(AItemYellowDrillObject, m_UpperRate) == 0x000568, "Member 'AItemYellowDrillObject::m_UpperRate' has a wrong offset!");
static_assert(offsetof(AItemYellowDrillObject, m_MiddleRate) == 0x00056C, "Member 'AItemYellowDrillObject::m_MiddleRate' has a wrong offset!");
static_assert(offsetof(AItemYellowDrillObject, m_UpperItemSeconds) == 0x000570, "Member 'AItemYellowDrillObject::m_UpperItemSeconds' has a wrong offset!");
static_assert(offsetof(AItemYellowDrillObject, m_MiddleItemSeconds) == 0x000574, "Member 'AItemYellowDrillObject::m_MiddleItemSeconds' has a wrong offset!");
static_assert(offsetof(AItemYellowDrillObject, m_LowerItemSeconds) == 0x000578, "Member 'AItemYellowDrillObject::m_LowerItemSeconds' has a wrong offset!");
static_assert(offsetof(AItemYellowDrillObject, m_MinKeepSeconds) == 0x00057C, "Member 'AItemYellowDrillObject::m_MinKeepSeconds' has a wrong offset!");
static_assert(offsetof(AItemYellowDrillObject, m_ItemSecondsList) == 0x000580, "Member 'AItemYellowDrillObject::m_ItemSecondsList' has a wrong offset!");
static_assert(offsetof(AItemYellowDrillObject, m_OverTakeNumToForceFinish) == 0x0005D0, "Member 'AItemYellowDrillObject::m_OverTakeNumToForceFinish' has a wrong offset!");
static_assert(offsetof(AItemYellowDrillObject, m_DecelerationSeconds) == 0x0005D4, "Member 'AItemYellowDrillObject::m_DecelerationSeconds' has a wrong offset!");

// Class UnionRun.UnionGimmickSystemManager
// 0x15E0 (0x1608 - 0x0028)
class UUnionGimmickSystemManager final : public UObject
{
public:
	uint8                                         Pad_28[0x13E0];                                    // 0x0028(0x13E0)(Fixing Size After Last Property [ Dumper-7 ])
	class AItemBoxEffectObject*                   m_itemBoxEffectObject;                             // 0x1408(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1410[0x1F8];                                   // 0x1410(0x01F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionGimmickSystemManager">();
	}
	static class UUnionGimmickSystemManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionGimmickSystemManager>();
	}
};
static_assert(alignof(UUnionGimmickSystemManager) == 0x000008, "Wrong alignment on UUnionGimmickSystemManager");
static_assert(sizeof(UUnionGimmickSystemManager) == 0x001608, "Wrong size on UUnionGimmickSystemManager");
static_assert(offsetof(UUnionGimmickSystemManager, m_itemBoxEffectObject) == 0x001408, "Member 'UUnionGimmickSystemManager::m_itemBoxEffectObject' has a wrong offset!");

// Class UnionRun.JumpStand
// 0x0018 (0x0358 - 0x0340)
class AJumpStand final : public AUnionCourseObjectBase
{
public:
	class UUnionStaticMeshComponent*              DrawStaticMeshComponent;                           // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0348(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EJumpStandSize                                JumpStandSize;                                     // 0x0350(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EJumpStandType                                JumpStandType;                                     // 0x0351(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsGravity;                                        // 0x0352(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsDash;                                           // 0x0353(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseMeshBySize;                                    // 0x0354(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bNoCollision;                                      // 0x0355(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCollisionOnly;                                    // 0x0356(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_357[0x1];                                      // 0x0357(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JumpStand">();
	}
	static class AJumpStand* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJumpStand>();
	}
};
static_assert(alignof(AJumpStand) == 0x000008, "Wrong alignment on AJumpStand");
static_assert(sizeof(AJumpStand) == 0x000358, "Wrong size on AJumpStand");
static_assert(offsetof(AJumpStand, DrawStaticMeshComponent) == 0x000340, "Member 'AJumpStand::DrawStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AJumpStand, DefaultSceneRoot) == 0x000348, "Member 'AJumpStand::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AJumpStand, JumpStandSize) == 0x000350, "Member 'AJumpStand::JumpStandSize' has a wrong offset!");
static_assert(offsetof(AJumpStand, JumpStandType) == 0x000351, "Member 'AJumpStand::JumpStandType' has a wrong offset!");
static_assert(offsetof(AJumpStand, bIsGravity) == 0x000352, "Member 'AJumpStand::bIsGravity' has a wrong offset!");
static_assert(offsetof(AJumpStand, bIsDash) == 0x000353, "Member 'AJumpStand::bIsDash' has a wrong offset!");
static_assert(offsetof(AJumpStand, bUseMeshBySize) == 0x000354, "Member 'AJumpStand::bUseMeshBySize' has a wrong offset!");
static_assert(offsetof(AJumpStand, bNoCollision) == 0x000355, "Member 'AJumpStand::bNoCollision' has a wrong offset!");
static_assert(offsetof(AJumpStand, bCollisionOnly) == 0x000356, "Member 'AJumpStand::bCollisionOnly' has a wrong offset!");

// Class UnionRun.ItemSystemObjDataAsset
// 0x00C8 (0x00F8 - 0x0030)
class UItemSystemObjDataAsset final : public UDataAsset
{
public:
	TSoftClassPtr<class UClass>                   LotteryObjectClass;                                // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   BootDataObjectClass;                               // 0x0058(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DroppedItemBoxFactoryClass;                        // 0x0080(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   OmochaoDroppedRingClass;                           // 0x00A8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   VioletVoidAbsorbedObjectClass;                     // 0x00D0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSystemObjDataAsset">();
	}
	static class UItemSystemObjDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemSystemObjDataAsset>();
	}
};
static_assert(alignof(UItemSystemObjDataAsset) == 0x000008, "Wrong alignment on UItemSystemObjDataAsset");
static_assert(sizeof(UItemSystemObjDataAsset) == 0x0000F8, "Wrong size on UItemSystemObjDataAsset");
static_assert(offsetof(UItemSystemObjDataAsset, LotteryObjectClass) == 0x000030, "Member 'UItemSystemObjDataAsset::LotteryObjectClass' has a wrong offset!");
static_assert(offsetof(UItemSystemObjDataAsset, BootDataObjectClass) == 0x000058, "Member 'UItemSystemObjDataAsset::BootDataObjectClass' has a wrong offset!");
static_assert(offsetof(UItemSystemObjDataAsset, DroppedItemBoxFactoryClass) == 0x000080, "Member 'UItemSystemObjDataAsset::DroppedItemBoxFactoryClass' has a wrong offset!");
static_assert(offsetof(UItemSystemObjDataAsset, OmochaoDroppedRingClass) == 0x0000A8, "Member 'UItemSystemObjDataAsset::OmochaoDroppedRingClass' has a wrong offset!");
static_assert(offsetof(UItemSystemObjDataAsset, VioletVoidAbsorbedObjectClass) == 0x0000D0, "Member 'UItemSystemObjDataAsset::VioletVoidAbsorbedObjectClass' has a wrong offset!");

// Class UnionRun.KingBoomBooProjectile
// 0x0060 (0x05D0 - 0x0570)
class AKingBoomBooProjectile : public AItemObjectBase
{
public:
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0568(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      TargetEffectComponent;                             // 0x0570(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      PillarEffectComponent;                             // 0x0578(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      EndEffectComponent;                                // 0x0580(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERacerDamageType                              DamageType;                                        // 0x0588(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_589[0x7];                                      // 0x0589(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTriggerComponent*                      TriggerComponent;                                  // 0x0590(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_598[0x38];                                     // 0x0598(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTriggerColliderConflict(const struct FHitTriggerInfo& HitInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KingBoomBooProjectile">();
	}
	static class AKingBoomBooProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKingBoomBooProjectile>();
	}
};
static_assert(alignof(AKingBoomBooProjectile) == 0x000010, "Wrong alignment on AKingBoomBooProjectile");
static_assert(sizeof(AKingBoomBooProjectile) == 0x0005D0, "Wrong size on AKingBoomBooProjectile");
static_assert(offsetof(AKingBoomBooProjectile, DefaultSceneRoot) == 0x000568, "Member 'AKingBoomBooProjectile::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AKingBoomBooProjectile, TargetEffectComponent) == 0x000570, "Member 'AKingBoomBooProjectile::TargetEffectComponent' has a wrong offset!");
static_assert(offsetof(AKingBoomBooProjectile, PillarEffectComponent) == 0x000578, "Member 'AKingBoomBooProjectile::PillarEffectComponent' has a wrong offset!");
static_assert(offsetof(AKingBoomBooProjectile, EndEffectComponent) == 0x000580, "Member 'AKingBoomBooProjectile::EndEffectComponent' has a wrong offset!");
static_assert(offsetof(AKingBoomBooProjectile, DamageType) == 0x000588, "Member 'AKingBoomBooProjectile::DamageType' has a wrong offset!");
static_assert(offsetof(AKingBoomBooProjectile, TriggerComponent) == 0x000590, "Member 'AKingBoomBooProjectile::TriggerComponent' has a wrong offset!");

// Class UnionRun.LapChangeObject
// 0x0000 (0x0340 - 0x0340)
class ALapChangeObject final : public AUnionCourseObjectBase
{
public:
	void OnFinalLapEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LapChangeObject">();
	}
	static class ALapChangeObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALapChangeObject>();
	}
};
static_assert(alignof(ALapChangeObject) == 0x000008, "Wrong alignment on ALapChangeObject");
static_assert(sizeof(ALapChangeObject) == 0x000340, "Wrong size on ALapChangeObject");

// Class UnionRun.UnionMoveRelativeRacer
// 0x00C8 (0x0100 - 0x0038)
class UUnionMoveRelativeRacer final : public UMoveController
{
public:
	uint8                                         Pad_38[0xC8];                                      // 0x0038(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionMoveRelativeRacer">();
	}
	static class UUnionMoveRelativeRacer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionMoveRelativeRacer>();
	}
};
static_assert(alignof(UUnionMoveRelativeRacer) == 0x000008, "Wrong alignment on UUnionMoveRelativeRacer");
static_assert(sizeof(UUnionMoveRelativeRacer) == 0x000100, "Wrong size on UUnionMoveRelativeRacer");

// Class UnionRun.LineGuide
// 0x0080 (0x0630 - 0x05B0)
class alignas(0x10) ALineGuide final : public AUnionGimmickObjectBase
{
public:
	class UHierarchicalInstancedStaticMeshComponent* HierarchicalInstancedStaticMeshComponent;       // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ZOffset;                                           // 0x05B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NumVisible;                                        // 0x05BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         IntervalFrames;                                    // 0x05C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C4[0x4];                                      // 0x05C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InstanceScale;                                     // 0x05C8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinDistance;                                       // 0x05E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E4[0x4];                                      // 0x05E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             DataTable;                                         // 0x05E8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F0[0x18];                                     // 0x05F0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ULineGuideDataAsset*                    DataAsset;                                         // 0x0608(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_610[0x8];                                      // 0x0610(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransform>                     InstanceTransforms;                                // 0x0618(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_628[0x8];                                      // 0x0628(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LineGuide">();
	}
	static class ALineGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALineGuide>();
	}
};
static_assert(alignof(ALineGuide) == 0x000010, "Wrong alignment on ALineGuide");
static_assert(sizeof(ALineGuide) == 0x000630, "Wrong size on ALineGuide");
static_assert(offsetof(ALineGuide, HierarchicalInstancedStaticMeshComponent) == 0x0005B0, "Member 'ALineGuide::HierarchicalInstancedStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(ALineGuide, ZOffset) == 0x0005B8, "Member 'ALineGuide::ZOffset' has a wrong offset!");
static_assert(offsetof(ALineGuide, NumVisible) == 0x0005BC, "Member 'ALineGuide::NumVisible' has a wrong offset!");
static_assert(offsetof(ALineGuide, IntervalFrames) == 0x0005C0, "Member 'ALineGuide::IntervalFrames' has a wrong offset!");
static_assert(offsetof(ALineGuide, InstanceScale) == 0x0005C8, "Member 'ALineGuide::InstanceScale' has a wrong offset!");
static_assert(offsetof(ALineGuide, MinDistance) == 0x0005E0, "Member 'ALineGuide::MinDistance' has a wrong offset!");
static_assert(offsetof(ALineGuide, DataTable) == 0x0005E8, "Member 'ALineGuide::DataTable' has a wrong offset!");
static_assert(offsetof(ALineGuide, DataAsset) == 0x000608, "Member 'ALineGuide::DataAsset' has a wrong offset!");
static_assert(offsetof(ALineGuide, InstanceTransforms) == 0x000618, "Member 'ALineGuide::InstanceTransforms' has a wrong offset!");

// Class UnionRun.LineGuideDataAsset
// 0x0048 (0x0078 - 0x0030)
class ULineGuideDataAsset final : public UDataAsset
{
public:
	bool                                          Fixed;                                             // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLineGuidePathData>             LineGuideDatas0;                                   // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLineGuidePathData>             LineGuideDatas1;                                   // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLineGuidePathData>             LineGuideDatas2;                                   // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLineGuidePathData>             LineGuideDatas3;                                   // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void ClearData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LineGuideDataAsset">();
	}
	static class ULineGuideDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULineGuideDataAsset>();
	}
};
static_assert(alignof(ULineGuideDataAsset) == 0x000008, "Wrong alignment on ULineGuideDataAsset");
static_assert(sizeof(ULineGuideDataAsset) == 0x000078, "Wrong size on ULineGuideDataAsset");
static_assert(offsetof(ULineGuideDataAsset, Fixed) == 0x000030, "Member 'ULineGuideDataAsset::Fixed' has a wrong offset!");
static_assert(offsetof(ULineGuideDataAsset, LineGuideDatas0) == 0x000038, "Member 'ULineGuideDataAsset::LineGuideDatas0' has a wrong offset!");
static_assert(offsetof(ULineGuideDataAsset, LineGuideDatas1) == 0x000048, "Member 'ULineGuideDataAsset::LineGuideDatas1' has a wrong offset!");
static_assert(offsetof(ULineGuideDataAsset, LineGuideDatas2) == 0x000058, "Member 'ULineGuideDataAsset::LineGuideDatas2' has a wrong offset!");
static_assert(offsetof(ULineGuideDataAsset, LineGuideDatas3) == 0x000068, "Member 'ULineGuideDataAsset::LineGuideDatas3' has a wrong offset!");

// Class UnionRun.NetworkComponent
// 0x0010 (0x00B0 - 0x00A0)
class UNetworkComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetworkComponent">();
	}
	static class UNetworkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNetworkComponent>();
	}
};
static_assert(alignof(UNetworkComponent) == 0x000008, "Wrong alignment on UNetworkComponent");
static_assert(sizeof(UNetworkComponent) == 0x0000B0, "Wrong size on UNetworkComponent");

// Class UnionRun.UnionItemInfoInterface
// 0x0000 (0x0000 - 0x0000)
class IUnionItemInfoInterface final
{
public:
	void NoticeChangeThrowDirectionEvent(int32 RacerIndex, EItemId ItemId, EItemThrowDirection ThrowType);
	void NoticeClearItemEvent(int32 RacerIndex);
	void NoticeDecreaseUsableTimesEvent(int32 RacerIndex);
	void NoticeEndIrregularCharging(int32 RacerIndex, EItemId ItemId);
	void NoticeEndItemEvent(int32 RacerIndex);
	void NoticeEndLostItemEvent(int32 RacerIndex, EItemId ItemId, EItemInfoType ItemInfoType);
	void NoticeExchangeIrregularHoldItem(int32 RacerIndex);
	void NoticeHoldItemEvent(int32 RacerIndex, EItemId ItemId, EItemThrowDirection DefaultThrowDirection, bool bGadgetLuckyItem);
	void NoticeItemStockTradeEvent(int32 RacerIndex, const struct FItemSet& PrevItemSet, const struct FItemSet& NewItemSet);
	void NoticeRefreshEvent(int32 RacerIndex);
	void NoticeResultLotteryItemEvent(int32 RacerIndex, EItemInfoType ItemInfoType);
	void NoticeStartIrregularCharging(int32 RacerIndex, EItemId ItemId);
	void NoticeStartLostItemEvent(int32 RacerIndex, EItemId ItemId, EItemInfoType ItemInfoType, int32 LostItemCount);
	void NoticeStartLotteryItemEvent(int32 RacerIndex, EItemInfoType ItemInfoType);
	void NoticeStartShuffleItemEvent(int32 RacerIndex);
	void NoticeTakePackageRingEvent(int32 RacerIndex, int32 InRingNum);
	void NoticeUpgradeEvent(int32 RacerIndex);
	void NoticeUseItemEvent(int32 RacerIndex, EItemId ItemId, EItemThrowDirection ThrowType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionItemInfoInterface">();
	}
	static class IUnionItemInfoInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUnionItemInfoInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IUnionItemInfoInterface) == 0x000001, "Wrong alignment on IUnionItemInfoInterface");
static_assert(sizeof(IUnionItemInfoInterface) == 0x000001, "Wrong size on IUnionItemInfoInterface");

// Class UnionRun.ObakeAnimInstance
// 0x0000 (0x0370 - 0x0370)
class UObakeAnimInstance final : public UAnimInstance
{
public:
	bool                                          bIsAttack;                                         // 0x0368(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsIdle;                                           // 0x0369(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36A[0x6];                                      // 0x036A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetIsAttack();
	bool GetIsIdle();
	void SetIsAttack(bool flag);
	void SetIsIdle(bool flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObakeAnimInstance">();
	}
	static class UObakeAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObakeAnimInstance>();
	}
};
static_assert(alignof(UObakeAnimInstance) == 0x000010, "Wrong alignment on UObakeAnimInstance");
static_assert(sizeof(UObakeAnimInstance) == 0x000370, "Wrong size on UObakeAnimInstance");
static_assert(offsetof(UObakeAnimInstance, bIsAttack) == 0x000368, "Member 'UObakeAnimInstance::bIsAttack' has a wrong offset!");
static_assert(offsetof(UObakeAnimInstance, bIsIdle) == 0x000369, "Member 'UObakeAnimInstance::bIsIdle' has a wrong offset!");

// Class UnionRun.OneDirectionComponent
// 0x0070 (0x02A0 - 0x0230)
class UOneDirectionComponent final : public USceneComponent
{
public:
	struct FVector                                PointStart;                                        // 0x0230(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PointEnd;                                          // 0x0248(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VisibleInGame;                                     // 0x0260(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261[0x3];                                      // 0x0261(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Interval;                                          // 0x0264(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0268(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotOffset;                                         // 0x0280(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OneDirectionComponent">();
	}
	static class UOneDirectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOneDirectionComponent>();
	}
};
static_assert(alignof(UOneDirectionComponent) == 0x000010, "Wrong alignment on UOneDirectionComponent");
static_assert(sizeof(UOneDirectionComponent) == 0x0002A0, "Wrong size on UOneDirectionComponent");
static_assert(offsetof(UOneDirectionComponent, PointStart) == 0x000230, "Member 'UOneDirectionComponent::PointStart' has a wrong offset!");
static_assert(offsetof(UOneDirectionComponent, PointEnd) == 0x000248, "Member 'UOneDirectionComponent::PointEnd' has a wrong offset!");
static_assert(offsetof(UOneDirectionComponent, VisibleInGame) == 0x000260, "Member 'UOneDirectionComponent::VisibleInGame' has a wrong offset!");
static_assert(offsetof(UOneDirectionComponent, Interval) == 0x000264, "Member 'UOneDirectionComponent::Interval' has a wrong offset!");
static_assert(offsetof(UOneDirectionComponent, Scale) == 0x000268, "Member 'UOneDirectionComponent::Scale' has a wrong offset!");
static_assert(offsetof(UOneDirectionComponent, RotOffset) == 0x000280, "Member 'UOneDirectionComponent::RotOffset' has a wrong offset!");

// Class UnionRun.OnlineConfigManager
// 0x0000 (0x0028 - 0x0028)
class UOnlineConfigManager final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineConfigManager">();
	}
	static class UOnlineConfigManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineConfigManager>();
	}
};
static_assert(alignof(UOnlineConfigManager) == 0x000008, "Wrong alignment on UOnlineConfigManager");
static_assert(sizeof(UOnlineConfigManager) == 0x000028, "Wrong size on UOnlineConfigManager");

// Class UnionRun.RaceCheatManagerMemberInterface
// 0x0000 (0x0000 - 0x0000)
class IRaceCheatManagerMemberInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceCheatManagerMemberInterface">();
	}
	static class IRaceCheatManagerMemberInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRaceCheatManagerMemberInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IRaceCheatManagerMemberInterface) == 0x000001, "Wrong alignment on IRaceCheatManagerMemberInterface");
static_assert(sizeof(IRaceCheatManagerMemberInterface) == 0x000001, "Wrong size on IRaceCheatManagerMemberInterface");

// Class UnionRun.PackageRingEffect
// 0x00A0 (0x0330 - 0x0290)
class APackageRingEffect final : public AActor
{
public:
	int32                                         RacerIndex;                                        // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESoundPan                                     SoundPan;                                          // 0x0294(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_295[0x3];                                      // 0x0295(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SoundPlayCount;                                    // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitStartSound;                                    // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoundInterval;                                     // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FiveRingSoundPlayCount;                            // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FiveRingWaitStartSound;                            // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FiveRingSoundInterval;                             // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class APackageRingEffect* EffectActor)> OnEffectSoundStartEvent;   // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class APackageRingEffect* EffectActor)> OnEffectFinishedEvent;     // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0[0x60];                                     // 0x02D0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayTakeRingSound();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PackageRingEffect">();
	}
	static class APackageRingEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<APackageRingEffect>();
	}
};
static_assert(alignof(APackageRingEffect) == 0x000008, "Wrong alignment on APackageRingEffect");
static_assert(sizeof(APackageRingEffect) == 0x000330, "Wrong size on APackageRingEffect");
static_assert(offsetof(APackageRingEffect, RacerIndex) == 0x000290, "Member 'APackageRingEffect::RacerIndex' has a wrong offset!");
static_assert(offsetof(APackageRingEffect, SoundPan) == 0x000294, "Member 'APackageRingEffect::SoundPan' has a wrong offset!");
static_assert(offsetof(APackageRingEffect, SoundPlayCount) == 0x000298, "Member 'APackageRingEffect::SoundPlayCount' has a wrong offset!");
static_assert(offsetof(APackageRingEffect, WaitStartSound) == 0x00029C, "Member 'APackageRingEffect::WaitStartSound' has a wrong offset!");
static_assert(offsetof(APackageRingEffect, SoundInterval) == 0x0002A0, "Member 'APackageRingEffect::SoundInterval' has a wrong offset!");
static_assert(offsetof(APackageRingEffect, FiveRingSoundPlayCount) == 0x0002A4, "Member 'APackageRingEffect::FiveRingSoundPlayCount' has a wrong offset!");
static_assert(offsetof(APackageRingEffect, FiveRingWaitStartSound) == 0x0002A8, "Member 'APackageRingEffect::FiveRingWaitStartSound' has a wrong offset!");
static_assert(offsetof(APackageRingEffect, FiveRingSoundInterval) == 0x0002AC, "Member 'APackageRingEffect::FiveRingSoundInterval' has a wrong offset!");
static_assert(offsetof(APackageRingEffect, OnEffectSoundStartEvent) == 0x0002B0, "Member 'APackageRingEffect::OnEffectSoundStartEvent' has a wrong offset!");
static_assert(offsetof(APackageRingEffect, OnEffectFinishedEvent) == 0x0002C0, "Member 'APackageRingEffect::OnEffectFinishedEvent' has a wrong offset!");

// Class UnionRun.PackageRingObject
// 0x0140 (0x0480 - 0x0340)
class APackageRingObject final : public AUnionCourseObjectBase
{
public:
	uint8                                         Pad_340[0x10];                                     // 0x0340(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              StaticMeshComponent;                               // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRingColliderParam                     _ColliderParam;                                    // 0x0358(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	EPackageRingType                              PackageRingType;                                   // 0x0378(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_379[0x3];                                      // 0x0379(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _RespawnWaitTime;                                  // 0x037C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RingNum;                                           // 0x0380(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_384[0x4];                                      // 0x0384(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USuckedMovement*                        SuckedMovement;                                    // 0x0388(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URelocationMovement*                    RelocationMovement;                                // 0x0390(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0398(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A0[0xCA];                                     // 0x03A0(0x00CA)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsAutoToggleEnable;                               // 0x046A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_46B[0x1];                                      // 0x046B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoEnableStartTime;                               // 0x046C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AutoDisableTime;                                   // 0x0470(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AutoEnableTime;                                    // 0x0474(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESpecialObjGroup                              m_SpecialGroup;                                    // 0x0478(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_479[0x7];                                      // 0x0479(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HitRacer(int32 RacerIndex);
	void SetRingType(EPackageRingType Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PackageRingObject">();
	}
	static class APackageRingObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<APackageRingObject>();
	}
};
static_assert(alignof(APackageRingObject) == 0x000008, "Wrong alignment on APackageRingObject");
static_assert(sizeof(APackageRingObject) == 0x000480, "Wrong size on APackageRingObject");
static_assert(offsetof(APackageRingObject, StaticMeshComponent) == 0x000350, "Member 'APackageRingObject::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(APackageRingObject, _ColliderParam) == 0x000358, "Member 'APackageRingObject::_ColliderParam' has a wrong offset!");
static_assert(offsetof(APackageRingObject, PackageRingType) == 0x000378, "Member 'APackageRingObject::PackageRingType' has a wrong offset!");
static_assert(offsetof(APackageRingObject, _RespawnWaitTime) == 0x00037C, "Member 'APackageRingObject::_RespawnWaitTime' has a wrong offset!");
static_assert(offsetof(APackageRingObject, RingNum) == 0x000380, "Member 'APackageRingObject::RingNum' has a wrong offset!");
static_assert(offsetof(APackageRingObject, SuckedMovement) == 0x000388, "Member 'APackageRingObject::SuckedMovement' has a wrong offset!");
static_assert(offsetof(APackageRingObject, RelocationMovement) == 0x000390, "Member 'APackageRingObject::RelocationMovement' has a wrong offset!");
static_assert(offsetof(APackageRingObject, DefaultSceneRoot) == 0x000398, "Member 'APackageRingObject::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(APackageRingObject, bIsAutoToggleEnable) == 0x00046A, "Member 'APackageRingObject::bIsAutoToggleEnable' has a wrong offset!");
static_assert(offsetof(APackageRingObject, AutoEnableStartTime) == 0x00046C, "Member 'APackageRingObject::AutoEnableStartTime' has a wrong offset!");
static_assert(offsetof(APackageRingObject, AutoDisableTime) == 0x000470, "Member 'APackageRingObject::AutoDisableTime' has a wrong offset!");
static_assert(offsetof(APackageRingObject, AutoEnableTime) == 0x000474, "Member 'APackageRingObject::AutoEnableTime' has a wrong offset!");
static_assert(offsetof(APackageRingObject, m_SpecialGroup) == 0x000478, "Member 'APackageRingObject::m_SpecialGroup' has a wrong offset!");

// Class UnionRun.PostEffectCollision
// 0x0030 (0x05E0 - 0x05B0)
class alignas(0x10) APostEffectCollision final : public AUnionGimmickObjectBase
{
public:
	class UGimmickStaticBodyComponent*            StaticBodyComponent;                               // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                CollisionSize;                                     // 0x05C0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseDirection;                                     // 0x05D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D9[0x7];                                      // 0x05D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PostEffectCollision">();
	}
	static class APostEffectCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<APostEffectCollision>();
	}
};
static_assert(alignof(APostEffectCollision) == 0x000010, "Wrong alignment on APostEffectCollision");
static_assert(sizeof(APostEffectCollision) == 0x0005E0, "Wrong size on APostEffectCollision");
static_assert(offsetof(APostEffectCollision, StaticBodyComponent) == 0x0005B0, "Member 'APostEffectCollision::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(APostEffectCollision, DefaultSceneRoot) == 0x0005B8, "Member 'APostEffectCollision::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(APostEffectCollision, CollisionSize) == 0x0005C0, "Member 'APostEffectCollision::CollisionSize' has a wrong offset!");
static_assert(offsetof(APostEffectCollision, bUseDirection) == 0x0005D8, "Member 'APostEffectCollision::bUseDirection' has a wrong offset!");

// Class UnionRun.UnionPlaneRunParam
// 0x0280 (0x02B0 - 0x0030)
class UUnionPlaneRunParam final : public UDataAsset
{
public:
	float                                         CommonCameraUpBlendRate;                           // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostCameraDeltaDistance;                          // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostCameraDeltaFOV;                               // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostCameraDeltaHeight;                            // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostCameraDeltaElevation;                         // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostCameraInterp;                                 // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostCameraRestoreSpring;                          // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostCameraRestoreDamping;                         // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraBlendSeconds;                                // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChargeCameraBlendSeconds;                          // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoundaryCameraStartDistanceX;                      // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoundaryCameraOffsetX;                             // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoundaryCameraStartDistanceY;                      // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoundaryCameraOffsetY;                             // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarningDist;                                       // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttractDist;                                       // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespotDist;                                        // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoundaryHeight;                                    // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoundaryWidth;                                     // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoundaryWarningSeconds;                            // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoundaryWindLengthRate;                            // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoInputDelaySeconds;                               // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoInputAngularSpeed;                               // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FarDeccel;                                         // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FarMaxAngularSpeed;                                // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FarMinAngularSpeed;                                // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RingGateDistance;                                  // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinusRingGateRadius;                               // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RingGateToCenterDegree;                            // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RingGateInAngularSpeedMin;                         // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RingGateInAngularSpeedMax;                         // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RingGateOutAngularSpeed;                           // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HandleAssistAngularSpeed;                          // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HandleAssistBlendRate;                             // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoundaryAngularSpeed;                              // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoundaryDeccel;                                    // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OuterBoundaryRespotSeconds;                        // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CobraAcceptDegree;                                 // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HookTurnStartDegree;                               // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CobraTurnStartDegree;                              // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarrelRollCollisionRadius;                         // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarrelRollCollisionLength;                         // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarrelRollCollisionForwardOffset;                  // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalDegreeMax;                                    // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalBodyPitchDegreeMax;                           // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalVelocityPitchDegreeMax;                       // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalBodyYawDegreeMax;                             // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalVelocityYawDegreeMax;                         // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CobraTurnInputDegree;                              // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlaneTurnAppearanceParams             NormalRollAppearanceParam;                         // 0x00F4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FPlaneTurnAppearanceParams             NormalPitchAppearanceParam;                        // 0x0104(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FPlaneTurnAppearanceParams             NormalYawAppearanceParam;                          // 0x0114(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FPlaneTurnSpeedParams                  NormalPitchSpeedParam;                             // 0x0124(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FPlaneTurnSpeedParams                  NormalYawSpeedParam;                               // 0x0134(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseChargeDashCamera;                              // 0x0144(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_145[0x3];                                      // 0x0145(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChargeDashDirectionBlendRate;                      // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlaneChargeTurnAppearanceParams       HookTurnRollAppearanceParam;                       // 0x014C(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FPlaneChargeTurnAppearanceParams       HookTurnYawAppearanceParam;                        // 0x0164(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FPlaneTurnSpeedParams                  HookTurnPitchSpeedParam;                           // 0x017C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FPlaneChargeTurnSpeedHandleParams      HookTurnYawSpeedParam;                             // 0x018C(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FPlaneChargeTurnAppearanceParams       CobraTurnRollAppearanceParam;                      // 0x01B4(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FPlaneChargeTurnAppearanceParams       CobraTurnPitchAppearanceParam;                     // 0x01CC(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FPlaneChargeTurnSpeedHandleParams      CobraTurnPitchSpeedParam;                          // 0x01E4(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FPlaneTurnSpeedParams                  CobraTurnYawSpeedParam;                            // 0x020C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FItemSpeedParam                        MinSpeed;                                          // 0x021C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         NoInputDeccel;                                     // 0x022C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WallHitCount;                                      // 0x0230(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadOnDeg;                                         // 0x0234(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadOnToCourseDegree;                              // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitCountIntervalSeconds;                           // 0x023C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlaneBounceSpeedParams                WallHitBounce;                                     // 0x0240(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FPlaneBounceSpeedParams                WallHeadOnBounce;                                  // 0x0250(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FPlaneBounceSpeedParams                CountOverWallHitBounce;                            // 0x0260(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FPlaneBounceSpeedParams                BumperHit;                                         // 0x0270(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FPlaneChangeDirectionParams            WallHitDirection;                                  // 0x0280(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FPlaneChangeDirectionParams            CountOverWallDirection;                            // 0x0288(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FPlaneDamageReactionParams             RocketPunch;                                       // 0x0290(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PunchHittingSeconds;                               // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ModelRotSmoothing;                                 // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionPlaneRunParam">();
	}
	static class UUnionPlaneRunParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionPlaneRunParam>();
	}
};
static_assert(alignof(UUnionPlaneRunParam) == 0x000008, "Wrong alignment on UUnionPlaneRunParam");
static_assert(sizeof(UUnionPlaneRunParam) == 0x0002B0, "Wrong size on UUnionPlaneRunParam");
static_assert(offsetof(UUnionPlaneRunParam, CommonCameraUpBlendRate) == 0x000030, "Member 'UUnionPlaneRunParam::CommonCameraUpBlendRate' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, BoostCameraDeltaDistance) == 0x000034, "Member 'UUnionPlaneRunParam::BoostCameraDeltaDistance' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, BoostCameraDeltaFOV) == 0x000038, "Member 'UUnionPlaneRunParam::BoostCameraDeltaFOV' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, BoostCameraDeltaHeight) == 0x00003C, "Member 'UUnionPlaneRunParam::BoostCameraDeltaHeight' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, BoostCameraDeltaElevation) == 0x000040, "Member 'UUnionPlaneRunParam::BoostCameraDeltaElevation' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, BoostCameraInterp) == 0x000044, "Member 'UUnionPlaneRunParam::BoostCameraInterp' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, BoostCameraRestoreSpring) == 0x000048, "Member 'UUnionPlaneRunParam::BoostCameraRestoreSpring' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, BoostCameraRestoreDamping) == 0x00004C, "Member 'UUnionPlaneRunParam::BoostCameraRestoreDamping' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, CameraBlendSeconds) == 0x000050, "Member 'UUnionPlaneRunParam::CameraBlendSeconds' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, ChargeCameraBlendSeconds) == 0x000054, "Member 'UUnionPlaneRunParam::ChargeCameraBlendSeconds' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, BoundaryCameraStartDistanceX) == 0x000058, "Member 'UUnionPlaneRunParam::BoundaryCameraStartDistanceX' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, BoundaryCameraOffsetX) == 0x00005C, "Member 'UUnionPlaneRunParam::BoundaryCameraOffsetX' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, BoundaryCameraStartDistanceY) == 0x000060, "Member 'UUnionPlaneRunParam::BoundaryCameraStartDistanceY' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, BoundaryCameraOffsetY) == 0x000064, "Member 'UUnionPlaneRunParam::BoundaryCameraOffsetY' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, WarningDist) == 0x000068, "Member 'UUnionPlaneRunParam::WarningDist' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, AttractDist) == 0x00006C, "Member 'UUnionPlaneRunParam::AttractDist' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, RespotDist) == 0x000070, "Member 'UUnionPlaneRunParam::RespotDist' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, BoundaryHeight) == 0x000074, "Member 'UUnionPlaneRunParam::BoundaryHeight' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, BoundaryWidth) == 0x000078, "Member 'UUnionPlaneRunParam::BoundaryWidth' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, BoundaryWarningSeconds) == 0x00007C, "Member 'UUnionPlaneRunParam::BoundaryWarningSeconds' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, BoundaryWindLengthRate) == 0x000080, "Member 'UUnionPlaneRunParam::BoundaryWindLengthRate' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, NoInputDelaySeconds) == 0x000084, "Member 'UUnionPlaneRunParam::NoInputDelaySeconds' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, NoInputAngularSpeed) == 0x000088, "Member 'UUnionPlaneRunParam::NoInputAngularSpeed' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, FarDeccel) == 0x00008C, "Member 'UUnionPlaneRunParam::FarDeccel' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, FarMaxAngularSpeed) == 0x000090, "Member 'UUnionPlaneRunParam::FarMaxAngularSpeed' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, FarMinAngularSpeed) == 0x000094, "Member 'UUnionPlaneRunParam::FarMinAngularSpeed' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, RingGateDistance) == 0x000098, "Member 'UUnionPlaneRunParam::RingGateDistance' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, MinusRingGateRadius) == 0x00009C, "Member 'UUnionPlaneRunParam::MinusRingGateRadius' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, RingGateToCenterDegree) == 0x0000A0, "Member 'UUnionPlaneRunParam::RingGateToCenterDegree' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, RingGateInAngularSpeedMin) == 0x0000A4, "Member 'UUnionPlaneRunParam::RingGateInAngularSpeedMin' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, RingGateInAngularSpeedMax) == 0x0000A8, "Member 'UUnionPlaneRunParam::RingGateInAngularSpeedMax' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, RingGateOutAngularSpeed) == 0x0000AC, "Member 'UUnionPlaneRunParam::RingGateOutAngularSpeed' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, HandleAssistAngularSpeed) == 0x0000B0, "Member 'UUnionPlaneRunParam::HandleAssistAngularSpeed' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, HandleAssistBlendRate) == 0x0000B4, "Member 'UUnionPlaneRunParam::HandleAssistBlendRate' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, BoundaryAngularSpeed) == 0x0000B8, "Member 'UUnionPlaneRunParam::BoundaryAngularSpeed' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, BoundaryDeccel) == 0x0000BC, "Member 'UUnionPlaneRunParam::BoundaryDeccel' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, OuterBoundaryRespotSeconds) == 0x0000C0, "Member 'UUnionPlaneRunParam::OuterBoundaryRespotSeconds' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, CobraAcceptDegree) == 0x0000C4, "Member 'UUnionPlaneRunParam::CobraAcceptDegree' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, HookTurnStartDegree) == 0x0000C8, "Member 'UUnionPlaneRunParam::HookTurnStartDegree' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, CobraTurnStartDegree) == 0x0000CC, "Member 'UUnionPlaneRunParam::CobraTurnStartDegree' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, BarrelRollCollisionRadius) == 0x0000D0, "Member 'UUnionPlaneRunParam::BarrelRollCollisionRadius' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, BarrelRollCollisionLength) == 0x0000D4, "Member 'UUnionPlaneRunParam::BarrelRollCollisionLength' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, BarrelRollCollisionForwardOffset) == 0x0000D8, "Member 'UUnionPlaneRunParam::BarrelRollCollisionForwardOffset' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, LocalDegreeMax) == 0x0000DC, "Member 'UUnionPlaneRunParam::LocalDegreeMax' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, LocalBodyPitchDegreeMax) == 0x0000E0, "Member 'UUnionPlaneRunParam::LocalBodyPitchDegreeMax' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, LocalVelocityPitchDegreeMax) == 0x0000E4, "Member 'UUnionPlaneRunParam::LocalVelocityPitchDegreeMax' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, LocalBodyYawDegreeMax) == 0x0000E8, "Member 'UUnionPlaneRunParam::LocalBodyYawDegreeMax' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, LocalVelocityYawDegreeMax) == 0x0000EC, "Member 'UUnionPlaneRunParam::LocalVelocityYawDegreeMax' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, CobraTurnInputDegree) == 0x0000F0, "Member 'UUnionPlaneRunParam::CobraTurnInputDegree' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, NormalRollAppearanceParam) == 0x0000F4, "Member 'UUnionPlaneRunParam::NormalRollAppearanceParam' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, NormalPitchAppearanceParam) == 0x000104, "Member 'UUnionPlaneRunParam::NormalPitchAppearanceParam' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, NormalYawAppearanceParam) == 0x000114, "Member 'UUnionPlaneRunParam::NormalYawAppearanceParam' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, NormalPitchSpeedParam) == 0x000124, "Member 'UUnionPlaneRunParam::NormalPitchSpeedParam' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, NormalYawSpeedParam) == 0x000134, "Member 'UUnionPlaneRunParam::NormalYawSpeedParam' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, bUseChargeDashCamera) == 0x000144, "Member 'UUnionPlaneRunParam::bUseChargeDashCamera' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, ChargeDashDirectionBlendRate) == 0x000148, "Member 'UUnionPlaneRunParam::ChargeDashDirectionBlendRate' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, HookTurnRollAppearanceParam) == 0x00014C, "Member 'UUnionPlaneRunParam::HookTurnRollAppearanceParam' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, HookTurnYawAppearanceParam) == 0x000164, "Member 'UUnionPlaneRunParam::HookTurnYawAppearanceParam' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, HookTurnPitchSpeedParam) == 0x00017C, "Member 'UUnionPlaneRunParam::HookTurnPitchSpeedParam' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, HookTurnYawSpeedParam) == 0x00018C, "Member 'UUnionPlaneRunParam::HookTurnYawSpeedParam' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, CobraTurnRollAppearanceParam) == 0x0001B4, "Member 'UUnionPlaneRunParam::CobraTurnRollAppearanceParam' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, CobraTurnPitchAppearanceParam) == 0x0001CC, "Member 'UUnionPlaneRunParam::CobraTurnPitchAppearanceParam' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, CobraTurnPitchSpeedParam) == 0x0001E4, "Member 'UUnionPlaneRunParam::CobraTurnPitchSpeedParam' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, CobraTurnYawSpeedParam) == 0x00020C, "Member 'UUnionPlaneRunParam::CobraTurnYawSpeedParam' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, MinSpeed) == 0x00021C, "Member 'UUnionPlaneRunParam::MinSpeed' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, NoInputDeccel) == 0x00022C, "Member 'UUnionPlaneRunParam::NoInputDeccel' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, WallHitCount) == 0x000230, "Member 'UUnionPlaneRunParam::WallHitCount' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, HeadOnDeg) == 0x000234, "Member 'UUnionPlaneRunParam::HeadOnDeg' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, HeadOnToCourseDegree) == 0x000238, "Member 'UUnionPlaneRunParam::HeadOnToCourseDegree' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, HitCountIntervalSeconds) == 0x00023C, "Member 'UUnionPlaneRunParam::HitCountIntervalSeconds' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, WallHitBounce) == 0x000240, "Member 'UUnionPlaneRunParam::WallHitBounce' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, WallHeadOnBounce) == 0x000250, "Member 'UUnionPlaneRunParam::WallHeadOnBounce' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, CountOverWallHitBounce) == 0x000260, "Member 'UUnionPlaneRunParam::CountOverWallHitBounce' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, BumperHit) == 0x000270, "Member 'UUnionPlaneRunParam::BumperHit' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, WallHitDirection) == 0x000280, "Member 'UUnionPlaneRunParam::WallHitDirection' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, CountOverWallDirection) == 0x000288, "Member 'UUnionPlaneRunParam::CountOverWallDirection' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, RocketPunch) == 0x000290, "Member 'UUnionPlaneRunParam::RocketPunch' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, PunchHittingSeconds) == 0x0002A4, "Member 'UUnionPlaneRunParam::PunchHittingSeconds' has a wrong offset!");
static_assert(offsetof(UUnionPlaneRunParam, ModelRotSmoothing) == 0x0002A8, "Member 'UUnionPlaneRunParam::ModelRotSmoothing' has a wrong offset!");

// Class UnionRun.RaceActionTutorialData
// 0x08D0 (0x0900 - 0x0030)
class URaceActionTutorialData final : public UDataAsset
{
public:
	struct FRaceActionTutorialStageData           RaceActionTutorial[0x5E];                          // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)

public:
	void LoadStageId();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceActionTutorialData">();
	}
	static class URaceActionTutorialData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceActionTutorialData>();
	}
};
static_assert(alignof(URaceActionTutorialData) == 0x000008, "Wrong alignment on URaceActionTutorialData");
static_assert(sizeof(URaceActionTutorialData) == 0x000900, "Wrong size on URaceActionTutorialData");
static_assert(offsetof(URaceActionTutorialData, RaceActionTutorial) == 0x000030, "Member 'URaceActionTutorialData::RaceActionTutorial' has a wrong offset!");

// Class UnionRun.UnionRacer
// 0x0030 (0x0058 - 0x0028)
class UUnionRacer final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  Vehicle;                                           // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionRaceLapInfo*                      RaceLapInfo;                                       // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionRacerStatusObject*                RacerStatus;                                       // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionRaceSituationObject*              RaceSituation;                                     // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool ApplyPauseInput();
	void ApplyVehicleInput();
	void ChangeVehicleDisplayMode(EVehicleDisplayMode InVehicleDisplayMode);
	void ClearVehicle();
	bool Destroy();
	void ExecTick(float DeltaSeconds);
	void GetPlayerControllerIndex(int32* OutPlayerControllerIndex);
	class UUnionRaceLapInfo* GetRaceLapInfo();
	void GetRacerIndex(int32* OutRacerIndex);
	class UUnionRaceSituationObject* GetRacerSituationObject();
	class UUnionRacerStatusObject* GetRacerStatusObject();
	int32 GetTestRaceCount();
	void SetPlayerControllerIndex(int32 InPlayerControllerIndex);
	void SetRaceLapInfo(class UUnionRaceLapInfo* InRaceLapInfo);
	void SetRacerIndex(int32 InRacerIndex);
	void SetTickable(bool bTickable);
	void SetVehicle(class APawn* InVehicle);
	void SetViewSplitId(EViewSplitId InViewSplitId);
	struct FTimerHandle UnionRacer_SetTimerDelegate(TDelegate<void()> Delegate, float Time, bool bLooping);
	void UpdateTestRace(float Delta);
	void UpdateVehicle(float Delta);
	void UpdateVehicleInput();

	EViewSplitId GetViewSplitId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRacer">();
	}
	static class UUnionRacer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRacer>();
	}
};
static_assert(alignof(UUnionRacer) == 0x000008, "Wrong alignment on UUnionRacer");
static_assert(sizeof(UUnionRacer) == 0x000058, "Wrong size on UUnionRacer");
static_assert(offsetof(UUnionRacer, Vehicle) == 0x000038, "Member 'UUnionRacer::Vehicle' has a wrong offset!");
static_assert(offsetof(UUnionRacer, RaceLapInfo) == 0x000040, "Member 'UUnionRacer::RaceLapInfo' has a wrong offset!");
static_assert(offsetof(UUnionRacer, RacerStatus) == 0x000048, "Member 'UUnionRacer::RacerStatus' has a wrong offset!");
static_assert(offsetof(UUnionRacer, RaceSituation) == 0x000050, "Member 'UUnionRacer::RaceSituation' has a wrong offset!");

// Class UnionRun.RaceObjectSkeletal
// 0x0010 (0x02A0 - 0x0290)
class ARaceObjectSkeletal : public AActor
{
public:
	class USceneComponent*                        Root;                                              // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 BodyRoot;                                          // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetBodySkeletalMesh(class USkeletalMesh* NewSkeletalMesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceObjectSkeletal">();
	}
	static class ARaceObjectSkeletal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARaceObjectSkeletal>();
	}
};
static_assert(alignof(ARaceObjectSkeletal) == 0x000008, "Wrong alignment on ARaceObjectSkeletal");
static_assert(sizeof(ARaceObjectSkeletal) == 0x0002A0, "Wrong size on ARaceObjectSkeletal");
static_assert(offsetof(ARaceObjectSkeletal, Root) == 0x000290, "Member 'ARaceObjectSkeletal::Root' has a wrong offset!");
static_assert(offsetof(ARaceObjectSkeletal, BodyRoot) == 0x000298, "Member 'ARaceObjectSkeletal::BodyRoot' has a wrong offset!");

// Class UnionRun.RacerReactionManager
// 0x01E0 (0x0208 - 0x0028)
class URacerReactionManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionRaceUI*                           RaceHUD;                                           // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EDriverId, ERacerReactionDriverType>     DriverTypeMap;                                     // 0x0038(0x0050)(NativeAccessSpecifierPublic)
	TArray<ERacerReactionDriverType>              RacerIndexTypeList;                                // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class URacerReactionInfoDataAsset*            RacerReactionInfoDataAsset;                        // 0x0098(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URacerReactionTextDataAsset*            RacerReactionTextDataAsset;                        // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x70];                                      // 0x00A8(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionAtomComponent*                    AtomComponent;                                     // 0x0118(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    AtomComponentList[0x3];                            // 0x0120(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionAtomComponent*                    AtomComponentRacerList[0xC];                       // 0x0138(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_198[0x70];                                     // 0x0198(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForcePlayVoice(const struct FRacerReactionVoice& ReactionVoice, int32 RacerIndex, float MinimumCoolTime);
	void SoundPlayIrregularInfoDod(const struct FRacerReactionVoice& ReactionVoice, int32 RacerIndex, float MinimumCoolTime, float Duration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RacerReactionManager">();
	}
	static class URacerReactionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URacerReactionManager>();
	}
};
static_assert(alignof(URacerReactionManager) == 0x000008, "Wrong alignment on URacerReactionManager");
static_assert(sizeof(URacerReactionManager) == 0x000208, "Wrong size on URacerReactionManager");
static_assert(offsetof(URacerReactionManager, RaceHUD) == 0x000030, "Member 'URacerReactionManager::RaceHUD' has a wrong offset!");
static_assert(offsetof(URacerReactionManager, DriverTypeMap) == 0x000038, "Member 'URacerReactionManager::DriverTypeMap' has a wrong offset!");
static_assert(offsetof(URacerReactionManager, RacerIndexTypeList) == 0x000088, "Member 'URacerReactionManager::RacerIndexTypeList' has a wrong offset!");
static_assert(offsetof(URacerReactionManager, RacerReactionInfoDataAsset) == 0x000098, "Member 'URacerReactionManager::RacerReactionInfoDataAsset' has a wrong offset!");
static_assert(offsetof(URacerReactionManager, RacerReactionTextDataAsset) == 0x0000A0, "Member 'URacerReactionManager::RacerReactionTextDataAsset' has a wrong offset!");
static_assert(offsetof(URacerReactionManager, AtomComponent) == 0x000118, "Member 'URacerReactionManager::AtomComponent' has a wrong offset!");
static_assert(offsetof(URacerReactionManager, AtomComponentList) == 0x000120, "Member 'URacerReactionManager::AtomComponentList' has a wrong offset!");
static_assert(offsetof(URacerReactionManager, AtomComponentRacerList) == 0x000138, "Member 'URacerReactionManager::AtomComponentRacerList' has a wrong offset!");

// Class UnionRun.UnionRaceDataManager
// 0x01D0 (0x01F8 - 0x0028)
class UUnionRaceDataManager final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionRacers*                           AppRacers;                                         // 0x0040(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x1B0];                                     // 0x0048(0x01B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRaceDataManager">();
	}
	static class UUnionRaceDataManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRaceDataManager>();
	}
};
static_assert(alignof(UUnionRaceDataManager) == 0x000008, "Wrong alignment on UUnionRaceDataManager");
static_assert(sizeof(UUnionRaceDataManager) == 0x0001F8, "Wrong size on UUnionRaceDataManager");
static_assert(offsetof(UUnionRaceDataManager, AppRacers) == 0x000040, "Member 'UUnionRaceDataManager::AppRacers' has a wrong offset!");

// Class UnionRun.RaceSituationManager
// 0x0098 (0x00C0 - 0x0028)
class URaceSituationManager final : public UObject
{
public:
	uint8                                         Pad_28[0x78];                                      // 0x0028(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class URacerReactionTriggerParam*             reactionTriggerParam;                              // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionRaceSituationParams*              situationParam;                                    // 0x00A8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceSituationManager">();
	}
	static class URaceSituationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceSituationManager>();
	}
};
static_assert(alignof(URaceSituationManager) == 0x000008, "Wrong alignment on URaceSituationManager");
static_assert(sizeof(URaceSituationManager) == 0x0000C0, "Wrong size on URaceSituationManager");
static_assert(offsetof(URaceSituationManager, reactionTriggerParam) == 0x0000A0, "Member 'URaceSituationManager::reactionTriggerParam' has a wrong offset!");
static_assert(offsetof(URaceSituationManager, situationParam) == 0x0000A8, "Member 'URaceSituationManager::situationParam' has a wrong offset!");

// Class UnionRun.UnionNavMarker
// 0x0078 (0x03B8 - 0x0340)
class AUnionNavMarker final : public AUnionCourseObjectBase
{
public:
	TMulticastInlineDelegate<void(const struct FTransform& NewTransform)> OnTransformChanged;        // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0350(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ENavMarkerLapType                             LapType;                                           // 0x0358(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EUnionNavMarkerType                           Type;                                              // 0x0359(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_35A[0x6];                                      // 0x035A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name_0;                                            // 0x0360(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Width;                                             // 0x0370(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Height;                                            // 0x0374(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class AActor>                  UseSplineActor;                                    // 0x0378(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SplineOnPosition;                                  // 0x03A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UseSplineLength;                                   // 0x03A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETransformRingType                            TransformRingType;                                 // 0x03A8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A9[0x3];                                      // 0x03A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Index_0;                                           // 0x03AC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsInvalid;                                        // 0x03B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsAnother;                                        // 0x03B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B2[0x6];                                      // 0x03B2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TSoftObjectPtr<class AActor> GetUseSplineActor();
	bool IsFinalLapOnly();
	void SetIndex(int32 NewIndex);
	void SetIsAnother(bool flag);
	void SetLapType(ENavMarkerLapType NewType);
	void SetSplineOnPosition(int32 InPosition);
	void SetTransformRingType(ETransformRingType TransformType);
	void SetType(EUnionNavMarkerType NewType);
	void SetUseSplineActor(TSoftObjectPtr<class AActor> InUseSplineActor);
	void SetUseSplineLength(float InLength);
	void UpdateSplineOnPosition();

	int32 GetIndex() const;
	ENavMarkerLapType GetLapType() const;
	int32 GetSplineOnPosition() const;
	ETransformRingType GetTransformRingType() const;
	EUnionNavMarkerType GetType() const;
	class UUnionSplineComponent* GetUnionSplineComponent() const;
	float GetUseSplineLength() const;
	bool IsAnother() const;
	bool IsInvalid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionNavMarker">();
	}
	static class AUnionNavMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnionNavMarker>();
	}
};
static_assert(alignof(AUnionNavMarker) == 0x000008, "Wrong alignment on AUnionNavMarker");
static_assert(sizeof(AUnionNavMarker) == 0x0003B8, "Wrong size on AUnionNavMarker");
static_assert(offsetof(AUnionNavMarker, OnTransformChanged) == 0x000340, "Member 'AUnionNavMarker::OnTransformChanged' has a wrong offset!");
static_assert(offsetof(AUnionNavMarker, DefaultSceneRoot) == 0x000350, "Member 'AUnionNavMarker::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AUnionNavMarker, LapType) == 0x000358, "Member 'AUnionNavMarker::LapType' has a wrong offset!");
static_assert(offsetof(AUnionNavMarker, Type) == 0x000359, "Member 'AUnionNavMarker::Type' has a wrong offset!");
static_assert(offsetof(AUnionNavMarker, Name_0) == 0x000360, "Member 'AUnionNavMarker::Name_0' has a wrong offset!");
static_assert(offsetof(AUnionNavMarker, Width) == 0x000370, "Member 'AUnionNavMarker::Width' has a wrong offset!");
static_assert(offsetof(AUnionNavMarker, Height) == 0x000374, "Member 'AUnionNavMarker::Height' has a wrong offset!");
static_assert(offsetof(AUnionNavMarker, UseSplineActor) == 0x000378, "Member 'AUnionNavMarker::UseSplineActor' has a wrong offset!");
static_assert(offsetof(AUnionNavMarker, SplineOnPosition) == 0x0003A0, "Member 'AUnionNavMarker::SplineOnPosition' has a wrong offset!");
static_assert(offsetof(AUnionNavMarker, UseSplineLength) == 0x0003A4, "Member 'AUnionNavMarker::UseSplineLength' has a wrong offset!");
static_assert(offsetof(AUnionNavMarker, TransformRingType) == 0x0003A8, "Member 'AUnionNavMarker::TransformRingType' has a wrong offset!");
static_assert(offsetof(AUnionNavMarker, Index_0) == 0x0003AC, "Member 'AUnionNavMarker::Index_0' has a wrong offset!");
static_assert(offsetof(AUnionNavMarker, bIsInvalid) == 0x0003B0, "Member 'AUnionNavMarker::bIsInvalid' has a wrong offset!");
static_assert(offsetof(AUnionNavMarker, bIsAnother) == 0x0003B1, "Member 'AUnionNavMarker::bIsAnother' has a wrong offset!");

// Class UnionRun.RaceTestPathCameraPawn
// 0x0298 (0x05B0 - 0x0318)
class alignas(0x10) ARaceTestPathCameraPawn final : public APawn
{
public:
	uint8                                         Pad_318[0x10];                                     // 0x0318(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        RotateYawRoot;                                     // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        RotatePitchRoot;                                   // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       TPCameraComponent;                                 // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_348[0x268];                                    // 0x0348(0x0268)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceTestPathCameraPawn">();
	}
	static class ARaceTestPathCameraPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARaceTestPathCameraPawn>();
	}
};
static_assert(alignof(ARaceTestPathCameraPawn) == 0x000010, "Wrong alignment on ARaceTestPathCameraPawn");
static_assert(sizeof(ARaceTestPathCameraPawn) == 0x0005B0, "Wrong size on ARaceTestPathCameraPawn");
static_assert(offsetof(ARaceTestPathCameraPawn, DefaultSceneRoot) == 0x000328, "Member 'ARaceTestPathCameraPawn::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(ARaceTestPathCameraPawn, RotateYawRoot) == 0x000330, "Member 'ARaceTestPathCameraPawn::RotateYawRoot' has a wrong offset!");
static_assert(offsetof(ARaceTestPathCameraPawn, RotatePitchRoot) == 0x000338, "Member 'ARaceTestPathCameraPawn::RotatePitchRoot' has a wrong offset!");
static_assert(offsetof(ARaceTestPathCameraPawn, TPCameraComponent) == 0x000340, "Member 'ARaceTestPathCameraPawn::TPCameraComponent' has a wrong offset!");

// Class UnionRun.UnionRaceInfoInterface
// 0x0000 (0x0000 - 0x0000)
class IUnionRaceInfoInterface final
{
public:
	void NoticeChangeCountDownEvent(int32 InNewValue, int32 InOldValue);
	void NoticeChangeRaceStateEvent(ERaceInfoStateType InNewState, ERaceInfoStateType InOldState);
	void NoticeRaceFinishEvent();
	void SetRaceInfo(class UUnionRaceInfo* InRaceInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRaceInfoInterface">();
	}
	static class IUnionRaceInfoInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUnionRaceInfoInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IUnionRaceInfoInterface) == 0x000001, "Wrong alignment on IUnionRaceInfoInterface");
static_assert(sizeof(IUnionRaceInfoInterface) == 0x000001, "Wrong size on IUnionRaceInfoInterface");

// Class UnionRun.RaceTestUtils
// 0x0000 (0x0028 - 0x0028)
class URaceTestUtils final : public UBlueprintFunctionLibrary
{
public:
	static void AssignFixedFpsForRaceLoadTest();
	static void EndAutoCsvProfile(class APlayerController* PC);
	static void EndAutoKibana(class APlayerController* PC);
	static void EndAutoProfileGpu(class APlayerController* PC);
	static void EndAutoUnrealInsights(class APlayerController* PC);
	static void EndRaceLoadTest(class APlayerController* PC);
	static void EndRaceTest(class APlayerController* PC);
	static bool GetAutoCsvProfileModeFlag();
	static bool GetAutoDebugKibanaModeFlag();
	static bool GetAutoDetailKibanaModeFlag();
	static bool GetAutoKibanaModeFlag();
	static bool GetAutoProfileGpuModeFlag();
	static bool GetAutoUnrealInsightsModeFlag();
	static class FString GetCumstomRaceTestConfig();
	static int32 GetNoHitItemPhysiceLayerMask();
	static bool GetOverrideCamera();
	static bool GetOverrideCameraElevation(float* Elevation);
	static bool GetOverrideCameraOffset(float* Offset);
	static bool GetOverrideCameraTargetY(float* Target);
	static bool GetOverrideCameraTargetZ(float* Target);
	static bool GetOverrideCameraVFov(float* VFov);
	static bool GetOverridePathCamera();
	static bool GetOverridePathCameraElevation(float* Elevation);
	static bool GetOverridePathCameraOffset(float* Offset);
	static bool GetOverridePathCameraTargetY(float* Target);
	static bool GetOverridePathCameraTargetZ(float* Target);
	static bool GetOverridePathCameraVFov(float* VFov);
	static ERaceLoadTestMode GetRaceLoadTestMode();
	static bool GetRacerSetting(int32 RacerIndex, struct FRaceTestRacerSetting* Setting);
	static const class URaceTestConfig* GetRaceTestConfig();
	static class URaceTestConfig* GetRaceTestConfigAccess();
	static const class UDataTable* GetRaceTestItemTableAsset();
	static int32 GetScreenNum();
	static class FString GetTagNameToDestroyActor();
	static bool IsAutoCsvProfileMode();
	static bool IsAutoDebugKibanaMode();
	static bool IsAutoDetailKibanaMode();
	static bool IsAutoKibanaMode();
	static bool IsAutoProfileGpuMode();
	static bool IsAutoUnrealInsightsMode();
	static bool IsDisabledGameHighLoading();
	static bool IsEnableItemTableSynchro();
	static bool IsFinalRaceLoadTest();
	static bool IsForceComRun(int32 RacerIndex);
	static bool IsNoBgmMode();
	static bool IsNoCourseObject();
	static bool IsNoGimmickObject();
	static bool IsNoHudMode();
	static bool IsPathCameraPawnMode();
	static bool IsPerformanceTestRun(int32 RacerIndex);
	static bool IsRaceLoadAutoTestMode();
	static bool IsRaceTestMode();
	static bool IsUseItemTable();
	static void OverrideDebugMenuRaceLoadTestMode(int32 Mode);
	static void ResetRaceLoadTestCount();
	static bool SaveRaceLoadAutoTestResult();
	static void SetAutoCsvProfileModeFlag(bool flag);
	static void SetAutoDebugKibanaModeFlag(bool flag);
	static void SetAutoDetailKibanaModeFlag(bool flag);
	static void SetAutoKibanaModeFlag(bool flag);
	static void SetAutoProfileGpuModeFlag(bool flag);
	static void SetAutoUnrealInsightsModeFlag(bool flag);
	static void SetCustomRaceTestConfig(const class FString& RaceTestConfig);
	static void SetDrivingCount(int32 DrivingCount);
	static void SetLoadingTime(float LoadingTime);
	static void SetOverrideCamera(bool flag);
	static void SetOverrideCameraElevation(float Elevation);
	static void SetOverrideCameraOffset(float Offset);
	static void SetOverrideCameraTargetY(float Target);
	static void SetOverrideCameraTargetZ(float Target);
	static void SetOverrideCameraVFov(float VFov);
	static void SetOverridePathCamera(bool flag);
	static void SetOverridePathCameraElevation(float Elevation);
	static void SetOverridePathCameraOffset(float Offset);
	static void SetOverridePathCameraTargetY(float Target);
	static void SetOverridePathCameraTargetZ(float Target);
	static void SetOverridePathCameraVFov(float VFov);
	static void SetPathCameraPawnMode(bool flag);
	static void SetRaceLoadTestCountMax(int32 Count);
	static void SetTagNameToDestroyActor(const class FString& TagName);
	static void StartAutoCsvProfile(class APlayerController* PC);
	static void StartAutoKibana(class APlayerController* PC);
	static void StartAutoProfileGpu(class APlayerController* PC);
	static void StartAutoUnrealInsights(class APlayerController* PC);
	static void StartRaceLoadTest(class APlayerController* PC);
	static void StartRaceTest(class APlayerController* PC);
	static void TickProfileGpuAndScreenshot(float DeltaTime, class APlayerController* PC);
	static void UpdateCameraByDebConst();
	static bool UpdateRaceLoadAutoTest(const TArray<EStageId>& OpenStageIDs);

	bool IsCustomRaceTestAutoConfigMode();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceTestUtils">();
	}
	static class URaceTestUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceTestUtils>();
	}
};
static_assert(alignof(URaceTestUtils) == 0x000008, "Wrong alignment on URaceTestUtils");
static_assert(sizeof(URaceTestUtils) == 0x000028, "Wrong size on URaceTestUtils");

// Class UnionRun.UnionRacerStatusObject
// 0x24D8 (0x2500 - 0x0028)
class UUnionRacerStatusObject final : public UObject
{
public:
	int32                                         RingCount;                                         // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RingAddReserveCount;                               // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHoldItemInfo                          ItemInfo;                                          // 0x0030(0x0080)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FItemAimInfo                           AimInfo;                                           // 0x00B0(0x0078)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<EGadgetId>                             GadgetInfo;                                        // 0x0128(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         RingCountPrev;                                     // 0x0138(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RingAddReserveCountPrev;                           // 0x013C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHoldItemInfo                          ItemInfoPrev;                                      // 0x0140(0x0080)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EIrregularEventId                             RacerIrregularEventIdPrev;                         // 0x01C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x7];                                      // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const int32& EventId, const int32& Value)> OnRacerStatusEventInt;  // 0x01C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const int32& EventId, const float& Value)> OnRacerStatusEventFloat; // 0x01D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         RacerIndex;                                        // 0x01E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RivalRacerIndex;                                   // 0x01EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 RivalRacersIndexArray;                             // 0x01F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_200[0xC];                                      // 0x0200(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerControllerIndex;                             // 0x020C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GroupIndex;                                        // 0x0210(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGroupColorId                                 GroupColorID;                                      // 0x0214(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDriverId                                     DriverId;                                          // 0x0215(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDriverType                                   DriverType;                                        // 0x0216(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERacerControlType                             RacerControlType;                                  // 0x0217(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrossplayPlatform                            CrossplayPlatform;                                 // 0x0218(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPlayable;                                        // 0x0219(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21A[0x2];                                      // 0x021A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ComLv;                                             // 0x021C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ComControlType;                                    // 0x0220(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MachineBehaviorID;                                 // 0x0224(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MachineId;                                         // 0x0228(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUserMachineCustomizeData              MachineCustomizeData;                              // 0x0230(0x0078)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	ECarStatusType                                MachineStatusType;                                 // 0x02A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUnionRaceCustomParam                  RaceCustomParam;                                   // 0x02AC(0x0014)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	double                                        HudOffset;                                         // 0x02C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDomainIndex                                  CurrentDomainIndex;                                // 0x02C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDomainIndex                                  PrevDomainIndex;                                   // 0x02C9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDomainNumber                                 CurrentDomainNumber;                               // 0x02CA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDomainNumber                                 PrevDomainNumber;                                  // 0x02CB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentLapCount;                                   // 0x02CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0[0x4];                                      // 0x02D0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ElapsedLapCount;                                   // 0x02D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentElapsedRatio;                               // 0x02D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElapsedRatio;                                      // 0x02DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunningDistance;                                   // 0x02E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInReverseRun;                                     // 0x02E4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInCourseOut;                                      // 0x02E5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInFootCutting;                                    // 0x02E6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInGoal;                                           // 0x02E7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldOffset;                                       // 0x02E8(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraWorldOffset;                                 // 0x0300(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentGravityNormal;                              // 0x0318(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RespotLocation;                                    // 0x0330(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RespotDirection;                                   // 0x0348(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMatrix                                RespotRotation;                                    // 0x0360(0x0080)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CurrentGravityLength;                              // 0x03E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rank;                                              // 0x03E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BeforeRaceRank;                                    // 0x03E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3EC[0x4];                                      // 0x03EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TotalRank;                                         // 0x03F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 FrontRankRacerIndices;                             // 0x03F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 BackRankRacerIndices;                              // 0x0408(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   RacerName;                                         // 0x0418(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EVehicleDisplayMode                           VehicleDisplayMode;                                // 0x0428(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDroneRemainDistance                          DroneRemainDistance;                               // 0x0429(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EIrregularEventId                             RacerIrregularEventId;                             // 0x042A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42B[0x1];                                      // 0x042B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AppearanceSteer;                                   // 0x042C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AppearanceCounterYaw;                              // 0x0430(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERacerDriftState                              CurrentDriftState;                                 // 0x0434(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_435[0x3];                                      // 0x0435(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUnionTyreMarkInfo>             TyreMarkInfo;                                      // 0x0438(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ReverseRunSeconds;                                 // 0x0448(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReverseRunRecoverCount;                            // 0x044C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackRunDistance;                                   // 0x0450(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoInputSignalTime;                                 // 0x0454(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TireRotSpeedMax_30fps1Screen;                      // 0x0458(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TireRotSpeedMax_30fpsOther;                        // 0x045C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TireRotSpeedMax_60fps1Screen;                      // 0x0460(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TireRotSpeedMax_60fpsOther;                        // 0x0464(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACarObject*                             CarObject;                                         // 0x0468(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Steering;                                          // 0x0470(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SteeringLR;                                        // 0x0474(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Accel;                                             // 0x0478(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Brake;                                             // 0x047C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_480[0x610];                                    // 0x0480(0x0610)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionVehicleModelInfo*                 UnionVehicleModelInfo;                             // 0x0A90(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionVehicleModelInfo*                 UnionVehicleModelInfoPrev;                         // 0x0A98(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionGameCameraInfo*                   UnionGameCameraInfo;                               // 0x0AA0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA8[0x18];                                     // 0x0AA8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AppCurrentDomainPosition;                          // 0x0AC0(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD8[0x18];                                     // 0x0AD8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AppLastDomainPosition;                             // 0x0AF0(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B08[0x1448];                                   // 0x0B08(0x1448)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUnionVehicleModelInfo*>         AppDomainVehicleModelInfos;                        // 0x1F50(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F60[0x140];                                   // 0x1F60(0x0140)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUnionGameCameraInfo*>           AppDomainGameCameraInfos;                          // 0x20A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	EDomainNumber                                 NextRaceDomainNumber;                              // 0x20B0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDomainNumber                                 PrevRaceDomainNumber;                              // 0x20B1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPassedOn;                                        // 0x20B2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShortcutRingPassedOn;                            // 0x20B3(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20B4[0x4];                                     // 0x20B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionRacePlayerStatus*                 RacePlayerStatus;                                  // 0x20B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUnionRaceStartDashParam               StartDashParam;                                    // 0x20C0(0x0030)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20F0[0x410];                                   // 0x20F0(0x0410)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddRaceCustomParam(const struct FUnionRaceCustomParam& InRaceCustomParam);
	void AddRunningDistance(float dist);
	void GetAppCurrentDomainPosition(struct FVector* OutAppCurrentDomainPosition);
	void GetAppDomainGameCameraInfos(TArray<class UUnionGameCameraInfo*>* OutAppDomainGameCameraInfos);
	void GetAppDomainVehicleModelInfos(TArray<class UUnionVehicleModelInfo*>* OutAppDomainVehicleModelInfos);
	void GetAppLastDomainPosition(struct FVector* OutAppLastDomainPosition);
	void GetCurrentDomainIndex(int32* OutCurrentDomainIndex);
	void GetCurrentDomainNumber(int32* OutCurrentDomainNumber);
	void GetCurrentElapsedRatio(float* OutElapsedRatio);
	void GetCurrentLapCount(int32* OutCurrentLapCount);
	void GetCurrentWorldOffset(struct FVector* OutWorldOffset);
	void GetEngineStatus(float* EngineRPM, float* EngineMaxRPM);
	void GetPlayerControllerIndex(int32* OutPlayerControllerIndex);
	class UUnionRacePlayerStatus* GetRacePlayerStatus();
	void GetRacerIndex(int32* OutRacerIndex);
	class FText GetRacerName();
	void GetRingCount(int32* OutRingCount);
	void GetRivalRacerIndex(int32* OutRacerIndex);
	void GetRivalRacersIndexArray(TArray<int32>* OutRacersIndexArray);
	int32 GetTestParam();
	void GetVehicleBodyGStatus(float* BodyG, float* BodyGd, float* BodyGr);
	void GetVehicleMoveSpeedStatus(float* SpeedMPH, float* SpeedKPH);
	void RemoveDamage(ERacerDamageType DamageType);
	void RequestBackCamera(bool flag);
	void ResetTakeDamage();
	void SetAirTrickAssistEnabled(bool bInNewValue);
	void SetAutoAcceleratorEnabled(bool bInNewValue);
	void SetClushGimmick(const struct FAttackedInfo& AttackedInfo);
	void SetCrossplayPlatform(ECrossplayPlatform InPlatform);
	void SetCurrentDomainIndex(EDomainIndex InCurrentDomainIndex);
	void SetCurrentDomainNumber(EDomainNumber InCurrentDomainNumber);
	void SetCurrentLapCount(int32 InCurrentLapCount);
	void SetCurrentWorldOffset(const struct FVector& InWorldOffset);
	void SetDriverId(EDriverId InDriverId);
	void SetDriverType(EDriverType InDriverType);
	void SetDroneRemainDistance(EDroneRemainDistance InDroneRemainDistance);
	void SetGroupIndex(int32 InGroupIndex);
	void SetHandleAssistEnabled(bool bInNewValue);
	void SetMachineBehaviorID(int32 InMachineBehaviorID);
	void SetMachineCustomizeData(const struct FUserMachineCustomizeData& InMachineCustomizeData);
	void SetMachineID(int32 InMachineID);
	void SetMachineStatusType(ECarStatusType NewStatus);
	void SetPlayable(bool InPlayable);
	void SetPlayerControllerIndex(int32 InPlayerControllerIndex);
	void SetRaceCustomParam(const struct FUnionRaceCustomParam& InRaceCustomParam);
	void SetRacerComControlType(int32 InComControlType);
	void SetRacerComLv(int32 InComLv);
	void SetRacerControlType(ERacerControlType InRacerControlType);
	void SetRacerIndex(int32 InRacerIndex);
	void SetRacerName(const class FText& InName);
	void SetRingCount(int32 InRingCount);
	void SetRivalRacerIndex(int32 InRacerIndex);
	void SetRivalRacersIndexArray(const TArray<int32>& InRacersIndex);
	void SetTakeDamage(const struct FAttackedInfo& AttackedInfo);
	void SetTestParam(int32 InNewParam);
	void SetTSRKeyAssignEnabled(bool bInNewValue);
	void SetViewSplitId(EViewSplitId InViewSplitId);

	float GetAppearanceCounterYaw() const;
	float GetAppearanceSteer() const;
	EDroneRemainDistance GetDroneRemainDistance() const;
	int32 GetGroupIndex() const;
	float GetInfiniteItemGauge(bool IsMain) const;
	float GetInfiniteItemGauge_New(EItemInfoType ItemInfoType) const;
	const struct FUserMachineCustomizeData GetMachineCustomizeData() const;
	ESoundPan GetPanSplitValue() const;
	void GetRaceCustomParam(struct FUnionRaceCustomParam* OutRaceCustomParam) const;
	int32 GetRacerComLv() const;
	ERacerControlType GetRacerControlType() const;
	EVehicleDisplayMode GetVehicleDisplayMode() const;
	EViewSplitId GetViewSplitId() const;
	bool IsAirTrickAssistEnabled() const;
	bool IsAnyDamage() const;
	bool IsAutoAcceleratorEnabled() const;
	bool IsClushGimmickObject() const;
	bool IsCom() const;
	bool IsGhostGoal() const;
	bool IsGhostHiddenInGame() const;
	bool IsGhostMachineEnabled() const;
	bool IsHandleAssistEnabled() const;
	bool IsItemIrregular(bool IsMain) const;
	bool IsItemIrregular_New(EItemInfoType ItemInfoType) const;
	bool IsLocalPlayer() const;
	bool IsLocalRacer() const;
	bool IsMachineCameraAssigned() const;
	bool IsOnlineCom() const;
	bool IsOnlinePlayer() const;
	bool IsRaceParkRivalRacerSkin() const;
	bool IsRemoteRacer() const;
	bool IsRivalCom() const;
	bool IsRivalPowerful() const;
	bool IsSomeonesCom() const;
	bool IsTakeDamage(ERacerDamageType DamageType) const;
	bool IsTakeSquashedDamage() const;
	bool IsTSRKeyAssignEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRacerStatusObject">();
	}
	static class UUnionRacerStatusObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRacerStatusObject>();
	}
};
static_assert(alignof(UUnionRacerStatusObject) == 0x000010, "Wrong alignment on UUnionRacerStatusObject");
static_assert(sizeof(UUnionRacerStatusObject) == 0x002500, "Wrong size on UUnionRacerStatusObject");
static_assert(offsetof(UUnionRacerStatusObject, RingCount) == 0x000028, "Member 'UUnionRacerStatusObject::RingCount' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, RingAddReserveCount) == 0x00002C, "Member 'UUnionRacerStatusObject::RingAddReserveCount' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, ItemInfo) == 0x000030, "Member 'UUnionRacerStatusObject::ItemInfo' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, AimInfo) == 0x0000B0, "Member 'UUnionRacerStatusObject::AimInfo' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, GadgetInfo) == 0x000128, "Member 'UUnionRacerStatusObject::GadgetInfo' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, RingCountPrev) == 0x000138, "Member 'UUnionRacerStatusObject::RingCountPrev' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, RingAddReserveCountPrev) == 0x00013C, "Member 'UUnionRacerStatusObject::RingAddReserveCountPrev' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, ItemInfoPrev) == 0x000140, "Member 'UUnionRacerStatusObject::ItemInfoPrev' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, RacerIrregularEventIdPrev) == 0x0001C0, "Member 'UUnionRacerStatusObject::RacerIrregularEventIdPrev' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, OnRacerStatusEventInt) == 0x0001C8, "Member 'UUnionRacerStatusObject::OnRacerStatusEventInt' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, OnRacerStatusEventFloat) == 0x0001D8, "Member 'UUnionRacerStatusObject::OnRacerStatusEventFloat' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, RacerIndex) == 0x0001E8, "Member 'UUnionRacerStatusObject::RacerIndex' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, RivalRacerIndex) == 0x0001EC, "Member 'UUnionRacerStatusObject::RivalRacerIndex' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, RivalRacersIndexArray) == 0x0001F0, "Member 'UUnionRacerStatusObject::RivalRacersIndexArray' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, PlayerControllerIndex) == 0x00020C, "Member 'UUnionRacerStatusObject::PlayerControllerIndex' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, GroupIndex) == 0x000210, "Member 'UUnionRacerStatusObject::GroupIndex' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, GroupColorID) == 0x000214, "Member 'UUnionRacerStatusObject::GroupColorID' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, DriverId) == 0x000215, "Member 'UUnionRacerStatusObject::DriverId' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, DriverType) == 0x000216, "Member 'UUnionRacerStatusObject::DriverType' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, RacerControlType) == 0x000217, "Member 'UUnionRacerStatusObject::RacerControlType' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, CrossplayPlatform) == 0x000218, "Member 'UUnionRacerStatusObject::CrossplayPlatform' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, IsPlayable) == 0x000219, "Member 'UUnionRacerStatusObject::IsPlayable' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, ComLv) == 0x00021C, "Member 'UUnionRacerStatusObject::ComLv' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, ComControlType) == 0x000220, "Member 'UUnionRacerStatusObject::ComControlType' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, MachineBehaviorID) == 0x000224, "Member 'UUnionRacerStatusObject::MachineBehaviorID' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, MachineId) == 0x000228, "Member 'UUnionRacerStatusObject::MachineId' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, MachineCustomizeData) == 0x000230, "Member 'UUnionRacerStatusObject::MachineCustomizeData' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, MachineStatusType) == 0x0002A8, "Member 'UUnionRacerStatusObject::MachineStatusType' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, RaceCustomParam) == 0x0002AC, "Member 'UUnionRacerStatusObject::RaceCustomParam' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, HudOffset) == 0x0002C0, "Member 'UUnionRacerStatusObject::HudOffset' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, CurrentDomainIndex) == 0x0002C8, "Member 'UUnionRacerStatusObject::CurrentDomainIndex' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, PrevDomainIndex) == 0x0002C9, "Member 'UUnionRacerStatusObject::PrevDomainIndex' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, CurrentDomainNumber) == 0x0002CA, "Member 'UUnionRacerStatusObject::CurrentDomainNumber' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, PrevDomainNumber) == 0x0002CB, "Member 'UUnionRacerStatusObject::PrevDomainNumber' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, CurrentLapCount) == 0x0002CC, "Member 'UUnionRacerStatusObject::CurrentLapCount' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, ElapsedLapCount) == 0x0002D4, "Member 'UUnionRacerStatusObject::ElapsedLapCount' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, CurrentElapsedRatio) == 0x0002D8, "Member 'UUnionRacerStatusObject::CurrentElapsedRatio' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, ElapsedRatio) == 0x0002DC, "Member 'UUnionRacerStatusObject::ElapsedRatio' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, RunningDistance) == 0x0002E0, "Member 'UUnionRacerStatusObject::RunningDistance' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, bInReverseRun) == 0x0002E4, "Member 'UUnionRacerStatusObject::bInReverseRun' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, bInCourseOut) == 0x0002E5, "Member 'UUnionRacerStatusObject::bInCourseOut' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, bInFootCutting) == 0x0002E6, "Member 'UUnionRacerStatusObject::bInFootCutting' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, bInGoal) == 0x0002E7, "Member 'UUnionRacerStatusObject::bInGoal' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, WorldOffset) == 0x0002E8, "Member 'UUnionRacerStatusObject::WorldOffset' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, CameraWorldOffset) == 0x000300, "Member 'UUnionRacerStatusObject::CameraWorldOffset' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, CurrentGravityNormal) == 0x000318, "Member 'UUnionRacerStatusObject::CurrentGravityNormal' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, RespotLocation) == 0x000330, "Member 'UUnionRacerStatusObject::RespotLocation' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, RespotDirection) == 0x000348, "Member 'UUnionRacerStatusObject::RespotDirection' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, RespotRotation) == 0x000360, "Member 'UUnionRacerStatusObject::RespotRotation' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, CurrentGravityLength) == 0x0003E0, "Member 'UUnionRacerStatusObject::CurrentGravityLength' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, Rank) == 0x0003E4, "Member 'UUnionRacerStatusObject::Rank' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, BeforeRaceRank) == 0x0003E8, "Member 'UUnionRacerStatusObject::BeforeRaceRank' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, TotalRank) == 0x0003F0, "Member 'UUnionRacerStatusObject::TotalRank' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, FrontRankRacerIndices) == 0x0003F8, "Member 'UUnionRacerStatusObject::FrontRankRacerIndices' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, BackRankRacerIndices) == 0x000408, "Member 'UUnionRacerStatusObject::BackRankRacerIndices' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, RacerName) == 0x000418, "Member 'UUnionRacerStatusObject::RacerName' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, VehicleDisplayMode) == 0x000428, "Member 'UUnionRacerStatusObject::VehicleDisplayMode' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, DroneRemainDistance) == 0x000429, "Member 'UUnionRacerStatusObject::DroneRemainDistance' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, RacerIrregularEventId) == 0x00042A, "Member 'UUnionRacerStatusObject::RacerIrregularEventId' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, AppearanceSteer) == 0x00042C, "Member 'UUnionRacerStatusObject::AppearanceSteer' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, AppearanceCounterYaw) == 0x000430, "Member 'UUnionRacerStatusObject::AppearanceCounterYaw' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, CurrentDriftState) == 0x000434, "Member 'UUnionRacerStatusObject::CurrentDriftState' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, TyreMarkInfo) == 0x000438, "Member 'UUnionRacerStatusObject::TyreMarkInfo' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, ReverseRunSeconds) == 0x000448, "Member 'UUnionRacerStatusObject::ReverseRunSeconds' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, ReverseRunRecoverCount) == 0x00044C, "Member 'UUnionRacerStatusObject::ReverseRunRecoverCount' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, BackRunDistance) == 0x000450, "Member 'UUnionRacerStatusObject::BackRunDistance' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, NoInputSignalTime) == 0x000454, "Member 'UUnionRacerStatusObject::NoInputSignalTime' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, TireRotSpeedMax_30fps1Screen) == 0x000458, "Member 'UUnionRacerStatusObject::TireRotSpeedMax_30fps1Screen' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, TireRotSpeedMax_30fpsOther) == 0x00045C, "Member 'UUnionRacerStatusObject::TireRotSpeedMax_30fpsOther' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, TireRotSpeedMax_60fps1Screen) == 0x000460, "Member 'UUnionRacerStatusObject::TireRotSpeedMax_60fps1Screen' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, TireRotSpeedMax_60fpsOther) == 0x000464, "Member 'UUnionRacerStatusObject::TireRotSpeedMax_60fpsOther' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, CarObject) == 0x000468, "Member 'UUnionRacerStatusObject::CarObject' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, Steering) == 0x000470, "Member 'UUnionRacerStatusObject::Steering' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, SteeringLR) == 0x000474, "Member 'UUnionRacerStatusObject::SteeringLR' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, Accel) == 0x000478, "Member 'UUnionRacerStatusObject::Accel' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, Brake) == 0x00047C, "Member 'UUnionRacerStatusObject::Brake' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, UnionVehicleModelInfo) == 0x000A90, "Member 'UUnionRacerStatusObject::UnionVehicleModelInfo' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, UnionVehicleModelInfoPrev) == 0x000A98, "Member 'UUnionRacerStatusObject::UnionVehicleModelInfoPrev' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, UnionGameCameraInfo) == 0x000AA0, "Member 'UUnionRacerStatusObject::UnionGameCameraInfo' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, AppCurrentDomainPosition) == 0x000AC0, "Member 'UUnionRacerStatusObject::AppCurrentDomainPosition' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, AppLastDomainPosition) == 0x000AF0, "Member 'UUnionRacerStatusObject::AppLastDomainPosition' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, AppDomainVehicleModelInfos) == 0x001F50, "Member 'UUnionRacerStatusObject::AppDomainVehicleModelInfos' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, AppDomainGameCameraInfos) == 0x0020A0, "Member 'UUnionRacerStatusObject::AppDomainGameCameraInfos' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, NextRaceDomainNumber) == 0x0020B0, "Member 'UUnionRacerStatusObject::NextRaceDomainNumber' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, PrevRaceDomainNumber) == 0x0020B1, "Member 'UUnionRacerStatusObject::PrevRaceDomainNumber' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, IsPassedOn) == 0x0020B2, "Member 'UUnionRacerStatusObject::IsPassedOn' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, IsShortcutRingPassedOn) == 0x0020B3, "Member 'UUnionRacerStatusObject::IsShortcutRingPassedOn' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, RacePlayerStatus) == 0x0020B8, "Member 'UUnionRacerStatusObject::RacePlayerStatus' has a wrong offset!");
static_assert(offsetof(UUnionRacerStatusObject, StartDashParam) == 0x0020C0, "Member 'UUnionRacerStatusObject::StartDashParam' has a wrong offset!");

// Class UnionRun.RaceUISubAirTrickInfo
// 0x0000 (0x02E0 - 0x02E0)
class URaceUISubAirTrickInfo : public UUserWidget
{
public:
	void SetAirTrickInfoAndFireAnimation(int32 SuccessCount, int32 SuccessBonusCount, bool IsGhostView);
	void SetAirTrickTextInfo(int32 SuccessCount, class UImage* Tex_1000, class UImage* Tex_0100, class UImage* Tex_0010, class UImage* Tex_0001, class UImage* Tex_Unit);

	int32 GetAirTrickBonusValue(int32 SuccessCount) const;
	int32 GetAirTrickValue(int32 SuccessCount) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceUISubAirTrickInfo">();
	}
	static class URaceUISubAirTrickInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceUISubAirTrickInfo>();
	}
};
static_assert(alignof(URaceUISubAirTrickInfo) == 0x000008, "Wrong alignment on URaceUISubAirTrickInfo");
static_assert(sizeof(URaceUISubAirTrickInfo) == 0x0002E0, "Wrong size on URaceUISubAirTrickInfo");

// Class UnionRun.RaceUISubApproachWarning
// 0x0140 (0x0420 - 0x02E0)
class URaceUISubApproachWarning : public UUserWidget
{
public:
	class UMaterialInstanceDynamic*               ItemIconMaterial;                                  // 0x02E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ItemIconShadowMaterial;                            // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EItemId, class UTexture2D*>              ItemIdSingle_TextureMap;                           // 0x02F0(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<EItemId, class UTexture2D*>              ItemIdSingleShadow_TextureMap;                     // 0x0340(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	EItemId                                       CurrentItemId;                                     // 0x0390(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFirstJumpIn;                                    // 0x0391(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_392[0x6];                                      // 0x0392(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USoundAtomCue*>                  ApproachSound;                                     // 0x0398(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCue*                          JumpInSound;                                       // 0x03B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B8[0x1];                                      // 0x03B8(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRacerApproach;                                    // 0x03B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBeepEnable;                                       // 0x03BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3BB[0x1];                                      // 0x03BB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Distance1;                                         // 0x03BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance2;                                         // 0x03C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance3;                                         // 0x03C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceDisable;                                   // 0x03C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceMax;                                       // 0x03CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRenderScale;                                    // 0x03D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           CanvasPanel_ItemWarning;                           // 0x03D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 WarningBlink_Add;                                  // 0x03E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 WarningBlink_Base;                                 // 0x03E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       ItemInComming;                                     // 0x03F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       ItemJumpIn;                                        // 0x03F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlinkSpeedRate;                                    // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_404[0x1C];                                     // 0x0404(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitItemEnemyApproachSetting(const float& InMaxScale, EUnionAttackItemInfoType AttackItemInfoType, const uint8& AttackItemId);
	void InitRacerApproachSetting();
	void OnPause(bool bInPause);
	void OnRemoveApproachWidget();
	void SetAttackTypeandId(const EUnionAttackItemInfoType& InAttackType, const EItemId& InItemId);
	void SetDriverId(EDriverId DriverId);
	void SetItemId(const int32& InItemId);
	void UpdateItemEnemyApproach(const float& ValueCM);
	void UpdateRacerApproach(const float& ValueCM);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceUISubApproachWarning">();
	}
	static class URaceUISubApproachWarning* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceUISubApproachWarning>();
	}
};
static_assert(alignof(URaceUISubApproachWarning) == 0x000008, "Wrong alignment on URaceUISubApproachWarning");
static_assert(sizeof(URaceUISubApproachWarning) == 0x000420, "Wrong size on URaceUISubApproachWarning");
static_assert(offsetof(URaceUISubApproachWarning, ItemIconMaterial) == 0x0002E0, "Member 'URaceUISubApproachWarning::ItemIconMaterial' has a wrong offset!");
static_assert(offsetof(URaceUISubApproachWarning, ItemIconShadowMaterial) == 0x0002E8, "Member 'URaceUISubApproachWarning::ItemIconShadowMaterial' has a wrong offset!");
static_assert(offsetof(URaceUISubApproachWarning, ItemIdSingle_TextureMap) == 0x0002F0, "Member 'URaceUISubApproachWarning::ItemIdSingle_TextureMap' has a wrong offset!");
static_assert(offsetof(URaceUISubApproachWarning, ItemIdSingleShadow_TextureMap) == 0x000340, "Member 'URaceUISubApproachWarning::ItemIdSingleShadow_TextureMap' has a wrong offset!");
static_assert(offsetof(URaceUISubApproachWarning, CurrentItemId) == 0x000390, "Member 'URaceUISubApproachWarning::CurrentItemId' has a wrong offset!");
static_assert(offsetof(URaceUISubApproachWarning, bIsFirstJumpIn) == 0x000391, "Member 'URaceUISubApproachWarning::bIsFirstJumpIn' has a wrong offset!");
static_assert(offsetof(URaceUISubApproachWarning, ApproachSound) == 0x000398, "Member 'URaceUISubApproachWarning::ApproachSound' has a wrong offset!");
static_assert(offsetof(URaceUISubApproachWarning, JumpInSound) == 0x0003B0, "Member 'URaceUISubApproachWarning::JumpInSound' has a wrong offset!");
static_assert(offsetof(URaceUISubApproachWarning, bRacerApproach) == 0x0003B9, "Member 'URaceUISubApproachWarning::bRacerApproach' has a wrong offset!");
static_assert(offsetof(URaceUISubApproachWarning, bBeepEnable) == 0x0003BA, "Member 'URaceUISubApproachWarning::bBeepEnable' has a wrong offset!");
static_assert(offsetof(URaceUISubApproachWarning, Distance1) == 0x0003BC, "Member 'URaceUISubApproachWarning::Distance1' has a wrong offset!");
static_assert(offsetof(URaceUISubApproachWarning, Distance2) == 0x0003C0, "Member 'URaceUISubApproachWarning::Distance2' has a wrong offset!");
static_assert(offsetof(URaceUISubApproachWarning, Distance3) == 0x0003C4, "Member 'URaceUISubApproachWarning::Distance3' has a wrong offset!");
static_assert(offsetof(URaceUISubApproachWarning, DistanceDisable) == 0x0003C8, "Member 'URaceUISubApproachWarning::DistanceDisable' has a wrong offset!");
static_assert(offsetof(URaceUISubApproachWarning, DistanceMax) == 0x0003CC, "Member 'URaceUISubApproachWarning::DistanceMax' has a wrong offset!");
static_assert(offsetof(URaceUISubApproachWarning, MaxRenderScale) == 0x0003D0, "Member 'URaceUISubApproachWarning::MaxRenderScale' has a wrong offset!");
static_assert(offsetof(URaceUISubApproachWarning, CanvasPanel_ItemWarning) == 0x0003D8, "Member 'URaceUISubApproachWarning::CanvasPanel_ItemWarning' has a wrong offset!");
static_assert(offsetof(URaceUISubApproachWarning, WarningBlink_Add) == 0x0003E0, "Member 'URaceUISubApproachWarning::WarningBlink_Add' has a wrong offset!");
static_assert(offsetof(URaceUISubApproachWarning, WarningBlink_Base) == 0x0003E8, "Member 'URaceUISubApproachWarning::WarningBlink_Base' has a wrong offset!");
static_assert(offsetof(URaceUISubApproachWarning, ItemInComming) == 0x0003F0, "Member 'URaceUISubApproachWarning::ItemInComming' has a wrong offset!");
static_assert(offsetof(URaceUISubApproachWarning, ItemJumpIn) == 0x0003F8, "Member 'URaceUISubApproachWarning::ItemJumpIn' has a wrong offset!");
static_assert(offsetof(URaceUISubApproachWarning, BlinkSpeedRate) == 0x000400, "Member 'URaceUISubApproachWarning::BlinkSpeedRate' has a wrong offset!");

// Class UnionRun.UnionRacerFunction
// 0x0000 (0x0028 - 0x0028)
class UUnionRacerFunction final : public UBlueprintFunctionLibrary
{
public:
	static float GetDistance(const struct FVector& Pos1, const struct FVector& Pos2);
	static int32 GetRacerGroupIndex(int32 InRacerIndex);
	static int32 GetRacerIndexByDriverID(EDriverId DriverId);
	static int32 GetRacerIndexByPlayerID(int32 PlayerId);
	static float GetRankingSkipInterval();
	static float GetRankUpGaugeSpeed();
	static class UUnionRacers* GetUnionRacers();
	static bool IsInScreen(const class APlayerController* PlayerController, const struct FVector& Position);
	static bool IsSameGroup(int32 InRacerIndexA, int32 InRacerIndexB);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRacerFunction">();
	}
	static class UUnionRacerFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRacerFunction>();
	}
};
static_assert(alignof(UUnionRacerFunction) == 0x000008, "Wrong alignment on UUnionRacerFunction");
static_assert(sizeof(UUnionRacerFunction) == 0x000028, "Wrong size on UUnionRacerFunction");

// Class UnionRun.RaceUISubBasicOperation
// 0x0000 (0x02E0 - 0x02E0)
class URaceUISubBasicOperation : public UUserWidget
{
public:
	bool IsKeyboard() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceUISubBasicOperation">();
	}
	static class URaceUISubBasicOperation* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceUISubBasicOperation>();
	}
};
static_assert(alignof(URaceUISubBasicOperation) == 0x000008, "Wrong alignment on URaceUISubBasicOperation");
static_assert(sizeof(URaceUISubBasicOperation) == 0x0002E0, "Wrong size on URaceUISubBasicOperation");

// Class UnionRun.UnionRaceHitInfoGroup
// 0x0060 (0x0340 - 0x02E0)
class UUnionRaceHitInfoGroup : public UUserWidget
{
public:
	float                                         ActiveTimer;                                       // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUIActive;                                        // 0x02E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E5[0x3];                                      // 0x02E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ItemIdIndex;                                       // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               ItemIconMaterial;                                  // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ItemIconShadowMaterial;                            // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTexture2D*>                     ItemIconTexture;                                   // 0x0300(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UTexture2D*>                     ItemShadowTexture;                                 // 0x0310(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_320[0x20];                                     // 0x0320(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetItemIdIndex_Impl(int32 InItemIdIndex);
	void UpdateHitInfoGroup(float Delta);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRaceHitInfoGroup">();
	}
	static class UUnionRaceHitInfoGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRaceHitInfoGroup>();
	}
};
static_assert(alignof(UUnionRaceHitInfoGroup) == 0x000008, "Wrong alignment on UUnionRaceHitInfoGroup");
static_assert(sizeof(UUnionRaceHitInfoGroup) == 0x000340, "Wrong size on UUnionRaceHitInfoGroup");
static_assert(offsetof(UUnionRaceHitInfoGroup, ActiveTimer) == 0x0002E0, "Member 'UUnionRaceHitInfoGroup::ActiveTimer' has a wrong offset!");
static_assert(offsetof(UUnionRaceHitInfoGroup, IsUIActive) == 0x0002E4, "Member 'UUnionRaceHitInfoGroup::IsUIActive' has a wrong offset!");
static_assert(offsetof(UUnionRaceHitInfoGroup, ItemIdIndex) == 0x0002E8, "Member 'UUnionRaceHitInfoGroup::ItemIdIndex' has a wrong offset!");
static_assert(offsetof(UUnionRaceHitInfoGroup, ItemIconMaterial) == 0x0002F0, "Member 'UUnionRaceHitInfoGroup::ItemIconMaterial' has a wrong offset!");
static_assert(offsetof(UUnionRaceHitInfoGroup, ItemIconShadowMaterial) == 0x0002F8, "Member 'UUnionRaceHitInfoGroup::ItemIconShadowMaterial' has a wrong offset!");
static_assert(offsetof(UUnionRaceHitInfoGroup, ItemIconTexture) == 0x000300, "Member 'UUnionRaceHitInfoGroup::ItemIconTexture' has a wrong offset!");
static_assert(offsetof(UUnionRaceHitInfoGroup, ItemShadowTexture) == 0x000310, "Member 'UUnionRaceHitInfoGroup::ItemShadowTexture' has a wrong offset!");

// Class UnionRun.RaceUISubBtnGuide
// 0x0000 (0x02E0 - 0x02E0)
class URaceUISubBtnGuide : public UUserWidget
{
public:
	EBtnGuidePlatFormController GetControllerType(int32 PlayerControllerIndex, bool IsNotSetKey);
	void GetUseItemKey(int32 PlayerControllerIndex);
	void SetUseItemKey(const struct FKey& UseItemKey);

	struct FKey GetFlightGuideKey(int32 PlayerControllerIndex, bool bSuggestUpInput) const;
	class FText GetKeyDisplayName(const struct FKey& InKey, int32 PlayerControllerIndex) const;
	int32 GetMouseButtonIndex(const struct FKey& InKey) const;
	struct FKey GetReleaseEffectKey(int32 PlayerControllerIndex) const;
	struct FKey GetSteerKey(int32 PlayerControllerIndex, int32 SteerNo) const;
	struct FKey GetUseItemKeyPC(int32 PlayerControllerIndex) const;
	bool IsKeyboard() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceUISubBtnGuide">();
	}
	static class URaceUISubBtnGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceUISubBtnGuide>();
	}
};
static_assert(alignof(URaceUISubBtnGuide) == 0x000008, "Wrong alignment on URaceUISubBtnGuide");
static_assert(sizeof(URaceUISubBtnGuide) == 0x0002E0, "Wrong size on URaceUISubBtnGuide");

// Class UnionRun.RacerReactionTextDataAsset
// 0x0010 (0x0040 - 0x0030)
class URacerReactionTextDataAsset final : public UDataAsset
{
public:
	TArray<struct FRacerReactionText>             TextList;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RacerReactionTextDataAsset">();
	}
	static class URacerReactionTextDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URacerReactionTextDataAsset>();
	}
};
static_assert(alignof(URacerReactionTextDataAsset) == 0x000008, "Wrong alignment on URacerReactionTextDataAsset");
static_assert(sizeof(URacerReactionTextDataAsset) == 0x000040, "Wrong size on URacerReactionTextDataAsset");
static_assert(offsetof(URacerReactionTextDataAsset, TextList) == 0x000030, "Member 'URacerReactionTextDataAsset::TextList' has a wrong offset!");

// Class UnionRun.RaceUISubCourseMapIcon
// 0x0010 (0x02F0 - 0x02E0)
class URaceUISubCourseMapIcon final : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsReader;                                          // 0x02E8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetReaderFlag(bool InReader);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceUISubCourseMapIcon">();
	}
	static class URaceUISubCourseMapIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceUISubCourseMapIcon>();
	}
};
static_assert(alignof(URaceUISubCourseMapIcon) == 0x000008, "Wrong alignment on URaceUISubCourseMapIcon");
static_assert(sizeof(URaceUISubCourseMapIcon) == 0x0002F0, "Wrong size on URaceUISubCourseMapIcon");
static_assert(offsetof(URaceUISubCourseMapIcon, IsReader) == 0x0002E8, "Member 'URaceUISubCourseMapIcon::IsReader' has a wrong offset!");

// Class UnionRun.RaceUISubGadgetIcon
// 0x0008 (0x02E8 - 0x02E0)
class URaceUISubGadgetIcon final : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetGadgetId(EGadgetId InGadgetId);
	void SetIconMaterial(int32 IconIndex);

	EGadgetId GetGadgetId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceUISubGadgetIcon">();
	}
	static class URaceUISubGadgetIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceUISubGadgetIcon>();
	}
};
static_assert(alignof(URaceUISubGadgetIcon) == 0x000008, "Wrong alignment on URaceUISubGadgetIcon");
static_assert(sizeof(URaceUISubGadgetIcon) == 0x0002E8, "Wrong size on URaceUISubGadgetIcon");

// Class UnionRun.RaceUISubRing
// 0x0060 (0x0340 - 0x02E0)
class URaceUISubRing : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x4];                                      // 0x02E0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentRingCount;                                  // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRingCount;                                      // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultMaxRingCount;                               // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOverDefault;                                     // 0x02F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNowPlayingOverSE;                                // 0x02F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F2[0x6];                                      // 0x02F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 NUM_Tex_100;                                       // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 NUM_Tex_010;                                       // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 NUM_Tex_001;                                       // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFirstEarned;                                      // 0x0310(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       CurrentLoopAnim;                                   // 0x0318(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_320[0x8];                                      // 0x0320(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       Ring_Loop_Red;                                     // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 RingBase_Eff_Img;                                  // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCircularThrobber*                      Eff_Ct;                                            // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetCurrentRingCount(const int32& NewRingCount);
	void SetParams(int32 RacerIndex);
	void SetRingBackColor(int32 Index_0, bool IsGroup, bool IsLocalMulti);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceUISubRing">();
	}
	static class URaceUISubRing* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceUISubRing>();
	}
};
static_assert(alignof(URaceUISubRing) == 0x000008, "Wrong alignment on URaceUISubRing");
static_assert(sizeof(URaceUISubRing) == 0x000340, "Wrong size on URaceUISubRing");
static_assert(offsetof(URaceUISubRing, CurrentRingCount) == 0x0002E4, "Member 'URaceUISubRing::CurrentRingCount' has a wrong offset!");
static_assert(offsetof(URaceUISubRing, MaxRingCount) == 0x0002E8, "Member 'URaceUISubRing::MaxRingCount' has a wrong offset!");
static_assert(offsetof(URaceUISubRing, DefaultMaxRingCount) == 0x0002EC, "Member 'URaceUISubRing::DefaultMaxRingCount' has a wrong offset!");
static_assert(offsetof(URaceUISubRing, IsOverDefault) == 0x0002F0, "Member 'URaceUISubRing::IsOverDefault' has a wrong offset!");
static_assert(offsetof(URaceUISubRing, IsNowPlayingOverSE) == 0x0002F1, "Member 'URaceUISubRing::IsNowPlayingOverSE' has a wrong offset!");
static_assert(offsetof(URaceUISubRing, NUM_Tex_100) == 0x0002F8, "Member 'URaceUISubRing::NUM_Tex_100' has a wrong offset!");
static_assert(offsetof(URaceUISubRing, NUM_Tex_010) == 0x000300, "Member 'URaceUISubRing::NUM_Tex_010' has a wrong offset!");
static_assert(offsetof(URaceUISubRing, NUM_Tex_001) == 0x000308, "Member 'URaceUISubRing::NUM_Tex_001' has a wrong offset!");
static_assert(offsetof(URaceUISubRing, bFirstEarned) == 0x000310, "Member 'URaceUISubRing::bFirstEarned' has a wrong offset!");
static_assert(offsetof(URaceUISubRing, CurrentLoopAnim) == 0x000318, "Member 'URaceUISubRing::CurrentLoopAnim' has a wrong offset!");
static_assert(offsetof(URaceUISubRing, Ring_Loop_Red) == 0x000328, "Member 'URaceUISubRing::Ring_Loop_Red' has a wrong offset!");
static_assert(offsetof(URaceUISubRing, RingBase_Eff_Img) == 0x000330, "Member 'URaceUISubRing::RingBase_Eff_Img' has a wrong offset!");
static_assert(offsetof(URaceUISubRing, Eff_Ct) == 0x000338, "Member 'URaceUISubRing::Eff_Ct' has a wrong offset!");

// Class UnionRun.UnionRaceSituationObject
// 0x0118 (0x0140 - 0x0028)
class UUnionRaceSituationObject final : public UObject
{
public:
	int32                                         Rank;                                              // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PrevRank;                                          // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LeadingRacerIndex;                                 // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LeadingRateDiff;                                   // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LeadingDistDiff;                                   // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FollowingRacerIndex;                               // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FollowingRatioDiff;                                // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FollowingDistDiff;                                 // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         rivalDistDiff;                                     // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         oddNumRankSeconds;                                 // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTeamEnergyCharging;                               // 0x0050(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInFootCutRing;                                    // 0x0051(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_52[0xEE];                                      // 0x0052(0x00EE)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsFootCutting();
	bool IsTeamEnergyCharging();
	void SetFollowingDistDiff(float followingDistance);
	void SetFollowingRacerIndex(int32 RacerIndex);
	void SetFollowingRatioDiff(float followingDistance);
	void SetLeadingDistDiff(float leadingDistance);
	void SetLeadingRacerIndex(int32 RacerIndex);
	void SetLeadingRatioDiff(float leadingDistance);
	void SetOddNumRankSeconds(float oddNumRankSeconds_0);
	void SetPrevRank(int32 Rank_0);
	void SetRank(int32 Rank_0);
	void SetRivalDistDiff(float rivalDistDiff_0);
	void SetTeamEnergyCharging(bool bCharging);

	float GetFollowingDistDiff() const;
	int32 GetFollowingRacerIndex() const;
	float GetFollowingRatioDiff() const;
	float GetLeadingDistDiff() const;
	int32 GetLeadingRacerIndex() const;
	float GetLeadingRatioDiff() const;
	float GetOddNumRankSeconds() const;
	int32 GetPrevRank() const;
	int32 GetRank() const;
	float GetRivalDistDiff() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRaceSituationObject">();
	}
	static class UUnionRaceSituationObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRaceSituationObject>();
	}
};
static_assert(alignof(UUnionRaceSituationObject) == 0x000008, "Wrong alignment on UUnionRaceSituationObject");
static_assert(sizeof(UUnionRaceSituationObject) == 0x000140, "Wrong size on UUnionRaceSituationObject");
static_assert(offsetof(UUnionRaceSituationObject, Rank) == 0x000028, "Member 'UUnionRaceSituationObject::Rank' has a wrong offset!");
static_assert(offsetof(UUnionRaceSituationObject, PrevRank) == 0x00002C, "Member 'UUnionRaceSituationObject::PrevRank' has a wrong offset!");
static_assert(offsetof(UUnionRaceSituationObject, LeadingRacerIndex) == 0x000030, "Member 'UUnionRaceSituationObject::LeadingRacerIndex' has a wrong offset!");
static_assert(offsetof(UUnionRaceSituationObject, LeadingRateDiff) == 0x000034, "Member 'UUnionRaceSituationObject::LeadingRateDiff' has a wrong offset!");
static_assert(offsetof(UUnionRaceSituationObject, LeadingDistDiff) == 0x000038, "Member 'UUnionRaceSituationObject::LeadingDistDiff' has a wrong offset!");
static_assert(offsetof(UUnionRaceSituationObject, FollowingRacerIndex) == 0x00003C, "Member 'UUnionRaceSituationObject::FollowingRacerIndex' has a wrong offset!");
static_assert(offsetof(UUnionRaceSituationObject, FollowingRatioDiff) == 0x000040, "Member 'UUnionRaceSituationObject::FollowingRatioDiff' has a wrong offset!");
static_assert(offsetof(UUnionRaceSituationObject, FollowingDistDiff) == 0x000044, "Member 'UUnionRaceSituationObject::FollowingDistDiff' has a wrong offset!");
static_assert(offsetof(UUnionRaceSituationObject, rivalDistDiff) == 0x000048, "Member 'UUnionRaceSituationObject::rivalDistDiff' has a wrong offset!");
static_assert(offsetof(UUnionRaceSituationObject, oddNumRankSeconds) == 0x00004C, "Member 'UUnionRaceSituationObject::oddNumRankSeconds' has a wrong offset!");
static_assert(offsetof(UUnionRaceSituationObject, bTeamEnergyCharging) == 0x000050, "Member 'UUnionRaceSituationObject::bTeamEnergyCharging' has a wrong offset!");
static_assert(offsetof(UUnionRaceSituationObject, bInFootCutRing) == 0x000051, "Member 'UUnionRaceSituationObject::bInFootCutRing' has a wrong offset!");

// Class UnionRun.RaceUISubGroupRing
// 0x0000 (0x0340 - 0x0340)
class URaceUISubGroupRing final : public URaceUISubRing
{
public:
	void SetRingCharaIcon(EDriverId DriverId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceUISubGroupRing">();
	}
	static class URaceUISubGroupRing* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceUISubGroupRing>();
	}
};
static_assert(alignof(URaceUISubGroupRing) == 0x000008, "Wrong alignment on URaceUISubGroupRing");
static_assert(sizeof(URaceUISubGroupRing) == 0x000340, "Wrong size on URaceUISubGroupRing");

// Class UnionRun.RaceUISubHitInfo
// 0x0040 (0x0320 - 0x02E0)
class URaceUISubHitInfo : public UUserWidget
{
public:
	class UMaterialInstanceDynamic*               LostItemIconMaterial;                              // 0x02E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LostItemIdIndex;                                   // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTexture2D*>                     ItemIconTexture;                                   // 0x02F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_300[0x20];                                     // 0x0300(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCharaIndex(int32 Index_0, bool IsRival);
	void SetCOMBackColor();
	void SetGroupColorMaterial(int32 Index_0);
	void SetLocalPlayerColorMaterial(int32 Index_0);
	void SetLostItemIdIndex_Implement(int32 InItemIdIndex);
	void SetPlatformIcon(ECrossplayPlatform Platform);
	void SwitchBaseUI(bool IsRival, bool IsPowerRival);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceUISubHitInfo">();
	}
	static class URaceUISubHitInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceUISubHitInfo>();
	}
};
static_assert(alignof(URaceUISubHitInfo) == 0x000008, "Wrong alignment on URaceUISubHitInfo");
static_assert(sizeof(URaceUISubHitInfo) == 0x000320, "Wrong size on URaceUISubHitInfo");
static_assert(offsetof(URaceUISubHitInfo, LostItemIconMaterial) == 0x0002E0, "Member 'URaceUISubHitInfo::LostItemIconMaterial' has a wrong offset!");
static_assert(offsetof(URaceUISubHitInfo, LostItemIdIndex) == 0x0002E8, "Member 'URaceUISubHitInfo::LostItemIdIndex' has a wrong offset!");
static_assert(offsetof(URaceUISubHitInfo, ItemIconTexture) == 0x0002F0, "Member 'URaceUISubHitInfo::ItemIconTexture' has a wrong offset!");

// Class UnionRun.RacerReactionDataAsset
// 0x0018 (0x0048 - 0x0030)
class URacerReactionDataAsset final : public UDataAsset
{
public:
	class UDataTable*                             DataTable;                                         // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRacerReactionRecord                   Data;                                              // 0x0038(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RacerReactionDataAsset">();
	}
	static class URacerReactionDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URacerReactionDataAsset>();
	}
};
static_assert(alignof(URacerReactionDataAsset) == 0x000008, "Wrong alignment on URacerReactionDataAsset");
static_assert(sizeof(URacerReactionDataAsset) == 0x000048, "Wrong size on URacerReactionDataAsset");
static_assert(offsetof(URacerReactionDataAsset, DataTable) == 0x000030, "Member 'URacerReactionDataAsset::DataTable' has a wrong offset!");
static_assert(offsetof(URacerReactionDataAsset, Data) == 0x000038, "Member 'URacerReactionDataAsset::Data' has a wrong offset!");

// Class UnionRun.RaceUISubItemIcon
// 0x04A0 (0x0780 - 0x02E0)
class URaceUISubItemIcon : public UUserWidget
{
public:
	TMap<EItemId, class UTexture2D*>              ItemId_TextureMap;                                 // 0x02E0(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<EItemId, class UTexture2D*>              ItemIdTriple_TextureMap;                           // 0x0330(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<EItemId, class UTexture2D*>              ItemIdDouble_TextureMap;                           // 0x0380(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<EItemId, class UTexture2D*>              ItemIdSingle_TextureMap;                           // 0x03D0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ESoundPan                                     UISoundPan;                                        // 0x0420(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_421[0x7];                                      // 0x0421(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UHorizontalBox*                         RingNum;                                           // 0x0428(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHorizontalBox*                         RingNum_Addtive;                                   // 0x0430(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           Canvas_Panel_Icon;                                 // 0x0438(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           Canvas_Panel_ItemIconRoot;                         // 0x0440(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ArdGauge;                                          // 0x0448(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 PackageRing;                                       // 0x0450(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            ControllerButtonIcon;                              // 0x0458(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ItemIconMaterial;                                  // 0x0460(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ItemIconAddtiveMaterial;                           // 0x0468(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EPackageRingNumColor, class UMaterialInstance*> PackageRingNumColorMaterial;                // 0x0470(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<EPackageRingNumColor, class UMaterialInstance*> PackageRingNumColorMaterial_Add;            // 0x04C0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_510[0x8];                                      // 0x0510(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPackageRingNumColor, class UMaterialInstanceDynamic*> RingNumMaterialMap_100;              // 0x0518(0x0050)(BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<EPackageRingNumColor, class UMaterialInstanceDynamic*> RingNumMaterialMap_10;               // 0x0568(0x0050)(BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<EPackageRingNumColor, class UMaterialInstanceDynamic*> RingNumMaterialMap_01;               // 0x05B8(0x0050)(BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<EPackageRingNumColor, class UMaterialInstanceDynamic*> RingNumMaterialMap_100_Add;          // 0x0608(0x0050)(BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<EPackageRingNumColor, class UMaterialInstanceDynamic*> RingNumMaterialMap_10_Add;           // 0x0658(0x0050)(BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<EPackageRingNumColor, class UMaterialInstanceDynamic*> RingNumMaterialMap_01_Add;           // 0x06A8(0x0050)(BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UImage*>                         PackageRingNumDigitImage;                          // 0x06F8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UImage*>                         PackageRingNumDigitImage_Add;                      // 0x0708(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               AttributeFrameMaterial;                            // 0x0718(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 AttributIconImage;                                 // 0x0720(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               AttributIconMaterial;                              // 0x0728(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemIdIndex;                                       // 0x0730(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RemainCount;                                       // 0x0734(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMainIcon;                                         // 0x0738(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLotteryingAnim;                                   // 0x0739(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoopAnimPlaying;                                  // 0x073A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_73B[0x45];                                     // 0x073B(0x0045)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseLottery();
	void DisplayHideAnim(bool Display);
	void FireUseAnim();
	uint8 GetRandomLotteryDisplayItemId();
	void ItemLostAnimStart(bool bHideIcon);
	void LotteryAnimEnd();
	void LotteryAnimStart();
	void LotteryDecideFinished();
	void LotterySeqStart(bool LotterySound);
	void OnFinishedDecide();
	void OnFinishedInAnim();
	void OnFinishedOutAnim();
	void PlayLoopAnim();
	void SetAttributeColorIndex(int32 InAttributeIndex);
	void SetGaugeType(bool bRemainCountGauge);
	void SetItemIdIndex(int32 InItemIdIndex, int32 InRemainCount, bool bIgnoreAttribute, bool bOnLottery);
	void SetItemIdTexture(const TMap<EItemId, class UTexture2D*>& InItemId_TextureMap);
	void SetLotteryDisplayItemIds(const TArray<uint8>& ItemIds);
	void SetRemainCountGauge(int32 Count, int32 MaxCount);
	void SetRingNum(int32 InRingCount);
	void SetRingNumVisible(bool bVisible);
	void SetupPackageRing();
	void StartCountDownBlink();
	void StopCountDownBlink();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceUISubItemIcon">();
	}
	static class URaceUISubItemIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceUISubItemIcon>();
	}
};
static_assert(alignof(URaceUISubItemIcon) == 0x000008, "Wrong alignment on URaceUISubItemIcon");
static_assert(sizeof(URaceUISubItemIcon) == 0x000780, "Wrong size on URaceUISubItemIcon");
static_assert(offsetof(URaceUISubItemIcon, ItemId_TextureMap) == 0x0002E0, "Member 'URaceUISubItemIcon::ItemId_TextureMap' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, ItemIdTriple_TextureMap) == 0x000330, "Member 'URaceUISubItemIcon::ItemIdTriple_TextureMap' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, ItemIdDouble_TextureMap) == 0x000380, "Member 'URaceUISubItemIcon::ItemIdDouble_TextureMap' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, ItemIdSingle_TextureMap) == 0x0003D0, "Member 'URaceUISubItemIcon::ItemIdSingle_TextureMap' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, UISoundPan) == 0x000420, "Member 'URaceUISubItemIcon::UISoundPan' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, RingNum) == 0x000428, "Member 'URaceUISubItemIcon::RingNum' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, RingNum_Addtive) == 0x000430, "Member 'URaceUISubItemIcon::RingNum_Addtive' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, Canvas_Panel_Icon) == 0x000438, "Member 'URaceUISubItemIcon::Canvas_Panel_Icon' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, Canvas_Panel_ItemIconRoot) == 0x000440, "Member 'URaceUISubItemIcon::Canvas_Panel_ItemIconRoot' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, ArdGauge) == 0x000448, "Member 'URaceUISubItemIcon::ArdGauge' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, PackageRing) == 0x000450, "Member 'URaceUISubItemIcon::PackageRing' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, ControllerButtonIcon) == 0x000458, "Member 'URaceUISubItemIcon::ControllerButtonIcon' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, ItemIconMaterial) == 0x000460, "Member 'URaceUISubItemIcon::ItemIconMaterial' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, ItemIconAddtiveMaterial) == 0x000468, "Member 'URaceUISubItemIcon::ItemIconAddtiveMaterial' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, PackageRingNumColorMaterial) == 0x000470, "Member 'URaceUISubItemIcon::PackageRingNumColorMaterial' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, PackageRingNumColorMaterial_Add) == 0x0004C0, "Member 'URaceUISubItemIcon::PackageRingNumColorMaterial_Add' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, RingNumMaterialMap_100) == 0x000518, "Member 'URaceUISubItemIcon::RingNumMaterialMap_100' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, RingNumMaterialMap_10) == 0x000568, "Member 'URaceUISubItemIcon::RingNumMaterialMap_10' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, RingNumMaterialMap_01) == 0x0005B8, "Member 'URaceUISubItemIcon::RingNumMaterialMap_01' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, RingNumMaterialMap_100_Add) == 0x000608, "Member 'URaceUISubItemIcon::RingNumMaterialMap_100_Add' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, RingNumMaterialMap_10_Add) == 0x000658, "Member 'URaceUISubItemIcon::RingNumMaterialMap_10_Add' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, RingNumMaterialMap_01_Add) == 0x0006A8, "Member 'URaceUISubItemIcon::RingNumMaterialMap_01_Add' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, PackageRingNumDigitImage) == 0x0006F8, "Member 'URaceUISubItemIcon::PackageRingNumDigitImage' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, PackageRingNumDigitImage_Add) == 0x000708, "Member 'URaceUISubItemIcon::PackageRingNumDigitImage_Add' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, AttributeFrameMaterial) == 0x000718, "Member 'URaceUISubItemIcon::AttributeFrameMaterial' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, AttributIconImage) == 0x000720, "Member 'URaceUISubItemIcon::AttributIconImage' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, AttributIconMaterial) == 0x000728, "Member 'URaceUISubItemIcon::AttributIconMaterial' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, ItemIdIndex) == 0x000730, "Member 'URaceUISubItemIcon::ItemIdIndex' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, RemainCount) == 0x000734, "Member 'URaceUISubItemIcon::RemainCount' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, bMainIcon) == 0x000738, "Member 'URaceUISubItemIcon::bMainIcon' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, bLotteryingAnim) == 0x000739, "Member 'URaceUISubItemIcon::bLotteryingAnim' has a wrong offset!");
static_assert(offsetof(URaceUISubItemIcon, bLoopAnimPlaying) == 0x00073A, "Member 'URaceUISubItemIcon::bLoopAnimPlaying' has a wrong offset!");

// Class UnionRun.RaceUISubItemSummonButton
// 0x0010 (0x02F0 - 0x02E0)
class URaceUISubItemSummonButton : public UUserWidget
{
public:
	class UBorder*                                BorderButton;                                      // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvailable;                                        // 0x02E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSummonInputKey(const struct FKey& Key, bool IsKeyboard, int32 PlayerControllerIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceUISubItemSummonButton">();
	}
	static class URaceUISubItemSummonButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceUISubItemSummonButton>();
	}
};
static_assert(alignof(URaceUISubItemSummonButton) == 0x000008, "Wrong alignment on URaceUISubItemSummonButton");
static_assert(sizeof(URaceUISubItemSummonButton) == 0x0002F0, "Wrong size on URaceUISubItemSummonButton");
static_assert(offsetof(URaceUISubItemSummonButton, BorderButton) == 0x0002E0, "Member 'URaceUISubItemSummonButton::BorderButton' has a wrong offset!");
static_assert(offsetof(URaceUISubItemSummonButton, bAvailable) == 0x0002E8, "Member 'URaceUISubItemSummonButton::bAvailable' has a wrong offset!");

// Class UnionRun.UnionCheckAcrossDomain
// 0x0018 (0x0050 - 0x0038)
class UUnionCheckAcrossDomain final : public UMoveController
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionCheckAcrossDomain">();
	}
	static class UUnionCheckAcrossDomain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionCheckAcrossDomain>();
	}
};
static_assert(alignof(UUnionCheckAcrossDomain) == 0x000008, "Wrong alignment on UUnionCheckAcrossDomain");
static_assert(sizeof(UUnionCheckAcrossDomain) == 0x000050, "Wrong size on UUnionCheckAcrossDomain");

// Class UnionRun.RaceUISubLap
// 0x0030 (0x0310 - 0x02E0)
class URaceUISubLap : public UUserWidget
{
public:
	class UTextureRenderTarget2D*                 LapRT;                                             // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTexture2D*>                     LapCountTextures;                                  // 0x02E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      LapCountMaterialInstance;                          // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               CurrentLapMID;                                     // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               MaxLapMID;                                         // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitializeLapCount(class UTextureRenderTarget2D* InRenderTarget);
	void SetCurrentLap(int32 Lap);
	void SetCurrentLapMID(class UMaterialInstanceDynamic* Mid);
	void SetMaxLap(int32 Lap);
	void SetMaxLapMID(class UMaterialInstanceDynamic* Mid);
	void UpdateLapCount(float InDelta);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceUISubLap">();
	}
	static class URaceUISubLap* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceUISubLap>();
	}
};
static_assert(alignof(URaceUISubLap) == 0x000008, "Wrong alignment on URaceUISubLap");
static_assert(sizeof(URaceUISubLap) == 0x000310, "Wrong size on URaceUISubLap");
static_assert(offsetof(URaceUISubLap, LapRT) == 0x0002E0, "Member 'URaceUISubLap::LapRT' has a wrong offset!");
static_assert(offsetof(URaceUISubLap, LapCountTextures) == 0x0002E8, "Member 'URaceUISubLap::LapCountTextures' has a wrong offset!");
static_assert(offsetof(URaceUISubLap, LapCountMaterialInstance) == 0x0002F8, "Member 'URaceUISubLap::LapCountMaterialInstance' has a wrong offset!");
static_assert(offsetof(URaceUISubLap, CurrentLapMID) == 0x000300, "Member 'URaceUISubLap::CurrentLapMID' has a wrong offset!");
static_assert(offsetof(URaceUISubLap, MaxLapMID) == 0x000308, "Member 'URaceUISubLap::MaxLapMID' has a wrong offset!");

// Class UnionRun.RaceUISubReturnDashGauge
// 0x0028 (0x0308 - 0x02E0)
class URaceUISubReturnDashGauge final : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOverlay*                               Overlay_Arrow_MovePoint;                           // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               MainGaugeMat;                                      // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AngleParamName;                                    // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerGaugeJustAngle;                              // 0x0300(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JudgeAreaJustAngle;                                // 0x0304(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UObject* GetButtonWidget();
	void SetDashInputKey(const struct FKey& Key);
	void SetGaugeParcent(float GaugeRate);
	void SetGaugePivotAndRange(class UImage* ImageRef, float PivotRate, float GaugeRateRange);
	void SetReturnDashSetting(const float& Pivot, const float& Range);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceUISubReturnDashGauge">();
	}
	static class URaceUISubReturnDashGauge* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceUISubReturnDashGauge>();
	}
};
static_assert(alignof(URaceUISubReturnDashGauge) == 0x000008, "Wrong alignment on URaceUISubReturnDashGauge");
static_assert(sizeof(URaceUISubReturnDashGauge) == 0x000308, "Wrong size on URaceUISubReturnDashGauge");
static_assert(offsetof(URaceUISubReturnDashGauge, Overlay_Arrow_MovePoint) == 0x0002E8, "Member 'URaceUISubReturnDashGauge::Overlay_Arrow_MovePoint' has a wrong offset!");
static_assert(offsetof(URaceUISubReturnDashGauge, MainGaugeMat) == 0x0002F0, "Member 'URaceUISubReturnDashGauge::MainGaugeMat' has a wrong offset!");
static_assert(offsetof(URaceUISubReturnDashGauge, AngleParamName) == 0x0002F8, "Member 'URaceUISubReturnDashGauge::AngleParamName' has a wrong offset!");
static_assert(offsetof(URaceUISubReturnDashGauge, PlayerGaugeJustAngle) == 0x000300, "Member 'URaceUISubReturnDashGauge::PlayerGaugeJustAngle' has a wrong offset!");
static_assert(offsetof(URaceUISubReturnDashGauge, JudgeAreaJustAngle) == 0x000304, "Member 'URaceUISubReturnDashGauge::JudgeAreaJustAngle' has a wrong offset!");

// Class UnionRun.RaceUISubRuleCount
// 0x0010 (0x02F0 - 0x02E0)
class URaceUISubRuleCount : public UUserWidget
{
public:
	int32                                         NowCount;                                          // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             TxtCount;                                          // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	int32 GetCount(int32 RacerIndex);
	const struct FMenuGroupRaceBonusData GetGroupRaceBonusData();
	void SetNewCount(int32 NewCuont);
	void UpdateRuleCountImpl(int32 RacerIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceUISubRuleCount">();
	}
	static class URaceUISubRuleCount* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceUISubRuleCount>();
	}
};
static_assert(alignof(URaceUISubRuleCount) == 0x000008, "Wrong alignment on URaceUISubRuleCount");
static_assert(sizeof(URaceUISubRuleCount) == 0x0002F0, "Wrong size on URaceUISubRuleCount");
static_assert(offsetof(URaceUISubRuleCount, NowCount) == 0x0002E0, "Member 'URaceUISubRuleCount::NowCount' has a wrong offset!");
static_assert(offsetof(URaceUISubRuleCount, TxtCount) == 0x0002E8, "Member 'URaceUISubRuleCount::TxtCount' has a wrong offset!");

// Class UnionRun.UnionCourseSkeletalMeshObject
// 0x0010 (0x0350 - 0x0340)
class AUnionCourseSkeletalMeshObject final : public AUnionCourseObjectBase
{
public:
	class UUnionSkeletalMeshComponent*            DrawSkeletalMeshComponent;                         // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              CollisionStaticMeshComponent;                      // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionCourseSkeletalMeshObject">();
	}
	static class AUnionCourseSkeletalMeshObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnionCourseSkeletalMeshObject>();
	}
};
static_assert(alignof(AUnionCourseSkeletalMeshObject) == 0x000008, "Wrong alignment on AUnionCourseSkeletalMeshObject");
static_assert(sizeof(AUnionCourseSkeletalMeshObject) == 0x000350, "Wrong size on AUnionCourseSkeletalMeshObject");
static_assert(offsetof(AUnionCourseSkeletalMeshObject, DrawSkeletalMeshComponent) == 0x000340, "Member 'AUnionCourseSkeletalMeshObject::DrawSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AUnionCourseSkeletalMeshObject, CollisionStaticMeshComponent) == 0x000348, "Member 'AUnionCourseSkeletalMeshObject::CollisionStaticMeshComponent' has a wrong offset!");

// Class UnionRun.RaceUISubStartGauge
// 0x0038 (0x0318 - 0x02E0)
class URaceUISubStartGauge : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOverlay*                               Overlay_Arrow_MovePoint;                           // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               MainGaurgeMat;                                     // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AngleParamName;                                    // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetSwitcher*                        ButtonSwitcher;                                    // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerGaugeJustAngle;                              // 0x0308(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JudgeAreaJustAngle;                                // 0x030C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GaugeRateMax;                                      // 0x0310(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UObject* GetButtonWidget();
	const struct FKey GetKeyAccel(int32 PlayerIndex);
	bool IsPlayControlKeyboard(int32 PlayerIndex);
	void SetDashInputKey(const struct FKey& Key, int32 PlayerIndex);
	void SetGaugeParcent(float GaugeRate);
	void SetGaugeParcentTrigger(float GaugeRate);
	void SetGaugePivotAndRange(class UImage* ImageRef, float PivotRate, float GaugeRateRange);
	void SetStartDashParamSetting(const struct FUnionRaceStartDashParam& InStartDashParam);
	void SetStartDashSetting(const float& LV3_PIVOT, const float& LV3_RANGE, const float& LV2_PIVOT, const float& LV2_RANGE, const float& NG1_PIVOT, const float& NG1_RANGE, const float& NG2_PIVOT, const float& NG2_RANGE);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceUISubStartGauge">();
	}
	static class URaceUISubStartGauge* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceUISubStartGauge>();
	}
};
static_assert(alignof(URaceUISubStartGauge) == 0x000008, "Wrong alignment on URaceUISubStartGauge");
static_assert(sizeof(URaceUISubStartGauge) == 0x000318, "Wrong size on URaceUISubStartGauge");
static_assert(offsetof(URaceUISubStartGauge, Overlay_Arrow_MovePoint) == 0x0002E8, "Member 'URaceUISubStartGauge::Overlay_Arrow_MovePoint' has a wrong offset!");
static_assert(offsetof(URaceUISubStartGauge, MainGaurgeMat) == 0x0002F0, "Member 'URaceUISubStartGauge::MainGaurgeMat' has a wrong offset!");
static_assert(offsetof(URaceUISubStartGauge, AngleParamName) == 0x0002F8, "Member 'URaceUISubStartGauge::AngleParamName' has a wrong offset!");
static_assert(offsetof(URaceUISubStartGauge, ButtonSwitcher) == 0x000300, "Member 'URaceUISubStartGauge::ButtonSwitcher' has a wrong offset!");
static_assert(offsetof(URaceUISubStartGauge, PlayerGaugeJustAngle) == 0x000308, "Member 'URaceUISubStartGauge::PlayerGaugeJustAngle' has a wrong offset!");
static_assert(offsetof(URaceUISubStartGauge, JudgeAreaJustAngle) == 0x00030C, "Member 'URaceUISubStartGauge::JudgeAreaJustAngle' has a wrong offset!");
static_assert(offsetof(URaceUISubStartGauge, GaugeRateMax) == 0x000310, "Member 'URaceUISubStartGauge::GaugeRateMax' has a wrong offset!");

// Class UnionRun.RaceUISubTeamGroup
// 0x0018 (0x02F8 - 0x02E0)
class URaceUISubTeamGroup : public UUserWidget
{
public:
	class URichTextBlock*                         TextYou;                                           // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImgRank;                                           // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ImgCharaIcon;                                      // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetCharaIconNative(class UTexture2D* IconTex);
	void SetDispTextYou(bool IsDisp);
	void SetRankNative(int32 Rank);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceUISubTeamGroup">();
	}
	static class URaceUISubTeamGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceUISubTeamGroup>();
	}
};
static_assert(alignof(URaceUISubTeamGroup) == 0x000008, "Wrong alignment on URaceUISubTeamGroup");
static_assert(sizeof(URaceUISubTeamGroup) == 0x0002F8, "Wrong size on URaceUISubTeamGroup");
static_assert(offsetof(URaceUISubTeamGroup, TextYou) == 0x0002E0, "Member 'URaceUISubTeamGroup::TextYou' has a wrong offset!");
static_assert(offsetof(URaceUISubTeamGroup, ImgRank) == 0x0002E8, "Member 'URaceUISubTeamGroup::ImgRank' has a wrong offset!");
static_assert(offsetof(URaceUISubTeamGroup, ImgCharaIcon) == 0x0002F0, "Member 'URaceUISubTeamGroup::ImgCharaIcon' has a wrong offset!");

// Class UnionRun.UnionCameraRunParam
// 0x02B0 (0x02E0 - 0x0030)
class UUnionCameraRunParam final : public UDataAsset
{
public:
	struct FRunChaseCameraParam                   ChaseCameraParam[0x8];                             // 0x0030(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRunChaseCameraParam                   ChaseCameraParam2P[0x8];                           // 0x0170(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FOVOutSeconds;                                     // 0x02B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElevationInterpSeconds;                            // 0x02B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceInterpSeconds;                             // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOVInterpSeconds;                                  // 0x02BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetForwardInterpSeconds;                        // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetHeightInterpSeconds;                         // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOVDelta;                                          // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetYDelta;                                      // 0x02CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetZDelta;                                      // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemAxisBlendDiffDegree;                           // 0x02D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemAxisBlendSeconds;                              // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceOffset4P;                                  // 0x02DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionCameraRunParam">();
	}
	static class UUnionCameraRunParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionCameraRunParam>();
	}
};
static_assert(alignof(UUnionCameraRunParam) == 0x000008, "Wrong alignment on UUnionCameraRunParam");
static_assert(sizeof(UUnionCameraRunParam) == 0x0002E0, "Wrong size on UUnionCameraRunParam");
static_assert(offsetof(UUnionCameraRunParam, ChaseCameraParam) == 0x000030, "Member 'UUnionCameraRunParam::ChaseCameraParam' has a wrong offset!");
static_assert(offsetof(UUnionCameraRunParam, ChaseCameraParam2P) == 0x000170, "Member 'UUnionCameraRunParam::ChaseCameraParam2P' has a wrong offset!");
static_assert(offsetof(UUnionCameraRunParam, FOVOutSeconds) == 0x0002B0, "Member 'UUnionCameraRunParam::FOVOutSeconds' has a wrong offset!");
static_assert(offsetof(UUnionCameraRunParam, ElevationInterpSeconds) == 0x0002B4, "Member 'UUnionCameraRunParam::ElevationInterpSeconds' has a wrong offset!");
static_assert(offsetof(UUnionCameraRunParam, DistanceInterpSeconds) == 0x0002B8, "Member 'UUnionCameraRunParam::DistanceInterpSeconds' has a wrong offset!");
static_assert(offsetof(UUnionCameraRunParam, FOVInterpSeconds) == 0x0002BC, "Member 'UUnionCameraRunParam::FOVInterpSeconds' has a wrong offset!");
static_assert(offsetof(UUnionCameraRunParam, TargetForwardInterpSeconds) == 0x0002C0, "Member 'UUnionCameraRunParam::TargetForwardInterpSeconds' has a wrong offset!");
static_assert(offsetof(UUnionCameraRunParam, TargetHeightInterpSeconds) == 0x0002C4, "Member 'UUnionCameraRunParam::TargetHeightInterpSeconds' has a wrong offset!");
static_assert(offsetof(UUnionCameraRunParam, FOVDelta) == 0x0002C8, "Member 'UUnionCameraRunParam::FOVDelta' has a wrong offset!");
static_assert(offsetof(UUnionCameraRunParam, TargetYDelta) == 0x0002CC, "Member 'UUnionCameraRunParam::TargetYDelta' has a wrong offset!");
static_assert(offsetof(UUnionCameraRunParam, TargetZDelta) == 0x0002D0, "Member 'UUnionCameraRunParam::TargetZDelta' has a wrong offset!");
static_assert(offsetof(UUnionCameraRunParam, ItemAxisBlendDiffDegree) == 0x0002D4, "Member 'UUnionCameraRunParam::ItemAxisBlendDiffDegree' has a wrong offset!");
static_assert(offsetof(UUnionCameraRunParam, ItemAxisBlendSeconds) == 0x0002D8, "Member 'UUnionCameraRunParam::ItemAxisBlendSeconds' has a wrong offset!");
static_assert(offsetof(UUnionCameraRunParam, DistanceOffset4P) == 0x0002DC, "Member 'UUnionCameraRunParam::DistanceOffset4P' has a wrong offset!");

// Class UnionRun.RaceUISubTeamGroupAll
// 0x0010 (0x02F0 - 0x02E0)
class URaceUISubTeamGroupAll : public UUserWidget
{
public:
	TArray<class URaceUISubTeamGroup*>            TeamGroup;                                         // 0x02E0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceUISubTeamGroupAll">();
	}
	static class URaceUISubTeamGroupAll* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceUISubTeamGroupAll>();
	}
};
static_assert(alignof(URaceUISubTeamGroupAll) == 0x000008, "Wrong alignment on URaceUISubTeamGroupAll");
static_assert(sizeof(URaceUISubTeamGroupAll) == 0x0002F0, "Wrong size on URaceUISubTeamGroupAll");
static_assert(offsetof(URaceUISubTeamGroupAll, TeamGroup) == 0x0002E0, "Member 'URaceUISubTeamGroupAll::TeamGroup' has a wrong offset!");

// Class UnionRun.RaceUISubTeamHUD
// 0x00E8 (0x03C8 - 0x02E0)
class URaceUISubTeamHUD : public UUserWidget
{
public:
	int32                                         ControlPlayerRacerIndex;                           // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PlayerTeamIndex;                                   // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 TeamRacersIndex;                                   // 0x02E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<int32, int32>                            TeamPanelIndexMap;                                 // 0x02F8(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<EDriverId, TSoftObjectPtr<class UTexture2D>> DriverIconMap;                                 // 0x0348(0x0050)(Edit, BlueprintVisible, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	int32                                         PlayerRacerIndex;                                  // 0x0398(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URaceUISubRuleCount*                    RuleCountUI;                                       // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        TeamRankSwithcer;                                  // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URaceUISubTeamGroupAll*                 UITeamGroupAll;                                    // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsSetGroupUI;                                      // 0x03B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B9[0xF];                                      // 0x03B9(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ExecChangeRank(int32 PanelIndex, EDriverId DriverId, bool IsDispPlayer, int32 Rank);
	bool ExecPlayChangeRank(int32 PanelIndex, EDriverId DriverId, bool IsDispPlayer, int32 Rank);
	bool ExecSetRankOnly(int32 PanelIndex, int32 Rank);
	int32 GetTeamRankRough();
	void SetTeamRank(int32 TeamRank);
	void UpdateCharaRank(bool IsForce);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceUISubTeamHUD">();
	}
	static class URaceUISubTeamHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceUISubTeamHUD>();
	}
};
static_assert(alignof(URaceUISubTeamHUD) == 0x000008, "Wrong alignment on URaceUISubTeamHUD");
static_assert(sizeof(URaceUISubTeamHUD) == 0x0003C8, "Wrong size on URaceUISubTeamHUD");
static_assert(offsetof(URaceUISubTeamHUD, ControlPlayerRacerIndex) == 0x0002E0, "Member 'URaceUISubTeamHUD::ControlPlayerRacerIndex' has a wrong offset!");
static_assert(offsetof(URaceUISubTeamHUD, PlayerTeamIndex) == 0x0002E4, "Member 'URaceUISubTeamHUD::PlayerTeamIndex' has a wrong offset!");
static_assert(offsetof(URaceUISubTeamHUD, TeamRacersIndex) == 0x0002E8, "Member 'URaceUISubTeamHUD::TeamRacersIndex' has a wrong offset!");
static_assert(offsetof(URaceUISubTeamHUD, TeamPanelIndexMap) == 0x0002F8, "Member 'URaceUISubTeamHUD::TeamPanelIndexMap' has a wrong offset!");
static_assert(offsetof(URaceUISubTeamHUD, DriverIconMap) == 0x000348, "Member 'URaceUISubTeamHUD::DriverIconMap' has a wrong offset!");
static_assert(offsetof(URaceUISubTeamHUD, PlayerRacerIndex) == 0x000398, "Member 'URaceUISubTeamHUD::PlayerRacerIndex' has a wrong offset!");
static_assert(offsetof(URaceUISubTeamHUD, RuleCountUI) == 0x0003A0, "Member 'URaceUISubTeamHUD::RuleCountUI' has a wrong offset!");
static_assert(offsetof(URaceUISubTeamHUD, TeamRankSwithcer) == 0x0003A8, "Member 'URaceUISubTeamHUD::TeamRankSwithcer' has a wrong offset!");
static_assert(offsetof(URaceUISubTeamHUD, UITeamGroupAll) == 0x0003B0, "Member 'URaceUISubTeamHUD::UITeamGroupAll' has a wrong offset!");
static_assert(offsetof(URaceUISubTeamHUD, IsSetGroupUI) == 0x0003B8, "Member 'URaceUISubTeamHUD::IsSetGroupUI' has a wrong offset!");

// Class UnionRun.RaceUISubTimeTrialTime
// 0x0040 (0x0320 - 0x02E0)
class URaceUISubTimeTrialTime : public UUserWidget
{
public:
	class URichTextBlock*                         TargetText;                                        // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URichTextBlock*                         PersonalBestText;                                  // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UImage*>                         NumberArr;                                         // 0x02F0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         StageTargetTime;                                   // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PersonalBestTime;                                  // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 PersonalBestLap;                                   // 0x0308(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsPersonalBestTimeExistance;                       // 0x0318(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNotGhostReplay;                                  // 0x0319(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31A[0x6];                                      // 0x031A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBestTime();
	void SetTargetTime(class URichTextBlock* TargetTextBlock, const class FText& TargetName, int32 TargetTime, bool IsClockCount);
	void SetTargetTime4Best(class URichTextBlock* TargetTextBlock);
	void SetVisibilityTime();
	struct FRaceUITimeTrialTime UpdateLapTime(int32 Lap, bool* IsBestLap);
	void UpdateTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceUISubTimeTrialTime">();
	}
	static class URaceUISubTimeTrialTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceUISubTimeTrialTime>();
	}
};
static_assert(alignof(URaceUISubTimeTrialTime) == 0x000008, "Wrong alignment on URaceUISubTimeTrialTime");
static_assert(sizeof(URaceUISubTimeTrialTime) == 0x000320, "Wrong size on URaceUISubTimeTrialTime");
static_assert(offsetof(URaceUISubTimeTrialTime, TargetText) == 0x0002E0, "Member 'URaceUISubTimeTrialTime::TargetText' has a wrong offset!");
static_assert(offsetof(URaceUISubTimeTrialTime, PersonalBestText) == 0x0002E8, "Member 'URaceUISubTimeTrialTime::PersonalBestText' has a wrong offset!");
static_assert(offsetof(URaceUISubTimeTrialTime, NumberArr) == 0x0002F0, "Member 'URaceUISubTimeTrialTime::NumberArr' has a wrong offset!");
static_assert(offsetof(URaceUISubTimeTrialTime, StageTargetTime) == 0x000300, "Member 'URaceUISubTimeTrialTime::StageTargetTime' has a wrong offset!");
static_assert(offsetof(URaceUISubTimeTrialTime, PersonalBestTime) == 0x000304, "Member 'URaceUISubTimeTrialTime::PersonalBestTime' has a wrong offset!");
static_assert(offsetof(URaceUISubTimeTrialTime, PersonalBestLap) == 0x000308, "Member 'URaceUISubTimeTrialTime::PersonalBestLap' has a wrong offset!");
static_assert(offsetof(URaceUISubTimeTrialTime, IsPersonalBestTimeExistance) == 0x000318, "Member 'URaceUISubTimeTrialTime::IsPersonalBestTimeExistance' has a wrong offset!");
static_assert(offsetof(URaceUISubTimeTrialTime, IsNotGhostReplay) == 0x000319, "Member 'URaceUISubTimeTrialTime::IsNotGhostReplay' has a wrong offset!");

// Class UnionRun.RaceUITutorialControllerKey
// 0x0000 (0x02E0 - 0x02E0)
class URaceUITutorialControllerKey : public UUserWidget
{
public:
	const struct FKey GetTutorialKey(ETutorialAction tutorialAction, int32 Index_0);
	void UpdateHintIndex(int32 InIndex);
	void UpdateTutorialIndex(int32 InIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceUITutorialControllerKey">();
	}
	static class URaceUITutorialControllerKey* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceUITutorialControllerKey>();
	}
};
static_assert(alignof(URaceUITutorialControllerKey) == 0x000008, "Wrong alignment on URaceUITutorialControllerKey");
static_assert(sizeof(URaceUITutorialControllerKey) == 0x0002E0, "Wrong size on URaceUITutorialControllerKey");

// Class UnionRun.RelocationMovement
// 0x00A0 (0x0140 - 0x00A0)
class URelocationMovement final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0xA0];                                      // 0x00A0(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RelocationMovement">();
	}
	static class URelocationMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<URelocationMovement>();
	}
};
static_assert(alignof(URelocationMovement) == 0x000008, "Wrong alignment on URelocationMovement");
static_assert(sizeof(URelocationMovement) == 0x000140, "Wrong size on URelocationMovement");

// Class UnionRun.ReplayFixedCameraCollision
// 0x0040 (0x05F0 - 0x05B0)
class alignas(0x10) AReplayFixedCameraCollision final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CollisionSize;                                     // 0x05B8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AReplayFixedCameraFocus>    StartCameraClass;                                  // 0x05D0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            StaticBodyComponent;                               // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AReplayFixedCameraFocus*                StartCameraObject;                                 // 0x05E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CreateCameraObject();
	void OnCollisionBaseHit(const struct FCollisionHitInfo& Info);
	void SetCameraData(const struct FVector& NewBoxSize);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplayFixedCameraCollision">();
	}
	static class AReplayFixedCameraCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReplayFixedCameraCollision>();
	}
};
static_assert(alignof(AReplayFixedCameraCollision) == 0x000010, "Wrong alignment on AReplayFixedCameraCollision");
static_assert(sizeof(AReplayFixedCameraCollision) == 0x0005F0, "Wrong size on AReplayFixedCameraCollision");
static_assert(offsetof(AReplayFixedCameraCollision, CollisionSize) == 0x0005B8, "Member 'AReplayFixedCameraCollision::CollisionSize' has a wrong offset!");
static_assert(offsetof(AReplayFixedCameraCollision, StartCameraClass) == 0x0005D0, "Member 'AReplayFixedCameraCollision::StartCameraClass' has a wrong offset!");
static_assert(offsetof(AReplayFixedCameraCollision, DefaultSceneRoot) == 0x0005D8, "Member 'AReplayFixedCameraCollision::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AReplayFixedCameraCollision, StaticBodyComponent) == 0x0005E0, "Member 'AReplayFixedCameraCollision::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AReplayFixedCameraCollision, StartCameraObject) == 0x0005E8, "Member 'AReplayFixedCameraCollision::StartCameraObject' has a wrong offset!");

// Class UnionRun.ReplayGhostActor
// 0x0080 (0x0310 - 0x0290)
class AReplayGhostActor final : public AActor
{
public:
	class UStaticMeshComponent*                   DebguMesh;                                         // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Root;                                              // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionSkeletalMeshComponent*            CockpitMeshComponent;                              // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAOStaticMeshComponent*            FrontMeshComponent;                                // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionAOStaticMeshComponent*            RearMeshComponent;                                 // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              SideMeshComponent;                                 // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UUnionStaticMeshComponent*>      TireMeshComponents;                                // 0x02C0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	class UDataTable*                             TireDataTable;                                     // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             CarShadowDataTable;                                // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     DummyMaterialInterface;                            // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E8[0x28];                                     // 0x02E8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplayGhostActor">();
	}
	static class AReplayGhostActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReplayGhostActor>();
	}
};
static_assert(alignof(AReplayGhostActor) == 0x000008, "Wrong alignment on AReplayGhostActor");
static_assert(sizeof(AReplayGhostActor) == 0x000310, "Wrong size on AReplayGhostActor");
static_assert(offsetof(AReplayGhostActor, DebguMesh) == 0x000290, "Member 'AReplayGhostActor::DebguMesh' has a wrong offset!");
static_assert(offsetof(AReplayGhostActor, Root) == 0x000298, "Member 'AReplayGhostActor::Root' has a wrong offset!");
static_assert(offsetof(AReplayGhostActor, CockpitMeshComponent) == 0x0002A0, "Member 'AReplayGhostActor::CockpitMeshComponent' has a wrong offset!");
static_assert(offsetof(AReplayGhostActor, FrontMeshComponent) == 0x0002A8, "Member 'AReplayGhostActor::FrontMeshComponent' has a wrong offset!");
static_assert(offsetof(AReplayGhostActor, RearMeshComponent) == 0x0002B0, "Member 'AReplayGhostActor::RearMeshComponent' has a wrong offset!");
static_assert(offsetof(AReplayGhostActor, SideMeshComponent) == 0x0002B8, "Member 'AReplayGhostActor::SideMeshComponent' has a wrong offset!");
static_assert(offsetof(AReplayGhostActor, TireMeshComponents) == 0x0002C0, "Member 'AReplayGhostActor::TireMeshComponents' has a wrong offset!");
static_assert(offsetof(AReplayGhostActor, TireDataTable) == 0x0002D0, "Member 'AReplayGhostActor::TireDataTable' has a wrong offset!");
static_assert(offsetof(AReplayGhostActor, CarShadowDataTable) == 0x0002D8, "Member 'AReplayGhostActor::CarShadowDataTable' has a wrong offset!");
static_assert(offsetof(AReplayGhostActor, DummyMaterialInterface) == 0x0002E0, "Member 'AReplayGhostActor::DummyMaterialInterface' has a wrong offset!");

// Class UnionRun.ReplayMoveCameraCollision
// 0x0040 (0x05F0 - 0x05B0)
class alignas(0x10) AReplayMoveCameraCollision final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CollisionSize;                                     // 0x05B8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AReplayMoveCameraFocus>     StartCameraClass;                                  // 0x05D0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGimmickStaticBodyComponent*            StaticBodyComponent;                               // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AReplayMoveCameraFocus*                 StartCameraObject;                                 // 0x05E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnCollisionBaseHit(const struct FCollisionHitInfo& Info);
	void SetCameraData(const struct FVector& NewBoxSize);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplayMoveCameraCollision">();
	}
	static class AReplayMoveCameraCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReplayMoveCameraCollision>();
	}
};
static_assert(alignof(AReplayMoveCameraCollision) == 0x000010, "Wrong alignment on AReplayMoveCameraCollision");
static_assert(sizeof(AReplayMoveCameraCollision) == 0x0005F0, "Wrong size on AReplayMoveCameraCollision");
static_assert(offsetof(AReplayMoveCameraCollision, CollisionSize) == 0x0005B8, "Member 'AReplayMoveCameraCollision::CollisionSize' has a wrong offset!");
static_assert(offsetof(AReplayMoveCameraCollision, StartCameraClass) == 0x0005D0, "Member 'AReplayMoveCameraCollision::StartCameraClass' has a wrong offset!");
static_assert(offsetof(AReplayMoveCameraCollision, DefaultSceneRoot) == 0x0005D8, "Member 'AReplayMoveCameraCollision::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(AReplayMoveCameraCollision, StaticBodyComponent) == 0x0005E0, "Member 'AReplayMoveCameraCollision::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(AReplayMoveCameraCollision, StartCameraObject) == 0x0005E8, "Member 'AReplayMoveCameraCollision::StartCameraObject' has a wrong offset!");

// Class UnionRun.ReplayMoveCameraFocus
// 0x0068 (0x0340 - 0x02D8)
class AReplayMoveCameraFocus final : public AUnionCameraBase
{
public:
	class USceneComponent*                        CameraRoot;                                        // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpringArmComponent*                    SpringArmComponent;                                // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRotBlend;                                      // 0x02E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               EndRot;                                            // 0x02F0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         EndArmLength;                                      // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpTime;                                        // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   EasingFunc;                                        // 0x0310(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_311[0x3];                                      // 0x0311(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterpExp;                                         // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_318[0x28];                                     // 0x0318(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplayMoveCameraFocus">();
	}
	static class AReplayMoveCameraFocus* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReplayMoveCameraFocus>();
	}
};
static_assert(alignof(AReplayMoveCameraFocus) == 0x000008, "Wrong alignment on AReplayMoveCameraFocus");
static_assert(sizeof(AReplayMoveCameraFocus) == 0x000340, "Wrong size on AReplayMoveCameraFocus");
static_assert(offsetof(AReplayMoveCameraFocus, CameraRoot) == 0x0002D8, "Member 'AReplayMoveCameraFocus::CameraRoot' has a wrong offset!");
static_assert(offsetof(AReplayMoveCameraFocus, SpringArmComponent) == 0x0002E0, "Member 'AReplayMoveCameraFocus::SpringArmComponent' has a wrong offset!");
static_assert(offsetof(AReplayMoveCameraFocus, bUseRotBlend) == 0x0002E8, "Member 'AReplayMoveCameraFocus::bUseRotBlend' has a wrong offset!");
static_assert(offsetof(AReplayMoveCameraFocus, EndRot) == 0x0002F0, "Member 'AReplayMoveCameraFocus::EndRot' has a wrong offset!");
static_assert(offsetof(AReplayMoveCameraFocus, EndArmLength) == 0x000308, "Member 'AReplayMoveCameraFocus::EndArmLength' has a wrong offset!");
static_assert(offsetof(AReplayMoveCameraFocus, InterpTime) == 0x00030C, "Member 'AReplayMoveCameraFocus::InterpTime' has a wrong offset!");
static_assert(offsetof(AReplayMoveCameraFocus, EasingFunc) == 0x000310, "Member 'AReplayMoveCameraFocus::EasingFunc' has a wrong offset!");
static_assert(offsetof(AReplayMoveCameraFocus, InterpExp) == 0x000314, "Member 'AReplayMoveCameraFocus::InterpExp' has a wrong offset!");

// Class UnionRun.RingGravityMovement
// 0x03F0 (0x0490 - 0x00A0)
class URingGravityMovement final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x3F0];                                     // 0x00A0(0x03F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RingGravityMovement">();
	}
	static class URingGravityMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<URingGravityMovement>();
	}
};
static_assert(alignof(URingGravityMovement) == 0x000008, "Wrong alignment on URingGravityMovement");
static_assert(sizeof(URingGravityMovement) == 0x000490, "Wrong size on URingGravityMovement");

// Class UnionRun.RingInstanceObject
// 0x01A0 (0x04E0 - 0x0340)
class alignas(0x10) ARingInstanceObject final : public AUnionCourseObjectBase
{
public:
	class UHierarchicalInstancedStaticMeshComponent* m_hismDomain0;                                  // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHierarchicalInstancedStaticMeshComponent* m_hismDomain1;                                  // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHierarchicalInstancedStaticMeshComponent* m_hismDomain2;                                  // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHierarchicalInstancedStaticMeshComponent* m_hismDomain3;                                  // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHierarchicalInstancedStaticMeshComponent* m_hismDroppedRings;                             // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHierarchicalInstancedStaticMeshComponent* m_hismOmochaoRings;                             // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHierarchicalInstancedStaticMeshComponent* m_hismSubDomain0;                               // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHierarchicalInstancedStaticMeshComponent* m_hismSubDomain1;                               // 0x0378(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHierarchicalInstancedStaticMeshComponent* m_hismSubDomain2;                               // 0x0380(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHierarchicalInstancedStaticMeshComponent* m_hismSubDomain3;                               // 0x0388(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0390(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_398[0x148];                                    // 0x0398(0x0148)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RingInstanceObject">();
	}
	static class ARingInstanceObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARingInstanceObject>();
	}
};
static_assert(alignof(ARingInstanceObject) == 0x000010, "Wrong alignment on ARingInstanceObject");
static_assert(sizeof(ARingInstanceObject) == 0x0004E0, "Wrong size on ARingInstanceObject");
static_assert(offsetof(ARingInstanceObject, m_hismDomain0) == 0x000340, "Member 'ARingInstanceObject::m_hismDomain0' has a wrong offset!");
static_assert(offsetof(ARingInstanceObject, m_hismDomain1) == 0x000348, "Member 'ARingInstanceObject::m_hismDomain1' has a wrong offset!");
static_assert(offsetof(ARingInstanceObject, m_hismDomain2) == 0x000350, "Member 'ARingInstanceObject::m_hismDomain2' has a wrong offset!");
static_assert(offsetof(ARingInstanceObject, m_hismDomain3) == 0x000358, "Member 'ARingInstanceObject::m_hismDomain3' has a wrong offset!");
static_assert(offsetof(ARingInstanceObject, m_hismDroppedRings) == 0x000360, "Member 'ARingInstanceObject::m_hismDroppedRings' has a wrong offset!");
static_assert(offsetof(ARingInstanceObject, m_hismOmochaoRings) == 0x000368, "Member 'ARingInstanceObject::m_hismOmochaoRings' has a wrong offset!");
static_assert(offsetof(ARingInstanceObject, m_hismSubDomain0) == 0x000370, "Member 'ARingInstanceObject::m_hismSubDomain0' has a wrong offset!");
static_assert(offsetof(ARingInstanceObject, m_hismSubDomain1) == 0x000378, "Member 'ARingInstanceObject::m_hismSubDomain1' has a wrong offset!");
static_assert(offsetof(ARingInstanceObject, m_hismSubDomain2) == 0x000380, "Member 'ARingInstanceObject::m_hismSubDomain2' has a wrong offset!");
static_assert(offsetof(ARingInstanceObject, m_hismSubDomain3) == 0x000388, "Member 'ARingInstanceObject::m_hismSubDomain3' has a wrong offset!");
static_assert(offsetof(ARingInstanceObject, DefaultSceneRoot) == 0x000390, "Member 'ARingInstanceObject::DefaultSceneRoot' has a wrong offset!");

// Class UnionRun.RingObject
// 0x0188 (0x04C8 - 0x0340)
class ARingObject final : public AUnionCourseObjectBase
{
public:
	uint8                                         Pad_340[0x10];                                     // 0x0340(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRingColliderParam                     _ColliderParam;                                    // 0x0350(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class USuckedMovement*                        SuckedMovement;                                    // 0x0370(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URelocationMovement*                    RelocationMovement;                                // 0x0378(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0380(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticBodyComponent*                   StaticBodyComponent;                               // 0x0388(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_390[0xB8];                                     // 0x0390(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RingScaleByExtndType[0x3];                         // 0x0448(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_490[0x10];                                     // 0x0490(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _RespawnWaitTime;                                  // 0x04A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _FinalLapChange;                                   // 0x04A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A5[0x3];                                      // 0x04A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _FinalLapRingNum;                                  // 0x04A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _FinalLapRingOffset;                               // 0x04AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsAutoToggleEnable;                               // 0x04B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B1[0x3];                                      // 0x04B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoEnableStartTime;                               // 0x04B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AutoDisableTime;                                   // 0x04B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AutoEnableTime;                                    // 0x04BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESpecialObjGroup                              m_SpecialGroup;                                    // 0x04C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERingExtndType                                RingExtndType;                                     // 0x04C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C2[0x6];                                      // 0x04C2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetFinalLapRingNum();
	float GetFinalLapRingOffset();
	bool IsFinalLapChange();
	void SetIsFinalLapChange(bool flag);
	void SetRingType();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RingObject">();
	}
	static class ARingObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARingObject>();
	}
};
static_assert(alignof(ARingObject) == 0x000008, "Wrong alignment on ARingObject");
static_assert(sizeof(ARingObject) == 0x0004C8, "Wrong size on ARingObject");
static_assert(offsetof(ARingObject, _ColliderParam) == 0x000350, "Member 'ARingObject::_ColliderParam' has a wrong offset!");
static_assert(offsetof(ARingObject, SuckedMovement) == 0x000370, "Member 'ARingObject::SuckedMovement' has a wrong offset!");
static_assert(offsetof(ARingObject, RelocationMovement) == 0x000378, "Member 'ARingObject::RelocationMovement' has a wrong offset!");
static_assert(offsetof(ARingObject, DefaultSceneRoot) == 0x000380, "Member 'ARingObject::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(ARingObject, StaticBodyComponent) == 0x000388, "Member 'ARingObject::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(ARingObject, RingScaleByExtndType) == 0x000448, "Member 'ARingObject::RingScaleByExtndType' has a wrong offset!");
static_assert(offsetof(ARingObject, _RespawnWaitTime) == 0x0004A0, "Member 'ARingObject::_RespawnWaitTime' has a wrong offset!");
static_assert(offsetof(ARingObject, _FinalLapChange) == 0x0004A4, "Member 'ARingObject::_FinalLapChange' has a wrong offset!");
static_assert(offsetof(ARingObject, _FinalLapRingNum) == 0x0004A8, "Member 'ARingObject::_FinalLapRingNum' has a wrong offset!");
static_assert(offsetof(ARingObject, _FinalLapRingOffset) == 0x0004AC, "Member 'ARingObject::_FinalLapRingOffset' has a wrong offset!");
static_assert(offsetof(ARingObject, bIsAutoToggleEnable) == 0x0004B0, "Member 'ARingObject::bIsAutoToggleEnable' has a wrong offset!");
static_assert(offsetof(ARingObject, AutoEnableStartTime) == 0x0004B4, "Member 'ARingObject::AutoEnableStartTime' has a wrong offset!");
static_assert(offsetof(ARingObject, AutoDisableTime) == 0x0004B8, "Member 'ARingObject::AutoDisableTime' has a wrong offset!");
static_assert(offsetof(ARingObject, AutoEnableTime) == 0x0004BC, "Member 'ARingObject::AutoEnableTime' has a wrong offset!");
static_assert(offsetof(ARingObject, m_SpecialGroup) == 0x0004C0, "Member 'ARingObject::m_SpecialGroup' has a wrong offset!");
static_assert(offsetof(ARingObject, RingExtndType) == 0x0004C1, "Member 'ARingObject::RingExtndType' has a wrong offset!");

// Class UnionRun.RockBreakObject
// 0x0000 (0x0690 - 0x0690)
class ARockBreakObject final : public ABreakObjectBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RockBreakObject">();
	}
	static class ARockBreakObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARockBreakObject>();
	}
};
static_assert(alignof(ARockBreakObject) == 0x000010, "Wrong alignment on ARockBreakObject");
static_assert(sizeof(ARockBreakObject) == 0x000690, "Wrong size on ARockBreakObject");

// Class UnionRun.RotatePlane
// 0x0020 (0x05D0 - 0x05B0)
class alignas(0x10) ARotatePlane final : public AUnionGimmickObjectBase
{
public:
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               Rotator;                                           // 0x05B8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RotatePlane">();
	}
	static class ARotatePlane* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARotatePlane>();
	}
};
static_assert(alignof(ARotatePlane) == 0x000010, "Wrong alignment on ARotatePlane");
static_assert(sizeof(ARotatePlane) == 0x0005D0, "Wrong size on ARotatePlane");
static_assert(offsetof(ARotatePlane, DefaultSceneRoot) == 0x0005B0, "Member 'ARotatePlane::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(ARotatePlane, Rotator) == 0x0005B8, "Member 'ARotatePlane::Rotator' has a wrong offset!");

// Class UnionRun.ShortcutRingObject
// 0x0050 (0x0390 - 0x0340)
class AShortcutRingObject final : public AUnionCourseObjectBase
{
public:
	uint8                                         Pad_340[0x8];                                      // 0x0340(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     GateActorClass_;                                   // 0x0348(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETravelRingType                               TravelRingType;                                    // 0x0350(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EShortcutRingType                             ShortcutRingType;                                  // 0x0351(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHalfRing;                                         // 0x0352(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_353[0x1];                                      // 0x0353(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ShortcutId;                                        // 0x0354(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EStageId                                      StageId_;                                          // 0x0358(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_359[0x3];                                      // 0x0359(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RingScale;                                         // 0x035C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseAnotherGate;                                   // 0x0360(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseOverrideCollisionScale;                        // 0x0361(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_362[0x2];                                      // 0x0362(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideCollisionScale;                            // 0x0364(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CameraActor;                                       // 0x0370(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         GateActors_;                                       // 0x0378(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0388(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	const float GetOverrideCollisionScale();
	const float GetRingScale();
	const int32 GetShortcutId();
	const EShortcutRingType GetShortcutRingType();
	const EStageId GetStageId();
	const bool IsHalfRing();
	const bool IsUseOverrideCollisionScale();
	void SetHalfRing(bool bHalf);
	void SetRingScale(float Scale);
	void SetShortcutId(int32 ID);
	void SetShortcutRingType(EShortcutRingType Type);
	void SetTravelRingType(ETravelRingType Type);
	void SetupShortcutRing();

	ETravelRingType GetTravelRingType() const;
	bool IsUseAnotherGate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShortcutRingObject">();
	}
	static class AShortcutRingObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShortcutRingObject>();
	}
};
static_assert(alignof(AShortcutRingObject) == 0x000008, "Wrong alignment on AShortcutRingObject");
static_assert(sizeof(AShortcutRingObject) == 0x000390, "Wrong size on AShortcutRingObject");
static_assert(offsetof(AShortcutRingObject, GateActorClass_) == 0x000348, "Member 'AShortcutRingObject::GateActorClass_' has a wrong offset!");
static_assert(offsetof(AShortcutRingObject, TravelRingType) == 0x000350, "Member 'AShortcutRingObject::TravelRingType' has a wrong offset!");
static_assert(offsetof(AShortcutRingObject, ShortcutRingType) == 0x000351, "Member 'AShortcutRingObject::ShortcutRingType' has a wrong offset!");
static_assert(offsetof(AShortcutRingObject, bHalfRing) == 0x000352, "Member 'AShortcutRingObject::bHalfRing' has a wrong offset!");
static_assert(offsetof(AShortcutRingObject, ShortcutId) == 0x000354, "Member 'AShortcutRingObject::ShortcutId' has a wrong offset!");
static_assert(offsetof(AShortcutRingObject, StageId_) == 0x000358, "Member 'AShortcutRingObject::StageId_' has a wrong offset!");
static_assert(offsetof(AShortcutRingObject, RingScale) == 0x00035C, "Member 'AShortcutRingObject::RingScale' has a wrong offset!");
static_assert(offsetof(AShortcutRingObject, bUseAnotherGate) == 0x000360, "Member 'AShortcutRingObject::bUseAnotherGate' has a wrong offset!");
static_assert(offsetof(AShortcutRingObject, bUseOverrideCollisionScale) == 0x000361, "Member 'AShortcutRingObject::bUseOverrideCollisionScale' has a wrong offset!");
static_assert(offsetof(AShortcutRingObject, OverrideCollisionScale) == 0x000364, "Member 'AShortcutRingObject::OverrideCollisionScale' has a wrong offset!");
static_assert(offsetof(AShortcutRingObject, CameraActor) == 0x000370, "Member 'AShortcutRingObject::CameraActor' has a wrong offset!");
static_assert(offsetof(AShortcutRingObject, GateActors_) == 0x000378, "Member 'AShortcutRingObject::GateActors_' has a wrong offset!");
static_assert(offsetof(AShortcutRingObject, DefaultSceneRoot) == 0x000388, "Member 'AShortcutRingObject::DefaultSceneRoot' has a wrong offset!");

// Class UnionRun.SimpleMoveComponent
// 0x00C8 (0x0168 - 0x00A0)
class USimpleMoveComponent final : public UActorComponent
{
public:
	struct FVector                                MoveDistance;                                      // 0x00A0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveTime;                                          // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESimpleMoveLoopType                           MoveType;                                          // 0x00BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            MoveCurve;                                         // 0x00C0(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotDistance;                                       // 0x00C8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotTime;                                           // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESimpleMoveLoopType                           RotType;                                           // 0x00E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RotCurve;                                          // 0x00E8(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x78];                                      // 0x00F0(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleMoveComponent">();
	}
	static class USimpleMoveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleMoveComponent>();
	}
};
static_assert(alignof(USimpleMoveComponent) == 0x000008, "Wrong alignment on USimpleMoveComponent");
static_assert(sizeof(USimpleMoveComponent) == 0x000168, "Wrong size on USimpleMoveComponent");
static_assert(offsetof(USimpleMoveComponent, MoveDistance) == 0x0000A0, "Member 'USimpleMoveComponent::MoveDistance' has a wrong offset!");
static_assert(offsetof(USimpleMoveComponent, MoveTime) == 0x0000B8, "Member 'USimpleMoveComponent::MoveTime' has a wrong offset!");
static_assert(offsetof(USimpleMoveComponent, MoveType) == 0x0000BC, "Member 'USimpleMoveComponent::MoveType' has a wrong offset!");
static_assert(offsetof(USimpleMoveComponent, MoveCurve) == 0x0000C0, "Member 'USimpleMoveComponent::MoveCurve' has a wrong offset!");
static_assert(offsetof(USimpleMoveComponent, RotDistance) == 0x0000C8, "Member 'USimpleMoveComponent::RotDistance' has a wrong offset!");
static_assert(offsetof(USimpleMoveComponent, RotTime) == 0x0000E0, "Member 'USimpleMoveComponent::RotTime' has a wrong offset!");
static_assert(offsetof(USimpleMoveComponent, RotType) == 0x0000E4, "Member 'USimpleMoveComponent::RotType' has a wrong offset!");
static_assert(offsetof(USimpleMoveComponent, RotCurve) == 0x0000E8, "Member 'USimpleMoveComponent::RotCurve' has a wrong offset!");

// Class UnionRun.SimpleVATAnimObject
// 0x0008 (0x0298 - 0x0290)
class ASimpleVATAnimObject final : public AActor
{
public:
	class UUnionVATAnimEventComponent*            VATAnim;                                           // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleVATAnimObject">();
	}
	static class ASimpleVATAnimObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASimpleVATAnimObject>();
	}
};
static_assert(alignof(ASimpleVATAnimObject) == 0x000008, "Wrong alignment on ASimpleVATAnimObject");
static_assert(sizeof(ASimpleVATAnimObject) == 0x000298, "Wrong size on ASimpleVATAnimObject");
static_assert(offsetof(ASimpleVATAnimObject, VATAnim) == 0x000290, "Member 'ASimpleVATAnimObject::VATAnim' has a wrong offset!");

// Class UnionRun.SkeletalSplineMoveObject
// 0x0008 (0x0318 - 0x0310)
class ASkeletalSplineMoveObject final : public ASplineMoveObject
{
public:
	class UUnionSkeletalMeshComponent*            SkeletalMeshComponent;                             // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkeletalSplineMoveObject">();
	}
	static class ASkeletalSplineMoveObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASkeletalSplineMoveObject>();
	}
};
static_assert(alignof(ASkeletalSplineMoveObject) == 0x000008, "Wrong alignment on ASkeletalSplineMoveObject");
static_assert(sizeof(ASkeletalSplineMoveObject) == 0x000318, "Wrong size on ASkeletalSplineMoveObject");
static_assert(offsetof(ASkeletalSplineMoveObject, SkeletalMeshComponent) == 0x000310, "Member 'ASkeletalSplineMoveObject::SkeletalMeshComponent' has a wrong offset!");

// Class UnionRun.SquidAnimInstance
// 0x0000 (0x0370 - 0x0370)
class USquidAnimInstance final : public UEnemyAnimInstance
{
public:
	bool IsSquidState(ESquidState State) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquidAnimInstance">();
	}
	static class USquidAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USquidAnimInstance>();
	}
};
static_assert(alignof(USquidAnimInstance) == 0x000010, "Wrong alignment on USquidAnimInstance");
static_assert(sizeof(USquidAnimInstance) == 0x000370, "Wrong size on USquidAnimInstance");

// Class UnionRun.SuckedMovement
// 0x00D0 (0x0170 - 0x00A0)
class USuckedMovement final : public UActorComponent
{
public:
	float                                         m_suckedTime;                                      // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_targetEndScale;                                  // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          m_enableScaleAnim;                                 // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEaseType                                     m_easeType;                                        // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0xC6];                                      // 0x00AA(0x00C6)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SuckedMovement">();
	}
	static class USuckedMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<USuckedMovement>();
	}
};
static_assert(alignof(USuckedMovement) == 0x000008, "Wrong alignment on USuckedMovement");
static_assert(sizeof(USuckedMovement) == 0x000170, "Wrong size on USuckedMovement");
static_assert(offsetof(USuckedMovement, m_suckedTime) == 0x0000A0, "Member 'USuckedMovement::m_suckedTime' has a wrong offset!");
static_assert(offsetof(USuckedMovement, m_targetEndScale) == 0x0000A4, "Member 'USuckedMovement::m_targetEndScale' has a wrong offset!");
static_assert(offsetof(USuckedMovement, m_enableScaleAnim) == 0x0000A8, "Member 'USuckedMovement::m_enableScaleAnim' has a wrong offset!");
static_assert(offsetof(USuckedMovement, m_easeType) == 0x0000A9, "Member 'USuckedMovement::m_easeType' has a wrong offset!");

// Class UnionRun.TimeCountCollision
// 0x0070 (0x0620 - 0x05B0)
class alignas(0x10) ATimeCountCollision final : public AUnionGimmickObjectBase
{
public:
	uint8                                         Pad_5B0[0x8];                                      // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticBodyComponent*                   StaticBodyComponent;                               // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETimeCountCollisionType                       CollisionType;                                     // 0x05C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C9[0x7];                                      // 0x05C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CollisionSize;                                     // 0x05D0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         DrawX;                                             // 0x05E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         DrawY;                                             // 0x05EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          m_bIsStartCollision;                               // 0x05F0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F1[0x2F];                                     // 0x05F1(0x002F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimeCountCollision">();
	}
	static class ATimeCountCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATimeCountCollision>();
	}
};
static_assert(alignof(ATimeCountCollision) == 0x000010, "Wrong alignment on ATimeCountCollision");
static_assert(sizeof(ATimeCountCollision) == 0x000620, "Wrong size on ATimeCountCollision");
static_assert(offsetof(ATimeCountCollision, DefaultSceneRoot) == 0x0005B8, "Member 'ATimeCountCollision::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(ATimeCountCollision, StaticBodyComponent) == 0x0005C0, "Member 'ATimeCountCollision::StaticBodyComponent' has a wrong offset!");
static_assert(offsetof(ATimeCountCollision, CollisionType) == 0x0005C8, "Member 'ATimeCountCollision::CollisionType' has a wrong offset!");
static_assert(offsetof(ATimeCountCollision, CollisionSize) == 0x0005D0, "Member 'ATimeCountCollision::CollisionSize' has a wrong offset!");
static_assert(offsetof(ATimeCountCollision, DrawX) == 0x0005E8, "Member 'ATimeCountCollision::DrawX' has a wrong offset!");
static_assert(offsetof(ATimeCountCollision, DrawY) == 0x0005EC, "Member 'ATimeCountCollision::DrawY' has a wrong offset!");
static_assert(offsetof(ATimeCountCollision, m_bIsStartCollision) == 0x0005F0, "Member 'ATimeCountCollision::m_bIsStartCollision' has a wrong offset!");

// Class UnionRun.TowerAnimInstance
// 0x0000 (0x0370 - 0x0370)
class UTowerAnimInstance final : public UEnemyAnimInstance
{
public:
	void OnEnterBreakLoop();
	void OnEnterWait();

	bool IsTowerState(ETowerState State) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TowerAnimInstance">();
	}
	static class UTowerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTowerAnimInstance>();
	}
};
static_assert(alignof(UTowerAnimInstance) == 0x000010, "Wrong alignment on UTowerAnimInstance");
static_assert(sizeof(UTowerAnimInstance) == 0x000370, "Wrong size on UTowerAnimInstance");

// Class UnionRun.TransformRingObject
// 0x0020 (0x0360 - 0x0340)
class ATransformRingObject final : public AUnionCourseObjectBase
{
public:
	ETransformRingType                            TransformRingType;                                 // 0x0340(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_341[0x3];                                      // 0x0341(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScaleRate;                                         // 0x0344(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0348(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x10];                                     // 0x0350(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const float GetRingScaleRate();
	void SetRingScaleRate(float Rate);
	void SetTransformRingType(ETransformRingType Type);
	void UpdateParallelMode(int32 RacerIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TransformRingObject">();
	}
	static class ATransformRingObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATransformRingObject>();
	}
};
static_assert(alignof(ATransformRingObject) == 0x000008, "Wrong alignment on ATransformRingObject");
static_assert(sizeof(ATransformRingObject) == 0x000360, "Wrong size on ATransformRingObject");
static_assert(offsetof(ATransformRingObject, TransformRingType) == 0x000340, "Member 'ATransformRingObject::TransformRingType' has a wrong offset!");
static_assert(offsetof(ATransformRingObject, ScaleRate) == 0x000344, "Member 'ATransformRingObject::ScaleRate' has a wrong offset!");
static_assert(offsetof(ATransformRingObject, DefaultSceneRoot) == 0x000348, "Member 'ATransformRingObject::DefaultSceneRoot' has a wrong offset!");

// Class UnionRun.TravelRingPostProcessActor
// 0x0008 (0x0298 - 0x0290)
class ATravelRingPostProcessActor final : public AActor
{
public:
	ETravelRingType                               TravelRingType;                                    // 0x0290(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TravelRingPostProcessActor">();
	}
	static class ATravelRingPostProcessActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATravelRingPostProcessActor>();
	}
};
static_assert(alignof(ATravelRingPostProcessActor) == 0x000008, "Wrong alignment on ATravelRingPostProcessActor");
static_assert(sizeof(ATravelRingPostProcessActor) == 0x000298, "Wrong size on ATravelRingPostProcessActor");
static_assert(offsetof(ATravelRingPostProcessActor, TravelRingType) == 0x000290, "Member 'ATravelRingPostProcessActor::TravelRingType' has a wrong offset!");

// Class UnionRun.TriggerComponent
// 0x0040 (0x0390 - 0x0350)
class UTriggerComponent final : public UCollisionBaseComponent
{
public:
	uint8                                         Pad_350[0x1];                                      // 0x0350(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseSurfaceSetting;                                // 0x0351(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUnionSurfaceFlag                      EditSurfaceFlag;                                   // 0x0352(0x001F)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	EUnionSurfaceType                             EditSurfaceType;                                   // 0x0371(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCCD;                                        // 0x0372(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_373[0x1];                                      // 0x0373(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CCDSphereRadius;                                   // 0x0374(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CCDValidDistance;                                  // 0x0378(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37C[0x14];                                     // 0x037C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCollisionBaseHit(const struct FCollisionHitInfo& Info);
	void OnCollisionHitResult(const struct FCollisionHitResultInfo& Info);
	void SetSurfaceFlag(const struct FUnionSurfaceFlag& flag);
	void SetSurfaceType(EUnionSurfaceType Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriggerComponent">();
	}
	static class UTriggerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTriggerComponent>();
	}
};
static_assert(alignof(UTriggerComponent) == 0x000010, "Wrong alignment on UTriggerComponent");
static_assert(sizeof(UTriggerComponent) == 0x000390, "Wrong size on UTriggerComponent");
static_assert(offsetof(UTriggerComponent, bUseSurfaceSetting) == 0x000351, "Member 'UTriggerComponent::bUseSurfaceSetting' has a wrong offset!");
static_assert(offsetof(UTriggerComponent, EditSurfaceFlag) == 0x000352, "Member 'UTriggerComponent::EditSurfaceFlag' has a wrong offset!");
static_assert(offsetof(UTriggerComponent, EditSurfaceType) == 0x000371, "Member 'UTriggerComponent::EditSurfaceType' has a wrong offset!");
static_assert(offsetof(UTriggerComponent, bEnableCCD) == 0x000372, "Member 'UTriggerComponent::bEnableCCD' has a wrong offset!");
static_assert(offsetof(UTriggerComponent, CCDSphereRadius) == 0x000374, "Member 'UTriggerComponent::CCDSphereRadius' has a wrong offset!");
static_assert(offsetof(UTriggerComponent, CCDValidDistance) == 0x000378, "Member 'UTriggerComponent::CCDValidDistance' has a wrong offset!");

// Class UnionRun.UnionAttackItemInfoInterface
// 0x0000 (0x0000 - 0x0000)
class IUnionAttackItemInfoInterface final
{
public:
	EEnemyItemId GetAttackEnemyItemIdIF();
	EItemId GetAttackItemIdIF();
	EDomainIndex GetObjectDomainIndex();
	struct FVector GetObjectDomainLocationUE();
	EDomainNumber GetObjectDomainNumber();
	int32 GetObjectLapCount();
	float GetObjectPathIndexDistance();
	float GetObjectRaceDistance();
	float GetObjectRaceDomainElapsedRatio();
	struct FVector GetObjectWorldLocation();
	bool GetSameDomainOnlyFlag();
	int32 GetUsingRacerIndex();
	bool IsAttackItemMoveToTargetIgnorePathIF();
	bool IsAttackItemTargetIF(int32 checkRacerIndex);
	bool IsAttackItemUsedForBackIF();

	EUnionAttackItemInfoType GetAttackItemInfoTypeIF() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionAttackItemInfoInterface">();
	}
	static class IUnionAttackItemInfoInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUnionAttackItemInfoInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IUnionAttackItemInfoInterface) == 0x000001, "Wrong alignment on IUnionAttackItemInfoInterface");
static_assert(sizeof(IUnionAttackItemInfoInterface) == 0x000001, "Wrong size on IUnionAttackItemInfoInterface");

// Class UnionRun.UnionBtCollisionBinaryAsset
// 0x0020 (0x0048 - 0x0028)
class UUnionBtCollisionBinaryAsset final : public UObject
{
public:
	struct FUnionBtCollisionBinaryParameter       Parameter;                                         // 0x0028(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionBtCollisionBinaryAsset">();
	}
	static class UUnionBtCollisionBinaryAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionBtCollisionBinaryAsset>();
	}
};
static_assert(alignof(UUnionBtCollisionBinaryAsset) == 0x000008, "Wrong alignment on UUnionBtCollisionBinaryAsset");
static_assert(sizeof(UUnionBtCollisionBinaryAsset) == 0x000048, "Wrong size on UUnionBtCollisionBinaryAsset");
static_assert(offsetof(UUnionBtCollisionBinaryAsset, Parameter) == 0x000028, "Member 'UUnionBtCollisionBinaryAsset::Parameter' has a wrong offset!");

// Class UnionRun.UnionCameraCarCamOffset
// 0x0030 (0x0410 - 0x03E0)
class AUnionCameraCarCamOffset : public AUnionCameraFocusOnTarget
{
public:
	bool                                          bUseSpecialCameraOffset;                           // 0x03E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplySpecialCameraOffsetToTarget;                 // 0x03E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E2[0x6];                                      // 0x03E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpecialCameraOffset;                               // 0x03E8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpecialCameraOffsetLerpTime;                       // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_404[0xC];                                      // 0x0404(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionCameraCarCamOffset">();
	}
	static class AUnionCameraCarCamOffset* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnionCameraCarCamOffset>();
	}
};
static_assert(alignof(AUnionCameraCarCamOffset) == 0x000010, "Wrong alignment on AUnionCameraCarCamOffset");
static_assert(sizeof(AUnionCameraCarCamOffset) == 0x000410, "Wrong size on AUnionCameraCarCamOffset");
static_assert(offsetof(AUnionCameraCarCamOffset, bUseSpecialCameraOffset) == 0x0003E0, "Member 'AUnionCameraCarCamOffset::bUseSpecialCameraOffset' has a wrong offset!");
static_assert(offsetof(AUnionCameraCarCamOffset, bApplySpecialCameraOffsetToTarget) == 0x0003E1, "Member 'AUnionCameraCarCamOffset::bApplySpecialCameraOffsetToTarget' has a wrong offset!");
static_assert(offsetof(AUnionCameraCarCamOffset, SpecialCameraOffset) == 0x0003E8, "Member 'AUnionCameraCarCamOffset::SpecialCameraOffset' has a wrong offset!");
static_assert(offsetof(AUnionCameraCarCamOffset, SpecialCameraOffsetLerpTime) == 0x000400, "Member 'AUnionCameraCarCamOffset::SpecialCameraOffsetLerpTime' has a wrong offset!");

// Class UnionRun.UnionCameraModifierPostEffect
// 0x00F8 (0x0140 - 0x0048)
class UUnionCameraModifierPostEffect final : public UCameraModifier
{
public:
	class UDataTable*                             PostEffectDataTable;                               // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EUnionCameraModifierPostEffectType, bool> PostEffectEnable;                                 // 0x0050(0x0050)(Edit, BlueprintVisible, EditFixedSize, NativeAccessSpecifierPublic)
	TMap<EUnionCameraModifierPostEffectType, class UMaterialInterface*> PostEffectMaterialInterface; // 0x00A0(0x0050)(Edit, BlueprintVisible, EditFixedSize, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<EUnionCameraModifierPostEffectType, class UMaterialInstanceDynamic*> PostEffectMaterialInstance; // 0x00F0(0x0050)(Edit, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void SetCameraPostEffectParameter(EUnionCameraModifierPostEffectType EffectType, class FName ParameterName, float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionCameraModifierPostEffect">();
	}
	static class UUnionCameraModifierPostEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionCameraModifierPostEffect>();
	}
};
static_assert(alignof(UUnionCameraModifierPostEffect) == 0x000008, "Wrong alignment on UUnionCameraModifierPostEffect");
static_assert(sizeof(UUnionCameraModifierPostEffect) == 0x000140, "Wrong size on UUnionCameraModifierPostEffect");
static_assert(offsetof(UUnionCameraModifierPostEffect, PostEffectDataTable) == 0x000048, "Member 'UUnionCameraModifierPostEffect::PostEffectDataTable' has a wrong offset!");
static_assert(offsetof(UUnionCameraModifierPostEffect, PostEffectEnable) == 0x000050, "Member 'UUnionCameraModifierPostEffect::PostEffectEnable' has a wrong offset!");
static_assert(offsetof(UUnionCameraModifierPostEffect, PostEffectMaterialInterface) == 0x0000A0, "Member 'UUnionCameraModifierPostEffect::PostEffectMaterialInterface' has a wrong offset!");
static_assert(offsetof(UUnionCameraModifierPostEffect, PostEffectMaterialInstance) == 0x0000F0, "Member 'UUnionCameraModifierPostEffect::PostEffectMaterialInstance' has a wrong offset!");

// Class UnionRun.UnionCameraWarpRing
// 0x0000 (0x03E0 - 0x03E0)
class AUnionCameraWarpRing : public AUnionCameraFocusOnTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionCameraWarpRing">();
	}
	static class AUnionCameraWarpRing* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnionCameraWarpRing>();
	}
};
static_assert(alignof(AUnionCameraWarpRing) == 0x000010, "Wrong alignment on AUnionCameraWarpRing");
static_assert(sizeof(AUnionCameraWarpRing) == 0x0003E0, "Wrong size on AUnionCameraWarpRing");

// Class UnionRun.UnionCheckOutsideCourse
// 0x0020 (0x0058 - 0x0038)
class UUnionCheckOutsideCourse final : public UMoveController
{
public:
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionCheckOutsideCourse">();
	}
	static class UUnionCheckOutsideCourse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionCheckOutsideCourse>();
	}
};
static_assert(alignof(UUnionCheckOutsideCourse) == 0x000008, "Wrong alignment on UUnionCheckOutsideCourse");
static_assert(sizeof(UUnionCheckOutsideCourse) == 0x000058, "Wrong size on UUnionCheckOutsideCourse");

// Class UnionRun.UnionComPathBinaryDataAsset
// 0x0010 (0x0038 - 0x0028)
class UUnionComPathBinaryDataAsset final : public UObject
{
public:
	TArray<uint8>                                 RawData;                                           // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionComPathBinaryDataAsset">();
	}
	static class UUnionComPathBinaryDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionComPathBinaryDataAsset>();
	}
};
static_assert(alignof(UUnionComPathBinaryDataAsset) == 0x000008, "Wrong alignment on UUnionComPathBinaryDataAsset");
static_assert(sizeof(UUnionComPathBinaryDataAsset) == 0x000038, "Wrong size on UUnionComPathBinaryDataAsset");
static_assert(offsetof(UUnionComPathBinaryDataAsset, RawData) == 0x000028, "Member 'UUnionComPathBinaryDataAsset::RawData' has a wrong offset!");

// Class UnionRun.UnionCourseStaticMeshObject
// 0x0010 (0x0350 - 0x0340)
class AUnionCourseStaticMeshObject final : public AUnionCourseObjectBase
{
public:
	class UUnionStaticMeshComponent*              DrawStaticMeshComponent;                           // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionStaticMeshComponent*              CollisionStaticMeshComponent;                      // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionCourseStaticMeshObject">();
	}
	static class AUnionCourseStaticMeshObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnionCourseStaticMeshObject>();
	}
};
static_assert(alignof(AUnionCourseStaticMeshObject) == 0x000008, "Wrong alignment on AUnionCourseStaticMeshObject");
static_assert(sizeof(AUnionCourseStaticMeshObject) == 0x000350, "Wrong size on AUnionCourseStaticMeshObject");
static_assert(offsetof(AUnionCourseStaticMeshObject, DrawStaticMeshComponent) == 0x000340, "Member 'AUnionCourseStaticMeshObject::DrawStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AUnionCourseStaticMeshObject, CollisionStaticMeshComponent) == 0x000348, "Member 'AUnionCourseStaticMeshObject::CollisionStaticMeshComponent' has a wrong offset!");

// Class UnionRun.UnionDebugStringSubsystem
// 0x0018 (0x0048 - 0x0030)
class UUnionDebugStringSubsystem final : public UGameInstanceSubsystem
{
public:
	bool                                          bDebugStringVisibleFlag;                           // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0xF];                                       // 0x0031(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UFont*                                  FontObject;                                        // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Draw(class UCanvas* InCanvas, class APlayerController* InPC);
	void PrintDebugString(const struct FDebugPrintStringStruct& DebugString);
	void SetDebugStringVisibleFlag(bool bVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionDebugStringSubsystem">();
	}
	static class UUnionDebugStringSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionDebugStringSubsystem>();
	}
};
static_assert(alignof(UUnionDebugStringSubsystem) == 0x000008, "Wrong alignment on UUnionDebugStringSubsystem");
static_assert(sizeof(UUnionDebugStringSubsystem) == 0x000048, "Wrong size on UUnionDebugStringSubsystem");
static_assert(offsetof(UUnionDebugStringSubsystem, bDebugStringVisibleFlag) == 0x000030, "Member 'UUnionDebugStringSubsystem::bDebugStringVisibleFlag' has a wrong offset!");
static_assert(offsetof(UUnionDebugStringSubsystem, FontObject) == 0x000040, "Member 'UUnionDebugStringSubsystem::FontObject' has a wrong offset!");

// Class UnionRun.UnionGadgetSystemManager
// 0x01D8 (0x0200 - 0x0028)
class UUnionGadgetSystemManager final : public UObject
{
public:
	uint8                                         Pad_28[0xA8];                                      // 0x0028(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	class UGadgetParameterDataAsset*              m_gadgetParameter;                                 // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x128];                                     // 0x00D8(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionGadgetSystemManager">();
	}
	static class UUnionGadgetSystemManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionGadgetSystemManager>();
	}
};
static_assert(alignof(UUnionGadgetSystemManager) == 0x000008, "Wrong alignment on UUnionGadgetSystemManager");
static_assert(sizeof(UUnionGadgetSystemManager) == 0x000200, "Wrong size on UUnionGadgetSystemManager");
static_assert(offsetof(UUnionGadgetSystemManager, m_gadgetParameter) == 0x0000D0, "Member 'UUnionGadgetSystemManager::m_gadgetParameter' has a wrong offset!");

// Class UnionRun.GroupInfo
// 0x0068 (0x0090 - 0x0028)
class UGroupInfo final : public UObject
{
public:
	uint8                                         Pad_28[0x68];                                      // 0x0028(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GroupInfo">();
	}
	static class UGroupInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGroupInfo>();
	}
};
static_assert(alignof(UGroupInfo) == 0x000008, "Wrong alignment on UGroupInfo");
static_assert(sizeof(UGroupInfo) == 0x000090, "Wrong size on UGroupInfo");

// Class UnionRun.UnionGroupSystemManager
// 0x0358 (0x0380 - 0x0028)
class UUnionGroupSystemManager final : public UObject
{
public:
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UObject*>                          m_UIListeners;                                     // 0x0080(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	TSet<class UObject*>                          m_GroupInfoListeners;                              // 0x00D0(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     m_GroupColorOverlayMaterial;                       // 0x0120(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x258];                                    // 0x0128(0x0258)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionGroupSystemManager">();
	}
	static class UUnionGroupSystemManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionGroupSystemManager>();
	}
};
static_assert(alignof(UUnionGroupSystemManager) == 0x000008, "Wrong alignment on UUnionGroupSystemManager");
static_assert(sizeof(UUnionGroupSystemManager) == 0x000380, "Wrong size on UUnionGroupSystemManager");
static_assert(offsetof(UUnionGroupSystemManager, m_UIListeners) == 0x000080, "Member 'UUnionGroupSystemManager::m_UIListeners' has a wrong offset!");
static_assert(offsetof(UUnionGroupSystemManager, m_GroupInfoListeners) == 0x0000D0, "Member 'UUnionGroupSystemManager::m_GroupInfoListeners' has a wrong offset!");
static_assert(offsetof(UUnionGroupSystemManager, m_GroupColorOverlayMaterial) == 0x000120, "Member 'UUnionGroupSystemManager::m_GroupColorOverlayMaterial' has a wrong offset!");

// Class UnionRun.UnionHoming
// 0x02A8 (0x02E0 - 0x0038)
class UUnionHoming final : public UMoveController
{
public:
	uint8                                         Pad_38[0x2A8];                                     // 0x0038(0x02A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionHoming">();
	}
	static class UUnionHoming* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionHoming>();
	}
};
static_assert(alignof(UUnionHoming) == 0x000008, "Wrong alignment on UUnionHoming");
static_assert(sizeof(UUnionHoming) == 0x0002E0, "Wrong size on UUnionHoming");

// Class UnionRun.UnionItemSkeletalMeshContainer
// 0x0000 (0x0F70 - 0x0F70)
class UUnionItemSkeletalMeshContainer : public USkeletalMeshComponent
{
public:
	bool                                          bUpdate;                                           // 0x0F68(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F69[0x7];                                      // 0x0F69(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginGame();
	void OnBeginItem(class AActor* OwnerActor);
	void OnEndItem();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionItemSkeletalMeshContainer">();
	}
	static class UUnionItemSkeletalMeshContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionItemSkeletalMeshContainer>();
	}
};
static_assert(alignof(UUnionItemSkeletalMeshContainer) == 0x000010, "Wrong alignment on UUnionItemSkeletalMeshContainer");
static_assert(sizeof(UUnionItemSkeletalMeshContainer) == 0x000F70, "Wrong size on UUnionItemSkeletalMeshContainer");
static_assert(offsetof(UUnionItemSkeletalMeshContainer, bUpdate) == 0x000F68, "Member 'UUnionItemSkeletalMeshContainer::bUpdate' has a wrong offset!");

// Class UnionRun.ItemMiscParam
// 0x0020 (0x0050 - 0x0030)
class UItemMiscParam final : public UDataAsset
{
public:
	float                                         InertiaMagnification;                              // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            GravityChangeCurve;                                // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFallingTime;                                    // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedMaxBlendSpaceValueThreshold;                  // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutopilotItemEndInvincibleTime;                    // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemMiscParam">();
	}
	static class UItemMiscParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemMiscParam>();
	}
};
static_assert(alignof(UItemMiscParam) == 0x000008, "Wrong alignment on UItemMiscParam");
static_assert(sizeof(UItemMiscParam) == 0x000050, "Wrong size on UItemMiscParam");
static_assert(offsetof(UItemMiscParam, InertiaMagnification) == 0x000030, "Member 'UItemMiscParam::InertiaMagnification' has a wrong offset!");
static_assert(offsetof(UItemMiscParam, GravityChangeCurve) == 0x000038, "Member 'UItemMiscParam::GravityChangeCurve' has a wrong offset!");
static_assert(offsetof(UItemMiscParam, MaxFallingTime) == 0x000040, "Member 'UItemMiscParam::MaxFallingTime' has a wrong offset!");
static_assert(offsetof(UItemMiscParam, SpeedMaxBlendSpaceValueThreshold) == 0x000044, "Member 'UItemMiscParam::SpeedMaxBlendSpaceValueThreshold' has a wrong offset!");
static_assert(offsetof(UItemMiscParam, AutopilotItemEndInvincibleTime) == 0x000048, "Member 'UItemMiscParam::AutopilotItemEndInvincibleTime' has a wrong offset!");

// Class UnionRun.UnionMachineRunParam
// 0x00C8 (0x00F8 - 0x0030)
class UUnionMachineRunParam final : public UDataAsset
{
public:
	float                                         SpeedLimitKMPHMin[0x4];                            // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedLimitKMPHMax[0x4];                            // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedLimitKMPHMonster[0x4];                        // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelNeutral;                                      // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelNormalRate;                                   // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelHighRate;                                     // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelSuperSonicRate;                               // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelUpMulMin[0x4];                                // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelUpMulMax[0x4];                                // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelUpMulMonster[0x4];                            // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashLimitUpperKMPH;                                // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDashChargeParams                      DashQuickChargeCar;                                // 0x00A4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FDashChargeParams                      DashQuickChargeBoat;                               // 0x00B4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FDashChargeParams                      DashQuickChargePlane;                              // 0x00C4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PowerRelativeSpeedMin;                             // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PowerRelativeSpeedMax;                             // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MonsterPowerRelativeSpeedMin;                      // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MonsterPowerRelativeSpeedMax;                      // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PowerRateInDrift;                                  // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MonsterPowerRateInDrift;                           // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PowerInputDelaySeconds;                            // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpinDriftPowerMax;                                 // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpinDriftPowerMin;                                 // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionMachineRunParam">();
	}
	static class UUnionMachineRunParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionMachineRunParam>();
	}
};
static_assert(alignof(UUnionMachineRunParam) == 0x000008, "Wrong alignment on UUnionMachineRunParam");
static_assert(sizeof(UUnionMachineRunParam) == 0x0000F8, "Wrong size on UUnionMachineRunParam");
static_assert(offsetof(UUnionMachineRunParam, SpeedLimitKMPHMin) == 0x000030, "Member 'UUnionMachineRunParam::SpeedLimitKMPHMin' has a wrong offset!");
static_assert(offsetof(UUnionMachineRunParam, SpeedLimitKMPHMax) == 0x000040, "Member 'UUnionMachineRunParam::SpeedLimitKMPHMax' has a wrong offset!");
static_assert(offsetof(UUnionMachineRunParam, SpeedLimitKMPHMonster) == 0x000050, "Member 'UUnionMachineRunParam::SpeedLimitKMPHMonster' has a wrong offset!");
static_assert(offsetof(UUnionMachineRunParam, AccelNeutral) == 0x000060, "Member 'UUnionMachineRunParam::AccelNeutral' has a wrong offset!");
static_assert(offsetof(UUnionMachineRunParam, AccelNormalRate) == 0x000064, "Member 'UUnionMachineRunParam::AccelNormalRate' has a wrong offset!");
static_assert(offsetof(UUnionMachineRunParam, AccelHighRate) == 0x000068, "Member 'UUnionMachineRunParam::AccelHighRate' has a wrong offset!");
static_assert(offsetof(UUnionMachineRunParam, AccelSuperSonicRate) == 0x00006C, "Member 'UUnionMachineRunParam::AccelSuperSonicRate' has a wrong offset!");
static_assert(offsetof(UUnionMachineRunParam, AccelUpMulMin) == 0x000070, "Member 'UUnionMachineRunParam::AccelUpMulMin' has a wrong offset!");
static_assert(offsetof(UUnionMachineRunParam, AccelUpMulMax) == 0x000080, "Member 'UUnionMachineRunParam::AccelUpMulMax' has a wrong offset!");
static_assert(offsetof(UUnionMachineRunParam, AccelUpMulMonster) == 0x000090, "Member 'UUnionMachineRunParam::AccelUpMulMonster' has a wrong offset!");
static_assert(offsetof(UUnionMachineRunParam, DashLimitUpperKMPH) == 0x0000A0, "Member 'UUnionMachineRunParam::DashLimitUpperKMPH' has a wrong offset!");
static_assert(offsetof(UUnionMachineRunParam, DashQuickChargeCar) == 0x0000A4, "Member 'UUnionMachineRunParam::DashQuickChargeCar' has a wrong offset!");
static_assert(offsetof(UUnionMachineRunParam, DashQuickChargeBoat) == 0x0000B4, "Member 'UUnionMachineRunParam::DashQuickChargeBoat' has a wrong offset!");
static_assert(offsetof(UUnionMachineRunParam, DashQuickChargePlane) == 0x0000C4, "Member 'UUnionMachineRunParam::DashQuickChargePlane' has a wrong offset!");
static_assert(offsetof(UUnionMachineRunParam, PowerRelativeSpeedMin) == 0x0000D4, "Member 'UUnionMachineRunParam::PowerRelativeSpeedMin' has a wrong offset!");
static_assert(offsetof(UUnionMachineRunParam, PowerRelativeSpeedMax) == 0x0000D8, "Member 'UUnionMachineRunParam::PowerRelativeSpeedMax' has a wrong offset!");
static_assert(offsetof(UUnionMachineRunParam, MonsterPowerRelativeSpeedMin) == 0x0000DC, "Member 'UUnionMachineRunParam::MonsterPowerRelativeSpeedMin' has a wrong offset!");
static_assert(offsetof(UUnionMachineRunParam, MonsterPowerRelativeSpeedMax) == 0x0000E0, "Member 'UUnionMachineRunParam::MonsterPowerRelativeSpeedMax' has a wrong offset!");
static_assert(offsetof(UUnionMachineRunParam, PowerRateInDrift) == 0x0000E4, "Member 'UUnionMachineRunParam::PowerRateInDrift' has a wrong offset!");
static_assert(offsetof(UUnionMachineRunParam, MonsterPowerRateInDrift) == 0x0000E8, "Member 'UUnionMachineRunParam::MonsterPowerRateInDrift' has a wrong offset!");
static_assert(offsetof(UUnionMachineRunParam, PowerInputDelaySeconds) == 0x0000EC, "Member 'UUnionMachineRunParam::PowerInputDelaySeconds' has a wrong offset!");
static_assert(offsetof(UUnionMachineRunParam, SpinDriftPowerMax) == 0x0000F0, "Member 'UUnionMachineRunParam::SpinDriftPowerMax' has a wrong offset!");
static_assert(offsetof(UUnionMachineRunParam, SpinDriftPowerMin) == 0x0000F4, "Member 'UUnionMachineRunParam::SpinDriftPowerMin' has a wrong offset!");

// Class UnionRun.UnionMonsterTruckMeshContainer
// 0x0058 (0x02E8 - 0x0290)
class AUnionMonsterTruckMeshContainer final : public AActor
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 BodyMeshComponent;                                 // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   BodyStaticMeshComponent;                           // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USkeletalMeshComponent*>         CockpitMeshComponents;                             // 0x02A8(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UStaticMeshComponent*>           UnitCarStaticMeshComponents;                       // 0x02B8(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UStaticMeshComponent*>           UnitBoatStaticMeshComponents;                      // 0x02C8(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class USkeletalMeshComponent*>         UnitPlaneSkeletalMeshComponents;                   // 0x02D8(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionMonsterTruckMeshContainer">();
	}
	static class AUnionMonsterTruckMeshContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnionMonsterTruckMeshContainer>();
	}
};
static_assert(alignof(AUnionMonsterTruckMeshContainer) == 0x000008, "Wrong alignment on AUnionMonsterTruckMeshContainer");
static_assert(sizeof(AUnionMonsterTruckMeshContainer) == 0x0002E8, "Wrong size on AUnionMonsterTruckMeshContainer");
static_assert(offsetof(AUnionMonsterTruckMeshContainer, BodyMeshComponent) == 0x000298, "Member 'AUnionMonsterTruckMeshContainer::BodyMeshComponent' has a wrong offset!");
static_assert(offsetof(AUnionMonsterTruckMeshContainer, BodyStaticMeshComponent) == 0x0002A0, "Member 'AUnionMonsterTruckMeshContainer::BodyStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AUnionMonsterTruckMeshContainer, CockpitMeshComponents) == 0x0002A8, "Member 'AUnionMonsterTruckMeshContainer::CockpitMeshComponents' has a wrong offset!");
static_assert(offsetof(AUnionMonsterTruckMeshContainer, UnitCarStaticMeshComponents) == 0x0002B8, "Member 'AUnionMonsterTruckMeshContainer::UnitCarStaticMeshComponents' has a wrong offset!");
static_assert(offsetof(AUnionMonsterTruckMeshContainer, UnitBoatStaticMeshComponents) == 0x0002C8, "Member 'AUnionMonsterTruckMeshContainer::UnitBoatStaticMeshComponents' has a wrong offset!");
static_assert(offsetof(AUnionMonsterTruckMeshContainer, UnitPlaneSkeletalMeshComponents) == 0x0002D8, "Member 'AUnionMonsterTruckMeshContainer::UnitPlaneSkeletalMeshComponents' has a wrong offset!");

// Class UnionRun.UnionMoveAttachRacer
// 0x0008 (0x0040 - 0x0038)
class UUnionMoveAttachRacer final : public UMoveController
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionMoveAttachRacer">();
	}
	static class UUnionMoveAttachRacer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionMoveAttachRacer>();
	}
};
static_assert(alignof(UUnionMoveAttachRacer) == 0x000008, "Wrong alignment on UUnionMoveAttachRacer");
static_assert(sizeof(UUnionMoveAttachRacer) == 0x000040, "Wrong size on UUnionMoveAttachRacer");

// Class UnionRun.UnionNavLoader
// 0x0018 (0x02A8 - 0x0290)
class AUnionNavLoader final : public AActor
{
public:
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ExportSplineActor;                                 // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionNavLoader">();
	}
	static class AUnionNavLoader* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnionNavLoader>();
	}
};
static_assert(alignof(AUnionNavLoader) == 0x000008, "Wrong alignment on AUnionNavLoader");
static_assert(sizeof(AUnionNavLoader) == 0x0002A8, "Wrong size on AUnionNavLoader");
static_assert(offsetof(AUnionNavLoader, ExportSplineActor) == 0x0002A0, "Member 'AUnionNavLoader::ExportSplineActor' has a wrong offset!");

// Class UnionRun.UnionPhysicalMaterial
// 0x0028 (0x00C0 - 0x0098)
class UUnionPhysicalMaterial final : public UPhysicalMaterial
{
public:
	struct FUnionSurfaceFlag                      SurfaceFlag;                                       // 0x0098(0x001F)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	EUnionSurfaceType                             PhysicalSurfaceType;                               // 0x00B7(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CameraId;                                          // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ParameterId;                                       // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	EUnionSurfaceType GetPhysicalSurfaceType() const;
	struct FUnionSurfaceFlag GetSurfaceFlag() const;
	bool IsAssistWall() const;
	bool IsAssistWallItemIgnoret() const;
	bool IsBouncy() const;
	bool IsBumpyHeavy() const;
	bool IsBumpyLight() const;
	bool IsBumpyMedium() const;
	bool IsCameraChange() const;
	bool IsCarDriveable() const;
	bool IsCylindrical() const;
	bool IsDash() const;
	bool IsGravitySwitch() const;
	bool IsGrindDash() const;
	bool IsGuidedJump() const;
	bool IsHitBouncyMidium() const;
	bool IsHitLoseRing() const;
	bool IsHitSlowdownLight() const;
	bool IsHitSlowdownMidium() const;
	bool IsIgnoreSticky() const;
	bool IsItemOnly() const;
	bool IsMachineOnlyWall() const;
	bool IsNoJump() const;
	bool IsNrrow() const;
	bool IsPseudoPlane() const;
	bool IsRespot() const;
	bool IsSlide() const;
	bool IsSlippy() const;
	bool IsSlowDownLight() const;
	bool IsSlowDownMedium() const;
	bool IsWall() const;
	bool IsYellowDrill() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionPhysicalMaterial">();
	}
	static class UUnionPhysicalMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionPhysicalMaterial>();
	}
};
static_assert(alignof(UUnionPhysicalMaterial) == 0x000008, "Wrong alignment on UUnionPhysicalMaterial");
static_assert(sizeof(UUnionPhysicalMaterial) == 0x0000C0, "Wrong size on UUnionPhysicalMaterial");
static_assert(offsetof(UUnionPhysicalMaterial, SurfaceFlag) == 0x000098, "Member 'UUnionPhysicalMaterial::SurfaceFlag' has a wrong offset!");
static_assert(offsetof(UUnionPhysicalMaterial, PhysicalSurfaceType) == 0x0000B7, "Member 'UUnionPhysicalMaterial::PhysicalSurfaceType' has a wrong offset!");
static_assert(offsetof(UUnionPhysicalMaterial, CameraId) == 0x0000B8, "Member 'UUnionPhysicalMaterial::CameraId' has a wrong offset!");
static_assert(offsetof(UUnionPhysicalMaterial, ParameterId) == 0x0000BC, "Member 'UUnionPhysicalMaterial::ParameterId' has a wrong offset!");

// Class UnionRun.UnionPlayerInfoBillboardUI
// 0x0000 (0x02E0 - 0x02E0)
class UUnionPlayerInfoBillboardUI final : public UUserWidget
{
public:
	void ChangeDriverInfo(const EDriverId& DriverId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionPlayerInfoBillboardUI">();
	}
	static class UUnionPlayerInfoBillboardUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionPlayerInfoBillboardUI>();
	}
};
static_assert(alignof(UUnionPlayerInfoBillboardUI) == 0x000008, "Wrong alignment on UUnionPlayerInfoBillboardUI");
static_assert(sizeof(UUnionPlayerInfoBillboardUI) == 0x0002E0, "Wrong size on UUnionPlayerInfoBillboardUI");

// Class UnionRun.UnionRaceCheatManager
// 0x0028 (0x00B0 - 0x0088)
class UUnionRaceCheatManager final : public UCheatManager
{
public:
	uint8                                         Pad_88[0x10];                                      // 0x0088(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCheatPerformance*                      CheatPerformance;                                  // 0x0098(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCheatItem*                             CheatItem;                                         // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCheatRaceCommon*                       CheatRaceCommon;                                   // 0x00A8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRaceCheatManager">();
	}
	static class UUnionRaceCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRaceCheatManager>();
	}
};
static_assert(alignof(UUnionRaceCheatManager) == 0x000008, "Wrong alignment on UUnionRaceCheatManager");
static_assert(sizeof(UUnionRaceCheatManager) == 0x0000B0, "Wrong size on UUnionRaceCheatManager");
static_assert(offsetof(UUnionRaceCheatManager, CheatPerformance) == 0x000098, "Member 'UUnionRaceCheatManager::CheatPerformance' has a wrong offset!");
static_assert(offsetof(UUnionRaceCheatManager, CheatItem) == 0x0000A0, "Member 'UUnionRaceCheatManager::CheatItem' has a wrong offset!");
static_assert(offsetof(UUnionRaceCheatManager, CheatRaceCommon) == 0x0000A8, "Member 'UUnionRaceCheatManager::CheatRaceCommon' has a wrong offset!");

// Class UnionRun.UnionRaceGadgetUI
// 0x0000 (0x02E0 - 0x02E0)
class UUnionRaceGadgetUI final : public UUserWidget
{
public:
	void InitializeIconsByGadgetInfo(const TArray<EGadgetId>& GadgetInfo);
	void InitializeIconsByRacerIndex(int32 RacerIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRaceGadgetUI">();
	}
	static class UUnionRaceGadgetUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRaceGadgetUI>();
	}
};
static_assert(alignof(UUnionRaceGadgetUI) == 0x000008, "Wrong alignment on UUnionRaceGadgetUI");
static_assert(sizeof(UUnionRaceGadgetUI) == 0x0002E0, "Wrong size on UUnionRaceGadgetUI");

// Class UnionRun.UnionRaceInfoNotifier
// 0x0060 (0x0088 - 0x0028)
class UUnionRaceInfoNotifier final : public UObject
{
public:
	TSet<TWeakObjectPtr<class UObject>>           ListenerSet;                                       // 0x0028(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	class UUnionRaceInfo*                         LastRaceInfoObject;                                // 0x0078(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterRaceInfoListener(class UObject* InListener);
	void Reset();
	void UnregisterRaceInfoListener(class UObject* InListener);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRaceInfoNotifier">();
	}
	static class UUnionRaceInfoNotifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRaceInfoNotifier>();
	}
};
static_assert(alignof(UUnionRaceInfoNotifier) == 0x000008, "Wrong alignment on UUnionRaceInfoNotifier");
static_assert(sizeof(UUnionRaceInfoNotifier) == 0x000088, "Wrong size on UUnionRaceInfoNotifier");
static_assert(offsetof(UUnionRaceInfoNotifier, ListenerSet) == 0x000028, "Member 'UUnionRaceInfoNotifier::ListenerSet' has a wrong offset!");
static_assert(offsetof(UUnionRaceInfoNotifier, LastRaceInfoObject) == 0x000078, "Member 'UUnionRaceInfoNotifier::LastRaceInfoObject' has a wrong offset!");

// Class UnionRun.UnionRaceMinimap
// 0x00D8 (0x03B8 - 0x02E0)
class UUnionRaceMinimap : public UUserWidget
{
public:
	class UOverlay*                               MainOverlay;                                       // 0x02E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDomainIndex                                  CurrentDomainIndex;                                // 0x02E8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDomainNumber                                 CurrentDomainNumber;                               // 0x02E9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EA[0x6];                                      // 0x02EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 IconsRT;                                           // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMinimapIconData>               RacerIconDatas;                                    // 0x02F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UTexture2D*>                     IconBaseTextures;                                  // 0x0308(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FMinimapIconInfoRow>            CharaIconInfos;                                    // 0x0318(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int32                                         RacerCount;                                        // 0x0328(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimapBaseRate;                                   // 0x032C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimapCourseRate;                                 // 0x0330(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimapCourseAngle;                                // 0x0334(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MinimapCourseOffset;                               // 0x0338(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMinimapInited;                                    // 0x0350(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMirrorCourse;                                     // 0x0351(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_352[0x6];                                      // 0x0352(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              IconScale;                                         // 0x0358(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class AActor*, uint8>                    CourseMapActor_IconMap;                            // 0x0368(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void AddCourseMapActor(class AActor* InAttackItem, EItemId InItemId);
	struct FLinearColor GetGroupColor(int32 GouupIndex);
	void InitializeMinimap(class UTextureRenderTarget2D* InRenderTarget);
	void InitializeRaceData();
	void RemoveCourseMapActor(class AActor* InAttackItem);
	void SetCourseMapCharaSpin(int32 RacerIndex);
	void SetCourseSetting(const TSoftObjectPtr<class UObject>& CourseTexture, float InOrthoRate, float InAngle, const struct FVector& InOffset);
	void SetDomainIndex(int32 InDomainIndex);
	void SetDomainNumber(int32 InDomainNumber);
	void SetDriverId(int32 RacerIndex, int32 DriverId);
	void SetGroupIndex(int32 RacerIndex, int32 GroupIndex);
	void SetMinimapIconItem(const int32& RacerIndex, const EItemId& InItemId);
	void SetMinimapIconType(const int32& RacerIndex, const EMinimapIconType& InMinimapIconType);
	void SetPlayerIndex(int32 RacerIndex, int32 PlayerIndex, bool IsPlayer, bool IsLocalMulti);
	void SetPosition(int32 RacerIndex, const struct FVector& InPosition);
	void SetPositionAndZOrder(int32 RacerIndex, const struct FVector& InPosition, const uint8& InZOrder);
	void SetRacerCount(int32 RacerCount_0);
	void SetRacerIconVisibility(int32 RacerIndex, ESlateVisibility NewVisibility);
	void SetReaderFlag(int32 RacerIndex, const bool& InIsReader);
	void SetRival(int32 RacerIndex, bool IsRival, bool IsPowerRival);
	void UpdateMinimap(float InDelta);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRaceMinimap">();
	}
	static class UUnionRaceMinimap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRaceMinimap>();
	}
};
static_assert(alignof(UUnionRaceMinimap) == 0x000008, "Wrong alignment on UUnionRaceMinimap");
static_assert(sizeof(UUnionRaceMinimap) == 0x0003B8, "Wrong size on UUnionRaceMinimap");
static_assert(offsetof(UUnionRaceMinimap, MainOverlay) == 0x0002E0, "Member 'UUnionRaceMinimap::MainOverlay' has a wrong offset!");
static_assert(offsetof(UUnionRaceMinimap, CurrentDomainIndex) == 0x0002E8, "Member 'UUnionRaceMinimap::CurrentDomainIndex' has a wrong offset!");
static_assert(offsetof(UUnionRaceMinimap, CurrentDomainNumber) == 0x0002E9, "Member 'UUnionRaceMinimap::CurrentDomainNumber' has a wrong offset!");
static_assert(offsetof(UUnionRaceMinimap, IconsRT) == 0x0002F0, "Member 'UUnionRaceMinimap::IconsRT' has a wrong offset!");
static_assert(offsetof(UUnionRaceMinimap, RacerIconDatas) == 0x0002F8, "Member 'UUnionRaceMinimap::RacerIconDatas' has a wrong offset!");
static_assert(offsetof(UUnionRaceMinimap, IconBaseTextures) == 0x000308, "Member 'UUnionRaceMinimap::IconBaseTextures' has a wrong offset!");
static_assert(offsetof(UUnionRaceMinimap, CharaIconInfos) == 0x000318, "Member 'UUnionRaceMinimap::CharaIconInfos' has a wrong offset!");
static_assert(offsetof(UUnionRaceMinimap, RacerCount) == 0x000328, "Member 'UUnionRaceMinimap::RacerCount' has a wrong offset!");
static_assert(offsetof(UUnionRaceMinimap, MinimapBaseRate) == 0x00032C, "Member 'UUnionRaceMinimap::MinimapBaseRate' has a wrong offset!");
static_assert(offsetof(UUnionRaceMinimap, MinimapCourseRate) == 0x000330, "Member 'UUnionRaceMinimap::MinimapCourseRate' has a wrong offset!");
static_assert(offsetof(UUnionRaceMinimap, MinimapCourseAngle) == 0x000334, "Member 'UUnionRaceMinimap::MinimapCourseAngle' has a wrong offset!");
static_assert(offsetof(UUnionRaceMinimap, MinimapCourseOffset) == 0x000338, "Member 'UUnionRaceMinimap::MinimapCourseOffset' has a wrong offset!");
static_assert(offsetof(UUnionRaceMinimap, bMinimapInited) == 0x000350, "Member 'UUnionRaceMinimap::bMinimapInited' has a wrong offset!");
static_assert(offsetof(UUnionRaceMinimap, bMirrorCourse) == 0x000351, "Member 'UUnionRaceMinimap::bMirrorCourse' has a wrong offset!");
static_assert(offsetof(UUnionRaceMinimap, IconScale) == 0x000358, "Member 'UUnionRaceMinimap::IconScale' has a wrong offset!");
static_assert(offsetof(UUnionRaceMinimap, CourseMapActor_IconMap) == 0x000368, "Member 'UUnionRaceMinimap::CourseMapActor_IconMap' has a wrong offset!");

// Class UnionRun.UnionRaceReturnDashUI
// 0x0010 (0x02F0 - 0x02E0)
class UUnionRaceReturnDashUI final : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URaceUISubReturnDashGauge*              WBP_Race_ReturnDash_Sub_ArcGauge;                  // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UObject* GetButtonWidget();
	void SetGaugeParcent(const float& GaugeRate);
	void SetReturnDashSetting(const float& Pivot, const float& Range);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRaceReturnDashUI">();
	}
	static class UUnionRaceReturnDashUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRaceReturnDashUI>();
	}
};
static_assert(alignof(UUnionRaceReturnDashUI) == 0x000008, "Wrong alignment on UUnionRaceReturnDashUI");
static_assert(sizeof(UUnionRaceReturnDashUI) == 0x0002F0, "Wrong size on UUnionRaceReturnDashUI");
static_assert(offsetof(UUnionRaceReturnDashUI, WBP_Race_ReturnDash_Sub_ArcGauge) == 0x0002E8, "Member 'UUnionRaceReturnDashUI::WBP_Race_ReturnDash_Sub_ArcGauge' has a wrong offset!");

// Class UnionRun.RacerReactionTriggerParam
// 0x0038 (0x0068 - 0x0030)
class URacerReactionTriggerParam final : public UDataAsset
{
public:
	float                                         RunDelaySeconds;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReverseRunDelaySeconds;                            // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunOffDelaySeconds;                                // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterStartDelaySeconds;                        // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterEndSeconds;                               // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterMainCourseEnterSeconds;                   // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterAnotherCourseEnterSeconds;                // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RivalStartDelaySeconds;                            // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RivalCatchUpDist;                                  // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RivalCatchUpDelaySeconds;                          // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RivalCaughtUpDist;                                 // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RivalCaughtUpDelaySeconds;                         // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KeepTopDelaySeconds;                               // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RacerReactionTriggerParam">();
	}
	static class URacerReactionTriggerParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<URacerReactionTriggerParam>();
	}
};
static_assert(alignof(URacerReactionTriggerParam) == 0x000008, "Wrong alignment on URacerReactionTriggerParam");
static_assert(sizeof(URacerReactionTriggerParam) == 0x000068, "Wrong size on URacerReactionTriggerParam");
static_assert(offsetof(URacerReactionTriggerParam, RunDelaySeconds) == 0x000030, "Member 'URacerReactionTriggerParam::RunDelaySeconds' has a wrong offset!");
static_assert(offsetof(URacerReactionTriggerParam, ReverseRunDelaySeconds) == 0x000034, "Member 'URacerReactionTriggerParam::ReverseRunDelaySeconds' has a wrong offset!");
static_assert(offsetof(URacerReactionTriggerParam, RunOffDelaySeconds) == 0x000038, "Member 'URacerReactionTriggerParam::RunOffDelaySeconds' has a wrong offset!");
static_assert(offsetof(URacerReactionTriggerParam, CharacterStartDelaySeconds) == 0x00003C, "Member 'URacerReactionTriggerParam::CharacterStartDelaySeconds' has a wrong offset!");
static_assert(offsetof(URacerReactionTriggerParam, CharacterEndSeconds) == 0x000040, "Member 'URacerReactionTriggerParam::CharacterEndSeconds' has a wrong offset!");
static_assert(offsetof(URacerReactionTriggerParam, CharacterMainCourseEnterSeconds) == 0x000044, "Member 'URacerReactionTriggerParam::CharacterMainCourseEnterSeconds' has a wrong offset!");
static_assert(offsetof(URacerReactionTriggerParam, CharacterAnotherCourseEnterSeconds) == 0x000048, "Member 'URacerReactionTriggerParam::CharacterAnotherCourseEnterSeconds' has a wrong offset!");
static_assert(offsetof(URacerReactionTriggerParam, RivalStartDelaySeconds) == 0x00004C, "Member 'URacerReactionTriggerParam::RivalStartDelaySeconds' has a wrong offset!");
static_assert(offsetof(URacerReactionTriggerParam, RivalCatchUpDist) == 0x000050, "Member 'URacerReactionTriggerParam::RivalCatchUpDist' has a wrong offset!");
static_assert(offsetof(URacerReactionTriggerParam, RivalCatchUpDelaySeconds) == 0x000054, "Member 'URacerReactionTriggerParam::RivalCatchUpDelaySeconds' has a wrong offset!");
static_assert(offsetof(URacerReactionTriggerParam, RivalCaughtUpDist) == 0x000058, "Member 'URacerReactionTriggerParam::RivalCaughtUpDist' has a wrong offset!");
static_assert(offsetof(URacerReactionTriggerParam, RivalCaughtUpDelaySeconds) == 0x00005C, "Member 'URacerReactionTriggerParam::RivalCaughtUpDelaySeconds' has a wrong offset!");
static_assert(offsetof(URacerReactionTriggerParam, KeepTopDelaySeconds) == 0x000060, "Member 'URacerReactionTriggerParam::KeepTopDelaySeconds' has a wrong offset!");

// Class UnionRun.RacerReactionInfoDataAsset
// 0x0010 (0x0040 - 0x0030)
class URacerReactionInfoDataAsset final : public UDataAsset
{
public:
	TArray<struct FRacerReactionInfo>             InfoList;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	void Import();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RacerReactionInfoDataAsset">();
	}
	static class URacerReactionInfoDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<URacerReactionInfoDataAsset>();
	}
};
static_assert(alignof(URacerReactionInfoDataAsset) == 0x000008, "Wrong alignment on URacerReactionInfoDataAsset");
static_assert(sizeof(URacerReactionInfoDataAsset) == 0x000040, "Wrong size on URacerReactionInfoDataAsset");
static_assert(offsetof(URacerReactionInfoDataAsset, InfoList) == 0x000030, "Member 'URacerReactionInfoDataAsset::InfoList' has a wrong offset!");

// Class UnionRun.UnionRacers
// 0x0148 (0x0170 - 0x0028)
class UUnionRacers final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class UUnionRacer*>               RacerMap;                                          // 0x0038(0x0050)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            PlayerControllerIndex_RacerMap;                    // 0x0088(0x0050)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            RacerIndex_PlayerControllerIndexMap;               // 0x00D8(0x0050)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	class UGroupInfo*                             GroupInfo;                                         // 0x0128(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionRaceUI*                           RaceHUD;                                           // 0x0130(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRankSort>                      RankSort;                                          // 0x0138(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EStageId                                      SelectedTravelStage;                               // 0x0148(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 GoalRanks;                                         // 0x0150(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int32>                                 GoalRacerIndexes;                                  // 0x0160(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static EDriverId GetDriverIdByRacerIndex(const int32 InRacerIndex);

	void ApplyPauseInputs();
	void ApplyVehicleInputs();
	void ChangeVehicleDisplayMode(int32 InRacerIndex, EVehicleDisplayMode InVehicleDisplayMode);
	void ClearVehicles();
	bool Destroy();
	void ExecTick(float DeltaSeconds);
	void GetLocalPlayers(TArray<class UUnionRacer*>* OutRacers);
	int32 GetPlayerRank(int32 PlayerIndex);
	class UUnionRaceUI* GetRaceHUDRef();
	class UUnionRaceLapInfo* GetRaceLapInfo(const int32& InRacerIndex);
	class UUnionRacer* GetRacer(int32 InRacerIndex);
	const struct FVector GetRacer3DPositionAndDomainNumber(int32 Index_0, EDomainNumber* DomainNum);
	int32 GetRacerIndexByRank(const int32& InRank);
	int32 GetRacerRank(int32 Index_0);
	class UUnionRaceSituationObject* GetRacerSituationObject(int32 InRacerIndex);
	class UUnionRacerStatusObject* GetRacerStatusObject(int32 InRacerIndex);
	int32 GetTestRaceCount();
	void HidePlayerNameHUD();
	void InitTestRace();
	bool IsOfflinePlayer(class UUnionRacer* Racer);
	bool IsOnlineCom(class UUnionRacer* Racer);
	bool IsPlayer(class UUnionRacer* Racer);
	void SetLinkPlayerControllerIndexToRacerIndex(const int32& PlayerControllerIndex, const int32& InRacerIndex);
	void SetRaceLapInfo(const int32& InRacerIndex, class UUnionRaceLapInfo* InRaceLapInfo);
	void SetTickable(bool bTickable);
	void SetVehicle(const int32& InRacerIndex, class APawn* InVehicle);
	struct FTimerHandle UnionRacers_SetTimerDelegate(TDelegate<void()> Delegate, float Time, bool bLooping);
	void UpdateBaggage(float Delta);
	void UpdateDomain(float Delta);
	void UpdatePlayerNameHUD(float Delta);
	void UpdateTestRace(float Delta);
	void UpdateVehicleInputs();
	void UpdateVehicles(float Delta);

	int32 GetGamePauseOwnerPlayerControllerIndex() const;
	int32 GetGamePauseOwnerRacerIndex() const;
	int32 GetPlayerControllerIndexByRacerIndex(const int32& InRacerIndex) const;
	int32 GetRacerIndexByPlayerControllerIndex(const int32& PlayerControllerIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRacers">();
	}
	static class UUnionRacers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRacers>();
	}
};
static_assert(alignof(UUnionRacers) == 0x000008, "Wrong alignment on UUnionRacers");
static_assert(sizeof(UUnionRacers) == 0x000170, "Wrong size on UUnionRacers");
static_assert(offsetof(UUnionRacers, RacerMap) == 0x000038, "Member 'UUnionRacers::RacerMap' has a wrong offset!");
static_assert(offsetof(UUnionRacers, PlayerControllerIndex_RacerMap) == 0x000088, "Member 'UUnionRacers::PlayerControllerIndex_RacerMap' has a wrong offset!");
static_assert(offsetof(UUnionRacers, RacerIndex_PlayerControllerIndexMap) == 0x0000D8, "Member 'UUnionRacers::RacerIndex_PlayerControllerIndexMap' has a wrong offset!");
static_assert(offsetof(UUnionRacers, GroupInfo) == 0x000128, "Member 'UUnionRacers::GroupInfo' has a wrong offset!");
static_assert(offsetof(UUnionRacers, RaceHUD) == 0x000130, "Member 'UUnionRacers::RaceHUD' has a wrong offset!");
static_assert(offsetof(UUnionRacers, RankSort) == 0x000138, "Member 'UUnionRacers::RankSort' has a wrong offset!");
static_assert(offsetof(UUnionRacers, SelectedTravelStage) == 0x000148, "Member 'UUnionRacers::SelectedTravelStage' has a wrong offset!");
static_assert(offsetof(UUnionRacers, GoalRanks) == 0x000150, "Member 'UUnionRacers::GoalRanks' has a wrong offset!");
static_assert(offsetof(UUnionRacers, GoalRacerIndexes) == 0x000160, "Member 'UUnionRacers::GoalRacerIndexes' has a wrong offset!");

// Class UnionRun.UnionRaceSituationParams
// 0x0028 (0x0058 - 0x0030)
class UUnionRaceSituationParams final : public UDataAsset
{
public:
	bool                                          bFootCutEnable;                                    // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFootCutParams                         FootCutParams[0x3];                                // 0x0034(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         NoItemUseSeconds;                                  // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespotDiffSeconds;                                 // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelectConflictDistance;                            // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRaceSituationParams">();
	}
	static class UUnionRaceSituationParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRaceSituationParams>();
	}
};
static_assert(alignof(UUnionRaceSituationParams) == 0x000008, "Wrong alignment on UUnionRaceSituationParams");
static_assert(sizeof(UUnionRaceSituationParams) == 0x000058, "Wrong size on UUnionRaceSituationParams");
static_assert(offsetof(UUnionRaceSituationParams, bFootCutEnable) == 0x000030, "Member 'UUnionRaceSituationParams::bFootCutEnable' has a wrong offset!");
static_assert(offsetof(UUnionRaceSituationParams, FootCutParams) == 0x000034, "Member 'UUnionRaceSituationParams::FootCutParams' has a wrong offset!");
static_assert(offsetof(UUnionRaceSituationParams, NoItemUseSeconds) == 0x00004C, "Member 'UUnionRaceSituationParams::NoItemUseSeconds' has a wrong offset!");
static_assert(offsetof(UUnionRaceSituationParams, RespotDiffSeconds) == 0x000050, "Member 'UUnionRaceSituationParams::RespotDiffSeconds' has a wrong offset!");
static_assert(offsetof(UUnionRaceSituationParams, SelectConflictDistance) == 0x000054, "Member 'UUnionRaceSituationParams::SelectConflictDistance' has a wrong offset!");

// Class UnionRun.UnionRaceStartUI
// 0x0010 (0x02F0 - 0x02E0)
class UUnionRaceStartUI : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class URaceUISubStartGauge*                   WBP_Race_StartDash_Sub_ArcGauge;                   // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UObject* GetButtonWidget();
	void SetCount(int32 InCount);
	void SetGaugeParcent(const float& GaugeRate);
	void SetStartDashParamSetting(const struct FUnionRaceStartDashParam& InStartDashParam);
	void SetStartDashSetting(const float& LV3_PIVOT, const float& LV3_RANGE, const float& LV2_PIVOT, const float& LV2_RANGE, const float& NG1_PIVOT, const float& NG1_RANGE, const float& NG2_PIVOT, const float& NG2_RANGE);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRaceStartUI">();
	}
	static class UUnionRaceStartUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRaceStartUI>();
	}
};
static_assert(alignof(UUnionRaceStartUI) == 0x000008, "Wrong alignment on UUnionRaceStartUI");
static_assert(sizeof(UUnionRaceStartUI) == 0x0002F0, "Wrong size on UUnionRaceStartUI");
static_assert(offsetof(UUnionRaceStartUI, WBP_Race_StartDash_Sub_ArcGauge) == 0x0002E8, "Member 'UUnionRaceStartUI::WBP_Race_StartDash_Sub_ArcGauge' has a wrong offset!");

// Class UnionRun.UnionRaceInfo
// 0x0028 (0x0050 - 0x0028)
class UUnionRaceInfo final : public UObject
{
public:
	float                                         RaceTime;                                          // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinutePart;                                        // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondPart;                                        // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MillimeterSecondPart;                              // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRaceStateCountdown;                              // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRaceStateOnRace;                                 // 0x0039(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRaceStateFinish;                                 // 0x003A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Race_CountDown_7;                                  // 0x003B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Race_CountDown_6;                                  // 0x003C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Race_CountDown_5;                                  // 0x003D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Race_CountDown_4;                                  // 0x003E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Race_CountDown_3;                                  // 0x003F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Race_CountDown_2;                                  // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Race_CountDown_1;                                  // 0x0041(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Race_CountDown_0;                                  // 0x0042(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Race_Finish;                                       // 0x0043(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERaceInfoStateType                            RaceStatus;                                        // 0x0044(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RaceCountDownValue;                                // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRaceInfo">();
	}
	static class UUnionRaceInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRaceInfo>();
	}
};
static_assert(alignof(UUnionRaceInfo) == 0x000008, "Wrong alignment on UUnionRaceInfo");
static_assert(sizeof(UUnionRaceInfo) == 0x000050, "Wrong size on UUnionRaceInfo");
static_assert(offsetof(UUnionRaceInfo, RaceTime) == 0x000028, "Member 'UUnionRaceInfo::RaceTime' has a wrong offset!");
static_assert(offsetof(UUnionRaceInfo, MinutePart) == 0x00002C, "Member 'UUnionRaceInfo::MinutePart' has a wrong offset!");
static_assert(offsetof(UUnionRaceInfo, SecondPart) == 0x000030, "Member 'UUnionRaceInfo::SecondPart' has a wrong offset!");
static_assert(offsetof(UUnionRaceInfo, MillimeterSecondPart) == 0x000034, "Member 'UUnionRaceInfo::MillimeterSecondPart' has a wrong offset!");
static_assert(offsetof(UUnionRaceInfo, IsRaceStateCountdown) == 0x000038, "Member 'UUnionRaceInfo::IsRaceStateCountdown' has a wrong offset!");
static_assert(offsetof(UUnionRaceInfo, IsRaceStateOnRace) == 0x000039, "Member 'UUnionRaceInfo::IsRaceStateOnRace' has a wrong offset!");
static_assert(offsetof(UUnionRaceInfo, IsRaceStateFinish) == 0x00003A, "Member 'UUnionRaceInfo::IsRaceStateFinish' has a wrong offset!");
static_assert(offsetof(UUnionRaceInfo, Race_CountDown_7) == 0x00003B, "Member 'UUnionRaceInfo::Race_CountDown_7' has a wrong offset!");
static_assert(offsetof(UUnionRaceInfo, Race_CountDown_6) == 0x00003C, "Member 'UUnionRaceInfo::Race_CountDown_6' has a wrong offset!");
static_assert(offsetof(UUnionRaceInfo, Race_CountDown_5) == 0x00003D, "Member 'UUnionRaceInfo::Race_CountDown_5' has a wrong offset!");
static_assert(offsetof(UUnionRaceInfo, Race_CountDown_4) == 0x00003E, "Member 'UUnionRaceInfo::Race_CountDown_4' has a wrong offset!");
static_assert(offsetof(UUnionRaceInfo, Race_CountDown_3) == 0x00003F, "Member 'UUnionRaceInfo::Race_CountDown_3' has a wrong offset!");
static_assert(offsetof(UUnionRaceInfo, Race_CountDown_2) == 0x000040, "Member 'UUnionRaceInfo::Race_CountDown_2' has a wrong offset!");
static_assert(offsetof(UUnionRaceInfo, Race_CountDown_1) == 0x000041, "Member 'UUnionRaceInfo::Race_CountDown_1' has a wrong offset!");
static_assert(offsetof(UUnionRaceInfo, Race_CountDown_0) == 0x000042, "Member 'UUnionRaceInfo::Race_CountDown_0' has a wrong offset!");
static_assert(offsetof(UUnionRaceInfo, Race_Finish) == 0x000043, "Member 'UUnionRaceInfo::Race_Finish' has a wrong offset!");
static_assert(offsetof(UUnionRaceInfo, RaceStatus) == 0x000044, "Member 'UUnionRaceInfo::RaceStatus' has a wrong offset!");
static_assert(offsetof(UUnionRaceInfo, RaceCountDownValue) == 0x000048, "Member 'UUnionRaceInfo::RaceCountDownValue' has a wrong offset!");

// Class UnionRun.UnionRaceLapInfo
// 0x0048 (0x0070 - 0x0028)
class UUnionRaceLapInfo final : public UObject
{
public:
	int32                                         m_LapCount;                                        // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUnionRaceTime                         m_LastStartTime;                                   // 0x002C(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FUnionRaceTime                         m_CurentLapTime;                                   // 0x003C(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FUnionRaceTime                         m_LastLapTime;                                     // 0x004C(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FUnionRaceTime                         m_BestLapTime;                                     // 0x005C(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static float GetLapTimeFloat(const struct FUnionRaceTime& Time);

	void GetBestLapTimeValue(int32* MinuteValue, int32* SecondValue, int32* MilliSecondValue);
	void GetCurentLapTimeValue(int32* MinuteValue, int32* SecondValue, int32* MilliSecondValue);
	void GetLastLapTimeValue(int32* MinuteValue, int32* SecondValue, int32* MilliSecondValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRaceLapInfo">();
	}
	static class UUnionRaceLapInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRaceLapInfo>();
	}
};
static_assert(alignof(UUnionRaceLapInfo) == 0x000008, "Wrong alignment on UUnionRaceLapInfo");
static_assert(sizeof(UUnionRaceLapInfo) == 0x000070, "Wrong size on UUnionRaceLapInfo");
static_assert(offsetof(UUnionRaceLapInfo, m_LapCount) == 0x000028, "Member 'UUnionRaceLapInfo::m_LapCount' has a wrong offset!");
static_assert(offsetof(UUnionRaceLapInfo, m_LastStartTime) == 0x00002C, "Member 'UUnionRaceLapInfo::m_LastStartTime' has a wrong offset!");
static_assert(offsetof(UUnionRaceLapInfo, m_CurentLapTime) == 0x00003C, "Member 'UUnionRaceLapInfo::m_CurentLapTime' has a wrong offset!");
static_assert(offsetof(UUnionRaceLapInfo, m_LastLapTime) == 0x00004C, "Member 'UUnionRaceLapInfo::m_LastLapTime' has a wrong offset!");
static_assert(offsetof(UUnionRaceLapInfo, m_BestLapTime) == 0x00005C, "Member 'UUnionRaceLapInfo::m_BestLapTime' has a wrong offset!");

// Class UnionRun.UnionRacePlayerStatus
// 0x01A8 (0x01D0 - 0x0028)
class UUnionRacePlayerStatus final : public UObject
{
public:
	bool                                          bIndexInited;                                      // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RacerIndex;                                        // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerControllerIndex;                             // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0xC];                                       // 0x0034(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	EDomainIndex                                  PresentDomainIndex;                                // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PresentDomainNumber;                               // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDomainIndex                                  PresentNextDomainIndex;                            // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDomainNumber                                 PresentNextDomainNumber;                           // 0x0049(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPresentValidTravelRing;                           // 0x004A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPresentNoticeRingOn;                              // 0x004B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPresentSelectStartOn;                             // 0x004C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPresentSelectingA;                                // 0x004D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPresentSelectingB;                                // 0x004E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPresentAnotherConfirmEndOn;                       // 0x004F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPresentJustBeforeOn;                              // 0x0050(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPresentIsSameDomainNumber;                        // 0x0051(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PresentTravelRingDomainPosition;                   // 0x0058(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMatrix                                PresentTravelRingDomainRotation;                   // 0x0070(0x0080)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UUnionVehicleModelInfo*                 PresentDomainVehicleModelInfo;                     // 0x00F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionGameCameraInfo*                   PresentDomainGameCameraInfo;                       // 0x00F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EDomainIndex                                  InRingDomainIndex;                                 // 0x0108(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InRingDomainNumber;                                // 0x010C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInRingValidTravelRing;                            // 0x0110(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInRingAnotherConfirmEndOn;                        // 0x0111(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInRingJustBeforeOn;                               // 0x0112(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInRingIsSameDomainNumber;                         // 0x0113(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InRingTravelRingDomainPosition;                    // 0x0118(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMatrix                                InRingTravelRingDomainRotation;                    // 0x0130(0x0080)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UUnionVehicleModelInfo*                 InRingDomainVehicleModelInfo;                      // 0x01B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUnionGameCameraInfo*                   InRingDomainGameCameraInfo;                        // 0x01B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitRacerIndex;                                   // 0x01C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitPlayerIndex;                                  // 0x01C1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C2[0xE];                                      // 0x01C2(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRacePlayerStatus">();
	}
	static class UUnionRacePlayerStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRacePlayerStatus>();
	}
};
static_assert(alignof(UUnionRacePlayerStatus) == 0x000010, "Wrong alignment on UUnionRacePlayerStatus");
static_assert(sizeof(UUnionRacePlayerStatus) == 0x0001D0, "Wrong size on UUnionRacePlayerStatus");
static_assert(offsetof(UUnionRacePlayerStatus, bIndexInited) == 0x000028, "Member 'UUnionRacePlayerStatus::bIndexInited' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, RacerIndex) == 0x00002C, "Member 'UUnionRacePlayerStatus::RacerIndex' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, PlayerControllerIndex) == 0x000030, "Member 'UUnionRacePlayerStatus::PlayerControllerIndex' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, PresentDomainIndex) == 0x000040, "Member 'UUnionRacePlayerStatus::PresentDomainIndex' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, PresentDomainNumber) == 0x000044, "Member 'UUnionRacePlayerStatus::PresentDomainNumber' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, PresentNextDomainIndex) == 0x000048, "Member 'UUnionRacePlayerStatus::PresentNextDomainIndex' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, PresentNextDomainNumber) == 0x000049, "Member 'UUnionRacePlayerStatus::PresentNextDomainNumber' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, bPresentValidTravelRing) == 0x00004A, "Member 'UUnionRacePlayerStatus::bPresentValidTravelRing' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, bPresentNoticeRingOn) == 0x00004B, "Member 'UUnionRacePlayerStatus::bPresentNoticeRingOn' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, bPresentSelectStartOn) == 0x00004C, "Member 'UUnionRacePlayerStatus::bPresentSelectStartOn' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, bPresentSelectingA) == 0x00004D, "Member 'UUnionRacePlayerStatus::bPresentSelectingA' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, bPresentSelectingB) == 0x00004E, "Member 'UUnionRacePlayerStatus::bPresentSelectingB' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, bPresentAnotherConfirmEndOn) == 0x00004F, "Member 'UUnionRacePlayerStatus::bPresentAnotherConfirmEndOn' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, bPresentJustBeforeOn) == 0x000050, "Member 'UUnionRacePlayerStatus::bPresentJustBeforeOn' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, bPresentIsSameDomainNumber) == 0x000051, "Member 'UUnionRacePlayerStatus::bPresentIsSameDomainNumber' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, PresentTravelRingDomainPosition) == 0x000058, "Member 'UUnionRacePlayerStatus::PresentTravelRingDomainPosition' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, PresentTravelRingDomainRotation) == 0x000070, "Member 'UUnionRacePlayerStatus::PresentTravelRingDomainRotation' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, PresentDomainVehicleModelInfo) == 0x0000F0, "Member 'UUnionRacePlayerStatus::PresentDomainVehicleModelInfo' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, PresentDomainGameCameraInfo) == 0x0000F8, "Member 'UUnionRacePlayerStatus::PresentDomainGameCameraInfo' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, InRingDomainIndex) == 0x000108, "Member 'UUnionRacePlayerStatus::InRingDomainIndex' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, InRingDomainNumber) == 0x00010C, "Member 'UUnionRacePlayerStatus::InRingDomainNumber' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, bInRingValidTravelRing) == 0x000110, "Member 'UUnionRacePlayerStatus::bInRingValidTravelRing' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, bInRingAnotherConfirmEndOn) == 0x000111, "Member 'UUnionRacePlayerStatus::bInRingAnotherConfirmEndOn' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, bInRingJustBeforeOn) == 0x000112, "Member 'UUnionRacePlayerStatus::bInRingJustBeforeOn' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, bInRingIsSameDomainNumber) == 0x000113, "Member 'UUnionRacePlayerStatus::bInRingIsSameDomainNumber' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, InRingTravelRingDomainPosition) == 0x000118, "Member 'UUnionRacePlayerStatus::InRingTravelRingDomainPosition' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, InRingTravelRingDomainRotation) == 0x000130, "Member 'UUnionRacePlayerStatus::InRingTravelRingDomainRotation' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, InRingDomainVehicleModelInfo) == 0x0001B0, "Member 'UUnionRacePlayerStatus::InRingDomainVehicleModelInfo' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, InRingDomainGameCameraInfo) == 0x0001B8, "Member 'UUnionRacePlayerStatus::InRingDomainGameCameraInfo' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, bInitRacerIndex) == 0x0001C0, "Member 'UUnionRacePlayerStatus::bInitRacerIndex' has a wrong offset!");
static_assert(offsetof(UUnionRacePlayerStatus, bInitPlayerIndex) == 0x0001C1, "Member 'UUnionRacePlayerStatus::bInitPlayerIndex' has a wrong offset!");

// Class UnionRun.ComCommonParams
// 0x0050 (0x0080 - 0x0030)
class UComCommonParams final : public UDataAsset
{
public:
	struct FComAvoidParams                        ComAvoidParams;                                    // 0x0030(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FComSlimeCancelParams                  ComSlimeCancelParams;                              // 0x0040(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FComAvoidKingBoomBooPillarParams       ComAvoidKingBoomBooPillarParams;                   // 0x0048(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FComTimingGimmickParams                ComTimingGimmickParams;                            // 0x0054(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FComLotteryParams                      ComLotteryParams;                                  // 0x007C(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ComCommonParams">();
	}
	static class UComCommonParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UComCommonParams>();
	}
};
static_assert(alignof(UComCommonParams) == 0x000008, "Wrong alignment on UComCommonParams");
static_assert(sizeof(UComCommonParams) == 0x000080, "Wrong size on UComCommonParams");
static_assert(offsetof(UComCommonParams, ComAvoidParams) == 0x000030, "Member 'UComCommonParams::ComAvoidParams' has a wrong offset!");
static_assert(offsetof(UComCommonParams, ComSlimeCancelParams) == 0x000040, "Member 'UComCommonParams::ComSlimeCancelParams' has a wrong offset!");
static_assert(offsetof(UComCommonParams, ComAvoidKingBoomBooPillarParams) == 0x000048, "Member 'UComCommonParams::ComAvoidKingBoomBooPillarParams' has a wrong offset!");
static_assert(offsetof(UComCommonParams, ComTimingGimmickParams) == 0x000054, "Member 'UComCommonParams::ComTimingGimmickParams' has a wrong offset!");
static_assert(offsetof(UComCommonParams, ComLotteryParams) == 0x00007C, "Member 'UComCommonParams::ComLotteryParams' has a wrong offset!");

// Class UnionRun.UnionRaceUI
// 0x0398 (0x0678 - 0x02E0)
class UUnionRaceUI : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	EViewSplitMode                                RaceSplitMode;                                     // 0x02F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F9[0x7];                                      // 0x02F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionRaceMinimap*                      RaceMinimap;                                       // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UUserWidget*>                    StartTextUI;                                       // 0x0308(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UUnionRaceStartUI*>              JudgeStartUI;                                      // 0x0318(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UUnionRaceReturnDashUI*>         JudgeReturnDashUI;                                 // 0x0328(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UUserWidget*>                    FinishTextUI;                                      // 0x0338(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class URaceUISubRing*>                 RingCountUI;                                       // 0x0348(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class URaceUISubLap*>                  LapCountUI;                                        // 0x0358(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class URaceUISubAiming*>               AimingUI;                                          // 0x0368(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<EUnionRaceHUDItemIconsState>           ItemIconsState;                                    // 0x0378(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UURaceUISubItemIconSet*>         ItemIconSet;                                       // 0x0388(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FSoundHandle>                   ItemLotterySoundArr;                               // 0x0398(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSoundHandle>                   YellowDrillShortTimeSoundArr;                      // 0x03A8(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  bItemPanelVisibility;                              // 0x03B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            RacerIndex_PlayerIndexMap;                         // 0x03C8(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            PlayerIndex_RacerIndexMap;                         // 0x0418(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<int32>                                 PackageRingPerformeCount;                          // 0x0468(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class APackageRingEffect*>             PackageRingEffects;                                // 0x0478(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class APackageRingEffect*>             PackageRingEffectsRemoveReserve;                   // 0x0488(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<EUnionRaceHUDPackageRingState>         PackageRingPerformState;                           // 0x0498(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UCanvasPanelSlot*>               WarningArea;                                       // 0x04A8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UImage*>                         WarningBelt;                                       // 0x04B8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<bool>                                  IsDispOnWarningBelt;                               // 0x04C8(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D8[0x18];                                     // 0x04D8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInstanceDynamic*>       WarningBeltMaterial;                               // 0x04F0(0x0010)(BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class UObject*, struct FUnionRaceHUDWarning> AttackObject_WarnigInfoMap;                    // 0x0500(0x0050)(BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_550[0x8];                                      // 0x0550(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUnionRaceHUDWarningPerPlayer>  AttackWarningPerPlayer;                            // 0x0558(0x0010)(BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FUnionRaceHUDWarning>           RacerApproachInfo;                                 // 0x0568(0x0010)(BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        PackageRingEffect;                                 // 0x0578(0x0020)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHoldItemInfo>                  HoldItemInfo;                                      // 0x0598(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class URaceUISubAirTrickInfo*>         AirTrickInfo;                                      // 0x05A8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UUnionRaceGadgetUI*>             GadgetUI;                                          // 0x05B8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UUnionRaceHitInfoGroup*>         HitInfoGroupUI;                                    // 0x05C8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FUnionRaceHUDPlayerNameUI>      PlayerNameInfoUI;                                  // 0x05D8(0x0010)(BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class URaceUISubPlayerName*>           RivalStartUI;                                      // 0x05E8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<bool>                                  IsComArr;                                          // 0x05F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UURaceUISubItemIconSet*>         WbpItemIconSetArr;                                 // 0x0608(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          IsEnableRedStarRing;                               // 0x0618(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_619[0x7];                                      // 0x0619(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URaceUISubBoost*>                BoostUI;                                           // 0x0620(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	class URaceUISubTimeTrialTime*                TimeTrialTime;                                     // 0x0630(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class URaceUISubTeamHUD*>              TeamHUD;                                           // 0x0638(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          IsRaceGroup;                                       // 0x0648(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEndStateForPauseMenu;                            // 0x0649(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPaused;                                          // 0x064A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64B[0x5];                                      // 0x064B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                PauseMenu;                                         // 0x0650(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_658[0x20];                                     // 0x0658(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAttackItemObject_Implementation(class UObject* InAttackItem);
	void ChangePlayerConntrollerForPauseMenu(int32 PlayerIndex);
	void DbgDrawTeamGaugeData(int32 PlayerControllerIndex);
	void DbgDrawTeamGaugeRate(int32 PlayerControllerIndex, float TransChargeRate, float LocalChargeRate, float GaugePercent, bool IsForce, bool IsBoost);
	void FireAirTrickInfo_Implementation(int32 PlayerControllerIndex, int32 SuccessCount, int32 SuccessBonusCount);
	void FireCourseMapCharaSpin_Implementation(int32 RacerIndex);
	void FireInOutAnim(bool bin, const TDelegate<void()>& OnAnimationEndEvent);
	int32 GetItemHoldCount(int32 PlayerControllerIndex, bool IsMain);
	int32 GetItemHoldCount_New(int32 PlayerControllerIndex, EItemInfoType ItemInfoType);
	void GetItemIconsState(int32 PlayerControllerIndex, EUnionRaceHUDItemIconsState* OutState);
	int32 GetItemPackageRingCount(int32 PlayerControllerIndex, bool IsMain);
	int32 GetItemPackageRingCount_New(int32 PlayerControllerIndex, EItemInfoType ItemInfoType);
	class UUnionRaceUIResultRedStarRings* GetRedStarRings_Implementation(int32 PlayerControllerIndex);
	class UObject* GetReturnDashButtonObject_Implementation(int32 PlayerControllerIndex);
	class UObject* GetStartDashButtonObject_Implementation(int32 PlayerControllerIndex);
	struct FUserGadgetPresetData GetTimeTiralGadgetPresetData();
	bool GetWarningBeltVisible_Implementation(int32 PlayerControllerIndex);
	void HiddenMainRaceUI();
	void HiddenRaceUI();
	void InitCpp();
	bool IsBehindCurrentCamera(const int32 PlayerControllerIndex, const struct FVector& WorldLocation);
	bool IsDebugAimingHidden();
	bool IsDebugBoostHidden();
	bool IsDebugGuideButtonHidden();
	bool IsGhostOnline();
	bool IsPlayingReplay();
	bool IsPubCameraPlayRace();
	bool IsViewGhostReplay();
	void NotifyIrregularInfiniteItem(int32 InRacerIndex);
	void OnPackageRingEffectFinished(class APackageRingEffect* EffectActor);
	void OnPackageRingEffectSoundStart(class APackageRingEffect* EffectActor);
	void OnReadyBeforeCountDown();
	void RemoveAttackInfoWidget_Implementation(class UObject* InAttackItem);
	void SetAfterHomingAimTargetedUIVisible_Implementation(int32 PlayerControllerIndex, bool bVisible);
	void SetAfterHomingAimUIVisible_Implementation(int32 PlayerControllerIndex, bool bVisible);
	void SetAimingUIVisible(bool bVisible);
	void SetAirTrickUIVisible(bool bVisible);
	void SetBeforeHomingAimTargetedUIVisible_Implementation(int32 PlayerControllerIndex, bool bVisible);
	void SetBeforeHomingAimUIVisible_Implementation(int32 PlayerControllerIndex, bool bVisible);
	void SetBoostUIVisible(bool bVisible);
	void SetCharaHeadUIVisible(bool bVisible);
	void SetCourseMapCharaSpin(int32 RacerIndex);
	void SetCourseMapUIVisible(bool bVisible);
	void SetDebugAimingHidden(bool flag);
	void SetDebugBoostHidden(bool flag);
	void SetDebugGuideButtonHidden(bool flag);
	void SetDebugItemWarningHidden(bool flag);
	void SetGadgetIconUIVisible(bool bVisible);
	void SetGuideButtonUIVisible(bool bVisible);
	void SetHitInfoUIVisible(bool bVisible);
	void SetItemIconsState(int32 PlayerControllerIndex, const EUnionRaceHUDItemIconsState& InState);
	void SetItemIconUIVisible(bool bVisible, int32 PlayerControllerIndex, bool bFlagOnly);
	void SetItemIconUIVisibleAll(bool bVisible);
	void SetItemWarningUIVisible(bool bVisible);
	void SetLapUIVisible(bool bVisible);
	void SetRaceMinimapRef_Implementation(class UUnionRaceMinimap* InRaceMinimap);
	void SetRacerApproachInfo(int32 PlayerControllerIndex, const TArray<class URaceUISubApproachWarning*>& ApproachInfo);
	void SetRacerIndex_Implementation(int32 PlayerControllerIndex, int32 InRacerIndex, bool IsLocalPlayer);
	void SetRaceUIVisible(bool bVisible);
	void SetRankUIVisible(bool bVisible);
	void SetRedStarRingUIVisible(bool bVisible);
	void SetReturnDashSetting_Implementation(int32 PlayerControllerIndex, float Pivot, float Range);
	void SetReturnDashUIGaugeRate_Implementation(int32 PlayerControllerIndex, float GaugeRate);
	void SetReturnDashUIVisible_Implementation(int32 PlayerControllerIndex, bool bVisible);
	void SetReturnDashUIVisibleWithAnim_Implementation(int32 PlayerControllerIndex, bool bVisible);
	void SetRingUIVisible(bool bVisible);
	void SetRivalStartUI_Implementation(int32 PlayerControllerIndex, class UUnionRacerStatusObject* RivalStatusObj);
	void SetSpeedNumUIVisible(bool bVisible);
	void SetStartDashButtonUIVisible(const int32 PlayerControllerIndex, const bool bVisible);
	void SetStartDashParamSetting_Implementation(int32 PlayerControllerIndex, const struct FUnionRaceStartDashParam& InStartDashParam);
	void SetStartUIGaugeRate_Implementation(int32 PlayerControllerIndex, float GaugeRate);
	void SetTeamRankUIVisible(bool bVisible);
	void SetTextBalloonUIVisible(bool bVisible);
	void SetWarningBeltVisible_Implementation(int32 PlayerControllerIndex, bool bVisible);
	void UpdateAttackInfoPosition(class UUserWidget* InAttackWidget, class UWidget* InHUDWarningArea, float InPosRate);
	void UpdateByHoldItemInfo_Implementation(int32 PlayerControllerIndex, const struct FHoldItemInfo& InItemInfo);
	void UpdateByRacers_Implementation(class UUnionRacers* InRacers);
	void UpdateHomingAimLocation_Implementation(int32 PlayerControllerIndex, const struct FVector& AimLocation);
	void UpdateHomingAimTargetedLocation_Implementation(int32 PlayerControllerIndex, const struct FVector& PlayerLocation);
	void UpdateIrregularInfiniteItem(int32 PlayerControllerIndex);
	void UpdateIsComSetting(int32 PlayerControllerIndex, bool IsCom);
	void UpdateMinimapIconByRacers_Implementation(class UUnionRacers* InRacers);
	void UpdateRaceHUD(float Delta);
	void UpdateReturnDashButton();
	void UpdateStartDashButton();

	bool IsLocalPlayer(int32 PlayerControllerIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRaceUI">();
	}
	static class UUnionRaceUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRaceUI>();
	}
};
static_assert(alignof(UUnionRaceUI) == 0x000008, "Wrong alignment on UUnionRaceUI");
static_assert(sizeof(UUnionRaceUI) == 0x000678, "Wrong size on UUnionRaceUI");
static_assert(offsetof(UUnionRaceUI, RaceSplitMode) == 0x0002F8, "Member 'UUnionRaceUI::RaceSplitMode' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, RaceMinimap) == 0x000300, "Member 'UUnionRaceUI::RaceMinimap' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, StartTextUI) == 0x000308, "Member 'UUnionRaceUI::StartTextUI' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, JudgeStartUI) == 0x000318, "Member 'UUnionRaceUI::JudgeStartUI' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, JudgeReturnDashUI) == 0x000328, "Member 'UUnionRaceUI::JudgeReturnDashUI' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, FinishTextUI) == 0x000338, "Member 'UUnionRaceUI::FinishTextUI' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, RingCountUI) == 0x000348, "Member 'UUnionRaceUI::RingCountUI' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, LapCountUI) == 0x000358, "Member 'UUnionRaceUI::LapCountUI' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, AimingUI) == 0x000368, "Member 'UUnionRaceUI::AimingUI' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, ItemIconsState) == 0x000378, "Member 'UUnionRaceUI::ItemIconsState' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, ItemIconSet) == 0x000388, "Member 'UUnionRaceUI::ItemIconSet' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, ItemLotterySoundArr) == 0x000398, "Member 'UUnionRaceUI::ItemLotterySoundArr' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, YellowDrillShortTimeSoundArr) == 0x0003A8, "Member 'UUnionRaceUI::YellowDrillShortTimeSoundArr' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, bItemPanelVisibility) == 0x0003B8, "Member 'UUnionRaceUI::bItemPanelVisibility' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, RacerIndex_PlayerIndexMap) == 0x0003C8, "Member 'UUnionRaceUI::RacerIndex_PlayerIndexMap' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, PlayerIndex_RacerIndexMap) == 0x000418, "Member 'UUnionRaceUI::PlayerIndex_RacerIndexMap' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, PackageRingPerformeCount) == 0x000468, "Member 'UUnionRaceUI::PackageRingPerformeCount' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, PackageRingEffects) == 0x000478, "Member 'UUnionRaceUI::PackageRingEffects' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, PackageRingEffectsRemoveReserve) == 0x000488, "Member 'UUnionRaceUI::PackageRingEffectsRemoveReserve' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, PackageRingPerformState) == 0x000498, "Member 'UUnionRaceUI::PackageRingPerformState' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, WarningArea) == 0x0004A8, "Member 'UUnionRaceUI::WarningArea' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, WarningBelt) == 0x0004B8, "Member 'UUnionRaceUI::WarningBelt' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, IsDispOnWarningBelt) == 0x0004C8, "Member 'UUnionRaceUI::IsDispOnWarningBelt' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, WarningBeltMaterial) == 0x0004F0, "Member 'UUnionRaceUI::WarningBeltMaterial' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, AttackObject_WarnigInfoMap) == 0x000500, "Member 'UUnionRaceUI::AttackObject_WarnigInfoMap' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, AttackWarningPerPlayer) == 0x000558, "Member 'UUnionRaceUI::AttackWarningPerPlayer' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, RacerApproachInfo) == 0x000568, "Member 'UUnionRaceUI::RacerApproachInfo' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, PackageRingEffect) == 0x000578, "Member 'UUnionRaceUI::PackageRingEffect' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, HoldItemInfo) == 0x000598, "Member 'UUnionRaceUI::HoldItemInfo' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, AirTrickInfo) == 0x0005A8, "Member 'UUnionRaceUI::AirTrickInfo' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, GadgetUI) == 0x0005B8, "Member 'UUnionRaceUI::GadgetUI' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, HitInfoGroupUI) == 0x0005C8, "Member 'UUnionRaceUI::HitInfoGroupUI' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, PlayerNameInfoUI) == 0x0005D8, "Member 'UUnionRaceUI::PlayerNameInfoUI' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, RivalStartUI) == 0x0005E8, "Member 'UUnionRaceUI::RivalStartUI' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, IsComArr) == 0x0005F8, "Member 'UUnionRaceUI::IsComArr' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, WbpItemIconSetArr) == 0x000608, "Member 'UUnionRaceUI::WbpItemIconSetArr' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, IsEnableRedStarRing) == 0x000618, "Member 'UUnionRaceUI::IsEnableRedStarRing' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, BoostUI) == 0x000620, "Member 'UUnionRaceUI::BoostUI' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, TimeTrialTime) == 0x000630, "Member 'UUnionRaceUI::TimeTrialTime' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, TeamHUD) == 0x000638, "Member 'UUnionRaceUI::TeamHUD' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, IsRaceGroup) == 0x000648, "Member 'UUnionRaceUI::IsRaceGroup' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, IsEndStateForPauseMenu) == 0x000649, "Member 'UUnionRaceUI::IsEndStateForPauseMenu' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, IsPaused) == 0x00064A, "Member 'UUnionRaceUI::IsPaused' has a wrong offset!");
static_assert(offsetof(UUnionRaceUI, PauseMenu) == 0x000650, "Member 'UUnionRaceUI::PauseMenu' has a wrong offset!");

// Class UnionRun.UnionRaceUIBPFL
// 0x0000 (0x0028 - 0x0028)
class UUnionRaceUIBPFL final : public UBlueprintFunctionLibrary
{
public:
	static ERaceItemCategory CalcItemCategory(const EItemId& InItemId);
	static void GetAnchorSettings(float* Dist1, float* Dist2, float* Dist3, float* DisableDist);
	static void GetAttackItemDistSettings(const EUnionAttackItemInfoType& Type, const uint8& InId, float* Dist1, float* Dist2, float* Dist3, float* DisableDist);
	static void GetBlackBombSettings(float* Dist1, float* Dist2, float* Dist3, float* DisableDist);
	static void GetBodyCutSettings(float* Dist1, float* Dist2, float* Dist3, float* DisableDist);
	static void GetDarkChaoSettings(float* Dist1, float* Dist2, float* Dist3, float* DisableDist);
	static void GetHomingPunchSettings(float* Dist1, float* Dist2, float* Dist3, float* DisableDist);
	static void GetKingBoomBooSettings(float* Dist1, float* Dist2, float* Dist3, float* DisableDist);
	static void GetMonsterTruckSettings(float* Dist1, float* Dist2, float* Dist3, float* DisableDist);
	static void GetRacerApproachSettings(float* Dist1, float* Dist2, float* Dist3, float* DisableDist);
	static void GetRocketPunchSettings(float* Dist1, float* Dist2, float* Dist3, float* DisableDist);
	static bool GetSelectorLabelByDriverId(const EDriverId InDriverId, class FString* OutLabel);
	static void GetSlicerSettings(float* Dist1, float* Dist2, float* Dist3, float* DisableDist);
	static void GetSlimeSettings(float* Dist1, float* Dist2, float* Dist3, float* DisableDist);
	static void GetSplashSettings(float* Dist1, float* Dist2, float* Dist3, float* DisableDist);
	static void GetT_RexSettings(float* Dist1, float* Dist2, float* Dist3, float* DisableDist);
	static void GetYellowDrillSettings(float* Dist1, float* Dist2, float* Dist3, float* DisableDist);
	static void HiddenRaceHUD();
	static bool IsAttackWarningItem(const EItemId& InItemId);
	static bool IsDebugAimingHidden();
	static bool IsIgnoreAttackWarningItemUseForBack(const EItemId& InItemId);
	static bool IsRareItemBP(const EItemId& InItemId);
	static void SetAimingHUDVisible(bool bVisible);
	static void SetAirTrickHUDVisible(bool bVisible);
	static void SetBoostHUDVisible(bool bVisible);
	static void SetCharaHeadHUDVisible(bool bVisible);
	static void SetCourseMapHUDVisible(bool bVisible);
	static void SetDebugRaceHUDVisible(bool bVisible);
	static void SetGadgetIconHUDVisible(bool bVisible);
	static void SetGuideButtonHUDVisible(bool bVisible);
	static void SetHitInfoHUDVisible(bool bVisible);
	static void SetItemIconHUDVisible(bool bVisible, int32 PlayerControllerIndex, bool bFlagOnly);
	static void SetItemIconHUDVisibleAll(bool bVisible);
	static void SetItemWarningHUDVisible(bool bVisible);
	static void SetLapHUDVisible(bool bVisible);
	static void SetRaceHUDVisible(bool bVisible);
	static void SetRankHUDVisible(bool bVisible);
	static void SetRedStarRingHUDVisible(bool bVisible);
	static void SetRingHUDVisible(bool bVisible);
	static void SetSpeedNumHUDVisible(bool bVisible);
	static void SetTeamRankHUDVisible(bool bVisible);
	static void SetTextBalloonHUDVisible(bool bVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRaceUIBPFL">();
	}
	static class UUnionRaceUIBPFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRaceUIBPFL>();
	}
};
static_assert(alignof(UUnionRaceUIBPFL) == 0x000008, "Wrong alignment on UUnionRaceUIBPFL");
static_assert(sizeof(UUnionRaceUIBPFL) == 0x000028, "Wrong size on UUnionRaceUIBPFL");

// Class UnionRun.UnionRaceUIFestaReward
// 0x0038 (0x0318 - 0x02E0)
class UUnionRaceUIFestaReward : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACameraActor*                           EventCamera;                                       // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACameraActor*                           EventCamera2;                                      // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USkeletalMesh*>                  RacerModelList;                                    // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Player_TeamIndex;                                  // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MachineOffsetY;                                    // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MachineAddY;                                       // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DestroyFestaResultData();
	EMachineId GetEMachineId(int32 Index_0);
	void GetRacerContributionList(int32 InPlayerRacerIndex, TArray<struct FFestaRacerContribution>* OutFestaRacerContribution);
	void GetUpdatePoint(const TArray<struct FFestaPointRewardUIData>& RewardDataArray, int32 StartIconCount, int32 NowPoint, int32 Add, float* OutIconWindowX, float* OutGagePosi, int32* OutGetRewardIndex);
	void SetupCameraPlayerZoom();
	class ACameraActor* SetupViewBg(const struct FVector& InCameraLocation, const struct FRotator& CameraRotation, bool bIsLightSpawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRaceUIFestaReward">();
	}
	static class UUnionRaceUIFestaReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRaceUIFestaReward>();
	}
};
static_assert(alignof(UUnionRaceUIFestaReward) == 0x000008, "Wrong alignment on UUnionRaceUIFestaReward");
static_assert(sizeof(UUnionRaceUIFestaReward) == 0x000318, "Wrong size on UUnionRaceUIFestaReward");
static_assert(offsetof(UUnionRaceUIFestaReward, EventCamera) == 0x0002E8, "Member 'UUnionRaceUIFestaReward::EventCamera' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIFestaReward, EventCamera2) == 0x0002F0, "Member 'UUnionRaceUIFestaReward::EventCamera2' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIFestaReward, RacerModelList) == 0x0002F8, "Member 'UUnionRaceUIFestaReward::RacerModelList' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIFestaReward, Player_TeamIndex) == 0x000308, "Member 'UUnionRaceUIFestaReward::Player_TeamIndex' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIFestaReward, MachineOffsetY) == 0x00030C, "Member 'UUnionRaceUIFestaReward::MachineOffsetY' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIFestaReward, MachineAddY) == 0x000310, "Member 'UUnionRaceUIFestaReward::MachineAddY' has a wrong offset!");

// Class UnionRun.UnionRaceUIResultLine
// 0x0028 (0x0308 - 0x02E0)
class UUnionRaceUIResultLine : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RacerNameString;                                   // 0x02E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RacerRankIndex;                                    // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLoadingMode;                                    // 0x02FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FD[0x3];                                      // 0x02FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionRacers*                           RacersRef;                                         // 0x0300(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ApplyWaitingAddPoint();
	void PlayAddBonus();
	void PlayBonusPoint(const class FText& BonusName, const class FText& BonusNum);
	void PlayBonusPointClose();
	void PlayCheckMatchPoint(int32 TotalPoint);
	void PlayGetAnimation();
	void PlayLoop1st();
	void PlayPlayerEffect();
	void PlayTotalPoint_Loop_After2nd();
	void SetArrowIndex(int32 ArrowIndex);
	void SetBeforeTotalPointValue(int32 BeforeTotalPoint);
	void SetCharacterId(EDriverId CharaId);
	void SetEarnPointValue(int32 EarnPoint);
	void SetLapTime(float Time);
	void SetLapTimePlus(float Time);
	void SetPlayerIndex(int32 PlayerIndex);
	void SetRacerIndex(int32 Index_0);
	void SetRacerName(const class FText& RacerName);
	void SetRankIndex(int32 RankIndex, bool bIsCheckCrown);
	void SetRankMatchMode();
	void SetTotalPointValue(int32 TotalPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRaceUIResultLine">();
	}
	static class UUnionRaceUIResultLine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRaceUIResultLine>();
	}
};
static_assert(alignof(UUnionRaceUIResultLine) == 0x000008, "Wrong alignment on UUnionRaceUIResultLine");
static_assert(sizeof(UUnionRaceUIResultLine) == 0x000308, "Wrong size on UUnionRaceUIResultLine");
static_assert(offsetof(UUnionRaceUIResultLine, RacerNameString) == 0x0002E8, "Member 'UUnionRaceUIResultLine::RacerNameString' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIResultLine, RacerRankIndex) == 0x0002F8, "Member 'UUnionRaceUIResultLine::RacerRankIndex' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIResultLine, bIsLoadingMode) == 0x0002FC, "Member 'UUnionRaceUIResultLine::bIsLoadingMode' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIResultLine, RacersRef) == 0x000300, "Member 'UUnionRaceUIResultLine::RacersRef' has a wrong offset!");

// Class UnionRun.UnionRaceUIGroupResultLine
// 0x0000 (0x0308 - 0x0308)
class UUnionRaceUIGroupResultLine final : public UUnionRaceUIResultLine
{
public:
	void SetGroupIndex(int32 InGroupIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRaceUIGroupResultLine">();
	}
	static class UUnionRaceUIGroupResultLine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRaceUIGroupResultLine>();
	}
};
static_assert(alignof(UUnionRaceUIGroupResultLine) == 0x000008, "Wrong alignment on UUnionRaceUIGroupResultLine");
static_assert(sizeof(UUnionRaceUIGroupResultLine) == 0x000308, "Wrong size on UUnionRaceUIGroupResultLine");

// Class UnionRun.UnionRaceUIGroupResultScene
// 0x0040 (0x0320 - 0x02E0)
class UUnionRaceUIGroupResultScene : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUnionRaceUIGroupTotalTable*>    GroupTotalTable;                                   // 0x02E8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UUnionRaceUIResultPanel*>        ResultLinesPanel;                                  // 0x02F8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const int32& FinishedResultStateId)> OnResultAnimationFinished;    // 0x0308(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	bool                                          ResultAnimationMoving;                             // 0x0318(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static int32 GetFestaBonusByRacerIndex(int32 RacerIndex);
	static int32 GetFestaBonusByTeamIndex(int32 TeamIndex);
	static EGroupBonusType GetFestaBonusType();
	static void GetFestaResultInfo(const TArray<int32>& TeamPointList, struct FFestaResultInfo* OutInfo, int32 InPlayerRacerIndex, ERaceSettingGrouping RaceSettingGrouping);

	void CalcLinesPanelVisibleByRacerCount();
	EGroupRaceRule GetGroupRaceRule();
	TArray<class UUnionRaceUIResultPanel*> GetResultLinesPanel();
	void PlayLinesPanelAddMoveAnim();
	void PlayLinesPanelInAnim();
	void PlayLinesPanelOutAnimByRacerCount();
	void PlayLinesPanelTotalInAnim();
	void SetLinesPanelRacerCount(int32 RacerCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRaceUIGroupResultScene">();
	}
	static class UUnionRaceUIGroupResultScene* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRaceUIGroupResultScene>();
	}
};
static_assert(alignof(UUnionRaceUIGroupResultScene) == 0x000008, "Wrong alignment on UUnionRaceUIGroupResultScene");
static_assert(sizeof(UUnionRaceUIGroupResultScene) == 0x000320, "Wrong size on UUnionRaceUIGroupResultScene");
static_assert(offsetof(UUnionRaceUIGroupResultScene, GroupTotalTable) == 0x0002E8, "Member 'UUnionRaceUIGroupResultScene::GroupTotalTable' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIGroupResultScene, ResultLinesPanel) == 0x0002F8, "Member 'UUnionRaceUIGroupResultScene::ResultLinesPanel' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIGroupResultScene, OnResultAnimationFinished) == 0x000308, "Member 'UUnionRaceUIGroupResultScene::OnResultAnimationFinished' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIGroupResultScene, ResultAnimationMoving) == 0x000318, "Member 'UUnionRaceUIGroupResultScene::ResultAnimationMoving' has a wrong offset!");

// Class UnionRun.UnionRaceUIGroupTotalTable
// 0x0018 (0x02F8 - 0x02E0)
class UUnionRaceUIGroupTotalTable : public UUserWidget
{
public:
	class UWidgetAnimation*                       GroupResult_Award;                                 // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       Num_Text_In;                                       // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       Num_Text_Loop;                                     // 0x02F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRaceUIGroupTotalTable">();
	}
	static class UUnionRaceUIGroupTotalTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRaceUIGroupTotalTable>();
	}
};
static_assert(alignof(UUnionRaceUIGroupTotalTable) == 0x000008, "Wrong alignment on UUnionRaceUIGroupTotalTable");
static_assert(sizeof(UUnionRaceUIGroupTotalTable) == 0x0002F8, "Wrong size on UUnionRaceUIGroupTotalTable");
static_assert(offsetof(UUnionRaceUIGroupTotalTable, GroupResult_Award) == 0x0002E0, "Member 'UUnionRaceUIGroupTotalTable::GroupResult_Award' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIGroupTotalTable, Num_Text_In) == 0x0002E8, "Member 'UUnionRaceUIGroupTotalTable::Num_Text_In' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIGroupTotalTable, Num_Text_Loop) == 0x0002F0, "Member 'UUnionRaceUIGroupTotalTable::Num_Text_Loop' has a wrong offset!");

// Class UnionRun.UnionRaceUIInterface
// 0x0000 (0x0000 - 0x0000)
class IUnionRaceUIInterface final
{
public:
	void AddAttackItemObject(class UObject* InAttackItem);
	void AddCourseMapActor(class AActor* InAttackItem, EItemId InItemId);
	void AddToHUDAttackInfoWidget(const TArray<class URaceUISubApproachWarning*>& InAttackWidget, const EUnionAttackItemInfoType& InItemType, const uint8& InId);
	void AfterFireManualAimingUI(int32 PlayerControllerIndex);
	void ApplyBoost(int32 PlayerControllerIndex);
	void ApplyJustBoost(int32 PlayerControllerIndex, int32 Level);
	void ChangeRingBoostGaugeToBoost(int32 PlayerControllerIndex);
	void ChangeRingBoostGaugeToNormal(int32 PlayerControllerIndex);
	void CloseSerifWindow();
	void DecideLotteryItem(int32 PlayerControllerIndex, EItemInfoType ItemInfoType, int32 InItemId);
	void DispOffControlGuideFlight(int32 PlayerControllerIndex);
	void DispOffControlItemUse(int32 PlayerControllerIndex);
	void DispOffControlReleaseItemEffect(int32 PlayerControllerIndex);
	void DispOffRaceActionTutorial(int32 PlayerControllerIndex);
	void DispOnControlGuideFlight(int32 PlayerControllerIndex, bool bSuggestUpInput);
	void DispOnControlItemUse(int32 PlayerControllerIndex, EItemId ItemId, bool bIsFever);
	void DispOnControlReleaseItemEffect(int32 PlayerControllerIndex, EItemId ItemId);
	void DispOnInterimReport(int32 PlayerControllerIndex);
	void DispOnRaceActionTutorial(int32 PlayerControllerIndex, ETutorialAction tutorialAction);
	void FireAirTrickInfo(int32 PlayerControllerIndex, int32 SuccessCount, int32 SuccessBonusCount);
	void FireAttackInfo(int32 PlayerControllerIndex, int32 InItemId, int32 AttackedByPlayerControllerIndex);
	void FireAttackItemHitInfo(int32 AttackedByPlayerControllerIndex, const uint8& InItemId, class UUnionRacerStatusObject* AttackToRacerStatusObject);
	void FireAttackItemHitInfo_New(const struct FFireAttackItemInfo& Info);
	void FireCourseMapCharaSpin(int32 RacerIndex);
	void FireFinishText(int32 PlayerControllerIndex);
	void FireInAnimStartUI();
	void FireItemHitInfo(int32 PlayerControllerIndex, int32 InItemId, int32 AttackToPlayerControllerIndex);
	void FireLotteryItem(int32 PlayerControllerIndex, EItemInfoType ItemInfoType, bool bIsSilent);
	void FireStartText(int32 PlayerControllerIndex);
	float GetAimingUIBaseScale();
	EDomainNumber GetCourseMapDomainNumber();
	class UUnionRaceUIResultRedStarRings* GetRedStarRings(int32 PlayerControllerIndex);
	class UObject* GetReturnDashButtonObject(int32 PlayerControllerIndex);
	class UObject* GetStartDashButtonObject(int32 PlayerControllerIndex);
	bool GetWarningBeltVisible(int32 PlayerControllerIndex);
	void LockOnManualAimingUI(int32 PlayerControllerIndex, bool bIsLockOn);
	void NotifyItemCountDownBlink(int32 PlayerControllerIndex, EItemInfoType ItemInfoType);
	void OpenSerifWindow(int32 ScreenIndex, ERacerReactionWindow WindowId, const class FText& TextId, int32 DriverId);
	void OpenSerifWindowEx(int32 ScreenIndex, const struct FRacerReactionVoice& SerifUIData);
	void PlayFestaIndividualChargeEffect(int32 PlayerControllerIndex, int32 RacerIndex);
	void RaceActionTutorialSuccess(int32 PlayerControllerIndex, ETutorialAction tutorialAction);
	void RemoveAttackInfoWidget(class UObject* InAttackItem);
	void RemoveCourseMapActor(class AActor* InAttackItem);
	void SetAfterHomingAimTargetedUIVisible(int32 PlayerControllerIndex, bool bVisible);
	void SetAfterHomingAimUIVisible(int32 PlayerControllerIndex, bool bVisible);
	void SetAttackInfoPosition(class URaceUISubApproachWarning* InAttackWidget, float PosRate, float Distance, int32 PlayerControllerIndex);
	void SetBeforeHomingAimTargetedUIVisible(int32 PlayerControllerIndex, bool bVisible);
	void SetBeforeHomingAimUIVisible(int32 PlayerControllerIndex, bool bVisible);
	void SetCourseSetting(const TSoftObjectPtr<class UObject>& CourseTexture, float OrthoRate, float Angle, const struct FVector& Offset);
	void SetEnableRedStarRing(bool bEnable);
	void SetGadgetIconActive(int32 PlayerControllerIndex, EGadgetId gadget, bool bActive);
	void SetGroupRingNum(int32 PlayerControllerIndex, int32 Num);
	void SetIrregular(int32 PlayerControllerIndex, int32 EventId);
	void SetIrregularInfiniteItem(int32 PlayerControllerIndex, EItemInfoType ItemInfoType, bool bVisible);
	void SetItemId(int32 PlayerControllerIndex, EItemInfoType ItemInfoType, int32 InItemId);
	void SetItemLifeTimeRate(int32 PlayerControllerIndex, EItemInfoType ItemInfoType, float NewRate);
	void SetItemPanelActive(int32 PlayerControllerIndex, bool bActive);
	void SetItemPanelVisible(int32 PlayerControllerIndex, bool bVisible);
	void SetItemRemainCount(int32 PlayerControllerIndex, EItemInfoType ItemInfoType, float RemainCount, float MaxCount);
	void SetManualAimingUIVisible(int32 PlayerControllerIndex, bool bVisible, float Scale, bool IsScaleKeepInHoming);
	void SetMinimapIconItem(const int32& RacerIndex, const EItemId& InItemId);
	void SetMinimapIconType(const int32& RacerIndex, const EMinimapIconType& InMinimapIconType);
	void SetPauseFlag(bool bPause);
	void SetPlayerCount(int32 PlayerCount);
	void SetPlayerName(int32 ScreenIndex, int32 PlayerControllerIndex, const struct FVector2D& ScreenPosition, const class FText& Name_0, bool bIsView);
	void SetPlayerNamePosition(int32 ScreenIndex, int32 PlayerControllerIndex, const struct FVector2D& ScreenPosition, bool bIsView);
	void SetPlayerPlatformIcon(int32 ScreenIndex, int32 PlayerControllerIndex, ECrossplayPlatform InPlatform);
	void SetQuickDriftCharge(int32 PlayerControllerIndex, bool Enable);
	void SetRaceMinimapRef(class UUnionRaceMinimap* InRaceMinimap);
	void SetRacerApproachInfoPosition(float PosRate, float Distance, int32 PlayerControllerIndex, uint8 RankAfterIndex, EDriverId InDriverId);
	void SetRacerApproachInfoVisible(int32 PlayerControllerIndex, uint8 RankAfterIndex, bool bVisible);
	void SetRacerIndex(int32 PlayerControllerIndex, int32 InRacerIndex, bool IsLocalPlayer);
	void SetRankIndex(int32 PlayerControllerIndex, int32 InRankIndex);
	void SetRedStarRingDisp(int32 PlayerControllerIndex, int32 RingIndex);
	void SetReturnDashSetting(int32 PlayerControllerIndex, float Pivot, float Range);
	void SetReturnDashUIGaugeRate(int32 PlayerControllerIndex, float GaugeRate);
	void SetReturnDashUIVisible(int32 PlayerControllerIndex, bool bVisible);
	void SetReturnDashUIVisibleWithAnim(int32 PlayerControllerIndex, bool bVisible);
	void SetRingBoostGaugeBoostPercent(int32 PlayerControllerIndex, float Percent);
	void SetRingBoostGaugeNormalPercent(int32 PlayerControllerIndex, float Percent);
	void SetRingBoostGaugeNormalPercentDirect(int32 PlayerControllerIndex, float Percent);
	void SetRingGroupColor(int32 PlayerControllerIndex, int32 GroupIndex, bool IsGroup, bool IsLocalMulti);
	void SetRingNum(int32 PlayerControllerIndex, int32 InRingNum);
	void SetRivalStartUI(int32 PlayerControllerIndex, class UUnionRacerStatusObject* RivalStatusObj);
	void SetStartDashParamSetting(int32 PlayerControllerIndex, const struct FUnionRaceStartDashParam& InStartDashParam);
	void SetStartUICountText(int32 StartCount);
	void SetStartUIGaugeRate(int32 PlayerControllerIndex, float GaugeRate);
	void SetTimeInfo(int32 PlayerControllerIndex, int32 InMinutes, int32 InSecondes, int32 InMilliSec);
	void SetTimeTrialLapInfo(int32 PlayerControllerIndex, int32 InLapCountNow, int32 InLapCountMax);
	void SettingToHUDAttackInfoWidget(const int32 PlayerControllerIndex, const class URaceUISubApproachWarning* InAttackWidget);
	void SetVisibilityCharge(int32 PlayerControllerIndex, bool Enable);
	void SetVisibilityRank(int32 PlayerControllerIndex, bool Enable);
	void SetWarningBeltVisible(int32 PlayerControllerIndex, bool bVisible);
	void SetWarningItemId(int32 PlayerControllerIndex, int32 InItemId);
	void SetYellowDrillShortTimeSoundEnable(int32 PlayerControllerIndex, bool bEnable);
	void StopLotteryItem(int32 PlayerControllerIndex, EItemInfoType ItemInfoType);
	void UpdateByHoldItemInfo(int32 PlayerControllerIndex, const struct FHoldItemInfo& InItemInfo);
	void UpdateByRacers(class UUnionRacers* InRacers);
	void UpdateCharge(int32 PlayerControllerIndex, int32 Level, float Rate);
	void UpdateHomingAimLocation(int32 PlayerControllerIndex, const struct FVector& AimLocation);
	void UpdateHomingAimTargetedLocation(int32 PlayerControllerIndex, const struct FVector& PlayerLocation);
	void UpdateManualAimingUILocation(int32 PlayerControllerIndex, const struct FVector& Location, const struct FMatrix& Rotation);
	void UpdateMinimapIconByRacers(class UUnionRacers* InRacers);
	void UpdateRank(int32 PlayerControllerIndex, int32 ChangeAmount);
	void UpdateSpeed(int32 PlayerControllerIndex, int32 SpeedKMPH);
	void UpgradeItemMain(int32 PlayerControllerIndex, int32 InItemId);
	void UseItem(int32 PlayerControllerIndex, int32 InItemId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRaceUIInterface">();
	}
	static class IUnionRaceUIInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUnionRaceUIInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IUnionRaceUIInterface) == 0x000001, "Wrong alignment on IUnionRaceUIInterface");
static_assert(sizeof(IUnionRaceUIInterface) == 0x000001, "Wrong size on IUnionRaceUIInterface");

// Class UnionRun.UnionRaceUIResultPanel
// 0x0190 (0x0470 - 0x02E0)
class UUnionRaceUIResultPanel : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUnionRaceUIResultLine*>         RankIndexLine;                                     // 0x02E8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            RacerIndex_RankIndex;                              // 0x02F8(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_348[0x50];                                     // 0x0348(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FPlayerRaceResultData>     RaceResultData;                                    // 0x0398(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<int32, struct FPlayerTotalResultData>    TotalResultData;                                   // 0x03E8(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMCEventBonusData                      MCEventBonusData;                                  // 0x0438(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_448[0x8];                                      // 0x0448(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const int32& FinishedResultStateId)> OnResultAnimationFinished;    // 0x0450(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	bool                                          ResultAnimationMoving;                             // 0x0460(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_461[0x7];                                      // 0x0461(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionRacers*                           RacersRef;                                         // 0x0468(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ApplyWaitingAddPoint(int32 RacerIndex);
	void CloseBonusPoints();
	TArray<class UUnionRaceUIResultLine*> GetRankIndexLine();
	struct FMCEventBonusData InitializeBonusPoints(const struct FMCEventData& EventData);
	void InitializeRaceResult(bool bIsRankMatch, bool bIsRaceCountOne);
	void InitializeResultData(bool bIsTotalDisp);
	void InitializeTotalPoints();
	void PlayGetAnimation(int32 RacerIndex);
	void PlayPlayerEffect(int32 RacerIndex);
	void PlayTotalPoint_Loop_After2nd(int32 RacerIndex);
	void SetArrowIndex(int32 RacerIndex, int32 ArrowIndex);
	void SetCharacterId(int32 RacerIndex, EDriverId CharaId);
	void SetEarnPointValue(int32 RacerIndex, int32 EarnPoint);
	void SetLoadingMode();
	void SetPlayerIndex(int32 RacerIndex, int32 PlayerIndex);
	void SetRacerCount(int32 RacerCount);
	void SetRacerName(int32 RacerIndex, const class FText& RacerName);
	void SetRacersRef(class UUnionRacers* InRacers);
	void SetRankIndex(int32 RacerIndex, int32 RaceRankIndex);
	void SetResultMode();
	bool UpdateTotalRank();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRaceUIResultPanel">();
	}
	static class UUnionRaceUIResultPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRaceUIResultPanel>();
	}
};
static_assert(alignof(UUnionRaceUIResultPanel) == 0x000008, "Wrong alignment on UUnionRaceUIResultPanel");
static_assert(sizeof(UUnionRaceUIResultPanel) == 0x000470, "Wrong size on UUnionRaceUIResultPanel");
static_assert(offsetof(UUnionRaceUIResultPanel, RankIndexLine) == 0x0002E8, "Member 'UUnionRaceUIResultPanel::RankIndexLine' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIResultPanel, RacerIndex_RankIndex) == 0x0002F8, "Member 'UUnionRaceUIResultPanel::RacerIndex_RankIndex' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIResultPanel, RaceResultData) == 0x000398, "Member 'UUnionRaceUIResultPanel::RaceResultData' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIResultPanel, TotalResultData) == 0x0003E8, "Member 'UUnionRaceUIResultPanel::TotalResultData' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIResultPanel, MCEventBonusData) == 0x000438, "Member 'UUnionRaceUIResultPanel::MCEventBonusData' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIResultPanel, OnResultAnimationFinished) == 0x000450, "Member 'UUnionRaceUIResultPanel::OnResultAnimationFinished' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIResultPanel, ResultAnimationMoving) == 0x000460, "Member 'UUnionRaceUIResultPanel::ResultAnimationMoving' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIResultPanel, RacersRef) == 0x000468, "Member 'UUnionRaceUIResultPanel::RacersRef' has a wrong offset!");

// Class UnionRun.UnionRaceUIResultRedStarRing
// 0x0018 (0x02F8 - 0x02E0)
class UUnionRaceUIResultRedStarRing : public UUserWidget
{
public:
	ERedStarRingUIType                            RedStarRingUIType;                                 // 0x02E0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       LastPlayingAnim;                                   // 0x02E8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPickUp;                                          // 0x02F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F1[0x7];                                      // 0x02F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitRing(bool bPickUp);
	void PickUpRing();
	void ResetRing();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRaceUIResultRedStarRing">();
	}
	static class UUnionRaceUIResultRedStarRing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRaceUIResultRedStarRing>();
	}
};
static_assert(alignof(UUnionRaceUIResultRedStarRing) == 0x000008, "Wrong alignment on UUnionRaceUIResultRedStarRing");
static_assert(sizeof(UUnionRaceUIResultRedStarRing) == 0x0002F8, "Wrong size on UUnionRaceUIResultRedStarRing");
static_assert(offsetof(UUnionRaceUIResultRedStarRing, RedStarRingUIType) == 0x0002E0, "Member 'UUnionRaceUIResultRedStarRing::RedStarRingUIType' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIResultRedStarRing, LastPlayingAnim) == 0x0002E8, "Member 'UUnionRaceUIResultRedStarRing::LastPlayingAnim' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIResultRedStarRing, IsPickUp) == 0x0002F0, "Member 'UUnionRaceUIResultRedStarRing::IsPickUp' has a wrong offset!");

// Class UnionRun.UnionRaceUIResultRedStarRings
// 0x0018 (0x02F8 - 0x02E0)
class UUnionRaceUIResultRedStarRings : public UUserWidget
{
public:
	ERedStarRingUIType                            RedStarRingUIType;                                 // 0x02E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUnionRaceUIResultRedStarRing*>  RedStarRings;                                      // 0x02E8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	TArray<ERedStarRingAcquisitionType> GetOtherResultRedStarRingAcquisitionType(const int32 Index_0);
	TArray<ERedStarRingAcquisitionType> GetRaceRedStarRingAcquisitionType();
	TArray<ERedStarRingAcquisitionType> GetResultRedStarRingAcquisitionType(const EStageId InStageId);
	ERedstarRingAllGetType GetResultRedStarRingAllGetType(const TArray<ERedStarRingAcquisitionType>& AcquisitionType, int32 PlayerIndex);
	void InitRings(const TArray<bool>& Rings);
	void PickUpRing(uint8 RingIndex);
	void ResetRings();
	void SetRedStarRingsRef(const TArray<class UUnionRaceUIResultRedStarRing*>& Rings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRaceUIResultRedStarRings">();
	}
	static class UUnionRaceUIResultRedStarRings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRaceUIResultRedStarRings>();
	}
};
static_assert(alignof(UUnionRaceUIResultRedStarRings) == 0x000008, "Wrong alignment on UUnionRaceUIResultRedStarRings");
static_assert(sizeof(UUnionRaceUIResultRedStarRings) == 0x0002F8, "Wrong size on UUnionRaceUIResultRedStarRings");
static_assert(offsetof(UUnionRaceUIResultRedStarRings, RedStarRingUIType) == 0x0002E0, "Member 'UUnionRaceUIResultRedStarRings::RedStarRingUIType' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIResultRedStarRings, RedStarRings) == 0x0002E8, "Member 'UUnionRaceUIResultRedStarRings::RedStarRings' has a wrong offset!");

// Class UnionRun.UnionRaceUIResultScene
// 0x00A8 (0x0388 - 0x02E0)
class UUnionRaceUIResultScene : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionRaceUIResultPanel*                ResultLinesPanel;                                  // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnResultFinished;                                  // 0x02F0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	bool                                          ResultAnimationMoving;                             // 0x0300(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUnionRaceUIResultSceneState                  _State;                                            // 0x0301(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          m_IsEnableGhost;                                   // 0x0302(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_303[0x1];                                      // 0x0303(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimeTrialLapTimes                     m_GhostTime;                                       // 0x0304(0x0040)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FTimeTrialLapTimes                     m_RecordTime;                                      // 0x0344(0x0040)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_384[0x4];                                      // 0x0384(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CalcLinesPanelVisibleByRacerCount();
	class FText GetGhostDiffLapTime(int32 LapNo, bool* OutIsUpTime, bool* OutIsSameTime);
	class FText GetGhostDiffTotalLapTime(bool* OutIsUpTime, bool* OutIsSameTime);
	int32 GetLapTime(int32 LapNo);
	class FText GetLapTimeText(int32 LapNo);
	class UUnionRaceUIResultPanel* GetResultLinesPanel();
	int32 GetTotalLapTime();
	class FText GetTotalLapTimeText();
	bool IsViewDiffLapTime(int32 LapNo);
	void PlayLinesPanelAddMoveAnim();
	void PlayLinesPanelInAnim();
	void PlayLinesPanelOutAnimByRacerCount();
	void PlayLinesPanelTotalInAnim();
	void SetLinesPanelRacerCount(int32 RacerCount);
	void SetupLapTime();

	bool IsEnableGhost() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRaceUIResultScene">();
	}
	static class UUnionRaceUIResultScene* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRaceUIResultScene>();
	}
};
static_assert(alignof(UUnionRaceUIResultScene) == 0x000008, "Wrong alignment on UUnionRaceUIResultScene");
static_assert(sizeof(UUnionRaceUIResultScene) == 0x000388, "Wrong size on UUnionRaceUIResultScene");
static_assert(offsetof(UUnionRaceUIResultScene, ResultLinesPanel) == 0x0002E8, "Member 'UUnionRaceUIResultScene::ResultLinesPanel' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIResultScene, OnResultFinished) == 0x0002F0, "Member 'UUnionRaceUIResultScene::OnResultFinished' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIResultScene, ResultAnimationMoving) == 0x000300, "Member 'UUnionRaceUIResultScene::ResultAnimationMoving' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIResultScene, _State) == 0x000301, "Member 'UUnionRaceUIResultScene::_State' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIResultScene, m_IsEnableGhost) == 0x000302, "Member 'UUnionRaceUIResultScene::m_IsEnableGhost' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIResultScene, m_GhostTime) == 0x000304, "Member 'UUnionRaceUIResultScene::m_GhostTime' has a wrong offset!");
static_assert(offsetof(UUnionRaceUIResultScene, m_RecordTime) == 0x000344, "Member 'UUnionRaceUIResultScene::m_RecordTime' has a wrong offset!");

// Class UnionRun.UnionRaceUIResultUtils
// 0x0000 (0x0028 - 0x0028)
class UUnionRaceUIResultUtils final : public UBlueprintFunctionLibrary
{
public:
	static int32 GetResultParam(const class FString& InParamString);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRaceUIResultUtils">();
	}
	static class UUnionRaceUIResultUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRaceUIResultUtils>();
	}
};
static_assert(alignof(UUnionRaceUIResultUtils) == 0x000008, "Wrong alignment on UUnionRaceUIResultUtils");
static_assert(sizeof(UUnionRaceUIResultUtils) == 0x000028, "Wrong size on UUnionRaceUIResultUtils");

// Class UnionRun.UnionReplayManager
// 0x05A0 (0x05C8 - 0x0028)
class UUnionReplayManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AReplayGhostActor*                      GoastActor;                                        // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x90];                                      // 0x0038(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 m_GhostActor;                                      // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x4F8];                                     // 0x00D0(0x04F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLoadComplete(ESaveDataStatus Status);
	void OnSaveComplete(ESaveDataStatus Status);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionReplayManager">();
	}
	static class UUnionReplayManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionReplayManager>();
	}
};
static_assert(alignof(UUnionReplayManager) == 0x000008, "Wrong alignment on UUnionReplayManager");
static_assert(sizeof(UUnionReplayManager) == 0x0005C8, "Wrong size on UUnionReplayManager");
static_assert(offsetof(UUnionReplayManager, GoastActor) == 0x000030, "Member 'UUnionReplayManager::GoastActor' has a wrong offset!");
static_assert(offsetof(UUnionReplayManager, m_GhostActor) == 0x0000C8, "Member 'UUnionReplayManager::m_GhostActor' has a wrong offset!");

// Class UnionRun.UnionRingInfoInterface
// 0x0000 (0x0000 - 0x0000)
class IUnionRingInfoInterface final
{
public:
	void NoticeTakeRedStarRingEvent(int32 RacerIndex, int32 RingIndex);
	void NoticeTakeRingEvent(int32 RacerIndex, const struct FUnionTakeRingInfo& Info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRingInfoInterface">();
	}
	static class IUnionRingInfoInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUnionRingInfoInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IUnionRingInfoInterface) == 0x000001, "Wrong alignment on IUnionRingInfoInterface");
static_assert(sizeof(IUnionRingInfoInterface) == 0x000001, "Wrong size on IUnionRingInfoInterface");

// Class UnionRun.UnionRingSystemManager
// 0xB328 (0xB350 - 0x0028)
class UUnionRingSystemManager final : public UObject
{
public:
	uint8                                         Pad_28[0xB328];                                    // 0x0028(0xB328)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRingSystemManager">();
	}
	static class UUnionRingSystemManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRingSystemManager>();
	}
};
static_assert(alignof(UUnionRingSystemManager) == 0x000008, "Wrong alignment on UUnionRingSystemManager");
static_assert(sizeof(UUnionRingSystemManager) == 0x00B350, "Wrong size on UUnionRingSystemManager");

// Class UnionRun.UnionRoundTripMoveComponent
// 0x00C8 (0x0168 - 0x00A0)
class UUnionRoundTripMoveComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TemplateID;                                        // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bValidMovement_;                                   // 0x00B4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                startLocation_;                                    // 0x00B8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                endLocation_;                                      // 0x00D0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRoundTripMoveParams                   outboundTripParam_;                                // 0x00E8(0x0014)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRoundTripMoveParams                   returnTripParam_;                                  // 0x00FC(0x0014)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bSnapStartLocationAtStart_;                        // 0x0110(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseLRRayCast_;                                    // 0x0111(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_112[0x2];                                      // 0x0112(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         racCastHeight_;                                    // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         racCastLength_;                                    // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         racCastInnerOffset_;                               // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         startDelay_;                                       // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         startOffsetBySeconds_;                             // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_128[0x40];                                     // 0x0128(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRoundTripMoveComponent">();
	}
	static class UUnionRoundTripMoveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRoundTripMoveComponent>();
	}
};
static_assert(alignof(UUnionRoundTripMoveComponent) == 0x000008, "Wrong alignment on UUnionRoundTripMoveComponent");
static_assert(sizeof(UUnionRoundTripMoveComponent) == 0x000168, "Wrong size on UUnionRoundTripMoveComponent");
static_assert(offsetof(UUnionRoundTripMoveComponent, TemplateID) == 0x0000B0, "Member 'UUnionRoundTripMoveComponent::TemplateID' has a wrong offset!");
static_assert(offsetof(UUnionRoundTripMoveComponent, bValidMovement_) == 0x0000B4, "Member 'UUnionRoundTripMoveComponent::bValidMovement_' has a wrong offset!");
static_assert(offsetof(UUnionRoundTripMoveComponent, startLocation_) == 0x0000B8, "Member 'UUnionRoundTripMoveComponent::startLocation_' has a wrong offset!");
static_assert(offsetof(UUnionRoundTripMoveComponent, endLocation_) == 0x0000D0, "Member 'UUnionRoundTripMoveComponent::endLocation_' has a wrong offset!");
static_assert(offsetof(UUnionRoundTripMoveComponent, outboundTripParam_) == 0x0000E8, "Member 'UUnionRoundTripMoveComponent::outboundTripParam_' has a wrong offset!");
static_assert(offsetof(UUnionRoundTripMoveComponent, returnTripParam_) == 0x0000FC, "Member 'UUnionRoundTripMoveComponent::returnTripParam_' has a wrong offset!");
static_assert(offsetof(UUnionRoundTripMoveComponent, bSnapStartLocationAtStart_) == 0x000110, "Member 'UUnionRoundTripMoveComponent::bSnapStartLocationAtStart_' has a wrong offset!");
static_assert(offsetof(UUnionRoundTripMoveComponent, bUseLRRayCast_) == 0x000111, "Member 'UUnionRoundTripMoveComponent::bUseLRRayCast_' has a wrong offset!");
static_assert(offsetof(UUnionRoundTripMoveComponent, racCastHeight_) == 0x000114, "Member 'UUnionRoundTripMoveComponent::racCastHeight_' has a wrong offset!");
static_assert(offsetof(UUnionRoundTripMoveComponent, racCastLength_) == 0x000118, "Member 'UUnionRoundTripMoveComponent::racCastLength_' has a wrong offset!");
static_assert(offsetof(UUnionRoundTripMoveComponent, racCastInnerOffset_) == 0x00011C, "Member 'UUnionRoundTripMoveComponent::racCastInnerOffset_' has a wrong offset!");
static_assert(offsetof(UUnionRoundTripMoveComponent, startDelay_) == 0x000120, "Member 'UUnionRoundTripMoveComponent::startDelay_' has a wrong offset!");
static_assert(offsetof(UUnionRoundTripMoveComponent, startOffsetBySeconds_) == 0x000124, "Member 'UUnionRoundTripMoveComponent::startOffsetBySeconds_' has a wrong offset!");

// Class UnionRun.UnionRunDebugBPFL
// 0x0000 (0x0028 - 0x0028)
class UUnionRunDebugBPFL final : public UBlueprintFunctionLibrary
{
public:
	static void ForceGoalRacerOnce();
	static void ForceGoalRacerWithoutLocalPlayer();
	static bool IsForcedCom(const int32 InRacerIndex);
	static void RegisterAttackItemDevOnly(class UObject* InObject);
	static void RemoveAttackItemDevOnly(class UObject* InObject);
	static void SwitchComStopMove();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRunDebugBPFL">();
	}
	static class UUnionRunDebugBPFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRunDebugBPFL>();
	}
};
static_assert(alignof(UUnionRunDebugBPFL) == 0x000008, "Wrong alignment on UUnionRunDebugBPFL");
static_assert(sizeof(UUnionRunDebugBPFL) == 0x000028, "Wrong size on UUnionRunDebugBPFL");

// Class UnionRun.UnionRunDebugPacketReplay
// 0x0000 (0x0028 - 0x0028)
class UUnionRunDebugPacketReplay final : public UBlueprintFunctionLibrary
{
public:
	static void GetOnlineRaceReplayData(TArray<uint8>* Data);
	static int32 LoadOnlineRaceReplay(struct FOnlineRaceReplay* RaceReplayData);
	static void SetOnlineRaceReplay(struct FOnlineRaceReplay* RaceReplayData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRunDebugPacketReplay">();
	}
	static class UUnionRunDebugPacketReplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRunDebugPacketReplay>();
	}
};
static_assert(alignof(UUnionRunDebugPacketReplay) == 0x000008, "Wrong alignment on UUnionRunDebugPacketReplay");
static_assert(sizeof(UUnionRunDebugPacketReplay) == 0x000028, "Wrong size on UUnionRunDebugPacketReplay");

// Class UnionRun.UnionRunPathBinaryDataAsset
// 0x0010 (0x0038 - 0x0028)
class UUnionRunPathBinaryDataAsset final : public UObject
{
public:
	TArray<uint8>                                 RawData;                                           // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRunPathBinaryDataAsset">();
	}
	static class UUnionRunPathBinaryDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRunPathBinaryDataAsset>();
	}
};
static_assert(alignof(UUnionRunPathBinaryDataAsset) == 0x000008, "Wrong alignment on UUnionRunPathBinaryDataAsset");
static_assert(sizeof(UUnionRunPathBinaryDataAsset) == 0x000038, "Wrong size on UUnionRunPathBinaryDataAsset");
static_assert(offsetof(UUnionRunPathBinaryDataAsset, RawData) == 0x000028, "Member 'UUnionRunPathBinaryDataAsset::RawData' has a wrong offset!");

// Class UnionRun.UnionSplineActor
// 0x0088 (0x03C8 - 0x0340)
class AUnionSplineActor final : public AUnionCourseObjectBase
{
public:
	class UUnionSplineComponent*                  Spline;                                            // 0x0340(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCoursePathCreateParams                CoursePathCreateParam;                             // 0x0348(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x03C0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionSplineActor">();
	}
	static class AUnionSplineActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnionSplineActor>();
	}
};
static_assert(alignof(AUnionSplineActor) == 0x000008, "Wrong alignment on AUnionSplineActor");
static_assert(sizeof(AUnionSplineActor) == 0x0003C8, "Wrong size on AUnionSplineActor");
static_assert(offsetof(AUnionSplineActor, Spline) == 0x000340, "Member 'AUnionSplineActor::Spline' has a wrong offset!");
static_assert(offsetof(AUnionSplineActor, CoursePathCreateParam) == 0x000348, "Member 'AUnionSplineActor::CoursePathCreateParam' has a wrong offset!");
static_assert(offsetof(AUnionSplineActor, DefaultSceneRoot) == 0x0003C0, "Member 'AUnionSplineActor::DefaultSceneRoot' has a wrong offset!");

// Class UnionRun.UnionSplineComponent
// 0x0090 (0x06B0 - 0x0620)
class UUnionSplineComponent final : public USplineComponent
{
public:
	TArray<struct FSplinePointParam>              _PointParam;                                       // 0x0618(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         _SplineLength;                                     // 0x0628(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EUnionSplineType                              _SplineType;                                       // 0x062C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62D[0x3];                                      // 0x062D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSplineParam                           _SplineParam;                                      // 0x0630(0x0014)(Edit, BlueprintVisible, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	int32                                         _RouteIndex;                                       // 0x0644(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bEnableBranch;                                    // 0x0648(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bOverrideBranchStartPath;                         // 0x0649(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64A[0x6];                                      // 0x064A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _BranchStartPath;                                  // 0x0650(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bOverrideConnectStartPointIndex;                  // 0x0658(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_659[0x3];                                      // 0x0659(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _ConnectStartPointIndex;                           // 0x065C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bOverrideBranchEndPath;                           // 0x0660(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_661[0x7];                                      // 0x0661(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _BranchEndPath;                                    // 0x0668(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bOverrideConnectEndPointIndex;                    // 0x0670(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_671[0x3];                                      // 0x0671(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _ConnectEndPointIndex;                             // 0x0674(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _RemoveBeforeIndex;                                // 0x0678(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _RemoveAfterIndex;                                 // 0x067C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _branchStartLocation;                              // 0x0680(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _branchEndLocation;                                // 0x0698(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void GetCurrentLocationAndRotation(float Length, bool bLoop, struct FVector* OutLocation, struct FVector* OutDirection, struct FRotator* OutRotation);
	bool GetSplineParamByArrayIndex(int32 ArrayIndex, struct FSplinePointParam* returnParam);
	bool GetSplineParamByIndex(int32 PointIndex, struct FSplinePointParam* returnParam);
	void InitSplinePointParam(const TArray<struct FSplinePointParam>& SplineParamArray);
	void PointParamUpdate();
	void PrePointParamUpdate(int32 RouteIndex, int32 StartPointIndex);
	void RemovePointAfterIndex();
	void RemovePointBeforeIndex();
	void RemovePointByIndex(const TArray<int32>& RemoveIndex);
	void RemovePointByPointIndex(int32 RemovePointIndex);
	void UpdateBranchLocation();

	EUnionSplineType GetSplineType() const;
	bool IsArrived(float Length) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionSplineComponent">();
	}
	static class UUnionSplineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionSplineComponent>();
	}
};
static_assert(alignof(UUnionSplineComponent) == 0x000010, "Wrong alignment on UUnionSplineComponent");
static_assert(sizeof(UUnionSplineComponent) == 0x0006B0, "Wrong size on UUnionSplineComponent");
static_assert(offsetof(UUnionSplineComponent, _PointParam) == 0x000618, "Member 'UUnionSplineComponent::_PointParam' has a wrong offset!");
static_assert(offsetof(UUnionSplineComponent, _SplineLength) == 0x000628, "Member 'UUnionSplineComponent::_SplineLength' has a wrong offset!");
static_assert(offsetof(UUnionSplineComponent, _SplineType) == 0x00062C, "Member 'UUnionSplineComponent::_SplineType' has a wrong offset!");
static_assert(offsetof(UUnionSplineComponent, _SplineParam) == 0x000630, "Member 'UUnionSplineComponent::_SplineParam' has a wrong offset!");
static_assert(offsetof(UUnionSplineComponent, _RouteIndex) == 0x000644, "Member 'UUnionSplineComponent::_RouteIndex' has a wrong offset!");
static_assert(offsetof(UUnionSplineComponent, _bEnableBranch) == 0x000648, "Member 'UUnionSplineComponent::_bEnableBranch' has a wrong offset!");
static_assert(offsetof(UUnionSplineComponent, _bOverrideBranchStartPath) == 0x000649, "Member 'UUnionSplineComponent::_bOverrideBranchStartPath' has a wrong offset!");
static_assert(offsetof(UUnionSplineComponent, _BranchStartPath) == 0x000650, "Member 'UUnionSplineComponent::_BranchStartPath' has a wrong offset!");
static_assert(offsetof(UUnionSplineComponent, _bOverrideConnectStartPointIndex) == 0x000658, "Member 'UUnionSplineComponent::_bOverrideConnectStartPointIndex' has a wrong offset!");
static_assert(offsetof(UUnionSplineComponent, _ConnectStartPointIndex) == 0x00065C, "Member 'UUnionSplineComponent::_ConnectStartPointIndex' has a wrong offset!");
static_assert(offsetof(UUnionSplineComponent, _bOverrideBranchEndPath) == 0x000660, "Member 'UUnionSplineComponent::_bOverrideBranchEndPath' has a wrong offset!");
static_assert(offsetof(UUnionSplineComponent, _BranchEndPath) == 0x000668, "Member 'UUnionSplineComponent::_BranchEndPath' has a wrong offset!");
static_assert(offsetof(UUnionSplineComponent, _bOverrideConnectEndPointIndex) == 0x000670, "Member 'UUnionSplineComponent::_bOverrideConnectEndPointIndex' has a wrong offset!");
static_assert(offsetof(UUnionSplineComponent, _ConnectEndPointIndex) == 0x000674, "Member 'UUnionSplineComponent::_ConnectEndPointIndex' has a wrong offset!");
static_assert(offsetof(UUnionSplineComponent, _RemoveBeforeIndex) == 0x000678, "Member 'UUnionSplineComponent::_RemoveBeforeIndex' has a wrong offset!");
static_assert(offsetof(UUnionSplineComponent, _RemoveAfterIndex) == 0x00067C, "Member 'UUnionSplineComponent::_RemoveAfterIndex' has a wrong offset!");
static_assert(offsetof(UUnionSplineComponent, _branchStartLocation) == 0x000680, "Member 'UUnionSplineComponent::_branchStartLocation' has a wrong offset!");
static_assert(offsetof(UUnionSplineComponent, _branchEndLocation) == 0x000698, "Member 'UUnionSplineComponent::_branchEndLocation' has a wrong offset!");

// Class UnionRun.UnionSplineMoveComponent
// 0x0140 (0x01E0 - 0x00A0)
class alignas(0x10) UUnionSplineMoveComponent final : public UActorComponent
{
public:
	float                                         MoveDistance;                                      // 0x00A0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReverse;                                          // 0x00A4(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPause;                                            // 0x00A5(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A6[0x2];                                       // 0x00A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionSplineComponent*                  Spline;                                            // 0x00A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReverseRot;                                       // 0x00B0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KeyMoveSpeed;                                      // 0x00B4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceMove;                                        // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSplineMoveSettingParam                SettingParam;                                      // 0x00C0(0x0068)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0xB8];                                     // 0x0128(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddMoveDistance(float AddDistance);
	void ForceMove();
	void ForceReverse(bool RotReverse);
	bool IsArrived();
	bool IsOverSplineMoveRate(float checkRate);
	bool IsStartWait(float DeltaTime);
	bool IsValidSpline();
	void MoveReset(bool ForceMove);
	void MoveUpdate(float DeltaTime, bool IsTransform);
	void SetLoopType(ESplineMoveLoopType LoopType);
	void SetMoveDistance(float NewDistance);
	void SetSpline(class UUnionSplineComponent* NewSpline);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionSplineMoveComponent">();
	}
	static class UUnionSplineMoveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionSplineMoveComponent>();
	}
};
static_assert(alignof(UUnionSplineMoveComponent) == 0x000010, "Wrong alignment on UUnionSplineMoveComponent");
static_assert(sizeof(UUnionSplineMoveComponent) == 0x0001E0, "Wrong size on UUnionSplineMoveComponent");
static_assert(offsetof(UUnionSplineMoveComponent, MoveDistance) == 0x0000A0, "Member 'UUnionSplineMoveComponent::MoveDistance' has a wrong offset!");
static_assert(offsetof(UUnionSplineMoveComponent, bReverse) == 0x0000A4, "Member 'UUnionSplineMoveComponent::bReverse' has a wrong offset!");
static_assert(offsetof(UUnionSplineMoveComponent, bPause) == 0x0000A5, "Member 'UUnionSplineMoveComponent::bPause' has a wrong offset!");
static_assert(offsetof(UUnionSplineMoveComponent, Spline) == 0x0000A8, "Member 'UUnionSplineMoveComponent::Spline' has a wrong offset!");
static_assert(offsetof(UUnionSplineMoveComponent, bReverseRot) == 0x0000B0, "Member 'UUnionSplineMoveComponent::bReverseRot' has a wrong offset!");
static_assert(offsetof(UUnionSplineMoveComponent, KeyMoveSpeed) == 0x0000B4, "Member 'UUnionSplineMoveComponent::KeyMoveSpeed' has a wrong offset!");
static_assert(offsetof(UUnionSplineMoveComponent, bForceMove) == 0x0000B8, "Member 'UUnionSplineMoveComponent::bForceMove' has a wrong offset!");
static_assert(offsetof(UUnionSplineMoveComponent, SettingParam) == 0x0000C0, "Member 'UUnionSplineMoveComponent::SettingParam' has a wrong offset!");

// Class UnionRun.UnionSwingCameraParams
// 0x05E0 (0x0610 - 0x0030)
class UUnionSwingCameraParams final : public UDataAsset
{
public:
	struct FSwingCameraStagePreset                AllStageParams[0x5E];                              // 0x0030(0x0010)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionSwingCameraParams">();
	}
	static class UUnionSwingCameraParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionSwingCameraParams>();
	}
};
static_assert(alignof(UUnionSwingCameraParams) == 0x000008, "Wrong alignment on UUnionSwingCameraParams");
static_assert(sizeof(UUnionSwingCameraParams) == 0x000610, "Wrong size on UUnionSwingCameraParams");
static_assert(offsetof(UUnionSwingCameraParams, AllStageParams) == 0x000030, "Member 'UUnionSwingCameraParams::AllStageParams' has a wrong offset!");

// Class UnionRun.UnionUcccLibrary
// 0x0000 (0x0028 - 0x0028)
class UUnionUcccLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FCommon_UserCheatParamData GetUserUcccParamData(int32 OnlineRacerIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionUcccLibrary">();
	}
	static class UUnionUcccLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionUcccLibrary>();
	}
};
static_assert(alignof(UUnionUcccLibrary) == 0x000008, "Wrong alignment on UUnionUcccLibrary");
static_assert(sizeof(UUnionUcccLibrary) == 0x000028, "Wrong size on UUnionUcccLibrary");

// Class UnionRun.UnionVehicleRaceObjectInterface
// 0x0000 (0x0000 - 0x0000)
class IUnionVehicleRaceObjectInterface final
{
public:
	void ActivateCameraIF(bool bActivate);
	void AddInputRecieveObject(class UObject* InObjectRef);
	void BeginInitialize();
	void BeginWaitInitialize();
	void ChangeMiniMode();
	void ChangeMonsterTruckMode();
	void ChangeNomalMode();
	void ExecVehicleControlEventAttackedInfo(EVehicleControlEvent EventId, const struct FAttackedInfo& Value);
	void ExecVehicleControlEventFloat(EVehicleControlEvent EventId, float Value);
	void ExecVehicleControlEventInt(EVehicleControlEvent EventId, int32 Value);
	void ExecVehicleControlEventSpecialStatus(EVehicleSpecialStatusEvent EventId, const EVehicleSpecialStatusType Value);
	void GetActiveItemPerfomanceObjects(TArray<class AActor*>* OutList);
	class AActor* GetDrone();
	void RemoveInputRecieveObject(class UObject* InObjectRef);
	void SetCockpitMeshSize(float NewSize);
	void SetLightChannel(int32 LightChannel);
	void SetLoadSkipForMonster(bool bSkip);
	void SetRacerIndex(const int32& NewIndex);
	void SetRacerStatusObject(class UUnionRacerStatusObject* NewObject);
	void SetVehicleDisplayMode(EVehicleDisplayMode NewVehicleDisplayMode);
	void SetVehicleMeshVisibility(bool NewVisibility, bool bRootCockpitComponent);
	class USoundAtomCue* SetVehicleSound(EVehicleSound VehicleSound, class USoundAtomCue* NewSound);
	class USoundAtomCue* SetVehicleSurfaceTypeSound(EVehicleSound VehicleSound, EUnionSurfaceType SurfaceType, class USoundAtomCue* NewSound);
	void SetVisibilityMachineBody(bool NewVisible);
	void UpdateLocalPlayerSetting(const int32& PlayerControllerIndex, const int32& LocalPlayerCount);

	EUnionSurfaceType GetCurrentSurfaceType() const;
	int32 GetRacerIndex() const;
	bool IsInAir() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionVehicleRaceObjectInterface">();
	}
	static class IUnionVehicleRaceObjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUnionVehicleRaceObjectInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IUnionVehicleRaceObjectInterface) == 0x000001, "Wrong alignment on IUnionVehicleRaceObjectInterface");
static_assert(sizeof(IUnionVehicleRaceObjectInterface) == 0x000001, "Wrong size on IUnionVehicleRaceObjectInterface");

// Class UnionRun.UnionVehicleModelInfo
// 0x0338 (0x0360 - 0x0028)
class UUnionVehicleModelInfo final : public UObject
{
public:
	struct FVector                                m_RootDomainPosition;                              // 0x0028(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMatrix                                m_RootDomainRotation;                              // 0x0040(0x0080)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        m_WheelDomainPosition;                             // 0x00C0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMatrix>                        m_WheelDomainRotation;                             // 0x00D0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        m_SuspArmDomainPosition;                           // 0x00E0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMatrix>                        m_SuspArmDomainRotation;                           // 0x00F0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         TireCount;                                         // 0x0100(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitTire;                                         // 0x0104(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_105[0x3];                                      // 0x0105(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Steering;                                          // 0x0108(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SteeringLR;                                        // 0x010C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionSteerRate;                                 // 0x0110(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pitch;                                             // 0x0114(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Accel;                                             // 0x0118(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Brake;                                             // 0x011C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EngineRPM;                                         // 0x0120(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EngineMaxRPM;                                      // 0x0124(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GearPosition;                                      // 0x0128(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedMPH;                                          // 0x012C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedKPH;                                          // 0x0130(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyG;                                             // 0x0134(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyGd;                                            // 0x0138(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyGr;                                            // 0x013C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyHitStrengthRateVsForward;                      // 0x0140(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyHitStrengthRateVsLeft;                         // 0x0144(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInDriftState;                                    // 0x0148(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInSpinDriftState;                                // 0x0149(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DriftStart;                                        // 0x014A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DriftEnd;                                          // 0x014B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DriftSwitch;                                       // 0x014C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DriftNoStartButtonOn;                              // 0x014D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DriftStartButtonOn;                                // 0x014E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DriftLeft;                                         // 0x014F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DriftRight;                                        // 0x0150(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x3];                                      // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChargeRate;                                        // 0x0154(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoostCharge_Drift_Stage_1;                         // 0x0158(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoostCharge_Drift_Stage_2;                         // 0x0159(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoostCharge_Drift_Stage_3;                         // 0x015A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoostCharge_Drift_Stage_4;                         // 0x015B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInBoost;                                         // 0x015C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoostStart_Stage_1;                                // 0x015D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoostStart_Stage_2;                                // 0x015E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoostStart_Stage_3;                                // 0x015F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoostStart_Stage_4;                                // 0x0160(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoostStart_Stage_5;                                // 0x0161(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoostStart_Stage_6;                                // 0x0162(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoostStart;                                        // 0x0163(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoostEnd;                                          // 0x0164(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Boost_StartLine;                                   // 0x0165(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Boost_Drift;                                       // 0x0166(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Boost_PickUp;                                      // 0x0167(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Boost_Pad;                                         // 0x0168(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Boost_PadOn;                                       // 0x0169(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Boost_Stunt;                                       // 0x016A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Boost_Skim;                                        // 0x016B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Boost_SlingShot;                                   // 0x016C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Boost_SlingshotBoostPad;                           // 0x016D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Boost_WhiteBoost;                                  // 0x016E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Boost_BouncyJump;                                  // 0x016F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Boost_GroupEnergy;                                 // 0x0170(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Boost_GadgetTouch;                                 // 0x0171(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Boost_FriendTouch;                                 // 0x0172(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Boost_Pad_Special;                                 // 0x0173(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Gadget_SwitchQuickCharge;                          // 0x0174(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInSpin;                                          // 0x0175(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SpinStart;                                         // 0x0176(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SpinEnd;                                           // 0x0177(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Landing;                                           // 0x0178(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CrouchOn;                                          // 0x0179(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HitTrackWall;                                      // 0x017A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HitTrackWallLeft;                                  // 0x017B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HitTrackWallRight;                                 // 0x017C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StartDash_Success_1;                               // 0x017D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StartDash_Success_2;                               // 0x017E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StartDash_Success_3;                               // 0x017F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StartDash_Failure;                                 // 0x0180(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0x3];                                      // 0x0181(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartDashChargeAmount;                             // 0x0184(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoostPad;                                          // 0x0188(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReactionPunch;                                     // 0x0189(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18A[0x2];                                      // 0x018A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DriftLevel;                                        // 0x018C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BoostLevel;                                        // 0x0190(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SpinLeft;                                          // 0x0194(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SpinRight;                                         // 0x0195(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HitFront;                                          // 0x0196(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HitRear;                                           // 0x0197(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HitLeft;                                           // 0x0198(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HitRight;                                          // 0x0199(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSquashed;                                        // 0x019A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SquashedStart;                                     // 0x019B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SquashedEnd;                                       // 0x019C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19D[0x3];                                      // 0x019D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SquashedFrame;                                     // 0x01A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReactionForward;                                   // 0x01A4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReactionBack;                                      // 0x01A5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A6[0x2];                                      // 0x01A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReactionVsOtherMachineStartingGrid;                // 0x01A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInSlipstream;                                    // 0x01AC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AD[0x3];                                      // 0x01AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpinFrame;                                         // 0x01B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInGuidedJump;                                    // 0x01B4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnGuidedJump;                                      // 0x01B5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInBouncyJump;                                    // 0x01B6(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TrickFlipFront;                                    // 0x01B7(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TrickFlipBack;                                     // 0x01B8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TrickFlipLeft;                                     // 0x01B9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TrickFlipRight;                                    // 0x01BA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TrickSpinLeft;                                     // 0x01BB(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TrickSpinRight;                                    // 0x01BC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TrickCorkscrewLeft;                                // 0x01BD(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TrickCorkscrewRight;                               // 0x01BE(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BarrelRollLeft;                                    // 0x01BF(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BarrelRollRight;                                   // 0x01C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TrickCancel;                                       // 0x01C1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TrickMissed;                                       // 0x01C2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C3[0x1];                                      // 0x01C3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TrickEndCountOn;                                   // 0x01C4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TrickEndCount;                                     // 0x01C8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrickMotionPlayTimeSec;                            // 0x01CC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RunoffDecelerationDisabled;                        // 0x01D0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DashEffect_IsInRed;                                // 0x01D1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DashEffect_IsInPink;                               // 0x01D2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DashEffect_IsInBlue;                               // 0x01D3(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DashEffect_IsInRainbow;                            // 0x01D4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DashEffect_RedOn;                                  // 0x01D5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DashEffect_RedOff;                                 // 0x01D6(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DashEffect_PinkOn;                                 // 0x01D7(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DashEffect_PinkOff;                                // 0x01D8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DashEffect_BlueOn;                                 // 0x01D9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DashEffect_BlueOff;                                // 0x01DA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DashEffect_RainbowOn;                              // 0x01DB(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DashEffect_RainbowOff;                             // 0x01DC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DashEffect_IsInRing;                               // 0x01DD(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DashEffect_RingOn;                                 // 0x01DE(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DashEffect_RingOff;                                // 0x01DF(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DashEffect_IsInWhiteBoost;                         // 0x01E0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DashEffect_WhiteBoostOn;                           // 0x01E1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DashEffect_WhiteBoostOff;                          // 0x01E2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DashEffect_IsInKingWhiteBoost;                     // 0x01E3(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DashEffect_KingWhiteBoostOn;                       // 0x01E4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DashEffect_KingWhiteBoostOff;                      // 0x01E5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DashEffect_IsSplashBoost;                          // 0x01E6(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DashEffect_SplashBoostOn;                          // 0x01E7(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DashEffect_SplashBoostOff;                         // 0x01E8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DashEffect_IsAirtrickDash;                         // 0x01E9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DashEffect_IsAirtrickDashOn;                       // 0x01EA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DashEffect_IsAirtrickDashOff;                      // 0x01EB(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MachineForm_Car;                                   // 0x01EC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MachineForm_Boat;                                  // 0x01ED(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MachineForm_Plane;                                 // 0x01EE(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MachineForm_Hover;                                 // 0x01EF(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MachineForm_YellowDrill;                           // 0x01F0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MachineForm_MonsterTruck;                          // 0x01F1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MachineForm_CyanLaser;                             // 0x01F2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DriveForm_Car;                                     // 0x01F3(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DriveForm_Boat;                                    // 0x01F4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DriveForm_Plane;                                   // 0x01F5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DriveForm_Drill;                                   // 0x01F6(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DriveForm_Laser;                                   // 0x01F7(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DriveForm_Warp;                                    // 0x01F8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TravelRingInvincible;                              // 0x01F9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TravelRingFollowingBoostLow;                       // 0x01FA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TravelRingFollowingBoostHigh;                      // 0x01FB(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TravelRingPPOn;                                    // 0x01FC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD[0x3];                                      // 0x01FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TravelRingPPRate;                                  // 0x0200(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TravelRingWhiteOutOn;                              // 0x0204(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TravelRingCubemapWhiteOutOn;                       // 0x0205(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_206[0x2];                                      // 0x0206(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TravelRingCubemapWhiteOutRate;                     // 0x0208(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShortcutRingStg1503;                               // 0x020C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          GoalOn;                                            // 0x0210(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TimeoutOn;                                         // 0x0211(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_212[0x2];                                      // 0x0212(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AllTireFloatingTime;                               // 0x0214(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPlaneBoundaryValid;                              // 0x0218(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_219[0x3];                                      // 0x0219(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlaneBoundarySizeRate;                             // 0x021C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlaneBoundaryPosition;                             // 0x0220(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatrix                                PlaneBoundaryRotation;                             // 0x0240(0x0080)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EResultCameraProductionType                   ForceResultCameraProductionType;                   // 0x02C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPlayBlizzardSound;                               // 0x02C1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C2[0x2];                                      // 0x02C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlizzardSoundParam;                                // 0x02C4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x38];                                     // 0x02C8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUnionTyreMarkInfo>             TyreMarkInfo;                                      // 0x0300(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_310[0x28];                                     // 0x0310(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 m_TireRadiusCM;                                    // 0x0338(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<bool>                                  HitMonsterTruckTire;                               // 0x0348(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetRootDomainPosition(struct FVector* OutRootDomainPosition);
	void GetRootDomainRotation(struct FQuat* OutRootDomainRotation);
	void InitTire(int32 InTireCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionVehicleModelInfo">();
	}
	static class UUnionVehicleModelInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionVehicleModelInfo>();
	}
};
static_assert(alignof(UUnionVehicleModelInfo) == 0x000010, "Wrong alignment on UUnionVehicleModelInfo");
static_assert(sizeof(UUnionVehicleModelInfo) == 0x000360, "Wrong size on UUnionVehicleModelInfo");
static_assert(offsetof(UUnionVehicleModelInfo, m_RootDomainPosition) == 0x000028, "Member 'UUnionVehicleModelInfo::m_RootDomainPosition' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, m_RootDomainRotation) == 0x000040, "Member 'UUnionVehicleModelInfo::m_RootDomainRotation' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, m_WheelDomainPosition) == 0x0000C0, "Member 'UUnionVehicleModelInfo::m_WheelDomainPosition' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, m_WheelDomainRotation) == 0x0000D0, "Member 'UUnionVehicleModelInfo::m_WheelDomainRotation' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, m_SuspArmDomainPosition) == 0x0000E0, "Member 'UUnionVehicleModelInfo::m_SuspArmDomainPosition' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, m_SuspArmDomainRotation) == 0x0000F0, "Member 'UUnionVehicleModelInfo::m_SuspArmDomainRotation' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, TireCount) == 0x000100, "Member 'UUnionVehicleModelInfo::TireCount' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, bInitTire) == 0x000104, "Member 'UUnionVehicleModelInfo::bInitTire' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, Steering) == 0x000108, "Member 'UUnionVehicleModelInfo::Steering' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, SteeringLR) == 0x00010C, "Member 'UUnionVehicleModelInfo::SteeringLR' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, AdditionSteerRate) == 0x000110, "Member 'UUnionVehicleModelInfo::AdditionSteerRate' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, Pitch) == 0x000114, "Member 'UUnionVehicleModelInfo::Pitch' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, Accel) == 0x000118, "Member 'UUnionVehicleModelInfo::Accel' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, Brake) == 0x00011C, "Member 'UUnionVehicleModelInfo::Brake' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, EngineRPM) == 0x000120, "Member 'UUnionVehicleModelInfo::EngineRPM' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, EngineMaxRPM) == 0x000124, "Member 'UUnionVehicleModelInfo::EngineMaxRPM' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, GearPosition) == 0x000128, "Member 'UUnionVehicleModelInfo::GearPosition' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, SpeedMPH) == 0x00012C, "Member 'UUnionVehicleModelInfo::SpeedMPH' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, SpeedKPH) == 0x000130, "Member 'UUnionVehicleModelInfo::SpeedKPH' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, BodyG) == 0x000134, "Member 'UUnionVehicleModelInfo::BodyG' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, BodyGd) == 0x000138, "Member 'UUnionVehicleModelInfo::BodyGd' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, BodyGr) == 0x00013C, "Member 'UUnionVehicleModelInfo::BodyGr' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, BodyHitStrengthRateVsForward) == 0x000140, "Member 'UUnionVehicleModelInfo::BodyHitStrengthRateVsForward' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, BodyHitStrengthRateVsLeft) == 0x000144, "Member 'UUnionVehicleModelInfo::BodyHitStrengthRateVsLeft' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, IsInDriftState) == 0x000148, "Member 'UUnionVehicleModelInfo::IsInDriftState' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, IsInSpinDriftState) == 0x000149, "Member 'UUnionVehicleModelInfo::IsInSpinDriftState' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DriftStart) == 0x00014A, "Member 'UUnionVehicleModelInfo::DriftStart' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DriftEnd) == 0x00014B, "Member 'UUnionVehicleModelInfo::DriftEnd' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DriftSwitch) == 0x00014C, "Member 'UUnionVehicleModelInfo::DriftSwitch' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DriftNoStartButtonOn) == 0x00014D, "Member 'UUnionVehicleModelInfo::DriftNoStartButtonOn' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DriftStartButtonOn) == 0x00014E, "Member 'UUnionVehicleModelInfo::DriftStartButtonOn' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DriftLeft) == 0x00014F, "Member 'UUnionVehicleModelInfo::DriftLeft' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DriftRight) == 0x000150, "Member 'UUnionVehicleModelInfo::DriftRight' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, ChargeRate) == 0x000154, "Member 'UUnionVehicleModelInfo::ChargeRate' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, BoostCharge_Drift_Stage_1) == 0x000158, "Member 'UUnionVehicleModelInfo::BoostCharge_Drift_Stage_1' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, BoostCharge_Drift_Stage_2) == 0x000159, "Member 'UUnionVehicleModelInfo::BoostCharge_Drift_Stage_2' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, BoostCharge_Drift_Stage_3) == 0x00015A, "Member 'UUnionVehicleModelInfo::BoostCharge_Drift_Stage_3' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, BoostCharge_Drift_Stage_4) == 0x00015B, "Member 'UUnionVehicleModelInfo::BoostCharge_Drift_Stage_4' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, IsInBoost) == 0x00015C, "Member 'UUnionVehicleModelInfo::IsInBoost' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, BoostStart_Stage_1) == 0x00015D, "Member 'UUnionVehicleModelInfo::BoostStart_Stage_1' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, BoostStart_Stage_2) == 0x00015E, "Member 'UUnionVehicleModelInfo::BoostStart_Stage_2' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, BoostStart_Stage_3) == 0x00015F, "Member 'UUnionVehicleModelInfo::BoostStart_Stage_3' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, BoostStart_Stage_4) == 0x000160, "Member 'UUnionVehicleModelInfo::BoostStart_Stage_4' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, BoostStart_Stage_5) == 0x000161, "Member 'UUnionVehicleModelInfo::BoostStart_Stage_5' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, BoostStart_Stage_6) == 0x000162, "Member 'UUnionVehicleModelInfo::BoostStart_Stage_6' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, BoostStart) == 0x000163, "Member 'UUnionVehicleModelInfo::BoostStart' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, BoostEnd) == 0x000164, "Member 'UUnionVehicleModelInfo::BoostEnd' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, Boost_StartLine) == 0x000165, "Member 'UUnionVehicleModelInfo::Boost_StartLine' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, Boost_Drift) == 0x000166, "Member 'UUnionVehicleModelInfo::Boost_Drift' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, Boost_PickUp) == 0x000167, "Member 'UUnionVehicleModelInfo::Boost_PickUp' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, Boost_Pad) == 0x000168, "Member 'UUnionVehicleModelInfo::Boost_Pad' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, Boost_PadOn) == 0x000169, "Member 'UUnionVehicleModelInfo::Boost_PadOn' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, Boost_Stunt) == 0x00016A, "Member 'UUnionVehicleModelInfo::Boost_Stunt' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, Boost_Skim) == 0x00016B, "Member 'UUnionVehicleModelInfo::Boost_Skim' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, Boost_SlingShot) == 0x00016C, "Member 'UUnionVehicleModelInfo::Boost_SlingShot' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, Boost_SlingshotBoostPad) == 0x00016D, "Member 'UUnionVehicleModelInfo::Boost_SlingshotBoostPad' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, Boost_WhiteBoost) == 0x00016E, "Member 'UUnionVehicleModelInfo::Boost_WhiteBoost' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, Boost_BouncyJump) == 0x00016F, "Member 'UUnionVehicleModelInfo::Boost_BouncyJump' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, Boost_GroupEnergy) == 0x000170, "Member 'UUnionVehicleModelInfo::Boost_GroupEnergy' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, Boost_GadgetTouch) == 0x000171, "Member 'UUnionVehicleModelInfo::Boost_GadgetTouch' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, Boost_FriendTouch) == 0x000172, "Member 'UUnionVehicleModelInfo::Boost_FriendTouch' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, Boost_Pad_Special) == 0x000173, "Member 'UUnionVehicleModelInfo::Boost_Pad_Special' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, Gadget_SwitchQuickCharge) == 0x000174, "Member 'UUnionVehicleModelInfo::Gadget_SwitchQuickCharge' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, IsInSpin) == 0x000175, "Member 'UUnionVehicleModelInfo::IsInSpin' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, SpinStart) == 0x000176, "Member 'UUnionVehicleModelInfo::SpinStart' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, SpinEnd) == 0x000177, "Member 'UUnionVehicleModelInfo::SpinEnd' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, Landing) == 0x000178, "Member 'UUnionVehicleModelInfo::Landing' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, CrouchOn) == 0x000179, "Member 'UUnionVehicleModelInfo::CrouchOn' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, HitTrackWall) == 0x00017A, "Member 'UUnionVehicleModelInfo::HitTrackWall' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, HitTrackWallLeft) == 0x00017B, "Member 'UUnionVehicleModelInfo::HitTrackWallLeft' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, HitTrackWallRight) == 0x00017C, "Member 'UUnionVehicleModelInfo::HitTrackWallRight' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, StartDash_Success_1) == 0x00017D, "Member 'UUnionVehicleModelInfo::StartDash_Success_1' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, StartDash_Success_2) == 0x00017E, "Member 'UUnionVehicleModelInfo::StartDash_Success_2' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, StartDash_Success_3) == 0x00017F, "Member 'UUnionVehicleModelInfo::StartDash_Success_3' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, StartDash_Failure) == 0x000180, "Member 'UUnionVehicleModelInfo::StartDash_Failure' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, StartDashChargeAmount) == 0x000184, "Member 'UUnionVehicleModelInfo::StartDashChargeAmount' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, BoostPad) == 0x000188, "Member 'UUnionVehicleModelInfo::BoostPad' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, ReactionPunch) == 0x000189, "Member 'UUnionVehicleModelInfo::ReactionPunch' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DriftLevel) == 0x00018C, "Member 'UUnionVehicleModelInfo::DriftLevel' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, BoostLevel) == 0x000190, "Member 'UUnionVehicleModelInfo::BoostLevel' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, SpinLeft) == 0x000194, "Member 'UUnionVehicleModelInfo::SpinLeft' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, SpinRight) == 0x000195, "Member 'UUnionVehicleModelInfo::SpinRight' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, HitFront) == 0x000196, "Member 'UUnionVehicleModelInfo::HitFront' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, HitRear) == 0x000197, "Member 'UUnionVehicleModelInfo::HitRear' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, HitLeft) == 0x000198, "Member 'UUnionVehicleModelInfo::HitLeft' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, HitRight) == 0x000199, "Member 'UUnionVehicleModelInfo::HitRight' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, IsSquashed) == 0x00019A, "Member 'UUnionVehicleModelInfo::IsSquashed' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, SquashedStart) == 0x00019B, "Member 'UUnionVehicleModelInfo::SquashedStart' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, SquashedEnd) == 0x00019C, "Member 'UUnionVehicleModelInfo::SquashedEnd' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, SquashedFrame) == 0x0001A0, "Member 'UUnionVehicleModelInfo::SquashedFrame' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, ReactionForward) == 0x0001A4, "Member 'UUnionVehicleModelInfo::ReactionForward' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, ReactionBack) == 0x0001A5, "Member 'UUnionVehicleModelInfo::ReactionBack' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, ReactionVsOtherMachineStartingGrid) == 0x0001A8, "Member 'UUnionVehicleModelInfo::ReactionVsOtherMachineStartingGrid' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, IsInSlipstream) == 0x0001AC, "Member 'UUnionVehicleModelInfo::IsInSlipstream' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, SpinFrame) == 0x0001B0, "Member 'UUnionVehicleModelInfo::SpinFrame' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, IsInGuidedJump) == 0x0001B4, "Member 'UUnionVehicleModelInfo::IsInGuidedJump' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, OnGuidedJump) == 0x0001B5, "Member 'UUnionVehicleModelInfo::OnGuidedJump' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, IsInBouncyJump) == 0x0001B6, "Member 'UUnionVehicleModelInfo::IsInBouncyJump' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, TrickFlipFront) == 0x0001B7, "Member 'UUnionVehicleModelInfo::TrickFlipFront' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, TrickFlipBack) == 0x0001B8, "Member 'UUnionVehicleModelInfo::TrickFlipBack' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, TrickFlipLeft) == 0x0001B9, "Member 'UUnionVehicleModelInfo::TrickFlipLeft' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, TrickFlipRight) == 0x0001BA, "Member 'UUnionVehicleModelInfo::TrickFlipRight' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, TrickSpinLeft) == 0x0001BB, "Member 'UUnionVehicleModelInfo::TrickSpinLeft' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, TrickSpinRight) == 0x0001BC, "Member 'UUnionVehicleModelInfo::TrickSpinRight' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, TrickCorkscrewLeft) == 0x0001BD, "Member 'UUnionVehicleModelInfo::TrickCorkscrewLeft' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, TrickCorkscrewRight) == 0x0001BE, "Member 'UUnionVehicleModelInfo::TrickCorkscrewRight' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, BarrelRollLeft) == 0x0001BF, "Member 'UUnionVehicleModelInfo::BarrelRollLeft' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, BarrelRollRight) == 0x0001C0, "Member 'UUnionVehicleModelInfo::BarrelRollRight' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, TrickCancel) == 0x0001C1, "Member 'UUnionVehicleModelInfo::TrickCancel' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, TrickMissed) == 0x0001C2, "Member 'UUnionVehicleModelInfo::TrickMissed' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, TrickEndCountOn) == 0x0001C4, "Member 'UUnionVehicleModelInfo::TrickEndCountOn' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, TrickEndCount) == 0x0001C8, "Member 'UUnionVehicleModelInfo::TrickEndCount' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, TrickMotionPlayTimeSec) == 0x0001CC, "Member 'UUnionVehicleModelInfo::TrickMotionPlayTimeSec' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, RunoffDecelerationDisabled) == 0x0001D0, "Member 'UUnionVehicleModelInfo::RunoffDecelerationDisabled' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DashEffect_IsInRed) == 0x0001D1, "Member 'UUnionVehicleModelInfo::DashEffect_IsInRed' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DashEffect_IsInPink) == 0x0001D2, "Member 'UUnionVehicleModelInfo::DashEffect_IsInPink' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DashEffect_IsInBlue) == 0x0001D3, "Member 'UUnionVehicleModelInfo::DashEffect_IsInBlue' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DashEffect_IsInRainbow) == 0x0001D4, "Member 'UUnionVehicleModelInfo::DashEffect_IsInRainbow' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DashEffect_RedOn) == 0x0001D5, "Member 'UUnionVehicleModelInfo::DashEffect_RedOn' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DashEffect_RedOff) == 0x0001D6, "Member 'UUnionVehicleModelInfo::DashEffect_RedOff' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DashEffect_PinkOn) == 0x0001D7, "Member 'UUnionVehicleModelInfo::DashEffect_PinkOn' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DashEffect_PinkOff) == 0x0001D8, "Member 'UUnionVehicleModelInfo::DashEffect_PinkOff' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DashEffect_BlueOn) == 0x0001D9, "Member 'UUnionVehicleModelInfo::DashEffect_BlueOn' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DashEffect_BlueOff) == 0x0001DA, "Member 'UUnionVehicleModelInfo::DashEffect_BlueOff' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DashEffect_RainbowOn) == 0x0001DB, "Member 'UUnionVehicleModelInfo::DashEffect_RainbowOn' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DashEffect_RainbowOff) == 0x0001DC, "Member 'UUnionVehicleModelInfo::DashEffect_RainbowOff' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DashEffect_IsInRing) == 0x0001DD, "Member 'UUnionVehicleModelInfo::DashEffect_IsInRing' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DashEffect_RingOn) == 0x0001DE, "Member 'UUnionVehicleModelInfo::DashEffect_RingOn' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DashEffect_RingOff) == 0x0001DF, "Member 'UUnionVehicleModelInfo::DashEffect_RingOff' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DashEffect_IsInWhiteBoost) == 0x0001E0, "Member 'UUnionVehicleModelInfo::DashEffect_IsInWhiteBoost' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DashEffect_WhiteBoostOn) == 0x0001E1, "Member 'UUnionVehicleModelInfo::DashEffect_WhiteBoostOn' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DashEffect_WhiteBoostOff) == 0x0001E2, "Member 'UUnionVehicleModelInfo::DashEffect_WhiteBoostOff' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DashEffect_IsInKingWhiteBoost) == 0x0001E3, "Member 'UUnionVehicleModelInfo::DashEffect_IsInKingWhiteBoost' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DashEffect_KingWhiteBoostOn) == 0x0001E4, "Member 'UUnionVehicleModelInfo::DashEffect_KingWhiteBoostOn' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DashEffect_KingWhiteBoostOff) == 0x0001E5, "Member 'UUnionVehicleModelInfo::DashEffect_KingWhiteBoostOff' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DashEffect_IsSplashBoost) == 0x0001E6, "Member 'UUnionVehicleModelInfo::DashEffect_IsSplashBoost' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DashEffect_SplashBoostOn) == 0x0001E7, "Member 'UUnionVehicleModelInfo::DashEffect_SplashBoostOn' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DashEffect_SplashBoostOff) == 0x0001E8, "Member 'UUnionVehicleModelInfo::DashEffect_SplashBoostOff' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DashEffect_IsAirtrickDash) == 0x0001E9, "Member 'UUnionVehicleModelInfo::DashEffect_IsAirtrickDash' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DashEffect_IsAirtrickDashOn) == 0x0001EA, "Member 'UUnionVehicleModelInfo::DashEffect_IsAirtrickDashOn' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DashEffect_IsAirtrickDashOff) == 0x0001EB, "Member 'UUnionVehicleModelInfo::DashEffect_IsAirtrickDashOff' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, MachineForm_Car) == 0x0001EC, "Member 'UUnionVehicleModelInfo::MachineForm_Car' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, MachineForm_Boat) == 0x0001ED, "Member 'UUnionVehicleModelInfo::MachineForm_Boat' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, MachineForm_Plane) == 0x0001EE, "Member 'UUnionVehicleModelInfo::MachineForm_Plane' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, MachineForm_Hover) == 0x0001EF, "Member 'UUnionVehicleModelInfo::MachineForm_Hover' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, MachineForm_YellowDrill) == 0x0001F0, "Member 'UUnionVehicleModelInfo::MachineForm_YellowDrill' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, MachineForm_MonsterTruck) == 0x0001F1, "Member 'UUnionVehicleModelInfo::MachineForm_MonsterTruck' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, MachineForm_CyanLaser) == 0x0001F2, "Member 'UUnionVehicleModelInfo::MachineForm_CyanLaser' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DriveForm_Car) == 0x0001F3, "Member 'UUnionVehicleModelInfo::DriveForm_Car' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DriveForm_Boat) == 0x0001F4, "Member 'UUnionVehicleModelInfo::DriveForm_Boat' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DriveForm_Plane) == 0x0001F5, "Member 'UUnionVehicleModelInfo::DriveForm_Plane' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DriveForm_Drill) == 0x0001F6, "Member 'UUnionVehicleModelInfo::DriveForm_Drill' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DriveForm_Laser) == 0x0001F7, "Member 'UUnionVehicleModelInfo::DriveForm_Laser' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, DriveForm_Warp) == 0x0001F8, "Member 'UUnionVehicleModelInfo::DriveForm_Warp' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, TravelRingInvincible) == 0x0001F9, "Member 'UUnionVehicleModelInfo::TravelRingInvincible' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, TravelRingFollowingBoostLow) == 0x0001FA, "Member 'UUnionVehicleModelInfo::TravelRingFollowingBoostLow' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, TravelRingFollowingBoostHigh) == 0x0001FB, "Member 'UUnionVehicleModelInfo::TravelRingFollowingBoostHigh' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, TravelRingPPOn) == 0x0001FC, "Member 'UUnionVehicleModelInfo::TravelRingPPOn' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, TravelRingPPRate) == 0x000200, "Member 'UUnionVehicleModelInfo::TravelRingPPRate' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, TravelRingWhiteOutOn) == 0x000204, "Member 'UUnionVehicleModelInfo::TravelRingWhiteOutOn' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, TravelRingCubemapWhiteOutOn) == 0x000205, "Member 'UUnionVehicleModelInfo::TravelRingCubemapWhiteOutOn' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, TravelRingCubemapWhiteOutRate) == 0x000208, "Member 'UUnionVehicleModelInfo::TravelRingCubemapWhiteOutRate' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, ShortcutRingStg1503) == 0x00020C, "Member 'UUnionVehicleModelInfo::ShortcutRingStg1503' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, GoalOn) == 0x000210, "Member 'UUnionVehicleModelInfo::GoalOn' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, TimeoutOn) == 0x000211, "Member 'UUnionVehicleModelInfo::TimeoutOn' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, AllTireFloatingTime) == 0x000214, "Member 'UUnionVehicleModelInfo::AllTireFloatingTime' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, IsPlaneBoundaryValid) == 0x000218, "Member 'UUnionVehicleModelInfo::IsPlaneBoundaryValid' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, PlaneBoundarySizeRate) == 0x00021C, "Member 'UUnionVehicleModelInfo::PlaneBoundarySizeRate' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, PlaneBoundaryPosition) == 0x000220, "Member 'UUnionVehicleModelInfo::PlaneBoundaryPosition' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, PlaneBoundaryRotation) == 0x000240, "Member 'UUnionVehicleModelInfo::PlaneBoundaryRotation' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, ForceResultCameraProductionType) == 0x0002C0, "Member 'UUnionVehicleModelInfo::ForceResultCameraProductionType' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, IsPlayBlizzardSound) == 0x0002C1, "Member 'UUnionVehicleModelInfo::IsPlayBlizzardSound' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, BlizzardSoundParam) == 0x0002C4, "Member 'UUnionVehicleModelInfo::BlizzardSoundParam' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, TyreMarkInfo) == 0x000300, "Member 'UUnionVehicleModelInfo::TyreMarkInfo' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, m_TireRadiusCM) == 0x000338, "Member 'UUnionVehicleModelInfo::m_TireRadiusCM' has a wrong offset!");
static_assert(offsetof(UUnionVehicleModelInfo, HitMonsterTruckTire) == 0x000348, "Member 'UUnionVehicleModelInfo::HitMonsterTruckTire' has a wrong offset!");

// Class UnionRun.UnionGameCameraInfo
// 0x0050 (0x0078 - 0x0028)
class UUnionGameCameraInfo final : public UObject
{
public:
	struct FVector                                m_DomainPosition;                                  // 0x0028(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                m_DomainTarget;                                    // 0x0040(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                m_DomainUp;                                        // 0x0058(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         m_FovY;                                            // 0x0070(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetDomainPosition(struct FVector* OutDomainPosition);
	void GetDomainTarget(struct FVector* OutDomainTarget);
	void GetDomainUp(struct FVector* OutDomainUp);
	float GetFovY();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionGameCameraInfo">();
	}
	static class UUnionGameCameraInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionGameCameraInfo>();
	}
};
static_assert(alignof(UUnionGameCameraInfo) == 0x000008, "Wrong alignment on UUnionGameCameraInfo");
static_assert(sizeof(UUnionGameCameraInfo) == 0x000078, "Wrong size on UUnionGameCameraInfo");
static_assert(offsetof(UUnionGameCameraInfo, m_DomainPosition) == 0x000028, "Member 'UUnionGameCameraInfo::m_DomainPosition' has a wrong offset!");
static_assert(offsetof(UUnionGameCameraInfo, m_DomainTarget) == 0x000040, "Member 'UUnionGameCameraInfo::m_DomainTarget' has a wrong offset!");
static_assert(offsetof(UUnionGameCameraInfo, m_DomainUp) == 0x000058, "Member 'UUnionGameCameraInfo::m_DomainUp' has a wrong offset!");
static_assert(offsetof(UUnionGameCameraInfo, m_FovY) == 0x000070, "Member 'UUnionGameCameraInfo::m_FovY' has a wrong offset!");

// Class UnionRun.FreshlyPaintData
// 0x0050 (0x0080 - 0x0030)
class UFreshlyPaintData final : public UDataAsset
{
public:
	TMap<EVehicleFreshlyPaint, struct FFreshlyPaintParameter> Parameter;                             // 0x0030(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FreshlyPaintData">();
	}
	static class UFreshlyPaintData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFreshlyPaintData>();
	}
};
static_assert(alignof(UFreshlyPaintData) == 0x000008, "Wrong alignment on UFreshlyPaintData");
static_assert(sizeof(UFreshlyPaintData) == 0x000080, "Wrong size on UFreshlyPaintData");
static_assert(offsetof(UFreshlyPaintData, Parameter) == 0x000030, "Member 'UFreshlyPaintData::Parameter' has a wrong offset!");

// Class UnionRun.UnionWeakHoming
// 0x0050 (0x0088 - 0x0038)
class UUnionWeakHoming final : public UMoveController
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionWeakHoming">();
	}
	static class UUnionWeakHoming* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionWeakHoming>();
	}
};
static_assert(alignof(UUnionWeakHoming) == 0x000008, "Wrong alignment on UUnionWeakHoming");
static_assert(sizeof(UUnionWeakHoming) == 0x000088, "Wrong size on UUnionWeakHoming");

// Class UnionRun.UnionYellowDrillContainer
// 0x0040 (0x02D0 - 0x0290)
class AUnionYellowDrillContainer final : public AActor
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionItemSkeletalMeshContainer*        YellowDrillMesh;                                   // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      LoopEffect;                                        // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      NomalOnGroundEffect;                               // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      WaterOnGroundEffect;                               // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      TransEffect;                                       // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      ReturnEffect;                                      // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAtomComponent*                         DrillLoopSound;                                    // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionYellowDrillContainer">();
	}
	static class AUnionYellowDrillContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnionYellowDrillContainer>();
	}
};
static_assert(alignof(AUnionYellowDrillContainer) == 0x000008, "Wrong alignment on AUnionYellowDrillContainer");
static_assert(sizeof(AUnionYellowDrillContainer) == 0x0002D0, "Wrong size on AUnionYellowDrillContainer");
static_assert(offsetof(AUnionYellowDrillContainer, YellowDrillMesh) == 0x000298, "Member 'AUnionYellowDrillContainer::YellowDrillMesh' has a wrong offset!");
static_assert(offsetof(AUnionYellowDrillContainer, LoopEffect) == 0x0002A0, "Member 'AUnionYellowDrillContainer::LoopEffect' has a wrong offset!");
static_assert(offsetof(AUnionYellowDrillContainer, NomalOnGroundEffect) == 0x0002A8, "Member 'AUnionYellowDrillContainer::NomalOnGroundEffect' has a wrong offset!");
static_assert(offsetof(AUnionYellowDrillContainer, WaterOnGroundEffect) == 0x0002B0, "Member 'AUnionYellowDrillContainer::WaterOnGroundEffect' has a wrong offset!");
static_assert(offsetof(AUnionYellowDrillContainer, TransEffect) == 0x0002B8, "Member 'AUnionYellowDrillContainer::TransEffect' has a wrong offset!");
static_assert(offsetof(AUnionYellowDrillContainer, ReturnEffect) == 0x0002C0, "Member 'AUnionYellowDrillContainer::ReturnEffect' has a wrong offset!");
static_assert(offsetof(AUnionYellowDrillContainer, DrillLoopSound) == 0x0002C8, "Member 'AUnionYellowDrillContainer::DrillLoopSound' has a wrong offset!");

// Class UnionRun.URaceUISubItemIconSet
// 0x0080 (0x0360 - 0x02E0)
class UURaceUISubItemIconSet : public UUserWidget
{
public:
	TArray<class URaceUISubItemIcon*>             ItemIcons;                                         // 0x02E0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          IsItemStockTrading;                                // 0x02F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F1[0x7];                                      // 0x02F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  IsVisibilityIrregular;                             // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UImage*>                         DSPArcGaugeArr;                                    // 0x0308(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UOverlay*>                       DSPIrregularArr;                                   // 0x0318(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UBorder*>                        DSPInfinityEffArr;                                 // 0x0328(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         PlayerControllerIndex;                             // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasTradeGadget;                                   // 0x033C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTradeGrayOut;                                     // 0x033D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33E[0x2];                                      // 0x033E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidget*                                TradeIcon;                                         // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class URaceUISubItemSummonButton*>     ItemSummonButtons;                                 // 0x0348(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetItemHoldCount(int32 PlayerIndex, EItemInfoType ItemInfoType);
	int32 GetItemPackageRingCount(int32 PlayerIndex, EItemInfoType ItemInfoType);
	float GetTradeCoolTimeParam(int32 PlayerIndex);
	void InitIrregular();
	bool IsSummonAvailable(int32 PlayerIndex, EItemInfoType ItemInfoType);
	bool IsTradeCoolTime(int32 PlayerIndex);
	void SetItemPanelVisibility(bool bVisibility);
	void SetItemTradeKey(const struct FKey& InKey, bool IsKeyboard);
	void SetTradeActive(bool bActive);
	void SetVisibilityIrregular(EItemInfoType ItemInfoType, bool IsVisible_0);

	int32 GetHoldItemCount(int32 RacerIndex) const;
	struct FItemSet GetHoldItemInfo() const;
	EItemStatus GetItemStatus(EItemInfoType ItemInfoType) const;
	int32 GetRacerIndex(int32 PlayerIndex) const;
	bool HasItemStockPlus() const;
	bool HasItemStockTrade() const;
	bool HasItemSummon() const;
	bool IsHideIconOnLost(int32 LostItemCount) const;
	bool IsIrregularChargeItem(EItemInfoType ItemInfoType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"URaceUISubItemIconSet">();
	}
	static class UURaceUISubItemIconSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UURaceUISubItemIconSet>();
	}
};
static_assert(alignof(UURaceUISubItemIconSet) == 0x000008, "Wrong alignment on UURaceUISubItemIconSet");
static_assert(sizeof(UURaceUISubItemIconSet) == 0x000360, "Wrong size on UURaceUISubItemIconSet");
static_assert(offsetof(UURaceUISubItemIconSet, ItemIcons) == 0x0002E0, "Member 'UURaceUISubItemIconSet::ItemIcons' has a wrong offset!");
static_assert(offsetof(UURaceUISubItemIconSet, IsItemStockTrading) == 0x0002F0, "Member 'UURaceUISubItemIconSet::IsItemStockTrading' has a wrong offset!");
static_assert(offsetof(UURaceUISubItemIconSet, IsVisibilityIrregular) == 0x0002F8, "Member 'UURaceUISubItemIconSet::IsVisibilityIrregular' has a wrong offset!");
static_assert(offsetof(UURaceUISubItemIconSet, DSPArcGaugeArr) == 0x000308, "Member 'UURaceUISubItemIconSet::DSPArcGaugeArr' has a wrong offset!");
static_assert(offsetof(UURaceUISubItemIconSet, DSPIrregularArr) == 0x000318, "Member 'UURaceUISubItemIconSet::DSPIrregularArr' has a wrong offset!");
static_assert(offsetof(UURaceUISubItemIconSet, DSPInfinityEffArr) == 0x000328, "Member 'UURaceUISubItemIconSet::DSPInfinityEffArr' has a wrong offset!");
static_assert(offsetof(UURaceUISubItemIconSet, PlayerControllerIndex) == 0x000338, "Member 'UURaceUISubItemIconSet::PlayerControllerIndex' has a wrong offset!");
static_assert(offsetof(UURaceUISubItemIconSet, bHasTradeGadget) == 0x00033C, "Member 'UURaceUISubItemIconSet::bHasTradeGadget' has a wrong offset!");
static_assert(offsetof(UURaceUISubItemIconSet, bTradeGrayOut) == 0x00033D, "Member 'UURaceUISubItemIconSet::bTradeGrayOut' has a wrong offset!");
static_assert(offsetof(UURaceUISubItemIconSet, TradeIcon) == 0x000340, "Member 'UURaceUISubItemIconSet::TradeIcon' has a wrong offset!");
static_assert(offsetof(UURaceUISubItemIconSet, ItemSummonButtons) == 0x000348, "Member 'UURaceUISubItemIconSet::ItemSummonButtons' has a wrong offset!");

// Class UnionRun.WhaleAnimInstance
// 0x0000 (0x0370 - 0x0370)
class UWhaleAnimInstance final : public UEnemyAnimInstance
{
public:
	bool                                          bIsJamp;                                           // 0x0368(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsJampTwist;                                      // 0x0369(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_36A[0x6];                                      // 0x036A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetIsJamp();
	bool GetIsJampTwist();
	void SetIsJamp(bool flag);
	void SetIsJampTwist(bool flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WhaleAnimInstance">();
	}
	static class UWhaleAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWhaleAnimInstance>();
	}
};
static_assert(alignof(UWhaleAnimInstance) == 0x000010, "Wrong alignment on UWhaleAnimInstance");
static_assert(sizeof(UWhaleAnimInstance) == 0x000370, "Wrong size on UWhaleAnimInstance");
static_assert(offsetof(UWhaleAnimInstance, bIsJamp) == 0x000368, "Member 'UWhaleAnimInstance::bIsJamp' has a wrong offset!");
static_assert(offsetof(UWhaleAnimInstance, bIsJampTwist) == 0x000369, "Member 'UWhaleAnimInstance::bIsJampTwist' has a wrong offset!");

}

