#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: UnionSystem

#include "Basic.hpp"

#include "UnionSystem_structs.hpp"
#include "CriWareRuntime_structs.hpp"
#include "CriWareRuntime_classes.hpp"
#include "InputCore_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "SlateCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "UMG_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "EnhancedInput_classes.hpp"
#include "Niagara_classes.hpp"
#include "ProceduralMeshComponent_classes.hpp"
#include "AnimationBudgetAllocator_classes.hpp"
#include "AnimToTexture_classes.hpp"
#include "Slate_structs.hpp"


namespace SDK
{

// Class UnionSystem.UnionStaticMeshComponent
// 0x0000 (0x05E0 - 0x05E0)
#pragma pack(push, 0x1)
class alignas(0x10) UUnionStaticMeshComponent : public UStaticMeshComponent
{
public:
	void ChangeMaterial(int32 MaterialID, bool bChange, class UMaterialInterface* InMaterial);
	void ResetMaterialAll();

	bool IsNotChangedMaterial(int32 MaterialID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionStaticMeshComponent">();
	}
	static class UUnionStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionStaticMeshComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UUnionStaticMeshComponent) == 0x000010, "Wrong alignment on UUnionStaticMeshComponent");
static_assert(sizeof(UUnionStaticMeshComponent) == 0x0005E0, "Wrong size on UUnionStaticMeshComponent");

// Class UnionSystem.AppControllerInputManager
// 0x0018 (0x0058 - 0x0040)
class UAppControllerInputManager final : public UTickableWorldSubsystem
{
public:
	TArray<class AAppPlayerController*>           Controllers;                                       // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AMenuPlayerController* GetMenuPlayerController(int32 PlayerControllerIndex);
	class AAppPlayerController* GetPlayerController(int32 PlayerControllerIndex);
	bool IsMenuMouseInputMode(int32 PlayerControllerIndex);
	void RemovePlayer(class APlayerController* PlayerController, bool bDestroyPawn);
	void SetTickable(bool bTickable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppControllerInputManager">();
	}
	static class UAppControllerInputManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppControllerInputManager>();
	}
};
static_assert(alignof(UAppControllerInputManager) == 0x000008, "Wrong alignment on UAppControllerInputManager");
static_assert(sizeof(UAppControllerInputManager) == 0x000058, "Wrong size on UAppControllerInputManager");
static_assert(offsetof(UAppControllerInputManager, Controllers) == 0x000040, "Member 'UAppControllerInputManager::Controllers' has a wrong offset!");

// Class UnionSystem.AppSequenceLogManagerSubsystem
// 0x0008 (0x0038 - 0x0030)
class UAppSequenceLogManagerSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BackupSequenceType();
	ESequenceMainType GetBackupSequenceMainType();
	ESequenceSubType GetBackupSequenceSubType();
	ESequenceMainType GetSequenceMainType();
	ESequenceSubType GetSequenceSubType();
	void SetSequenceSubType(ESequenceSubType SubType);
	void SetSequenceType(ESequenceMainType MainType, ESequenceSubType SubType);

	int32 GetSequenceTypeNum() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppSequenceLogManagerSubsystem">();
	}
	static class UAppSequenceLogManagerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppSequenceLogManagerSubsystem>();
	}
};
static_assert(alignof(UAppSequenceLogManagerSubsystem) == 0x000008, "Wrong alignment on UAppSequenceLogManagerSubsystem");
static_assert(sizeof(UAppSequenceLogManagerSubsystem) == 0x000038, "Wrong size on UAppSequenceLogManagerSubsystem");

// Class UnionSystem.AppFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UAppFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int32 GetClampUserNameLength();
	static class FString GetDateString(const struct FDateTime& DateTime);
	static class FString GetDateTimeString(const struct FDateTime& DateTime);
	static class FString GetDateTimeStringWithoutSecond(const struct FDateTime& DateTime);
	static class FString GetHexString(int32 Input, int32 Length, bool AddZero);
	static struct FDateTime GetLocalDateTime(int64 UnixTimestampFromServer);
	static class FString GetLocalDateTimeString(int64 UnixTimestampFromServer);
	static EMilestoneVersion GetMileStoneVersion();
	static EMilestoneVersion GetMileStoneVersionWithWorldContext(const class UObject* WorldContextObject);
	static EAppSupportedPlatform GetPlatform();
	static ECrossplayPlatform GetPlatformGroup();
	static class FString GetUtcDateTimeString(int64 UnixTimestampFromServer);
	static int32 HexToNumber(const class FString& str);
	static bool Is2ndRom();
	static bool Is2ndRomWithWorldContext(const class UObject* WorldContextObject);
	static bool IsDevelopmentBuild();
	static bool IsMasterLaunchOptionEnabled();
	static bool IsPlayInEditor();
	static bool IsPlayStation();
	static bool IsPre2ndRom();
	static bool IsShippingBuild();
	static bool IsSupportHDVibration();
	static bool IsSwitch();
	static bool IsTestBuild();
	static bool IsVersionOverThan10100();
	static bool IsWindows();
	static bool IsXbox();
	static void OutputUE_LOG(EAppLogLevel InLevel, const class FString& Message);
	static void SetMilestoneVersion(EMilestoneVersion NewMilestoneVersion);
	static class FString TruncateStringWithEllipsis(const class FString& str, int32 Length);
	static class FText TruncateTextWithEllipsis(const class FText& Text, int32 Length);
	static class UObject* TryLoadAsset(const class FString& AssetPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppFunctionLibrary">();
	}
	static class UAppFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppFunctionLibrary>();
	}
};
static_assert(alignof(UAppFunctionLibrary) == 0x000008, "Wrong alignment on UAppFunctionLibrary");
static_assert(sizeof(UAppFunctionLibrary) == 0x000028, "Wrong size on UAppFunctionLibrary");

// Class UnionSystem.ChallengeStatsUtility
// 0x0000 (0x0028 - 0x0028)
class UChallengeStatsUtility final : public UBlueprintFunctionLibrary
{
public:
	static void AddChallengeStats(EChallengeId InChallengeId, int32 InValue);
	static void ChallengeProgressUpdateCategory(const EChallengeCategory InCategory);
	static void CheckAllChallengeStats();
	static TArray<EChallengeId> GetCategoryChallenge(const EChallengeCategory InCategory);
	static TArray<struct FChallengeStruct> GetCategoryChallengeData(const EChallengeCategory InCategory);
	static int32 GetCategoryClearCount(const EChallengeCategory InCategory);
	static TArray<struct FChallengeStatsData> GetCategoryStats(const EChallengeCategory InCategory);
	static EChallengeCategory GetChallengeCategory(const EChallengeId InId);
	static struct FChallengeStruct GetChallengeData(const EChallengeId InChallengeId);
	static int32 GetChallengeProgressCount();
	static EChallengeProgressState GetChallengeProgressState(const EChallengeId InChallengeId);
	static struct FChallengeStatsData GetChallengeStats(const EChallengeId InChallengeId);
	static int32 GetChallengeStatsCount(const EChallengeId InChallengeId);
	static struct FChallengePointReward GetPointReward(int32 ItemGetBgIdx, int32 ItemGetPointIdx);
	static int32 GetSpecialChallengeClearCount();
	static bool IsChallengeAcquiredStateCheck();
	static bool IsChallengeCategoryNewIcon(const EChallengeCategory InCategory);
	static bool IsCompleteChallenge(const EChallengeId InChallengeId);
	static bool IsCompleteChallengeCategory(const EChallengeCategory InCategory);
	static void SetChallengeProgressState(const EChallengeId InChallengeId, const EChallengeProgressState InProgressState);
	static void SetChallengeStats(EChallengeId InChallengeId, int32 InValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengeStatsUtility">();
	}
	static class UChallengeStatsUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChallengeStatsUtility>();
	}
};
static_assert(alignof(UChallengeStatsUtility) == 0x000008, "Wrong alignment on UChallengeStatsUtility");
static_assert(sizeof(UChallengeStatsUtility) == 0x000028, "Wrong size on UChallengeStatsUtility");

// Class UnionSystem.MilestoneUtil
// 0x0000 (0x0028 - 0x0028)
class UMilestoneUtil final : public UBlueprintFunctionLibrary
{
public:
	static EMilestoneVersion GetEnablePrelaunchAnotherStageLotteryMilestoneVersion();
	static const TArray<EDriverId> GetGrandPrixRivalDriverIds();
	static EDriverId GetRivalByMilestoneVersion();
	static bool IsAlreadyGrandPrixLeast1Play();
	static bool IsCharaIconLockCover(EDriverId DriverId);
	static bool IsCloseCourseInRaceParkCustomMatchMilestoneVersion();
	static bool IsDisableDecisionInRaceParkMilestoneVersion();
	static bool IsDisableEtceteraChallengeMilestoneVersion();
	static bool IsDisableEtceteraHintMilestoneVersion();
	static bool IsDisableEtceteraOthersMilestoneVersion();
	static bool IsDisableEtceteraStoreMilestoneVersion();
	static bool IsDisableEtceteraTitleMilestoneVersion();
	static bool IsDisableFestaMilestoneVersion();
	static bool IsDisableFriendlistMilestoneVersion();
	static bool IsDisableGrandPrixCourse2MilestoneVersion();
	static bool IsDisableGrandPrixCourse3MilestoneVersion();
	static bool IsDisableGrandPrixCourseMilestoneVersion();
	static bool IsDisableGrandPrixMilestoneVersion();
	static bool IsDisableHornAuraTabMilestoneVersion();
	static bool IsDisableRaceParkMilestoneVersion();
	static bool IsDisableRaceParkRivalOnOffMilestoneVersion();
	static bool IsDisableSelectTimeTrialMilestoneVersion();
	static bool IsDisableTimeTrialMilestoneVersion();
	static bool IsDisableTopMenuFestaRuleMilestoneVersion();
	static bool IsDisableTopMenuNewsMilestoneVersion();
	static bool IsDisableTrialMilestoneVersion();
	static bool IsEnableAdvertiseRatingMilestoneVersion();
	static bool IsEnableEtceteraFullGameStoreMilestoneVersion();
	static bool IsEnableResetSaveDataMilestoneVersion();
	static bool IsEnableSpecificTitleDebugCommandMilestoneVersion();
	static bool IsEnableThumbnailCollaboRaceMilestoneVersion();
	static bool IsEnableTitleDemoMilestoneVersion();
	static bool IsEnableTitleStoreMilestoneVersion();
	static bool IsEnableTopMenuStoreMilestoneVersion();
	static bool IsEnableTopMenuStorePopupAutoMilestoneVersion();
	static bool IsExclusionGhostUpDownloadEventMilestoneVersion();
	static bool IsForceEnableTopMenuNewsMilestoneVersion();
	static bool IsHiddenCharacter(EDriverId DriverId);
	static bool IsHiddenMachineParts(EMachineId MachineId);
	static bool IsHiddenRomVerMilestoneVersion();
	static bool IsHiddenWebManualQRcodeMilestoneVersion();
	static bool IsInitialMachineParts(EMachineId MachineId, int32 FrontPrice, int32 RearPrice, int32 TirePrice);
	static bool IsLimitDonpaTicketMilestoneVersion();
	static bool IsLimitRewardInRaceParkMilestoneVersion();
	static bool IsOfflineMilestoneVersion();
	static bool IsRaceUnLockedMilestoneVersion(const EGameModeId InGameModeId, const EStageId InStageId);
	static bool IsSkipDodonpaEventMilestoneVersion();
	static bool IsSkipSelectPlayNumMilestoneVersion();
	static bool IsTopMenuAccessLoginSuccessOnly();
	static bool IsVisibleCompanyNameMilestoneVersion();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MilestoneUtil">();
	}
	static class UMilestoneUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMilestoneUtil>();
	}
};
static_assert(alignof(UMilestoneUtil) == 0x000008, "Wrong alignment on UMilestoneUtil");
static_assert(sizeof(UMilestoneUtil) == 0x000028, "Wrong size on UMilestoneUtil");

// Class UnionSystem.AppGameInstance
// 0x0020 (0x01E0 - 0x01C0)
class UAppGameInstance : public UGameInstance
{
public:
	uint8                                         Pad_1C0[0x20];                                     // 0x01C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReadVCSChangelistFromFile();
	void Set2ndRom(bool Is2ndRom);

	void GetVCSRevisionNum(int32* OutVCSRevisionNum) const;
	void GetVCSRevisionStr(class FString* OutVCSString) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppGameInstance">();
	}
	static class UAppGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppGameInstance>();
	}
};
static_assert(alignof(UAppGameInstance) == 0x000008, "Wrong alignment on UAppGameInstance");
static_assert(sizeof(UAppGameInstance) == 0x0001E0, "Wrong size on UAppGameInstance");

// Class UnionSystem.HonorTitleListDataAsset
// 0x0058 (0x0088 - 0x0030)
class UHonorTitleListDataAsset final : public UDataAsset
{
public:
	class UDataTable*                             HonorTitleCompositeDataTable;                      // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, struct FHonorTitleListData>       HonorTitleTableDataMap;                            // 0x0038(0x0050)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)

public:
	void ClearData();
	void Update();

	TArray<struct FHonorTitleListData> GetAllHonorTitleAndIdWithRarity(int32 Rarity, TArray<int32>* outHonorTitleIdArray) const;
	TArray<struct FHonorTitleListData> GetAllHonorTitleWithRarity(int32 Rarity) const;
	TSoftObjectPtr<class UTexture2D> GetHonorTitlePlate(int32 HonorTitleId) const;
	int32 GetHonorTitleRarity(int32 HonorTitleId) const;
	class FText GetHonorTitleVBName(int32 HonorTitleId, bool* IsValid) const;
	bool GetIsHonorTitleDLC(int32 HonorTitleIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HonorTitleListDataAsset">();
	}
	static class UHonorTitleListDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHonorTitleListDataAsset>();
	}
};
static_assert(alignof(UHonorTitleListDataAsset) == 0x000008, "Wrong alignment on UHonorTitleListDataAsset");
static_assert(sizeof(UHonorTitleListDataAsset) == 0x000088, "Wrong size on UHonorTitleListDataAsset");
static_assert(offsetof(UHonorTitleListDataAsset, HonorTitleCompositeDataTable) == 0x000030, "Member 'UHonorTitleListDataAsset::HonorTitleCompositeDataTable' has a wrong offset!");
static_assert(offsetof(UHonorTitleListDataAsset, HonorTitleTableDataMap) == 0x000038, "Member 'UHonorTitleListDataAsset::HonorTitleTableDataMap' has a wrong offset!");

// Class UnionSystem.AppGameMode
// 0x0000 (0x0328 - 0x0328)
class AAppGameMode : public AGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppGameMode">();
	}
	static class AAppGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAppGameMode>();
	}
};
static_assert(alignof(AAppGameMode) == 0x000008, "Wrong alignment on AAppGameMode");
static_assert(sizeof(AAppGameMode) == 0x000328, "Wrong size on AAppGameMode");

// Class UnionSystem.ControllerButtonData
// 0x0050 (0x0080 - 0x0030)
class UControllerButtonData final : public UDataAsset
{
public:
	TMap<struct FKey, EControllerButtonTextureIndex> KeyConfig;                                      // 0x0030(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControllerButtonData">();
	}
	static class UControllerButtonData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControllerButtonData>();
	}
};
static_assert(alignof(UControllerButtonData) == 0x000008, "Wrong alignment on UControllerButtonData");
static_assert(sizeof(UControllerButtonData) == 0x000080, "Wrong size on UControllerButtonData");
static_assert(offsetof(UControllerButtonData, KeyConfig) == 0x000030, "Member 'UControllerButtonData::KeyConfig' has a wrong offset!");

// Class UnionSystem.SimpleAnimationComponent
// 0x0080 (0x0120 - 0x00A0)
class alignas(0x10) USimpleAnimationComponent : public UActorComponent
{
public:
	class UAnimSequence*                          Animation;                                         // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Target;                                            // 0x00A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayOffsetInFrame;                                 // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x68];                                      // 0x00B8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleAnimationComponent">();
	}
	static class USimpleAnimationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleAnimationComponent>();
	}
};
static_assert(alignof(USimpleAnimationComponent) == 0x000010, "Wrong alignment on USimpleAnimationComponent");
static_assert(sizeof(USimpleAnimationComponent) == 0x000120, "Wrong size on USimpleAnimationComponent");
static_assert(offsetof(USimpleAnimationComponent, Animation) == 0x0000A0, "Member 'USimpleAnimationComponent::Animation' has a wrong offset!");
static_assert(offsetof(USimpleAnimationComponent, Target) == 0x0000A8, "Member 'USimpleAnimationComponent::Target' has a wrong offset!");
static_assert(offsetof(USimpleAnimationComponent, PlayRate) == 0x0000B0, "Member 'USimpleAnimationComponent::PlayRate' has a wrong offset!");
static_assert(offsetof(USimpleAnimationComponent, PlayOffsetInFrame) == 0x0000B4, "Member 'USimpleAnimationComponent::PlayOffsetInFrame' has a wrong offset!");

// Class UnionSystem.SimpleAnimEventComponent
// 0x0020 (0x0140 - 0x0120)
class USimpleAnimEventComponent final : public USimpleAnimationComponent
{
public:
	TArray<struct FUnionSimpleAnimEvent>          AnimEventSequence;                                 // 0x0120(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_130[0x10];                                     // 0x0130(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleAnimEventComponent">();
	}
	static class USimpleAnimEventComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleAnimEventComponent>();
	}
};
static_assert(alignof(USimpleAnimEventComponent) == 0x000010, "Wrong alignment on USimpleAnimEventComponent");
static_assert(sizeof(USimpleAnimEventComponent) == 0x000140, "Wrong size on USimpleAnimEventComponent");
static_assert(offsetof(USimpleAnimEventComponent, AnimEventSequence) == 0x000120, "Member 'USimpleAnimEventComponent::AnimEventSequence' has a wrong offset!");

// Class UnionSystem.AtomListenerFocusPointForCamera
// 0x0020 (0x0250 - 0x0230)
class UAtomListenerFocusPointForCamera : public USceneComponent
{
public:
	float                                         DistanceFocusLevel;                                // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionFocusLevel;                               // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       Camera;                                            // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_240[0x10];                                     // 0x0240(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCameraActivated();
	void SetCamera(class UCameraComponent* NewCamera);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtomListenerFocusPointForCamera">();
	}
	static class UAtomListenerFocusPointForCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtomListenerFocusPointForCamera>();
	}
};
static_assert(alignof(UAtomListenerFocusPointForCamera) == 0x000010, "Wrong alignment on UAtomListenerFocusPointForCamera");
static_assert(sizeof(UAtomListenerFocusPointForCamera) == 0x000250, "Wrong size on UAtomListenerFocusPointForCamera");
static_assert(offsetof(UAtomListenerFocusPointForCamera, DistanceFocusLevel) == 0x000230, "Member 'UAtomListenerFocusPointForCamera::DistanceFocusLevel' has a wrong offset!");
static_assert(offsetof(UAtomListenerFocusPointForCamera, DirectionFocusLevel) == 0x000234, "Member 'UAtomListenerFocusPointForCamera::DirectionFocusLevel' has a wrong offset!");
static_assert(offsetof(UAtomListenerFocusPointForCamera, Camera) == 0x000238, "Member 'UAtomListenerFocusPointForCamera::Camera' has a wrong offset!");

// Class UnionSystem.AppListenerFocusPoint
// 0x0000 (0x0250 - 0x0250)
class UAppListenerFocusPoint final : public UAtomListenerFocusPointForCamera
{
public:
	void SetupComponent(int32 PlayerIndex, int32 NumLocalPlayers);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppListenerFocusPoint">();
	}
	static class UAppListenerFocusPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppListenerFocusPoint>();
	}
};
static_assert(alignof(UAppListenerFocusPoint) == 0x000010, "Wrong alignment on UAppListenerFocusPoint");
static_assert(sizeof(UAppListenerFocusPoint) == 0x000250, "Wrong size on UAppListenerFocusPoint");

// Class UnionSystem.AppOptionConfigSaveGameHelper
// 0x0000 (0x0028 - 0x0028)
class UAppOptionConfigSaveGameHelper final : public UBlueprintFunctionLibrary
{
public:
	static bool AllowCrossPlay();
	static bool AllowCrossPlayOnlyAppSetting();
	static void ApplyAmbientOcclusion();
	static void ApplyAntiAliasMethod();
	static void ApplyAudioSettings();
	static void ApplyBlur();
	static void ApplyFrameRateLimit();
	static void ApplyFullscreenMode(bool ApplyImmediately);
	static void ApplyGraphicMode();
	static void ApplyGraphicQuality();
	static void ApplyGraphicsSettings();
	static void ApplyModelQuality();
	static void ApplyReflectionQuality();
	static void ApplyRenderingScale();
	static void ApplyResolutionSize(bool ApplyImmediately);
	static void ApplyScreenBrightness();
	static void ApplyShadowQuality();
	static void ApplyUseDisplay(bool ApplyImmediately);
	static void ApplyVSync(bool ApplyImmediately);
	static void CalcGetUserAssistData(TArray<struct FUserAssistData>* OutAssistData);
	static ECaptionVisible GetCaptionVisibility();
	static EKeyConfigOperationType GetControllerOperationType(int32 InPlayerIndex);
	static EForceFeedbackLevel GetForceFeedbackLevel(int32 PlayerIndex);
	static ELanguage GetTextLangFromSave();
	static ELanguage GetVoiceLangFromSave();
	static void InitTextLangIfInvalid();
	static void InitVoiceLangIfInvalid();
	static bool IsControllerGyroAssistEnabled(int32 InPlayerIndex);
	static bool IsControllerOperationTypeCustom(int32 InPlayerIndex);
	static bool IsDiffUserAssistDataWithSaveData(const TArray<struct FUserAssistData>& InAssistData);
	static bool IsInverseAcceptAndCancel(int32 InPlayerIndex);
	static bool IsInverseFlyModeUpDown(int32 InPlayerIndex);
	static bool IsRunningOnSteamDeck();
	static void ResetControllerSettingsForLocalMultiPlayer();
	static void SetAllPlayerForceFeedbackLevelFromSave();
	static void SetControllerGyroAssistEnabled(int32 InPlayerIndex, bool InEnable);
	static void SetControllerOperationType(int32 InPlayerIndex, EKeyConfigOperationType InOperationType);
	static void SetForceFeedbackLevel(int32 PlayerIndex, EForceFeedbackLevel VibrationLevel);
	static void SetInverseAcceptAndCancel(int32 InPlayerIndex, bool InInverse);
	static void SetTextLangToSave(ELanguage NewLanguage);
	static void SetVoiceLangToSave(ELanguage NewLanguage);
	static bool UpdateGraphicSettingsAtFirstTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppOptionConfigSaveGameHelper">();
	}
	static class UAppOptionConfigSaveGameHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppOptionConfigSaveGameHelper>();
	}
};
static_assert(alignof(UAppOptionConfigSaveGameHelper) == 0x000008, "Wrong alignment on UAppOptionConfigSaveGameHelper");
static_assert(sizeof(UAppOptionConfigSaveGameHelper) == 0x000028, "Wrong size on UAppOptionConfigSaveGameHelper");

// Class UnionSystem.AppPlayerController
// 0x01E0 (0x0A38 - 0x0858)
class AAppPlayerController : public APlayerController
{
public:
	uint8                                         Pad_858[0x8];                                      // 0x0858(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputDataAsset*                        InputDataAsset;                                    // 0x0860(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultInputConfigName;                            // 0x0868(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EAppControllerInputType BeforeType, EAppControllerInputType AfterType)> OnChangeControllerInputTypeEvent; // 0x0870(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FPointerEvent& InPointerEvent)> OnMousePointerEvent;  // 0x0880(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FPointerEvent& InPointerEvent)> OnMousePointerUpEvent; // 0x0890(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMouseFullScreenClickEvent;                       // 0x08A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMouseLeftButtonReleasedEvent;                    // 0x08B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C0[0x100];                                    // 0x08C0(0x0100)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                LastHoveredObject;                                 // 0x09C0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C8[0x70];                                     // 0x09C8(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddRegisterSubMenu(class UObject* InMenuObject, int32 InPriority);
	void ApplyOptionControllerSettings();
	bool CalcIsMousePositionInViewport();
	void CalcTutorialControllerType(uint8* Type, uint8* Platform);
	void ClearUserFocus();
	void DoInputMenu(EMenuInputKey InKey);
	EAppControllerInputType GetCurrentInputType();
	class UObject* GetLastHoveredObject();
	struct FKey GetMappableKeyByMappingName(const class FName& MappingName);
	struct FKey GetMenuConfigKey(const class FName& InActionName, bool IsGamepad, bool IsAnalog);
	struct FKey GetRaceConfigKey(const class FName& InActionName, bool IsPrimary, bool IsGamepad);
	void OnApplicationHasReactivated();
	void OnChangeControllerInputType(EAppControllerInputType BeforeType, EAppControllerInputType AfterType);
	void OnLeftMousePressed();
	void OnLeftStickVectorAxisEvent(const struct FVector& InStickVector);
	void OnMousePointer(const struct FPointerEvent& InPointerEvent);
	void OnMousePointerEventBP(const struct FPointerEvent& InPointerEvent);
	void OnMousePointerUp(const struct FPointerEvent& InPointerEvent);
	void RegisterMainMenu(class UObject* InObject, EMainMenuRegistPriority InPriority);
	void RegisterMenu(class UObject* InMenuObject, int32 InPriority);
	void SetCurrentInputConfig(const class FName InputConfigName);
	void SetEnableMainMenu(const class UObject* InObject, bool IsEnable);
	void SetEnableMainMenuAll(bool IsEnable);
	void SetEnableMainMenuLowerPriority(bool IsEnable, int32 InPrioirty);
	void SetEnableMainMenuUpperPriority(bool IsEnable, int32 InPrioirty);
	void SetEnableSubMenu(const class UObject* InObject, bool IsEnable);
	void SetEnableSubMenuAll(bool IsEnable);
	void SetEnableSubMenuLowerPriority(bool IsEnable, int32 InPrioirty);
	void SetEnableSubMenuUpperPriority(bool IsEnable, int32 InPrioirty);
	void SetForceNonConsumeMouseEvent(bool bEnable);
	void SetInputBlocked(bool InBlocked);
	void SetLastHoveredObject(class UObject* HoveredObject);
	bool UnregisterMainMenu(const class UObject* InObject);
	void UnregisterMainMenuAll();
	void UnregisterMenu();
	bool UnregisterSingleMenu(const class UObject* InMenuObject);
	bool UnregisterSingleSubMenu(const class UObject* InMenuObject);
	void UnregisterSubMenu();

	bool GetLeftMouseButtonPressing() const;
	struct FVector2D GetLeftStickAxisValue() const;
	class UObject* GetRegisteredMenu() const;
	TArray<class UObject*> GetRegisteredSubMenu() const;
	class FName GetSystemFocusedWidgetName() const;
	bool OnIsMenuInputEnabled() const;
	bool OnIsSubMenuInputEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppPlayerController">();
	}
	static class AAppPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAppPlayerController>();
	}
};
static_assert(alignof(AAppPlayerController) == 0x000008, "Wrong alignment on AAppPlayerController");
static_assert(sizeof(AAppPlayerController) == 0x000A38, "Wrong size on AAppPlayerController");
static_assert(offsetof(AAppPlayerController, InputDataAsset) == 0x000860, "Member 'AAppPlayerController::InputDataAsset' has a wrong offset!");
static_assert(offsetof(AAppPlayerController, DefaultInputConfigName) == 0x000868, "Member 'AAppPlayerController::DefaultInputConfigName' has a wrong offset!");
static_assert(offsetof(AAppPlayerController, OnChangeControllerInputTypeEvent) == 0x000870, "Member 'AAppPlayerController::OnChangeControllerInputTypeEvent' has a wrong offset!");
static_assert(offsetof(AAppPlayerController, OnMousePointerEvent) == 0x000880, "Member 'AAppPlayerController::OnMousePointerEvent' has a wrong offset!");
static_assert(offsetof(AAppPlayerController, OnMousePointerUpEvent) == 0x000890, "Member 'AAppPlayerController::OnMousePointerUpEvent' has a wrong offset!");
static_assert(offsetof(AAppPlayerController, OnMouseFullScreenClickEvent) == 0x0008A0, "Member 'AAppPlayerController::OnMouseFullScreenClickEvent' has a wrong offset!");
static_assert(offsetof(AAppPlayerController, OnMouseLeftButtonReleasedEvent) == 0x0008B0, "Member 'AAppPlayerController::OnMouseLeftButtonReleasedEvent' has a wrong offset!");
static_assert(offsetof(AAppPlayerController, LastHoveredObject) == 0x0009C0, "Member 'AAppPlayerController::LastHoveredObject' has a wrong offset!");

// Class UnionSystem.AppPlayerControllerSubsystem
// 0x0280 (0x02B0 - 0x0030)
class UAppPlayerControllerSubsystem final : public UGameInstanceSubsystem
{
public:
	TMap<class FName, EControllerButtonTextureIndex> ButtonNameToTextureIndex;                       // 0x0030(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, class UMaterialInstanceDynamic*> ButtonMaterials;                              // 0x0080(0x0050)(BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class FName, class FName>                TagToActionMapping;                                // 0x00D0(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<struct FKey, class UMaterialInstanceDynamic*> KeyToButtonMaterial;                          // 0x0120(0x0050)(BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<struct FKey, EControllerButtonTextureIndex> KeyToPadTextureIndex;                           // 0x0170(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             CurrentButtonTexture;                              // 0x01C0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UControllerButtonData*                  FKeyToControllerTextureIndex;                      // 0x01C8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CurrentDisplayKeyboardLayout;                      // 0x01D0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CurrentDisplayKeytopPattern;                       // 0x01D1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D2[0x6];                                      // 0x01D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EControllerButtonTextureIndex, EMenuKeyboardButtonTextureIndex> PadToMenuKeyboardTextureIndex; // 0x01D8(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x28];                                     // 0x0228(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AAppPlayerController*>           AppPlayerControllers;                              // 0x0250(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<struct FKey, struct FLocalizeRuntimeTextArray> KeyToKeytopTextMap;                          // 0x0260(0x0050)(NativeAccessSpecifierPrivate)

public:
	void AddDeviceChangeInterface(int32 InPlayerControllerIndex, class UObject* InIFObject);
	EAppControllerInputType CalcCurrentDeviceButtonTexture(int32 PlayerControllerIndex, class UTexture2D** OutTexure);
	void CallChangeControllerInputType(int32 InPlayerControllerIndex, EAppControllerInputType InControllerInputType);
	class AAppPlayerController* CreatePlayer(int32 ControllerId, bool bSpawnPlayerController);
	class AAppPlayerController* GetAppPlayerController(int32 ControllerId);
	int32 GetControllerTextureIndexFromFKey(const struct FKey& InKey);
	EControllerButtonTextureType GetCurrentButtonTextureType();
	class UTexture2D* GetCurrentDeviceTexture();
	class UTexture2D* GetMenuKeyboardButtonTexture();
	class UTexture2D* GetMenuMouseButtonTexture();
	void RemoveDeviceChangeInterface(int32 InPlayerControllerIndex, class UObject* InIFObject);
	void RemovePlayer(int32 ControllerId, bool bDestroyPawn);
	void SetButtonTextureType(EControllerButtonTextureType InTextureType);
	class AAppPlayerController* SetPlayer(int32 ControllerId, class APlayerController* PlayerController);
	void SetTextureForButtonMaterials(class UObject* InTextureObj);
	void UpdateButtonMaterialByDeviceType(uint8 DeviceType);
	void UpdateCurrentButtonTextureType();

	uint8 GetCurrentDisplayKeytopPattern(int32 InPlayerIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppPlayerControllerSubsystem">();
	}
	static class UAppPlayerControllerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppPlayerControllerSubsystem>();
	}
};
static_assert(alignof(UAppPlayerControllerSubsystem) == 0x000008, "Wrong alignment on UAppPlayerControllerSubsystem");
static_assert(sizeof(UAppPlayerControllerSubsystem) == 0x0002B0, "Wrong size on UAppPlayerControllerSubsystem");
static_assert(offsetof(UAppPlayerControllerSubsystem, ButtonNameToTextureIndex) == 0x000030, "Member 'UAppPlayerControllerSubsystem::ButtonNameToTextureIndex' has a wrong offset!");
static_assert(offsetof(UAppPlayerControllerSubsystem, ButtonMaterials) == 0x000080, "Member 'UAppPlayerControllerSubsystem::ButtonMaterials' has a wrong offset!");
static_assert(offsetof(UAppPlayerControllerSubsystem, TagToActionMapping) == 0x0000D0, "Member 'UAppPlayerControllerSubsystem::TagToActionMapping' has a wrong offset!");
static_assert(offsetof(UAppPlayerControllerSubsystem, KeyToButtonMaterial) == 0x000120, "Member 'UAppPlayerControllerSubsystem::KeyToButtonMaterial' has a wrong offset!");
static_assert(offsetof(UAppPlayerControllerSubsystem, KeyToPadTextureIndex) == 0x000170, "Member 'UAppPlayerControllerSubsystem::KeyToPadTextureIndex' has a wrong offset!");
static_assert(offsetof(UAppPlayerControllerSubsystem, CurrentButtonTexture) == 0x0001C0, "Member 'UAppPlayerControllerSubsystem::CurrentButtonTexture' has a wrong offset!");
static_assert(offsetof(UAppPlayerControllerSubsystem, FKeyToControllerTextureIndex) == 0x0001C8, "Member 'UAppPlayerControllerSubsystem::FKeyToControllerTextureIndex' has a wrong offset!");
static_assert(offsetof(UAppPlayerControllerSubsystem, CurrentDisplayKeyboardLayout) == 0x0001D0, "Member 'UAppPlayerControllerSubsystem::CurrentDisplayKeyboardLayout' has a wrong offset!");
static_assert(offsetof(UAppPlayerControllerSubsystem, CurrentDisplayKeytopPattern) == 0x0001D1, "Member 'UAppPlayerControllerSubsystem::CurrentDisplayKeytopPattern' has a wrong offset!");
static_assert(offsetof(UAppPlayerControllerSubsystem, PadToMenuKeyboardTextureIndex) == 0x0001D8, "Member 'UAppPlayerControllerSubsystem::PadToMenuKeyboardTextureIndex' has a wrong offset!");
static_assert(offsetof(UAppPlayerControllerSubsystem, AppPlayerControllers) == 0x000250, "Member 'UAppPlayerControllerSubsystem::AppPlayerControllers' has a wrong offset!");
static_assert(offsetof(UAppPlayerControllerSubsystem, KeyToKeytopTextMap) == 0x000260, "Member 'UAppPlayerControllerSubsystem::KeyToKeytopTextMap' has a wrong offset!");

// Class UnionSystem.AppRaceEventManager
// 0x0238 (0x0278 - 0x0040)
class UAppRaceEventManager final : public UTickableWorldSubsystem
{
public:
	TMulticastInlineDelegate<void(int32 Value)>   OnRacerPassedTravelRingGate;                       // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& Value)> OnRaceSetBGMNameFirstLap;             // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& Value)> OnRacePassedToPreFirstLapWhenAnotherTimeTraial; // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& Value1, const class FString& Value2)> OnRacePassedToFirstLap; // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnRacePassedToFirstLapWhenAnotherTimeTraial;       // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnRaceTransitionToDomainSubInFirstLap;             // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnRaceReturnFromDomainSubInFirstLap;               // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnRaceSelectTravelRingGate;                        // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& Value1, bool Value2)> OnRaceDecideTravelRingGate; // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool Value)>    OnRacePassedToSecondLap;                           // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnRaceTransitionToDomainSubInSecondLap;            // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnRaceReturnFromDomainSubInSecondLap;              // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& Value)> OnRacePassedToFinalLap;               // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& Value)> OnRacePassedToFinalLapWhenTimeTiral;  // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnRaceFinalLapLast;                                // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnRaceTransitionToDomainSubInFinalLap;             // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnRaceReturnFromDomainSubInFinalLap;               // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnRaceGoal;                                        // 0x0150(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FAppRaceEventGoalData& Value)> OnRaceGoalWithParam;   // 0x0160(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& Value1, const class FString& Value2)> OnRacePassedToSecondLapForce; // 0x0170(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& Value1, const class FString& Value2)> OnRacePassedToFinalLapForce; // 0x0180(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float Value)>   OnRaceSetAisacRingGateDistanceFirstLapToSecondLap; // 0x0190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float Value)>   OnRaceSetAisacRingGateDistanceSecondLapToFinalLap; // 0x01A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool Value)>    OnRaceBGMOnCourseEditor;                           // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnRaceBGMFinished;                                 // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool Value)>    OnEnableRaceSilenceSound;                          // 0x01D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool Value)>    OnEnableResultSilenceSound;                        // 0x01E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const EMainSubCourseIndex& Value1, int32 Value2)> OnChangeSubCourse; // 0x01F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          RingGates;                                         // 0x0200(0x0010)(BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          TravelRings;                                       // 0x0210(0x0010)(BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          TravelRingLeftWaves;                               // 0x0220(0x0010)(BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          TravelRingRightWaves;                              // 0x0230(0x0010)(BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          TravelRingFloors;                                  // 0x0240(0x0010)(BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          TravelDecidePanels;                                // 0x0250(0x0010)(BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          SequenceParameterActorList;                        // 0x0260(0x0010)(BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bForceSkipResultSequence;                          // 0x0270(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTickable(bool bTickable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppRaceEventManager">();
	}
	static class UAppRaceEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppRaceEventManager>();
	}
};
static_assert(alignof(UAppRaceEventManager) == 0x000008, "Wrong alignment on UAppRaceEventManager");
static_assert(sizeof(UAppRaceEventManager) == 0x000278, "Wrong size on UAppRaceEventManager");
static_assert(offsetof(UAppRaceEventManager, OnRacerPassedTravelRingGate) == 0x000040, "Member 'UAppRaceEventManager::OnRacerPassedTravelRingGate' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, OnRaceSetBGMNameFirstLap) == 0x000050, "Member 'UAppRaceEventManager::OnRaceSetBGMNameFirstLap' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, OnRacePassedToPreFirstLapWhenAnotherTimeTraial) == 0x000060, "Member 'UAppRaceEventManager::OnRacePassedToPreFirstLapWhenAnotherTimeTraial' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, OnRacePassedToFirstLap) == 0x000070, "Member 'UAppRaceEventManager::OnRacePassedToFirstLap' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, OnRacePassedToFirstLapWhenAnotherTimeTraial) == 0x000080, "Member 'UAppRaceEventManager::OnRacePassedToFirstLapWhenAnotherTimeTraial' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, OnRaceTransitionToDomainSubInFirstLap) == 0x000090, "Member 'UAppRaceEventManager::OnRaceTransitionToDomainSubInFirstLap' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, OnRaceReturnFromDomainSubInFirstLap) == 0x0000A0, "Member 'UAppRaceEventManager::OnRaceReturnFromDomainSubInFirstLap' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, OnRaceSelectTravelRingGate) == 0x0000B0, "Member 'UAppRaceEventManager::OnRaceSelectTravelRingGate' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, OnRaceDecideTravelRingGate) == 0x0000C0, "Member 'UAppRaceEventManager::OnRaceDecideTravelRingGate' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, OnRacePassedToSecondLap) == 0x0000D0, "Member 'UAppRaceEventManager::OnRacePassedToSecondLap' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, OnRaceTransitionToDomainSubInSecondLap) == 0x0000E0, "Member 'UAppRaceEventManager::OnRaceTransitionToDomainSubInSecondLap' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, OnRaceReturnFromDomainSubInSecondLap) == 0x0000F0, "Member 'UAppRaceEventManager::OnRaceReturnFromDomainSubInSecondLap' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, OnRacePassedToFinalLap) == 0x000100, "Member 'UAppRaceEventManager::OnRacePassedToFinalLap' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, OnRacePassedToFinalLapWhenTimeTiral) == 0x000110, "Member 'UAppRaceEventManager::OnRacePassedToFinalLapWhenTimeTiral' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, OnRaceFinalLapLast) == 0x000120, "Member 'UAppRaceEventManager::OnRaceFinalLapLast' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, OnRaceTransitionToDomainSubInFinalLap) == 0x000130, "Member 'UAppRaceEventManager::OnRaceTransitionToDomainSubInFinalLap' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, OnRaceReturnFromDomainSubInFinalLap) == 0x000140, "Member 'UAppRaceEventManager::OnRaceReturnFromDomainSubInFinalLap' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, OnRaceGoal) == 0x000150, "Member 'UAppRaceEventManager::OnRaceGoal' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, OnRaceGoalWithParam) == 0x000160, "Member 'UAppRaceEventManager::OnRaceGoalWithParam' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, OnRacePassedToSecondLapForce) == 0x000170, "Member 'UAppRaceEventManager::OnRacePassedToSecondLapForce' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, OnRacePassedToFinalLapForce) == 0x000180, "Member 'UAppRaceEventManager::OnRacePassedToFinalLapForce' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, OnRaceSetAisacRingGateDistanceFirstLapToSecondLap) == 0x000190, "Member 'UAppRaceEventManager::OnRaceSetAisacRingGateDistanceFirstLapToSecondLap' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, OnRaceSetAisacRingGateDistanceSecondLapToFinalLap) == 0x0001A0, "Member 'UAppRaceEventManager::OnRaceSetAisacRingGateDistanceSecondLapToFinalLap' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, OnRaceBGMOnCourseEditor) == 0x0001B0, "Member 'UAppRaceEventManager::OnRaceBGMOnCourseEditor' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, OnRaceBGMFinished) == 0x0001C0, "Member 'UAppRaceEventManager::OnRaceBGMFinished' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, OnEnableRaceSilenceSound) == 0x0001D0, "Member 'UAppRaceEventManager::OnEnableRaceSilenceSound' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, OnEnableResultSilenceSound) == 0x0001E0, "Member 'UAppRaceEventManager::OnEnableResultSilenceSound' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, OnChangeSubCourse) == 0x0001F0, "Member 'UAppRaceEventManager::OnChangeSubCourse' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, RingGates) == 0x000200, "Member 'UAppRaceEventManager::RingGates' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, TravelRings) == 0x000210, "Member 'UAppRaceEventManager::TravelRings' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, TravelRingLeftWaves) == 0x000220, "Member 'UAppRaceEventManager::TravelRingLeftWaves' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, TravelRingRightWaves) == 0x000230, "Member 'UAppRaceEventManager::TravelRingRightWaves' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, TravelRingFloors) == 0x000240, "Member 'UAppRaceEventManager::TravelRingFloors' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, TravelDecidePanels) == 0x000250, "Member 'UAppRaceEventManager::TravelDecidePanels' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, SequenceParameterActorList) == 0x000260, "Member 'UAppRaceEventManager::SequenceParameterActorList' has a wrong offset!");
static_assert(offsetof(UAppRaceEventManager, bForceSkipResultSequence) == 0x000270, "Member 'UAppRaceEventManager::bForceSkipResultSequence' has a wrong offset!");

// Class UnionSystem.AppSaveGameHelper
// 0x0000 (0x0028 - 0x0028)
class UAppSaveGameHelper final : public UBlueprintFunctionLibrary
{
public:
	static void AddALLRivalWinCount();
	static void AddCompensationData(int32 ID);
	static void AddRaceStatsValue(const EStatsEventId InStatsId, const int32 Value);
	static void AddRewardGetDisplayRequestData(ERewardAchievementType InRewardAchievementType);
	static void AddRivalWinCount(EDriverId DriverId);
	static bool CheckRewardGetDisplayRequest(ERewardAchievementType InRewardAchievementType);
	static bool CheckRewardGetDisplayRequestData();
	static void ClearDriverNew(EDriverId InDriverId);
	static void ClearHintRead(EHintId InHintId);
	static void ClearIncompleteCollaboGPVictoryPopupRequired();
	static void ClearRewardGetDisplayRequestData(ERewardAchievementType InRewardAchievementType);
	static void ClearRewardGetDisplayRequestDataAll();
	static void ConvertItemSwitchSettingSaveToTableStruct(const struct FItemSwitchSettingSave& InSetting, struct FItemSwitchSetting* OutSetting);
	static void ConvertPartyRacePresetSettingSaveToTableStruct(const struct FPartyRacePresetSettingSave& InSetting, struct FPartyRacePresetSetting* OutSetting);
	static void Debug_AllSetHintRead();
	static void Debug_InitUserHintData();
	static void ExecuteSaveDataHealthCheck();
	static bool GetAlbumAvailable(int32 ID);
	static TArray<int32> GetAllHonorTitleUnlock();
	static TArray<int32> GetAllNewHonorTitleUnlocked();
	static float GetChallengeLastShowProgress();
	static int32 GetChallengeShowProgress();
	static TArray<int32> GetCompensationIdArray();
	static TArray<EStageId> GetCourseSwitchSetting(EGameModeId InGameModeId);
	static struct FUserAlbumTrackID GetCustomLapBGM(int32 Lap);
	static bool GetDodonpaEventCompleteFlag(EGrandPrixEventFlag SaveDataFlagId);
	static int32 GetFriendShipGivedTicket(EDriverId ID);
	static struct FUserGadgetCustomizeData GetGadgetCustomizeData();
	static int32 GetGrandPrixBeforeRivalLevel(EMenuSpeedClassId SpeedClassId);
	static int32 GetGrandPrixClassClearedCountByMenuSpeedClass(const EMenuSpeedClassId& SpeedClassId);
	static int32 GetGrandPrixClassClearedCountByMenuSpeedClassIgnoreContinuity(const EMenuSpeedClassId& SpeedClassId);
	static int32 GetGrandPrixRivalLevel(EMenuSpeedClassId SpeedClassId);
	static int32 GetGrandPrixWinCount();
	static int32 GetHonorTitleIndex();
	static struct FHonorTitleListData GetHonorTitleInfo();
	static bool GetHonorTitleUnlock(int32 HonorTitleIndex);
	static bool GetIsGhostUploaded(const EStageId InStageId, const ESpeedClassId InSpeedClassId, bool* bOutIsValid);
	static bool GetIsValidGhost(const EStageId InStageId, const ESpeedClassId InSpeedClassId);
	static struct FItemSwitchSetting GetItemSwitchSetting(EGameModeId InGameModeId);
	static struct FItemSwitchSettingSave GetItemSwitchSettingSave(EGameModeId InGameModeId);
	static void GetMachineColorPresetAll(TArray<EMachineColorPresetId>* OutMachineColorPresetId);
	static void GetMachinePartsAll(TArray<EMachineId>* OutFrontPartsId, TArray<EMachineId>* OutRearPartsId, TArray<EMachineId>* OutTirePartsId);
	static bool GetNewHonorTitleUnlocked(int32 HonorTitleIndex);
	static bool GetNoticeLobbyInvitationOnRace();
	static int32 GetPlayerIconBgColorId();
	static int32 GetPlayerIconId();
	static EGrandPrixProgressId GetProgressIdGrandPrixAnyClass(EGrandPrixId GrandPrixId);
	static EGrandPrixProgressId GetProgressIdGrandPrixMenuSpeedClass(const EGrandPrixId& GrandPirxId, const EMenuSpeedClassId& MenuSpeedClassId);
	static void GetRaceParkCustomRaceSetting(struct FPartyRacePresetSetting* OutSetting);
	static int32 GetRaceStatsValue(const EStatsEventId InStatsId);
	static TArray<bool> GetRedStarRingAcquisitionPerStage(const EStageId InStageId);
	static int32 GetRivalAppearanceCount(EDriverId DriverId);
	static int32 GetRivalAppearanceCountMin(const TArray<EDriverId>& CheckDriverIds, const TArray<EDriverId>& IgnoreDriverIds);
	static int32 GetRivalLevelAdjust();
	static int32 GetRivalWinCount(EDriverId DriverId);
	static int32 GetRivalWinRewardEventCount();
	static int32 GetSelectedGadgetPresetId(int32 InPlayerIndex);
	static TArray<int32> GetSelectedGadgetPresetIdsAllPlayer();
	static ETimeTrialWinLoseDispId GetTimeTrialLastResultId();
	static bool GetTimeTrialMedalAcquisition(const EStageId InStageId, const ESpeedClassId InSpeedClassId);
	static struct FUserTimeTrialRaceData GetTimeTrialRaceData(const EStageId InStageId, const ESpeedClassId InSpeedClassId, bool* bOutIsGhostValid);
	static int32 GetTimeTrialRewardCount();
	static uint8 GetTipsDisplayIndex();
	static uint8 GetTopKnockdownRivalLevel(const EMenuSpeedClassId SpeedClassId, const EDriverId DriverId);
	static TArray<uint8> GetTopKnockdownRivalLevelArray(const EMenuSpeedClassId SpeedClassId);
	static bool GetTrackAvailable(int32 ID);
	static bool GetTutorialActionCompletedFlag(const ETutorialAction tutorialAction);
	static bool GetTutorialCompletedFlagPerStage(const EStageId InStageId);
	static bool GetTutorialPopupDispFlag();
	static void GetUserCommonData(struct FUserCommonData* OutUserCommonData);
	static void GetUserDriverData(struct FUserDriverData* OutUserDriverData);
	static void GetUserDriverProperty(EDriverId InDriverId, struct FUserDriverProperty* OutUserDriverProperty);
	static void GetUserHintData(struct FUserHintData* OutUserHintData);
	static void GetUserHintProperty(EHintId InHintId, struct FUserHintProperty* OutUserHintProperty);
	static void GetUserMachineCustomizeData(EMachineId InMachineID, struct FUserMachineCustomizeData* OutUserMachineCustomizeData);
	static int32 GetUserNiceCount();
	static void GetUserRewardGetDisplayRequestData(struct FUserRewardGetDisplayRequestData* OutUserRewardGetDisplayRequestData);
	static EDriverId GetUserSelectedDriverId();
	static EMachineId GetUserSelectedMachineId();
	static bool HasAgreedNoticeAgreement();
	static bool HasEnteredMachineCustomizeSequence();
	static bool IsClearedGrandPrixAnySpeedClass(EGrandPrixId GrandPrixId);
	static bool IsClearedGrandPrixMenuSpeedClass(const EGrandPrixId& GrandPirxId, const EMenuSpeedClassId& SpeedClassId);
	static bool IsCompletedGrandPrixEvent(EGrandPrixEventFlag EventFlagId);
	static bool IsCompletedMachineParts(EMachineId InMachineID);
	static bool IsCompleteMainChallenge();
	static bool IsCompleteSpecialChallenge();
	static bool IsDiffGadgetPresetIds(const TArray<int32>& GadgetPresetIds);
	static bool IsFinishedAdvertiseLogoFlow();
	static bool IsGetFrontParts(EMachineId InMachineID);
	static bool IsGetMachineColorPreset(EMachineColorPresetId InMachineColorPresetId);
	static bool IsGetRearParts(EMachineId InMachineID);
	static bool IsGetTireParts(EMachineId InMachineID);
	static bool IsGrandPrixFirstIrregularAppeared();
	static bool IsGrandPrixLeast1Play();
	static bool IsGrandPrixLeast1PlayEachGrandPrix(EGrandPrixId GrandPrixId);
	static bool IsGrandPrixSelectTimeTrialLinkFirst();
	static bool IsGrandPrixWinRewardOverTiming();
	static bool IsIncompleteCollaboGPVictoryPopupRequired();
	static bool IsNewDriver(EDriverId InDriverId);
	static bool IsNewHint(EHintId InHintId);
	static bool IsOpenedMirrorClass();
	static bool IsOpenMirror();
	static bool IsOpenSuperSonicSpeed();
	static bool IsPatchUpdate();
	static bool IsReadHint(EHintId InHintId);
	static bool IsSelectableDriver(EDriverId InDriverId);
	static bool IsSpawnGrandPrixLevelDownUIFlag(const EMenuSpeedClassId SpeedClassId);
	static bool IsSpawnPowerRivalFlag();
	static bool IsStickerUnlocked(int32 InStickerId);
	static void ReflectRivalLose(const EMenuSpeedClassId SpeedClassId);
	static void ReflectRivalWin(const EMenuSpeedClassId SpeedClassId, const EDriverId DriverId, const int32 MaxRivalLevel, const int32 PowerRivalAddLevel, const int32 KnockdownRivalLevel, const bool bSpawnedPowRival);
	static void RemoveCompensationData(int32 ID);
	static void ResetCompensationData();
	static void ResetCourseSwitchSetting(EGameModeId InGameModeId);
	static void ResetItemSwitchSetting(EGameModeId InGameModeId);
	static void ResetNewHonorTitle(int32 HonorTitleIndex);
	static void ResetRaceParkCustomRaceSetting();
	static bool ResetSaveDataIfSpecificMilestoneVersion();
	static void ResetTimeTrialData();
	static void RollbackRivalResult(EMenuSpeedClassId SpeedClassId);
	static void SaveAgreedNoticeAgreement();
	static void SaveFinishedAdvertiseLogoFlow();
	static void SaveNoticeCheckTime();
	static void SaveOnceRomVersionId();
	static void SaveTimeTrialMedalAcquisition(const EStageId InStageId, const ESpeedClassId InSpeedClassId, const bool bInAcquisition);
	static void SaveTimeTrialRaceData(const struct FUserTimeTrialRaceData& UserTimeTrialRaceData, const EStageId InStageId, const ESpeedClassId InSpeedClassId);
	static void SaveTimeTrialRewardCountUp();
	static void SetAlbumAvailable(int32 ID);
	static void SetChallengeLastShowProgress(float Progress);
	static void SetChallengeShowProgress(int32 InProgress);
	static void SetCompleteMainChallenge(bool InComplete);
	static void SetCompleteSpecialChallenge(bool InComplete);
	static void SetCourseSwitchSetting(EGameModeId InGameModeId, const TArray<EStageId>& InStageIds);
	static void SetCustomLapBGM(int32 Lap, const struct FUserAlbumTrackID& AlbumTrack);
	static void SetDodonpaEventCompleteFlag(EGrandPrixEventFlag SaveDataFlagId, bool IsComplete);
	static void SetDriverSelectable(EDriverId InDriverId);
	static void SetDriverUnselectable(EDriverId InDriverId);
	static void SetGadgetCustomizeDataSelectedIndex(int32 SelectedIndex);
	static void SetGrandPrixALLKnockDownRivalLevel(const uint8 SetValue);
	static void SetGrandPrixALLRivalLevel(const uint8 SetValue);
	static void SetGrandPrixFirstIrregularAppeared(bool bAppeared);
	static void SetGrandPrixLeast1Play(bool bEnable);
	static void SetGrandPrixLeast1PlayEachGrandPrix(EGrandPrixId GrandPrixId, bool InLeast1Play);
	static void SetGrandPrixSelectTimeTrialLinkFirst(bool First);
	static void SetHasEnteredMachineCustomizeSequence(bool bInHasEntered);
	static void SetHintNew(EHintId InHintId, bool bInIsNew);
	static void SetHintRead(EHintId InHintId);
	static void SetHonorTitleIndex(int32 HonorTitleIndex);
	static void SetIsGhostUploaded(const EStageId InStageId, const ESpeedClassId InSpeedClassId, bool bInIsGhostUploaded);
	static void SetIsValidGhost(const EStageId InStageId, const ESpeedClassId InSpeedClassId, bool bInIsValidGhost);
	static void SetItemSwitchSetting(EGameModeId InGameModeId, const struct FItemSwitchSettingSave& InItemSwitchSetting);
	static void SetItemSwitchSettingSave(EGameModeId InGameModeId, const struct FItemSwitchSettingSave& InItemSwitchSetting);
	static void SetNoticeLobbyInvitationOnRace(bool bInEnable);
	static void SetOpenMirror(bool bEnable);
	static void SetOpenSuperSonicSpeed(bool bEnable);
	static void SetPlayerIconBgColorId(const class FString& ID);
	static void SetPlayerIconId(int32 ID);
	static void SetRaceParkCustomRaceSetting(const struct FPartyRacePresetSetting& PartyRacePresetSetting);
	static void SetRedStarRingAcquisitionPerStage(const EStageId InStageId, const TArray<bool>& InAcquisition);
	static void SetRivalAppearanceCount(EDriverId DriverId, int32 NewCount);
	static void SetRivalLevelAdjust(int32 NewAmount);
	static void SetRivalWinCount(EDriverId DriverId, int32 NewCount);
	static void SetSelectedGadgetPresetId(int32 InPlayerIndex, int32 InPresetId);
	static void SetSpawnGrandPrixALLLevelDownUIFlag(const bool SetEnabled);
	static void SetSpawnGrandPrixLevelDownUIFlag(const EMenuSpeedClassId SpeedClassId, const bool SetEnabled);
	static void SetSpawnPowerRivalFlag(const bool SetValue);
	static void SetTimeTrialLastResultId(const ETimeTrialWinLoseDispId InResultId);
	static void SetTipsDisplayIndex(uint8 InIndex);
	static void SetTrackAvailable(int32 ID);
	static void SetTutorialActionCompletedFlag(const ETutorialAction tutorialAction, const bool bCompleted);
	static void SetTutorialCompletedFlagPerStage(const EStageId InStageId, const bool bCompleted);
	static void SetTutorialPopupDispFlag(const bool bDisped);
	static void SetUserDriverProperty(EDriverId InDriverId, const struct FUserDriverProperty& InUserDriverProperty);
	static void SetUserHintProperty(EHintId InHintId, const struct FUserHintProperty& InUserHintProperty);
	static void SetUserMachineCustomizeData(EMachineId InMachineID, const struct FUserMachineCustomizeData& InUserMachineCustomizeData);
	static void SetUserNiceCount(int32 InNiceCount);
	static void SetUserSelectedDriverId(EDriverId InDriverId);
	static void SetUserSelectedMachineId(EMachineId InMachineID);
	static void UnlockHonorTitle(int32 HonorTitleIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppSaveGameHelper">();
	}
	static class UAppSaveGameHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppSaveGameHelper>();
	}
};
static_assert(alignof(UAppSaveGameHelper) == 0x000008, "Wrong alignment on UAppSaveGameHelper");
static_assert(sizeof(UAppSaveGameHelper) == 0x000028, "Wrong size on UAppSaveGameHelper");

// Class UnionSystem.AppSaveGame
// 0x0C30 (0x0C58 - 0x0028)
class UAppSaveGame final : public USaveGame
{
public:
	struct FSaveDataHeader                        _Header;                                           // 0x0028(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUserCommonData                        _UserCommonData;                                   // 0x0038(0x0078)(NativeAccessSpecifierPublic)
	struct FUserMachineAssemblyData               _UserMachineAssemblyData;                          // 0x00B0(0x0390)(NativeAccessSpecifierPublic)
	struct FUserGrandPrixData                     _UserGrandPrixData;                                // 0x0440(0x01D0)(NativeAccessSpecifierPublic)
	struct FUserTimeTrialData                     _UserTimeTrialData;                                // 0x0610(0x0018)(NativeAccessSpecifierPublic)
	struct FChallengeSaveData                     _UserChallengeData;                                // 0x0628(0x0058)(NativeAccessSpecifierPublic)
	struct FUserTutorialData                      _UserTutorialData;                                 // 0x0680(0x00A8)(NativeAccessSpecifierPublic)
	struct FUserDriverData                        _UserDriverData;                                   // 0x0728(0x0050)(NativeAccessSpecifierPublic)
	struct FUserHintData                          _UserHintData;                                     // 0x0778(0x0018)(NativeAccessSpecifierPublic)
	TArray<struct FUserAssistData>                _UserAssistData;                                   // 0x0790(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FUserRewardGetDisplayRequestData       _UserRewardGetDisplayRequestData;                  // 0x07A0(0x0010)(NativeAccessSpecifierPublic)
	struct FStatsSaveData                         _StatsData;                                        // 0x07B0(0x0140)(NativeAccessSpecifierPublic)
	struct FAppFriendUserData                     _AppFriendUserData;                                // 0x08F0(0x0078)(NativeAccessSpecifierPublic)
	struct FUserNoticeData                        _AppNoticeData;                                    // 0x0968(0x0018)(NativeAccessSpecifierPublic)
	struct FUserPartyRaceData                     _UserPartyRaceData;                                // 0x0980(0x0120)(NativeAccessSpecifierPublic)
	struct FUserPartyRaceRivalData                _UserPartyRaceRivalData;                           // 0x0AA0(0x0004)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA4[0x4];                                      // 0x0AA4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUserHonorTitleData                    _UserHonorTitleData;                               // 0x0AA8(0x0068)(NativeAccessSpecifierPublic)
	struct FUserCustomLapBGMData                  _UserCustomLapBGMData;                             // 0x0B10(0x0010)(NativeAccessSpecifierPublic)
	struct FUserJukeboxData                       _UserJukeboxData;                                  // 0x0B20(0x00A8)(NativeAccessSpecifierPublic)
	struct FUserFriendShipData                    _UserFriendShipData;                               // 0x0BC8(0x0050)(NativeAccessSpecifierPublic)
	struct FUserGadgetCustomizeData               _UserGadgetCustomizeData;                          // 0x0C18(0x0001)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C19[0x7];                                      // 0x0C19(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUserActivityCardFlagData              _UserActivityCardFlagData;                         // 0x0C20(0x0028)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FCompensationData                      _CompensationData;                                 // 0x0C48(0x0010)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppSaveGame">();
	}
	static class UAppSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppSaveGame>();
	}
};
static_assert(alignof(UAppSaveGame) == 0x000008, "Wrong alignment on UAppSaveGame");
static_assert(sizeof(UAppSaveGame) == 0x000C58, "Wrong size on UAppSaveGame");
static_assert(offsetof(UAppSaveGame, _Header) == 0x000028, "Member 'UAppSaveGame::_Header' has a wrong offset!");
static_assert(offsetof(UAppSaveGame, _UserCommonData) == 0x000038, "Member 'UAppSaveGame::_UserCommonData' has a wrong offset!");
static_assert(offsetof(UAppSaveGame, _UserMachineAssemblyData) == 0x0000B0, "Member 'UAppSaveGame::_UserMachineAssemblyData' has a wrong offset!");
static_assert(offsetof(UAppSaveGame, _UserGrandPrixData) == 0x000440, "Member 'UAppSaveGame::_UserGrandPrixData' has a wrong offset!");
static_assert(offsetof(UAppSaveGame, _UserTimeTrialData) == 0x000610, "Member 'UAppSaveGame::_UserTimeTrialData' has a wrong offset!");
static_assert(offsetof(UAppSaveGame, _UserChallengeData) == 0x000628, "Member 'UAppSaveGame::_UserChallengeData' has a wrong offset!");
static_assert(offsetof(UAppSaveGame, _UserTutorialData) == 0x000680, "Member 'UAppSaveGame::_UserTutorialData' has a wrong offset!");
static_assert(offsetof(UAppSaveGame, _UserDriverData) == 0x000728, "Member 'UAppSaveGame::_UserDriverData' has a wrong offset!");
static_assert(offsetof(UAppSaveGame, _UserHintData) == 0x000778, "Member 'UAppSaveGame::_UserHintData' has a wrong offset!");
static_assert(offsetof(UAppSaveGame, _UserAssistData) == 0x000790, "Member 'UAppSaveGame::_UserAssistData' has a wrong offset!");
static_assert(offsetof(UAppSaveGame, _UserRewardGetDisplayRequestData) == 0x0007A0, "Member 'UAppSaveGame::_UserRewardGetDisplayRequestData' has a wrong offset!");
static_assert(offsetof(UAppSaveGame, _StatsData) == 0x0007B0, "Member 'UAppSaveGame::_StatsData' has a wrong offset!");
static_assert(offsetof(UAppSaveGame, _AppFriendUserData) == 0x0008F0, "Member 'UAppSaveGame::_AppFriendUserData' has a wrong offset!");
static_assert(offsetof(UAppSaveGame, _AppNoticeData) == 0x000968, "Member 'UAppSaveGame::_AppNoticeData' has a wrong offset!");
static_assert(offsetof(UAppSaveGame, _UserPartyRaceData) == 0x000980, "Member 'UAppSaveGame::_UserPartyRaceData' has a wrong offset!");
static_assert(offsetof(UAppSaveGame, _UserPartyRaceRivalData) == 0x000AA0, "Member 'UAppSaveGame::_UserPartyRaceRivalData' has a wrong offset!");
static_assert(offsetof(UAppSaveGame, _UserHonorTitleData) == 0x000AA8, "Member 'UAppSaveGame::_UserHonorTitleData' has a wrong offset!");
static_assert(offsetof(UAppSaveGame, _UserCustomLapBGMData) == 0x000B10, "Member 'UAppSaveGame::_UserCustomLapBGMData' has a wrong offset!");
static_assert(offsetof(UAppSaveGame, _UserJukeboxData) == 0x000B20, "Member 'UAppSaveGame::_UserJukeboxData' has a wrong offset!");
static_assert(offsetof(UAppSaveGame, _UserFriendShipData) == 0x000BC8, "Member 'UAppSaveGame::_UserFriendShipData' has a wrong offset!");
static_assert(offsetof(UAppSaveGame, _UserGadgetCustomizeData) == 0x000C18, "Member 'UAppSaveGame::_UserGadgetCustomizeData' has a wrong offset!");
static_assert(offsetof(UAppSaveGame, _UserActivityCardFlagData) == 0x000C20, "Member 'UAppSaveGame::_UserActivityCardFlagData' has a wrong offset!");
static_assert(offsetof(UAppSaveGame, _CompensationData) == 0x000C48, "Member 'UAppSaveGame::_CompensationData' has a wrong offset!");

// Class UnionSystem.AppTimeSubsystem
// 0x0050 (0x0080 - 0x0030)
class UAppTimeSubsystem final : public UGameInstanceSubsystem
{
public:
	TMap<class FName, struct FDateTime>           NamedDateTime;                                     // 0x0030(0x0050)(NativeAccessSpecifierPrivate)

public:
	void AddNamedDateTimeNow(const class FName& InTimeName);
	bool GetTimeSpanMillisecondsByNamedDateTimes(const class FName& InBeginTimeName, const class FName& InEndTimeName, int32* OutTimeSpan);
	void LogTimeSpanMillisecondsByNamedDateTimes(const class FName& InBeginTimeName, const class FName& InEndTimeName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppTimeSubsystem">();
	}
	static class UAppTimeSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppTimeSubsystem>();
	}
};
static_assert(alignof(UAppTimeSubsystem) == 0x000008, "Wrong alignment on UAppTimeSubsystem");
static_assert(sizeof(UAppTimeSubsystem) == 0x000080, "Wrong size on UAppTimeSubsystem");
static_assert(offsetof(UAppTimeSubsystem, NamedDateTime) == 0x000030, "Member 'UAppTimeSubsystem::NamedDateTime' has a wrong offset!");

// Class UnionSystem.AppTimeUtil
// 0x0000 (0x0028 - 0x0028)
class UAppTimeUtil final : public UBlueprintFunctionLibrary
{
public:
	static void AddNamedDateTimeNow(const class FName& InTimeName);
	static class FText LocalizeDateTimePlaceholder(const class FText& BaseText, const struct FDateTime& StartDateUTCTime, const struct FDateTime& EndDateUTCTime);
	static void LogTimeSpanMillisecondsByNamedDateTimes(const class FName& InBeginTimeName, const class FName& InEndTimeName);
	static class FText MakeDateText(const struct FDateTime& DateTime);
	static class FText MakeDateTimeText(const struct FDateTime& DateTime);
	static struct FTimespan Sub_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B);
	static bool UnionDateTimeParse(class FString& DateTimeString, struct FDateTime* OutDateTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppTimeUtil">();
	}
	static class UAppTimeUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppTimeUtil>();
	}
};
static_assert(alignof(UAppTimeUtil) == 0x000008, "Wrong alignment on UAppTimeUtil");
static_assert(sizeof(UAppTimeUtil) == 0x000028, "Wrong size on UAppTimeUtil");

// Class UnionSystem.AppViewUtil
// 0x0000 (0x0028 - 0x0028)
class UAppViewUtil final : public UBlueprintFunctionLibrary
{
public:
	static EViewSplitId CalcViewSplitId(int32 InPlayerControllerIndex, int32 InSelectedPlayerCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppViewUtil">();
	}
	static class UAppViewUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppViewUtil>();
	}
};
static_assert(alignof(UAppViewUtil) == 0x000008, "Wrong alignment on UAppViewUtil");
static_assert(sizeof(UAppViewUtil) == 0x000028, "Wrong size on UAppViewUtil");

// Class UnionSystem.AuthSubsystem
// 0x00F0 (0x0120 - 0x0030)
class UAuthSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0xF0];                                      // 0x0030(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DebugGetOnlineToken(const class FString& Endpoint, int32 LocalUserNum);
	void DebugPrintLoggedInUserInfo(int32 LocalUserNum);
	bool GetOnlineToken(int32 LocalUserNum, class FString* outToken);
	bool GetOnlineTokenFromnUniqueNetId(const struct FUniqueNetIdRepl& UserId, class FString* outToken);
	void OnCompleteUserGetDataRequest(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error);
	void SetCachedAppUserBaseData(const struct FUserGetDataResponse& Response);
	void SetCachedAppUserFairPlayPointData(const struct FFairPointCheckFairPointResponse& Response);
	void SetupCachedAppUserBaseData();
	void StartLogin(int32 LocalUserNum, TDelegate<void(int32 LocalUserNum, bool bWasSuccessful, const class FString& ErrorMessage)> OnComplete);
	void StartLogout(int32 LocalUserNum, TDelegate<void(int32 LocalUserNum, bool bWasSuccessful)> OnComplete);

	struct FUniqueNetIdRepl CreatePlatformUniquePlayerId(const class FString& PlayerIdString) const;
	struct FUniqueNetIdRepl CreateUniquePlayerId(const class FString& PlayerIdString) const;
	class FString GetAuthenticatedWith(int32 LocalUserNum) const;
	const struct FAppUserBaseData GetCachedAppUserBaseData() const;
	class FString GetEOSAuthToken(int32 LocalUserNum) const;
	class FString GetExternalAccountId(int32 LocalUserNum) const;
	class FString GetLoggedInPlayerNickname(int32 LocalUserNum) const;
	struct FUniqueNetIdRepl GetLoggedInUserId(int32 LocalUserNum) const;
	class FString GetLoggedInUserIdString(int32 LocalUserNum) const;
	class FString GetOnlineEnvironment(int32 LocalUserNum) const;
	class FString GetPlatformToken(int32 LocalUserNum) const;
	bool IsLoggedIn(int32 LocalUserNum) const;
	bool IsMatchLoggedInUserId(const class FString& ProductUserId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthSubsystem">();
	}
	static class UAuthSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthSubsystem>();
	}
};
static_assert(alignof(UAuthSubsystem) == 0x000008, "Wrong alignment on UAuthSubsystem");
static_assert(sizeof(UAuthSubsystem) == 0x000120, "Wrong size on UAuthSubsystem");

// Class UnionSystem.BPFL_AppInputUtil
// 0x0000 (0x0028 - 0x0028)
class UBPFL_AppInputUtil final : public UBlueprintFunctionLibrary
{
public:
	static class AAppPlayerController* GetAppPlayerController(int32 ControllerId);
	static bool IsRegisteredMenuObject(int32 InPlayerIndex, class UObject* MenuObject);
	static void UnRegisterMenuObject(int32 InPlayerIndex, class UObject* MenuObject, EAppInputValid* OutputPin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPFL_AppInputUtil">();
	}
	static class UBPFL_AppInputUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPFL_AppInputUtil>();
	}
};
static_assert(alignof(UBPFL_AppInputUtil) == 0x000008, "Wrong alignment on UBPFL_AppInputUtil");
static_assert(sizeof(UBPFL_AppInputUtil) == 0x000028, "Wrong size on UBPFL_AppInputUtil");

// Class UnionSystem.BPFL_AutoPlay
// 0x0000 (0x0028 - 0x0028)
class UBPFL_AutoPlay final : public UBlueprintFunctionLibrary
{
public:
	static void DoInputKey(class APlayerController* Controller, const struct FKey& Key, EInputEvent EventType, double Delta, bool bGamepad);
	static void DoInputMenu(class AAppPlayerController* AppController, EMenuInputKey InKey);
	static void DoInputRacePressed(class ARacePlayerController* RaceController, ERaceInputKey InKey, float Amount);
	static void DoInputRaceReleased(class ARacePlayerController* RaceController, ERaceInputKey InKey);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPFL_AutoPlay">();
	}
	static class UBPFL_AutoPlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPFL_AutoPlay>();
	}
};
static_assert(alignof(UBPFL_AutoPlay) == 0x000008, "Wrong alignment on UBPFL_AutoPlay");
static_assert(sizeof(UBPFL_AutoPlay) == 0x000028, "Wrong size on UBPFL_AutoPlay");

// Class UnionSystem.CollectHelper
// 0x0000 (0x0028 - 0x0028)
class UCollectHelper final : public UBlueprintFunctionLibrary
{
public:
	static class FString CollectBytesData(const class FString& Name_0, const class FString& Suffix, const TArray<uint8>& Data);
	static class FString CollectCacheDirectory();
	static class FString CollectChangeList();
	static bool CollectCheckEnabled();
	static class FString CollectLevelName();
	static class FString CollectScreenShot(const class FString& Name_0);
	static class FString CollectStringData(const class FString& Name_0, const class FString& Suffix, const class FString& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectHelper">();
	}
	static class UCollectHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectHelper>();
	}
};
static_assert(alignof(UCollectHelper) == 0x000008, "Wrong alignment on UCollectHelper");
static_assert(sizeof(UCollectHelper) == 0x000028, "Wrong size on UCollectHelper");

// Class UnionSystem.CryptoHelper
// 0x0000 (0x0028 - 0x0028)
class UCryptoHelper final : public UBlueprintFunctionLibrary
{
public:
	static class FString DecryptFromTextString(const class FString& Data, const class FString& HexKey, const class FString& Vector);
	static class FString EncryptFromByteArrayIntoTextString(const TArray<uint8>& Bytes, const class FString& HexKey, const class FString& Vector);
	static class FString EncryptIntoTextString(const class FString& Data, const class FString& HexKey, const class FString& Vector);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CryptoHelper">();
	}
	static class UCryptoHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCryptoHelper>();
	}
};
static_assert(alignof(UCryptoHelper) == 0x000008, "Wrong alignment on UCryptoHelper");
static_assert(sizeof(UCryptoHelper) == 0x000028, "Wrong size on UCryptoHelper");

// Class UnionSystem.DataCollectSubsystem
// 0x00F0 (0x0120 - 0x0030)
class UDataCollectSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0xF0];                                      // 0x0030(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString CollectBytesData(const class FString& Name_0, const class FString& Suffix, const TArray<uint8>& Data);
	class FString CollectCacheDirectory();
	bool CollectCheckEnabled();
	class FString CollectLevelName();
	class FString CollectScreenShot(const class FString& Name_0);
	class FString CollectStringData(const class FString& Name_0, const class FString& Suffix, const class FString& Data);

	class FString CollectChangeList() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DataCollectSubsystem">();
	}
	static class UDataCollectSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDataCollectSubsystem>();
	}
};
static_assert(alignof(UDataCollectSubsystem) == 0x000008, "Wrong alignment on UDataCollectSubsystem");
static_assert(sizeof(UDataCollectSubsystem) == 0x000120, "Wrong size on UDataCollectSubsystem");

// Class UnionSystem.DebugImportantLogLine
// 0x0000 (0x02E0 - 0x02E0)
class UDebugImportantLogLine final : public UUserWidget
{
public:
	void SetLog(const class FString& ClassName, const class FString& LogString, const class FString& DateTimeString);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugImportantLogLine">();
	}
	static class UDebugImportantLogLine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugImportantLogLine>();
	}
};
static_assert(alignof(UDebugImportantLogLine) == 0x000008, "Wrong alignment on UDebugImportantLogLine");
static_assert(sizeof(UDebugImportantLogLine) == 0x0002E0, "Wrong size on UDebugImportantLogLine");

// Class UnionSystem.DebugImportantLogPanel
// 0x0008 (0x02E8 - 0x02E0)
class UDebugImportantLogPanel final : public UUserWidget
{
public:
	int32                                         MaxEntryCount;                                     // 0x02E0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddLog(const class FString& ClassName, const class FString& LogString, const class FString& DateTimeString);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugImportantLogPanel">();
	}
	static class UDebugImportantLogPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugImportantLogPanel>();
	}
};
static_assert(alignof(UDebugImportantLogPanel) == 0x000008, "Wrong alignment on UDebugImportantLogPanel");
static_assert(sizeof(UDebugImportantLogPanel) == 0x0002E8, "Wrong size on UDebugImportantLogPanel");
static_assert(offsetof(UDebugImportantLogPanel, MaxEntryCount) == 0x0002E0, "Member 'UDebugImportantLogPanel::MaxEntryCount' has a wrong offset!");

// Class UnionSystem.DebugImportantLogSubsystem
// 0x0010 (0x0040 - 0x0030)
class UDebugImportantLogSubsystem final : public UGameInstanceSubsystem
{
public:
	class UDebugImportantLogPanel*                ImportantLogPanel;                                 // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPanelVisibility;                                  // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddImportantLog(const class FString& LogLocation, const class FString& LogString);
	class UDebugImportantLogPanel* GetImportantLogPanel();
	void SetImportantLogCount(int32 NewCount);
	void SetImportantLogPanelVisible(bool bNewVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugImportantLogSubsystem">();
	}
	static class UDebugImportantLogSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugImportantLogSubsystem>();
	}
};
static_assert(alignof(UDebugImportantLogSubsystem) == 0x000008, "Wrong alignment on UDebugImportantLogSubsystem");
static_assert(sizeof(UDebugImportantLogSubsystem) == 0x000040, "Wrong size on UDebugImportantLogSubsystem");
static_assert(offsetof(UDebugImportantLogSubsystem, ImportantLogPanel) == 0x000030, "Member 'UDebugImportantLogSubsystem::ImportantLogPanel' has a wrong offset!");
static_assert(offsetof(UDebugImportantLogSubsystem, bPanelVisibility) == 0x000038, "Member 'UDebugImportantLogSubsystem::bPanelVisibility' has a wrong offset!");

// Class UnionSystem.DebugImportantLogUtil
// 0x0000 (0x0028 - 0x0028)
class UDebugImportantLogUtil final : public UBlueprintFunctionLibrary
{
public:
	static void AddImportantLog(const class FString& LogLocation, const class FString& LogString);
	static void SetImportantLogCount(int32 NewCount);
	static void SetImportantLogVisible(bool bNewVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugImportantLogUtil">();
	}
	static class UDebugImportantLogUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugImportantLogUtil>();
	}
};
static_assert(alignof(UDebugImportantLogUtil) == 0x000008, "Wrong alignment on UDebugImportantLogUtil");
static_assert(sizeof(UDebugImportantLogUtil) == 0x000028, "Wrong size on UDebugImportantLogUtil");

// Class UnionSystem.DebugOnlineAutoPlaySetting
// 0x0000 (0x0028 - 0x0028)
class UDebugOnlineAutoPlaySetting final : public UBlueprintFunctionLibrary
{
public:
	static int32 GetDebugAutoPlayMode();
	static bool IsDebugAutoPlay();
	static bool IsDebugAutoPlayShortRace();
	static void SetDebugAutoPlay(bool flg);
	static void SetDebugAutoPlayMode(int32 Mode);
	static void SetDebugAutoPlayShortRace(bool flg);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugOnlineAutoPlaySetting">();
	}
	static class UDebugOnlineAutoPlaySetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugOnlineAutoPlaySetting>();
	}
};
static_assert(alignof(UDebugOnlineAutoPlaySetting) == 0x000008, "Wrong alignment on UDebugOnlineAutoPlaySetting");
static_assert(sizeof(UDebugOnlineAutoPlaySetting) == 0x000028, "Wrong size on UDebugOnlineAutoPlaySetting");

// Class UnionSystem.DeviceChangeInterface
// 0x0000 (0x0000 - 0x0000)
class IDeviceChangeInterface final
{
public:
	void ChangeInputTypeIF(EAppControllerInputType InNewControllerInputType);
	void ChangeKeyboardLayoutIF(uint8 InNewKeyboardLayout, uint8 InNewKeytopPattern);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeviceChangeInterface">();
	}
	static class IDeviceChangeInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDeviceChangeInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IDeviceChangeInterface) == 0x000001, "Wrong alignment on IDeviceChangeInterface");
static_assert(sizeof(IDeviceChangeInterface) == 0x000001, "Wrong size on IDeviceChangeInterface");

// Class UnionSystem.DriverIdUtilityLibrary
// 0x0000 (0x0028 - 0x0028)
class UDriverIdUtilityLibrary final : public UBlueprintFunctionLibrary
{
public:
	static EDriverId GetRaceRivalDriverId(EGameModeId GameModeID, EDriverId InDriverId);
	static EDriverId GetRivalDriverId(EDriverId InDriverId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DriverIdUtilityLibrary">();
	}
	static class UDriverIdUtilityLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDriverIdUtilityLibrary>();
	}
};
static_assert(alignof(UDriverIdUtilityLibrary) == 0x000008, "Wrong alignment on UDriverIdUtilityLibrary");
static_assert(sizeof(UDriverIdUtilityLibrary) == 0x000028, "Wrong size on UDriverIdUtilityLibrary");

// Class UnionSystem.LobbyMemberContextBase
// 0x0078 (0x00A0 - 0x0028)
class ULobbyMemberContextBase : public UObject
{
public:
	class ULobbyContextBase*                      LobbyContext;                                      // 0x0028(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULobbyMemberTransactionParam*           TransactionParam;                                  // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x68];                                      // 0x0038(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BeginTransaction();
	bool EndTransaction(TDelegate<void(bool bSuccessful, const struct FLobbyOperationResult& Result)> OnComplete);
	bool EndTransaction_NoCallback();
	void OnMemberUpdateInternal();
	void OnUpdateMemberSelfComplete(bool bSuccessful, const struct FLobbyOperationResult& Result, TDelegate<void(bool bSuccessful, const struct FLobbyOperationResult& Result)> OnComplete);
	void SetupLocalMemberAttributeInternal();

	bool Compare(class ULobbyMemberContextBase* Other) const;
	bool GetAppUserBaseData(struct FAppUserBaseData* OutAppUserBaseData) const;
	class FString GetInternalUserId() const;
	int32 GetLobbyMemberIndex() const;
	bool GetSystemMiscVersions(int32* romType, int32* RomVersion, int32* MasterDataVersion) const;
	void GetUserIdRepl(struct FUniqueNetIdRepl* OutResult) const;
	void GetUserIdString(class FString* OutResult) const;
	bool IsCom() const;
	bool IsLobbyHost() const;
	bool IsLocalUser() const;
	bool IsValetCom() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyMemberContextBase">();
	}
	static class ULobbyMemberContextBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyMemberContextBase>();
	}
};
static_assert(alignof(ULobbyMemberContextBase) == 0x000008, "Wrong alignment on ULobbyMemberContextBase");
static_assert(sizeof(ULobbyMemberContextBase) == 0x0000A0, "Wrong size on ULobbyMemberContextBase");
static_assert(offsetof(ULobbyMemberContextBase, LobbyContext) == 0x000028, "Member 'ULobbyMemberContextBase::LobbyContext' has a wrong offset!");
static_assert(offsetof(ULobbyMemberContextBase, TransactionParam) == 0x000030, "Member 'ULobbyMemberContextBase::TransactionParam' has a wrong offset!");

// Class UnionSystem.MatchmakingRequestMemberContext
// 0x0000 (0x00A0 - 0x00A0)
class UMatchmakingRequestMemberContext : public ULobbyMemberContextBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchmakingRequestMemberContext">();
	}
	static class UMatchmakingRequestMemberContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchmakingRequestMemberContext>();
	}
};
static_assert(alignof(UMatchmakingRequestMemberContext) == 0x000008, "Wrong alignment on UMatchmakingRequestMemberContext");
static_assert(sizeof(UMatchmakingRequestMemberContext) == 0x0000A0, "Wrong size on UMatchmakingRequestMemberContext");

// Class UnionSystem.DummyMatchmakingMemberContext
// 0x0000 (0x00A0 - 0x00A0)
class UDummyMatchmakingMemberContext final : public UMatchmakingRequestMemberContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DummyMatchmakingMemberContext">();
	}
	static class UDummyMatchmakingMemberContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDummyMatchmakingMemberContext>();
	}
};
static_assert(alignof(UDummyMatchmakingMemberContext) == 0x000008, "Wrong alignment on UDummyMatchmakingMemberContext");
static_assert(sizeof(UDummyMatchmakingMemberContext) == 0x0000A0, "Wrong size on UDummyMatchmakingMemberContext");

// Class UnionSystem.EnhancedInputHelper
// 0x0000 (0x0028 - 0x0028)
class UEnhancedInputHelper final : public UBlueprintFunctionLibrary
{
public:
	static void ExchangeInputKey(class UInputMappingContext* InputMappingContext, const struct FEnhancedActionKeyMapping& BeforeMapping, const struct FKey& AfterKey);
	static TArray<struct FEnhancedActionKeyMapping> GetEnhancedActionKeyMappingByName(class UInputMappingContext* InputMappingContext, const class FName& InputName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnhancedInputHelper">();
	}
	static class UEnhancedInputHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnhancedInputHelper>();
	}
};
static_assert(alignof(UEnhancedInputHelper) == 0x000008, "Wrong alignment on UEnhancedInputHelper");
static_assert(sizeof(UEnhancedInputHelper) == 0x000028, "Wrong size on UEnhancedInputHelper");

// Class UnionSystem.FestaUIDataAsset
// 0x0058 (0x0088 - 0x0030)
class UFestaUIDataAsset final : public UDataAsset
{
public:
	class UDataTable*                             FestaUIDataTable;                                  // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FFestaUIData>        FestaUITableDataMap;                               // 0x0038(0x0050)(NativeAccessSpecifierPrivate)

public:
	void ClearData();
	const TArray<struct FFestaTeamUIData> GetFestaUITableDataTeamUIDataArray(int32 InFestaId);
	const struct FFestaTeamUIData GetFestaUITableDataTeamUIDataArrayIndex(class FName RowName, int32 Index_0);
	const TArray<TSoftObjectPtr<class UTexture2D>> GetFestaUITableSignageTex(class FName RowName);
	void GetFestaUITeamUIDataByGroupColorId(int32 TeamId, EGroupColorId GroupColorID, TArray<struct FFestaTeamUIData>* ArrayData, bool* IsFound);
	bool IsFestaUITableDataTeamUIDataArrayIndexFound(class FName RowName, int32 Index_0);
	void Update();

	void GetFestaUIData(int32 festaId, bool* bFoundData, struct FFestaUIData* FestaUIData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FestaUIDataAsset">();
	}
	static class UFestaUIDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFestaUIDataAsset>();
	}
};
static_assert(alignof(UFestaUIDataAsset) == 0x000008, "Wrong alignment on UFestaUIDataAsset");
static_assert(sizeof(UFestaUIDataAsset) == 0x000088, "Wrong size on UFestaUIDataAsset");
static_assert(offsetof(UFestaUIDataAsset, FestaUIDataTable) == 0x000030, "Member 'UFestaUIDataAsset::FestaUIDataTable' has a wrong offset!");
static_assert(offsetof(UFestaUIDataAsset, FestaUITableDataMap) == 0x000038, "Member 'UFestaUIDataAsset::FestaUITableDataMap' has a wrong offset!");

// Class UnionSystem.FestaUtil
// 0x0000 (0x0028 - 0x0028)
class UFestaUtil final : public UBlueprintFunctionLibrary
{
public:
	static int32 ConvertFestaIdToTypeId(const int32 festaId);
	static class FText GetFestaChanceUpRatioText(int32 Ratio);
	static EGroupColorId GetFestaGroupColorId(int32 festaId, int32 GroupIndex);
	static int32 GetFestaIdUtil();
	static struct FColor GetFestaMainColor(int32 GroupIndex);
	static class FText GetFestaPointText(int32 Point);
	static class FText GetFestaRentalPlateText(const class FText& TargetGadgetname);
	static struct FUIColorInfo GetFestaUIColorInfo(int32 festaId, int32 GroupIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FestaUtil">();
	}
	static class UFestaUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFestaUtil>();
	}
};
static_assert(alignof(UFestaUtil) == 0x000008, "Wrong alignment on UFestaUtil");
static_assert(sizeof(UFestaUtil) == 0x000028, "Wrong size on UFestaUtil");

// Class UnionSystem.FlagFileManager
// 0x0148 (0x0178 - 0x0030)
class UFlagFileManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x148];                                     // 0x0030(0x0148)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlagFileManager">();
	}
	static class UFlagFileManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlagFileManager>();
	}
};
static_assert(alignof(UFlagFileManager) == 0x000008, "Wrong alignment on UFlagFileManager");
static_assert(sizeof(UFlagFileManager) == 0x000178, "Wrong size on UFlagFileManager");

// Class UnionSystem.FriendSubsystem
// 0x0CA0 (0x0CD0 - 0x0030)
class UFriendSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0xCA0];                                     // 0x0030(0x0CA0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBlockPlayer(const class FString& ProductUserId, TDelegate<void(EBlockPlayerErrorCode ErrorCode, const class FString& ProductUserId)> OnComplete);
	void AddReceivedLobbyInvitationCount();
	void AddRecentPlayers(int32 LocalUserNum, TArray<struct FUniqueNetIdRepl>& IdList, const class FString& Date);
	void CallOnGetFriendInfoComplete(bool bWasSuccessful, const TArray<class FString>& ExternalIds, const TArray<class FString>& ConvertedIds);
	void ClearFinishedForceUpdateFriendListFlag();
	void ClearRecentPlayer();
	bool ContainsBlockPlayer(const TArray<class FString>& ProductUserIds, TArray<class FString>* OutBlockPlayerIds);
	bool ConvertPlatformIdToUserIdRequest(TArray<struct FUniqueNetIdRepl>& IdList, TDelegate<void(bool bWasSuccessful, const TArray<class FString>& ExternalIds, const TArray<class FString>& ConvertedIds)> OnComplete, bool ForceConvert);
	void DebugToggleBlockPlayerState(const class FString& ProductUserId);
	void DeleteBlockPlayer(const class FString& ProductUserId);
	void DeleteRecentPlayer(const class FString& ProductUserId);
	bool ForceUpdateFriendList();
	EAppSupportedPlatform GetAppSupportedPlatformByStringData(const class FString& InPlatformStr);
	void GetBlockPlayerList(TArray<class FString>* OutBlockPlayers, EBlockPlayerFilter Filter);
	EBlockPlayerState GetBlockPlayerState(const class FString& ProductUserId);
	void GetFriendInfo(const class FString& ProductUserId, TDelegate<void(bool PlatformFriend, bool TerraFriend, const class FString& userName, const struct FFriendCommonPart_FriendData& FriendData)> OnCompleted);
	ECrossplayPlatform GetPlatformTypeByStringData(const class FString& InPlatformStr);
	bool GetRecentPlayerList(TMap<class FString, class FString>* OutRecentPlayers);
	void GetRecentPlayerStatsSimple(TDelegate<void(bool bWasSuccessful, const TArray<struct FCommon_UserSearchData>& SearchDatas, EResponseCodeAbstract ResCodeAbstract)> OnCompleteDelegate);
	void GetTerraFriendCallback(bool bWasSuccessful, const struct FFriendGetFriendListResponse& list);
	bool GetTerraFriendList(TDelegate<void(bool bWasSuccessful, const struct FFriendGetFriendListResponse& list)> OnCompleteDelegate);
	int32 GetTerraFriendNum();
	void GetUserProfileGDK(int32 LocalUserNum, TArray<class FString>& XuidStrings, TDelegate<void(bool bWasSuccessful, EGetUserProfileError Error, const TArray<class FString>& GamerTags)> OnComplete);
	bool IsAcceptWaitPlayerExist();
	bool IsBlocked(const class FString& ProductUserId);
	bool IsEnableGetUserProfileGDK();
	bool IsFinishedForceUpdateFriendList();
	bool IsFriend(const class FString& ProductUserId);
	bool IsFriendRequestBlocked(int32 InFriendRequestErrorCode);
	bool IsPlatformFriend(const class FString& ProductUserId);
	bool IsSetPlatformBlockPlayers();
	bool IsTerraFriend(const class FString& ProductUserId);
	bool IsValidLobbyInvitation();
	void LobbyInvitationGetUserSearchData(const struct FUserGetUserSearchRequest& SearchRequest, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool SearchError)> Delegate);
	void MinusReceivedLobbyInvitationCount();
	void OnBlockPlayerIdMappingsComplete(bool bWasSuccessful, const TArray<class FString>& ExternalIds, const TArray<class FString>& ConvertedIds);
	void OnCompleteRequestCheckFairPoint(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error);
	void OnConvertBlockPlayerPuidToTerraIdComplete(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error);
	void OnConvertPuidToTerraIdComplete(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error);
	void OnGetTerraFriendLastDateComplete(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error);
	void OnGetTerraFriendListCheckPlayerNameComplete(bool bGetTerraFriendListError);
	void OnGetTerraFriendListComplete(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error);
	void OnLobbyInvitationGetUserSearchComplete(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error);
	void OnPlatformFriendIdMappingsComplete(bool bWasSuccessful, const TArray<class FString>& ExternalIds, const TArray<class FString>& ConvertedIds);
	void OnProductUserIdFriendRequestConvertComplete(bool bWasSuccessful, const TArray<class FString>& ExternalIds, const TArray<class FString>& ConvertedIds);
	void OnRequestCancelByBlockingCompleted(bool bWasSuccessful, int32 ErrorCode);
	void OnTerraFriendCommonComplete(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error);
	void OnTerraFriendListCheckPlayerNameComplete(bool bSuccess, const TArray<class FString>& PlayerNameList, bool bGetTerraFriendListError);
	void OnTerraFriendRequestComplete(bool bWasSuccessful, int32 ErrorCode);
	void OnTerraGetUserSearchCheckPlayerNameComplete(bool bCheckPlayerNameSuccess, const TArray<class FString>& PlayerNameList, EFriendsListUserSearchCacheType CacheType, EResponseCodeAbstract ResponseCodeAbstract, bool bSearchPlayerDataSuccess);
	void OnTerraGetUserSearchCompleteBlockPlayer(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error);
	void OnTerraGetUserSearchCompleteLobbyInvitation(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error);
	void OnTerraGetUserSearchCompletePFFriend(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error);
	void OnTerraGetUserSearchCompleteRecentPlayer(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error);
	void OnTerraGetUserSearchCompleteSearchLobbyID(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error);
	void OnTerraGetUserSearchCompleteSearchPlayerID(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error);
	void OnUnfriendByBlockingCompleted(bool bWasSuccessful, int32 ErrorCode);
	void OnUnfriendByPFBlockingCompleted(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error);
	void QueryReadPlatformBlockPlayers(TDelegate<void(bool bWasSuccessful)> OnComplete);
	void QueryReadPlatformFriends(int32 LocalUserNum, TDelegate<void(bool bWasSuccessful)> OnComplete);
	void RefreshBlockPlayers(TDelegate<void(bool bWasSuccessful)> OnComplete);
	void RequestCheckFairPoint();
	void ResetAllRequestDelegate();
	void ResetReceivedLobbyInvitationCount();
	void SetCacheExpiration(int32 Minutes);
	void SetReceivedLobbyInvitationCount(int32 LobbyInvitationCount);
	bool TerraFriendAccept(const class FString& TargetID, TDelegate<void(bool bWasSuccessful, int32 ErrorCode)> OnCompleteDelegate);
	bool TerraFriendReject(const class FString& TargetID, TDelegate<void(bool bWasSuccessful, int32 ErrorCode)> OnCompleteDelegate);
	bool TerraFriendRequest(const class FString& TargetID, TDelegate<void(bool bWasSuccessful, int32 ErrorCode)> OnCompleteDelegate);
	bool TerraFriendRequestByUserSearchData(const TArray<struct FCommon_UserSearchData>& UserSearchData, TDelegate<void(bool bWasSuccessful, int32 ErrorCode)> OnCompleteDelegate);
	bool TerraFriendRequestCancel(const class FString& TargetID, TDelegate<void(bool bWasSuccessful, int32 ErrorCode)> OnCompleteDelegate);
	bool TerraFriendsRequest(const TArray<class FString>& targetIds, TDelegate<void(bool bWasSuccessful, int32 ErrorCode)> OnCompleteDelegate);
	bool TerraFriendUnfriend(const class FString& TargetID, TDelegate<void(bool bWasSuccessful, int32 ErrorCode)> OnCompleteDelegate);
	bool TerraGetUserSearchRequest(const TArray<class FString>& TargetUserIds, int32 selectFlg, TDelegate<void(bool bWasSuccessful, const TArray<struct FCommon_UserSearchData>& SearchDatas, EResponseCodeAbstract ResCodeAbstract)> Delegate, EFriendsListUserSearchCacheType CacheType);

	bool GetNotifyFriendInvite() const;
	bool GetPlatformFriendDisplayName(const struct FUniqueNetIdRepl& UserId, class FString* OutResult) const;
	bool GetPlatformFriendList(TArray<struct FUniqueNetIdRepl>* OutPlatformFriendList) const;
	int32 GetReceivedLobbyInvitationCount() const;
	bool GetUserSearchDataByProductUserId(const class FString& ProductUserId, struct FCommon_UserSearchData* OutUserSearchData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendSubsystem">();
	}
	static class UFriendSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriendSubsystem>();
	}
};
static_assert(alignof(UFriendSubsystem) == 0x000008, "Wrong alignment on UFriendSubsystem");
static_assert(sizeof(UFriendSubsystem) == 0x000CD0, "Wrong size on UFriendSubsystem");

// Class UnionSystem.GameActivitySubsystem
// 0x0000 (0x0030 - 0x0030)
class UGameActivitySubsystem final : public UGameInstanceSubsystem
{
public:
	void ChangeActivityAvailability(int32 LocalUserNum, const struct FActivityObjectIdData& ActivityIdData, TDelegate<void(const struct FUniqueNetIdRepl& PlatformUserId, bool bSuccess)> OnComplete);
	void EndActivity(int32 LocalUserNum, const struct FActivityObjectIdData& ActivityIdData, const struct FEndActivityOption& Option, TDelegate<void(const struct FUniqueNetIdRepl& PlatformUserId, EGameModeId ActivityId, EGameActivityOutcomeType Outcome, bool bSuccess)> OnComplete);
	void StartActivity(int32 LocalUserNum, const struct FActivityObjectIdData& ActivityIdData, const struct FStartActivityOption& Option, TDelegate<void(const struct FUniqueNetIdRepl& PlatformUserId, EGameModeId ActivityId, bool bSuccess)> OnComplete);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameActivitySubsystem">();
	}
	static class UGameActivitySubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameActivitySubsystem>();
	}
};
static_assert(alignof(UGameActivitySubsystem) == 0x000008, "Wrong alignment on UGameActivitySubsystem");
static_assert(sizeof(UGameActivitySubsystem) == 0x000030, "Wrong size on UGameActivitySubsystem");

// Class UnionSystem.GameHttpSubsystem
// 0x03E0 (0x0410 - 0x0030)
class UGameHttpSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x280];                                     // 0x0030(0x0280)(Fixing Size After Last Property [ Dumper-7 ])
	struct FServerList                            ServerList;                                        // 0x02B0(0x0160)(NativeAccessSpecifierPrivate)

public:
	bool ReceiveFromServerRaw(int32 Handle, class FString* OutData, bool* OutError);
	int32 SendToServerRaw(const struct FGameHttpRequestOption& Option, const class FString& ApiName, const class FString& Data);
	void SendToServerRawCallbacked(const struct FGameHttpRequestOption& Option, const class FString& ApiName, const class FString& Data, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameHttpSubsystem">();
	}
	static class UGameHttpSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameHttpSubsystem>();
	}
};
static_assert(alignof(UGameHttpSubsystem) == 0x000008, "Wrong alignment on UGameHttpSubsystem");
static_assert(sizeof(UGameHttpSubsystem) == 0x000410, "Wrong size on UGameHttpSubsystem");
static_assert(offsetof(UGameHttpSubsystem, ServerList) == 0x0002B0, "Member 'UGameHttpSubsystem::ServerList' has a wrong offset!");

// Class UnionSystem.GhostDataController
// 0x04F8 (0x0520 - 0x0028)
class UGhostDataController final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool IsError, EUploadState UploadState)> CompleteUpload;           // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              FinishUpload;                                      // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UGhostUploader*                         m_ghostUploader;                                   // 0x0050(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGhostResultUploader*                   m_resultUploader;                                  // 0x0058(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x4C0];                                     // 0x0060(0x04C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CancelUpload();
	void Deinitialize();
	void SetCurrentStageVersion(const int32& InCurrentStageVersion);
	void SetUploadStageIds(const ESpeedClassId SpeedClass, const TArray<EStageId>& StageIds);
	bool StartUpload();

	EResponseCodeAbstract GetResponseCode() const;
	int32 GetUploadCount() const;
	class FString GetUploadDateTime() const;
	int32 GetUploadMaxCount() const;
	float GetUploadRate() const;
	ESpeedClassId GetUploadSpeedClassId() const;
	EStageId GetUploadStageId() const;
	bool IsBusy() const;
	bool IsCancel() const;
	bool IsGhostDataError() const;
	bool IsResponceCheat() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GhostDataController">();
	}
	static class UGhostDataController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGhostDataController>();
	}
};
static_assert(alignof(UGhostDataController) == 0x000008, "Wrong alignment on UGhostDataController");
static_assert(sizeof(UGhostDataController) == 0x000520, "Wrong size on UGhostDataController");
static_assert(offsetof(UGhostDataController, CompleteUpload) == 0x000030, "Member 'UGhostDataController::CompleteUpload' has a wrong offset!");
static_assert(offsetof(UGhostDataController, FinishUpload) == 0x000040, "Member 'UGhostDataController::FinishUpload' has a wrong offset!");
static_assert(offsetof(UGhostDataController, m_ghostUploader) == 0x000050, "Member 'UGhostDataController::m_ghostUploader' has a wrong offset!");
static_assert(offsetof(UGhostDataController, m_resultUploader) == 0x000058, "Member 'UGhostDataController::m_resultUploader' has a wrong offset!");

// Class UnionSystem.GhostDebugMenu
// 0x0028 (0x0050 - 0x0028)
class UGhostDebugMenu final : public UObject
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GhostDebugMenu">();
	}
	static class UGhostDebugMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGhostDebugMenu>();
	}
};
static_assert(alignof(UGhostDebugMenu) == 0x000008, "Wrong alignment on UGhostDebugMenu");
static_assert(sizeof(UGhostDebugMenu) == 0x000050, "Wrong size on UGhostDebugMenu");

// Class UnionSystem.GhostDonwnloadController
// 0x00F8 (0x0388 - 0x0290)
class AGhostDonwnloadController : public AActor
{
public:
	TMulticastInlineDelegate<void(bool OutIsError)> FinishDownload;                                  // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              FailedDownload;                                    // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B0[0x28];                                     // 0x02B0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UGhostDownloader*                       m_ghostDownloader;                                 // 0x02D8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E0[0xA8];                                     // 0x02E0(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CancelDownload();
	bool ConvertGhostData(struct FReplaySaveInfo* OutGhostData);
	float GetDownloadRate();
	bool StartDownload(const class FString& UserId, const ESpeedClassId SpeedClass, const EStageId StageId, const class FString& DateTime, const int32& StageVersion);

	EResponseCodeAbstract GetResponseCode() const;
	bool IsBusy() const;
	bool IsCancel() const;
	bool IsGhostDownloading() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GhostDonwnloadController">();
	}
	static class AGhostDonwnloadController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGhostDonwnloadController>();
	}
};
static_assert(alignof(AGhostDonwnloadController) == 0x000008, "Wrong alignment on AGhostDonwnloadController");
static_assert(sizeof(AGhostDonwnloadController) == 0x000388, "Wrong size on AGhostDonwnloadController");
static_assert(offsetof(AGhostDonwnloadController, FinishDownload) == 0x000290, "Member 'AGhostDonwnloadController::FinishDownload' has a wrong offset!");
static_assert(offsetof(AGhostDonwnloadController, FailedDownload) == 0x0002A0, "Member 'AGhostDonwnloadController::FailedDownload' has a wrong offset!");
static_assert(offsetof(AGhostDonwnloadController, m_ghostDownloader) == 0x0002D8, "Member 'AGhostDonwnloadController::m_ghostDownloader' has a wrong offset!");

// Class UnionSystem.GhostDownloader
// 0x00B8 (0x00E0 - 0x0028)
class UGhostDownloader final : public UObject
{
public:
	TDelegate<void(int32 ResCode, int32 ContentLength, float ElapsedTime, bool Error)> m_completeDelegate; // 0x0028(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TDelegate<void(int32 Length, float Rate)>     m_progressDelegate;                                // 0x0038(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x98];                                      // 0x0048(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCompleteDelegate(int32 ResCode, int32 ContentLength, float ElapsedTime, bool bIsError);
	void OnProgressDelegate(int32 Length, float Rate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GhostDownloader">();
	}
	static class UGhostDownloader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGhostDownloader>();
	}
};
static_assert(alignof(UGhostDownloader) == 0x000008, "Wrong alignment on UGhostDownloader");
static_assert(sizeof(UGhostDownloader) == 0x0000E0, "Wrong size on UGhostDownloader");
static_assert(offsetof(UGhostDownloader, m_completeDelegate) == 0x000028, "Member 'UGhostDownloader::m_completeDelegate' has a wrong offset!");
static_assert(offsetof(UGhostDownloader, m_progressDelegate) == 0x000038, "Member 'UGhostDownloader::m_progressDelegate' has a wrong offset!");

// Class UnionSystem.GhostResultUploader
// 0x0178 (0x01A0 - 0x0028)
class UGhostResultUploader final : public UObject
{
public:
	uint8                                         Pad_28[0x178];                                     // 0x0028(0x0178)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GhostResultUploader">();
	}
	static class UGhostResultUploader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGhostResultUploader>();
	}
};
static_assert(alignof(UGhostResultUploader) == 0x000008, "Wrong alignment on UGhostResultUploader");
static_assert(sizeof(UGhostResultUploader) == 0x0001A0, "Wrong size on UGhostResultUploader");

// Class UnionSystem.GhostSubSystem
// 0x01D0 (0x0200 - 0x0030)
class UGhostSubSystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGhostDebugMenu*                        m_GhostDebugMenu;                                  // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x50];                                      // 0x0040(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FReplaySaveInfo                        m_DownloadGhostData;                               // 0x0090(0x0140)(NativeAccessSpecifierPrivate)
	class FString                                 m_CurrentUserId;                                   // 0x01D0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ESpeedClassId                                 m_CurrentSpeedClassId;                             // 0x01E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EStageId                                      m_CurrentStageId;                                  // 0x01E1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E2[0x6];                                      // 0x01E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 m_CurrentDateTime;                                 // 0x01E8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F8[0x8];                                      // 0x01F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckCachedGhostDataUserMatch(const class FString& InUserId, const ESpeedClassId InSpeedClass, const EStageId InStageId, const class FString& InDateTime);
	bool GetDownloadGhostData(struct FReplaySaveInfo* OutGhostData);
	void ResetDownloadGhostData();
	void SetDownloadGhostData(const class FString& InUserId, const ESpeedClassId InSpeedClass, const EStageId InStageId, const class FString& InDateTime, const class FString& InRankingName, const struct FReplaySaveInfo& InGhostData);
	void SetGhostRequestFailed(bool InFailed);

	bool IsGhostRequestFailed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GhostSubSystem">();
	}
	static class UGhostSubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGhostSubSystem>();
	}
};
static_assert(alignof(UGhostSubSystem) == 0x000008, "Wrong alignment on UGhostSubSystem");
static_assert(sizeof(UGhostSubSystem) == 0x000200, "Wrong size on UGhostSubSystem");
static_assert(offsetof(UGhostSubSystem, m_GhostDebugMenu) == 0x000038, "Member 'UGhostSubSystem::m_GhostDebugMenu' has a wrong offset!");
static_assert(offsetof(UGhostSubSystem, m_DownloadGhostData) == 0x000090, "Member 'UGhostSubSystem::m_DownloadGhostData' has a wrong offset!");
static_assert(offsetof(UGhostSubSystem, m_CurrentUserId) == 0x0001D0, "Member 'UGhostSubSystem::m_CurrentUserId' has a wrong offset!");
static_assert(offsetof(UGhostSubSystem, m_CurrentSpeedClassId) == 0x0001E0, "Member 'UGhostSubSystem::m_CurrentSpeedClassId' has a wrong offset!");
static_assert(offsetof(UGhostSubSystem, m_CurrentStageId) == 0x0001E1, "Member 'UGhostSubSystem::m_CurrentStageId' has a wrong offset!");
static_assert(offsetof(UGhostSubSystem, m_CurrentDateTime) == 0x0001E8, "Member 'UGhostSubSystem::m_CurrentDateTime' has a wrong offset!");

// Class UnionSystem.GhostUploader
// 0x00C0 (0x00E8 - 0x0028)
class UGhostUploader final : public UObject
{
public:
	TDelegate<void(int32 ResCode, int32 ContentLength, float ElapsedTime, bool Error)> m_completeDelegate; // 0x0028(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TDelegate<void(int32 Length, float Rate)>     m_progressDelegate;                                // 0x0038(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0xA0];                                      // 0x0048(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCompleteDelegate(int32 ResCode, int32 ContentLength, float ElapsedTime, bool bIsError);
	void OnProgressDelegate(int32 Length, float Rate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GhostUploader">();
	}
	static class UGhostUploader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGhostUploader>();
	}
};
static_assert(alignof(UGhostUploader) == 0x000008, "Wrong alignment on UGhostUploader");
static_assert(sizeof(UGhostUploader) == 0x0000E8, "Wrong size on UGhostUploader");
static_assert(offsetof(UGhostUploader, m_completeDelegate) == 0x000028, "Member 'UGhostUploader::m_completeDelegate' has a wrong offset!");
static_assert(offsetof(UGhostUploader, m_progressDelegate) == 0x000038, "Member 'UGhostUploader::m_progressDelegate' has a wrong offset!");

// Class UnionSystem.GrandPrixCommonData
// 0x0030 (0x0060 - 0x0030)
class UGrandPrixCommonData final : public UDataAsset
{
public:
	uint8                                         RivalLevelMax;                                     // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PowerRivalAddLevel;                                // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BlankIconHideCount;                                // 0x0032(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxLevelUpRivalLevel;                              // 0x0033(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PowerRivalFrequency;                               // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RivalWinFirstRewardEventThreshold;                 // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RivalWinRewardEventThreshold;                      // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EDriverId>                             TargetRivalIds;                                    // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EStageId>                              FeverConditionAnotherStageIds;                     // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrandPrixCommonData">();
	}
	static class UGrandPrixCommonData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGrandPrixCommonData>();
	}
};
static_assert(alignof(UGrandPrixCommonData) == 0x000008, "Wrong alignment on UGrandPrixCommonData");
static_assert(sizeof(UGrandPrixCommonData) == 0x000060, "Wrong size on UGrandPrixCommonData");
static_assert(offsetof(UGrandPrixCommonData, RivalLevelMax) == 0x000030, "Member 'UGrandPrixCommonData::RivalLevelMax' has a wrong offset!");
static_assert(offsetof(UGrandPrixCommonData, PowerRivalAddLevel) == 0x000031, "Member 'UGrandPrixCommonData::PowerRivalAddLevel' has a wrong offset!");
static_assert(offsetof(UGrandPrixCommonData, BlankIconHideCount) == 0x000032, "Member 'UGrandPrixCommonData::BlankIconHideCount' has a wrong offset!");
static_assert(offsetof(UGrandPrixCommonData, MaxLevelUpRivalLevel) == 0x000033, "Member 'UGrandPrixCommonData::MaxLevelUpRivalLevel' has a wrong offset!");
static_assert(offsetof(UGrandPrixCommonData, PowerRivalFrequency) == 0x000034, "Member 'UGrandPrixCommonData::PowerRivalFrequency' has a wrong offset!");
static_assert(offsetof(UGrandPrixCommonData, RivalWinFirstRewardEventThreshold) == 0x000038, "Member 'UGrandPrixCommonData::RivalWinFirstRewardEventThreshold' has a wrong offset!");
static_assert(offsetof(UGrandPrixCommonData, RivalWinRewardEventThreshold) == 0x00003C, "Member 'UGrandPrixCommonData::RivalWinRewardEventThreshold' has a wrong offset!");
static_assert(offsetof(UGrandPrixCommonData, TargetRivalIds) == 0x000040, "Member 'UGrandPrixCommonData::TargetRivalIds' has a wrong offset!");
static_assert(offsetof(UGrandPrixCommonData, FeverConditionAnotherStageIds) == 0x000050, "Member 'UGrandPrixCommonData::FeverConditionAnotherStageIds' has a wrong offset!");

// Class UnionSystem.UIColorInfoDataAsset
// 0x0058 (0x0088 - 0x0030)
class UUIColorInfoDataAsset final : public UDataAsset
{
public:
	class UDataTable*                             UIColorInfoDataTable;                              // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EGroupColorId, struct FUIColorInfoData>  UIColorInfoDataMap;                                // 0x0038(0x0050)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)

public:
	void ClearData();
	const struct FUIColorInfo GetUIColorInfo(EGroupColorId colorId);
	void Update();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIColorInfoDataAsset">();
	}
	static class UUIColorInfoDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIColorInfoDataAsset>();
	}
};
static_assert(alignof(UUIColorInfoDataAsset) == 0x000008, "Wrong alignment on UUIColorInfoDataAsset");
static_assert(sizeof(UUIColorInfoDataAsset) == 0x000088, "Wrong size on UUIColorInfoDataAsset");
static_assert(offsetof(UUIColorInfoDataAsset, UIColorInfoDataTable) == 0x000030, "Member 'UUIColorInfoDataAsset::UIColorInfoDataTable' has a wrong offset!");
static_assert(offsetof(UUIColorInfoDataAsset, UIColorInfoDataMap) == 0x000038, "Member 'UUIColorInfoDataAsset::UIColorInfoDataMap' has a wrong offset!");

// Class UnionSystem.HashHelper
// 0x0000 (0x0028 - 0x0028)
class UHashHelper final : public UBlueprintFunctionLibrary
{
public:
	static TArray<uint8> HashIntoByteArray(const class FString& Data);
	static TArray<uint8> HashIntoByteArrayFromByteArray(const TArray<uint8>& Bytes);
	static class FString HashIntoTextString(const class FString& Data);
	static class FString HashIntoTextStringFromByteArray(const TArray<uint8>& Bytes);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HashHelper">();
	}
	static class UHashHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHashHelper>();
	}
};
static_assert(alignof(UHashHelper) == 0x000008, "Wrong alignment on UHashHelper");
static_assert(sizeof(UHashHelper) == 0x000028, "Wrong size on UHashHelper");

// Class UnionSystem.HttpHelper
// 0x0000 (0x0028 - 0x0028)
class UHttpHelper final : public UBlueprintFunctionLibrary
{
public:
	static bool GetCurrentUserId(class FString* UserId);
	static bool GetIntplServerDateTime(struct FDateTime* OutDateTime);
	static bool GetLastMaintenanceData(class FString* StartTime, class FString* endTime, int32* noticeId);
	static bool GetLastServerTime(class FString* ServerTime);
	static void LoginContextInitialize(const class FString& ProductUserId, const class FString& UserId);
	static void LoginContextInitializeForMaintenance(const class FString& ProviderId);
	static void LoginContextUpdate(const struct FLoginCheckResponse& Response);
	static void Parse_CntReplayGetSignedUrl(const class FString& OutData, int32* ResCode, struct FCntReplayGetSignedUrlResponse* Response);
	static void Parse_CompensationGetCompensations(const class FString& OutData, int32* ResCode, struct FCompensationGetCompensationsResponse* Response);
	static void Parse_DebugChangeFairPlayPoint(const class FString& OutData, int32* ResCode, struct FDebugChangeFairPlayPointResponse* Response);
	static void Parse_DebugChangeRankMatchRate(const class FString& OutData, int32* ResCode, struct FDebugChangeRankMatchRateResponse* Response);
	static void Parse_DebugConnectTest(const class FString& OutData, int32* ResCode, struct FDebugConnectTestResponse* Response);
	static void Parse_DebugMatchmakingSubscribeFesta(const class FString& OutData, int32* ResCode, struct FDebugMatchmakingSubscribeFestaResponse* Response);
	static void Parse_DebugMatchmakingSubscribeLegendCompe(const class FString& OutData, int32* ResCode, struct FDebugMatchmakingSubscribeLegendCompeResponse* Response);
	static void Parse_DebugMatchmakingSubscribeRankMatch(const class FString& OutData, int32* ResCode, struct FDebugMatchmakingSubscribeRankMatchResponse* Response);
	static void Parse_FairPointAddFairPoint(const class FString& OutData, int32* ResCode, struct FFairPointAddFairPointResponse* Response);
	static void Parse_FairPointCheckFairPoint(const class FString& OutData, int32* ResCode, struct FFairPointCheckFairPointResponse* Response);
	static void Parse_FairPointSubFairPoint(const class FString& OutData, int32* ResCode, struct FFairPointSubFairPointResponse* Response);
	static void Parse_FestaCheckFestaReward(const class FString& OutData, int32* ResCode, struct FFestaCheckFestaRewardResponse* Response);
	static void Parse_FestaFestaTop(const class FString& OutData, int32* ResCode, struct FFestaFestaTopResponse* Response);
	static void Parse_FriendAcceptFriend(const class FString& OutData, int32* ResCode, struct FFriendAcceptFriendResponse* Response);
	static void Parse_FriendApplyFriend(const class FString& OutData, int32* ResCode, struct FFriendApplyFriendResponse* Response);
	static void Parse_FriendCancelFriend(const class FString& OutData, int32* ResCode, struct FFriendCancelFriendResponse* Response);
	static void Parse_FriendGetFriendLastDate(const class FString& OutData, int32* ResCode, struct FFriendGetFriendLastDateResponse* Response);
	static void Parse_FriendGetFriendList(const class FString& OutData, int32* ResCode, struct FFriendGetFriendListResponse* Response);
	static void Parse_FriendNotifyFriend(const class FString& OutData, int32* ResCode, struct FFriendNotifyFriendResponse* Response);
	static void Parse_FriendRejectFriend(const class FString& OutData, int32* ResCode, struct FFriendRejectFriendResponse* Response);
	static void Parse_FriendRequestFriend(const class FString& OutData, int32* ResCode, struct FFriendRequestFriendResponse* Response);
	static void Parse_FriendUnfriend(const class FString& OutData, int32* ResCode, struct FFriendUnfriendResponse* Response);
	static void Parse_GhostGetFriendGhostData(const class FString& OutData, int32* ResCode, struct FGhostGetFriendGhostDataResponse* Response);
	static void Parse_GhostGetRankingGhostData(const class FString& OutData, int32* ResCode, struct FGhostGetRankingGhostDataResponse* Response);
	static void Parse_HealthCheck(const class FString& OutData, int32* ResCode, struct FHealthCheckResponse* Response);
	static void Parse_LegendCompeCheckLegendCompeReward(const class FString& OutData, int32* ResCode, struct FLegendCompeCheckLegendCompeRewardResponse* Response);
	static void Parse_LobbyGenerateLobby(const class FString& OutData, int32* ResCode, struct FLobbyGenerateLobbyResponse* Response);
	static void Parse_LobbyGetEosLobbyId(const class FString& OutData, int32* ResCode, struct FLobbyGetEosLobbyIdResponse* Response);
	static void Parse_LobbyKeepAlive(const class FString& OutData, int32* ResCode, struct FLobbyKeepAliveResponse* Response);
	static void Parse_LobbyRemoveLobby(const class FString& OutData, int32* ResCode, struct FLobbyRemoveLobbyResponse* Response);
	static void Parse_LoginCheck(const class FString& OutData, int32* ResCode, struct FLoginCheckResponse* Response);
	static void Parse_MasterDataGetMaintenanceSchedule(const class FString& OutData, int32* ResCode, struct FMasterDataGetMaintenanceScheduleResponse* Response);
	static void Parse_MasterDataGetMasterData(const class FString& OutData, int32* ResCode, struct FMasterDataGetMasterDataResponse* Response);
	static void Parse_MasterDataGetVersion(const class FString& OutData, int32* ResCode, struct FMasterDataGetVersionResponse* Response);
	static void Parse_MatchmakingDescribe(const class FString& OutData, int32* ResCode, struct FMatchmakingDescribeResponse* Response);
	static void Parse_MatchmakingStop(const class FString& OutData, int32* ResCode, struct FMatchmakingStopResponse* Response);
	static void Parse_MatchmakingSubscribeFesta(const class FString& OutData, int32* ResCode, struct FMatchmakingSubscribeFestaResponse* Response);
	static void Parse_MatchmakingSubscribeLegendCompe(const class FString& OutData, int32* ResCode, struct FMatchmakingSubscribeLegendCompeResponse* Response);
	static void Parse_MatchmakingSubscribeRankMatch(const class FString& OutData, int32* ResCode, struct FMatchmakingSubscribeRankMatchResponse* Response);
	static void Parse_MatchmakingUnsubscribe(const class FString& OutData, int32* ResCode, struct FMatchmakingUnsubscribeResponse* Response);
	static void Parse_OntSaveOntParticipantUser(const class FString& OutData, int32* ResCode, struct FOntSaveOntParticipantUserResponse* Response);
	static void Parse_OperationSaveAutoReport(const class FString& OutData, int32* ResCode, struct FOperationSaveAutoReportResponse* Response);
	static void Parse_OperationSaveOperatorReport(const class FString& OutData, int32* ResCode, struct FOperationSaveOperatorReportResponse* Response);
	static void Parse_RankingGetFriendRankingFestaPoint(const class FString& OutData, int32* ResCode, struct FRankingGetFriendRankingFestaPointResponse* Response);
	static void Parse_RankingGetFriendRankingLegendCompe(const class FString& OutData, int32* ResCode, struct FRankingGetFriendRankingLegendCompeResponse* Response);
	static void Parse_RankingGetFriendRankingRankMatch(const class FString& OutData, int32* ResCode, struct FRankingGetFriendRankingRankMatchResponse* Response);
	static void Parse_RankingGetMyRankingFestaPoint(const class FString& OutData, int32* ResCode, struct FRankingGetMyRankingFestaPointResponse* Response);
	static void Parse_RankingGetMyRankingLegendCompe(const class FString& OutData, int32* ResCode, struct FRankingGetMyRankingLegendCompeResponse* Response);
	static void Parse_RankingGetMyRankingRankMatch(const class FString& OutData, int32* ResCode, struct FRankingGetMyRankingRankMatchResponse* Response);
	static void Parse_RankingGetMyRankingTimeTrial(const class FString& OutData, int32* ResCode, struct FRankingGetMyRankingTimeTrialResponse* Response);
	static void Parse_RankingGetRankingFestaPoint(const class FString& OutData, int32* ResCode, struct FRankingGetRankingFestaPointResponse* Response);
	static void Parse_RankingGetRankingLegendCompe(const class FString& OutData, int32* ResCode, struct FRankingGetRankingLegendCompeResponse* Response);
	static void Parse_RankingGetRankingRankMatch(const class FString& OutData, int32* ResCode, struct FRankingGetRankingRankMatchResponse* Response);
	static void Parse_RankingGetRankingTimeTrial(const class FString& OutData, int32* ResCode, struct FRankingGetRankingTimeTrialResponse* Response);
	static void Parse_ResultSaveFestaResult(const class FString& OutData, int32* ResCode, struct FResultSaveFestaResultResponse* Response);
	static void Parse_ResultSaveLegendCompeResult(const class FString& OutData, int32* ResCode, struct FResultSaveLegendCompeResultResponse* Response);
	static void Parse_ResultSaveRankMatchResult(const class FString& OutData, int32* ResCode, struct FResultSaveRankMatchResultResponse* Response);
	static void Parse_ResultSaveTimeTrialResult(const class FString& OutData, int32* ResCode, struct FResultSaveTimeTrialResultResponse* Response);
	static void Parse_RomCheckRomVersion(const class FString& OutData, int32* ResCode, struct FRomCheckRomVersionResponse* Response);
	static void Parse_SamplePart1(const class FString& OutData, int32* ResCode, struct FSamplePart1Response* Response);
	static void Parse_SessionKeepalive(const class FString& OutData, int32* ResCode, struct FSessionKeepaliveResponse* Response);
	static void Parse_StartSaveFestaStart(const class FString& OutData, int32* ResCode, struct FStartSaveFestaStartResponse* Response);
	static void Parse_StartSaveLegendCompeStart(const class FString& OutData, int32* ResCode, struct FStartSaveLegendCompeStartResponse* Response);
	static void Parse_StartSaveRankMatchStart(const class FString& OutData, int32* ResCode, struct FStartSaveRankMatchStartResponse* Response);
	static void Parse_UserGetData(const class FString& OutData, int32* ResCode, struct FUserGetDataResponse* Response);
	static void Parse_UserGetPartsData(const class FString& OutData, int32* ResCode, struct FUserGetPartsDataResponse* Response);
	static void Parse_UserGetUserIdsByPuid(const class FString& OutData, int32* ResCode, struct FUserGetUserIdsByPuidResponse* Response);
	static void Parse_UserGetUserIdsByUid(const class FString& OutData, int32* ResCode, struct FUserGetUserIdsByUidResponse* Response);
	static void Parse_UserGetUserNetworkSettings(const class FString& OutData, int32* ResCode, struct FUserGetUserNetworkSettingsResponse* Response);
	static void Parse_UserGetUserSearch(const class FString& OutData, int32* ResCode, struct FUserGetUserSearchResponse* Response);
	static void Parse_UserNintendoSwitchOnlineCheck(const class FString& OutData, int32* ResCode, struct FUserNintendoSwitchOnlineCheckResponse* Response);
	static void Parse_UserSavePaidDlcOwnerships(const class FString& OutData, int32* ResCode, struct FUserSavePaidDlcOwnershipsResponse* Response);
	static void Parse_UserSaveUserNetworkSettings(const class FString& OutData, int32* ResCode, struct FUserSaveUserNetworkSettingsResponse* Response);
	static void QueryServerTime(TDelegate<void(const struct FDateTime& Timestamp, bool Error)> OnComplete);
	static bool Receive_CntReplayGetSignedUrl(int32 Handle, bool* OutError, int32* ResCode, struct FCntReplayGetSignedUrlResponse* Response);
	static bool Receive_CompensationGetCompensations(int32 Handle, bool* OutError, int32* ResCode, struct FCompensationGetCompensationsResponse* Response);
	static bool Receive_DebugChangeFairPlayPoint(int32 Handle, bool* OutError, int32* ResCode, struct FDebugChangeFairPlayPointResponse* Response);
	static bool Receive_DebugChangeRankMatchRate(int32 Handle, bool* OutError, int32* ResCode, struct FDebugChangeRankMatchRateResponse* Response);
	static bool Receive_DebugConnectTest(int32 Handle, bool* OutError, int32* ResCode, struct FDebugConnectTestResponse* Response);
	static bool Receive_DebugMatchmakingSubscribeFesta(int32 Handle, bool* OutError, int32* ResCode, struct FDebugMatchmakingSubscribeFestaResponse* Response);
	static bool Receive_DebugMatchmakingSubscribeLegendCompe(int32 Handle, bool* OutError, int32* ResCode, struct FDebugMatchmakingSubscribeLegendCompeResponse* Response);
	static bool Receive_DebugMatchmakingSubscribeRankMatch(int32 Handle, bool* OutError, int32* ResCode, struct FDebugMatchmakingSubscribeRankMatchResponse* Response);
	static bool Receive_FairPointAddFairPoint(int32 Handle, bool* OutError, int32* ResCode, struct FFairPointAddFairPointResponse* Response);
	static bool Receive_FairPointCheckFairPoint(int32 Handle, bool* OutError, int32* ResCode, struct FFairPointCheckFairPointResponse* Response);
	static bool Receive_FairPointSubFairPoint(int32 Handle, bool* OutError, int32* ResCode, struct FFairPointSubFairPointResponse* Response);
	static bool Receive_FestaCheckFestaReward(int32 Handle, bool* OutError, int32* ResCode, struct FFestaCheckFestaRewardResponse* Response);
	static bool Receive_FestaFestaTop(int32 Handle, bool* OutError, int32* ResCode, struct FFestaFestaTopResponse* Response);
	static bool Receive_FriendAcceptFriend(int32 Handle, bool* OutError, int32* ResCode, struct FFriendAcceptFriendResponse* Response);
	static bool Receive_FriendApplyFriend(int32 Handle, bool* OutError, int32* ResCode, struct FFriendApplyFriendResponse* Response);
	static bool Receive_FriendCancelFriend(int32 Handle, bool* OutError, int32* ResCode, struct FFriendCancelFriendResponse* Response);
	static bool Receive_FriendGetFriendLastDate(int32 Handle, bool* OutError, int32* ResCode, struct FFriendGetFriendLastDateResponse* Response);
	static bool Receive_FriendGetFriendList(int32 Handle, bool* OutError, int32* ResCode, struct FFriendGetFriendListResponse* Response);
	static bool Receive_FriendNotifyFriend(int32 Handle, bool* OutError, int32* ResCode, struct FFriendNotifyFriendResponse* Response);
	static bool Receive_FriendRejectFriend(int32 Handle, bool* OutError, int32* ResCode, struct FFriendRejectFriendResponse* Response);
	static bool Receive_FriendRequestFriend(int32 Handle, bool* OutError, int32* ResCode, struct FFriendRequestFriendResponse* Response);
	static bool Receive_FriendUnfriend(int32 Handle, bool* OutError, int32* ResCode, struct FFriendUnfriendResponse* Response);
	static bool Receive_GhostGetFriendGhostData(int32 Handle, bool* OutError, int32* ResCode, struct FGhostGetFriendGhostDataResponse* Response);
	static bool Receive_GhostGetRankingGhostData(int32 Handle, bool* OutError, int32* ResCode, struct FGhostGetRankingGhostDataResponse* Response);
	static bool Receive_HealthCheck(int32 Handle, bool* OutError, int32* ResCode, struct FHealthCheckResponse* Response);
	static bool Receive_LegendCompeCheckLegendCompeReward(int32 Handle, bool* OutError, int32* ResCode, struct FLegendCompeCheckLegendCompeRewardResponse* Response);
	static bool Receive_LobbyGenerateLobby(int32 Handle, bool* OutError, int32* ResCode, struct FLobbyGenerateLobbyResponse* Response);
	static bool Receive_LobbyGetEosLobbyId(int32 Handle, bool* OutError, int32* ResCode, struct FLobbyGetEosLobbyIdResponse* Response);
	static bool Receive_LobbyKeepAlive(int32 Handle, bool* OutError, int32* ResCode, struct FLobbyKeepAliveResponse* Response);
	static bool Receive_LobbyRemoveLobby(int32 Handle, bool* OutError, int32* ResCode, struct FLobbyRemoveLobbyResponse* Response);
	static bool Receive_LoginCheck(int32 Handle, bool* OutError, int32* ResCode, struct FLoginCheckResponse* Response);
	static bool Receive_MasterDataGetMaintenanceSchedule(int32 Handle, bool* OutError, int32* ResCode, struct FMasterDataGetMaintenanceScheduleResponse* Response);
	static bool Receive_MasterDataGetMasterData(int32 Handle, bool* OutError, int32* ResCode, struct FMasterDataGetMasterDataResponse* Response);
	static bool Receive_MasterDataGetVersion(int32 Handle, bool* OutError, int32* ResCode, struct FMasterDataGetVersionResponse* Response);
	static bool Receive_MatchmakingDescribe(int32 Handle, bool* OutError, int32* ResCode, struct FMatchmakingDescribeResponse* Response);
	static bool Receive_MatchmakingStop(int32 Handle, bool* OutError, int32* ResCode, struct FMatchmakingStopResponse* Response);
	static bool Receive_MatchmakingSubscribeFesta(int32 Handle, bool* OutError, int32* ResCode, struct FMatchmakingSubscribeFestaResponse* Response);
	static bool Receive_MatchmakingSubscribeLegendCompe(int32 Handle, bool* OutError, int32* ResCode, struct FMatchmakingSubscribeLegendCompeResponse* Response);
	static bool Receive_MatchmakingSubscribeRankMatch(int32 Handle, bool* OutError, int32* ResCode, struct FMatchmakingSubscribeRankMatchResponse* Response);
	static bool Receive_MatchmakingUnsubscribe(int32 Handle, bool* OutError, int32* ResCode, struct FMatchmakingUnsubscribeResponse* Response);
	static bool Receive_OntSaveOntParticipantUser(int32 Handle, bool* OutError, int32* ResCode, struct FOntSaveOntParticipantUserResponse* Response);
	static bool Receive_OperationSaveAutoReport(int32 Handle, bool* OutError, int32* ResCode, struct FOperationSaveAutoReportResponse* Response);
	static bool Receive_OperationSaveOperatorReport(int32 Handle, bool* OutError, int32* ResCode, struct FOperationSaveOperatorReportResponse* Response);
	static bool Receive_RankingGetFriendRankingFestaPoint(int32 Handle, bool* OutError, int32* ResCode, struct FRankingGetFriendRankingFestaPointResponse* Response);
	static bool Receive_RankingGetFriendRankingLegendCompe(int32 Handle, bool* OutError, int32* ResCode, struct FRankingGetFriendRankingLegendCompeResponse* Response);
	static bool Receive_RankingGetFriendRankingRankMatch(int32 Handle, bool* OutError, int32* ResCode, struct FRankingGetFriendRankingRankMatchResponse* Response);
	static bool Receive_RankingGetMyRankingFestaPoint(int32 Handle, bool* OutError, int32* ResCode, struct FRankingGetMyRankingFestaPointResponse* Response);
	static bool Receive_RankingGetMyRankingLegendCompe(int32 Handle, bool* OutError, int32* ResCode, struct FRankingGetMyRankingLegendCompeResponse* Response);
	static bool Receive_RankingGetMyRankingRankMatch(int32 Handle, bool* OutError, int32* ResCode, struct FRankingGetMyRankingRankMatchResponse* Response);
	static bool Receive_RankingGetMyRankingTimeTrial(int32 Handle, bool* OutError, int32* ResCode, struct FRankingGetMyRankingTimeTrialResponse* Response);
	static bool Receive_RankingGetRankingFestaPoint(int32 Handle, bool* OutError, int32* ResCode, struct FRankingGetRankingFestaPointResponse* Response);
	static bool Receive_RankingGetRankingLegendCompe(int32 Handle, bool* OutError, int32* ResCode, struct FRankingGetRankingLegendCompeResponse* Response);
	static bool Receive_RankingGetRankingRankMatch(int32 Handle, bool* OutError, int32* ResCode, struct FRankingGetRankingRankMatchResponse* Response);
	static bool Receive_RankingGetRankingTimeTrial(int32 Handle, bool* OutError, int32* ResCode, struct FRankingGetRankingTimeTrialResponse* Response);
	static bool Receive_ResultSaveFestaResult(int32 Handle, bool* OutError, int32* ResCode, struct FResultSaveFestaResultResponse* Response);
	static bool Receive_ResultSaveLegendCompeResult(int32 Handle, bool* OutError, int32* ResCode, struct FResultSaveLegendCompeResultResponse* Response);
	static bool Receive_ResultSaveRankMatchResult(int32 Handle, bool* OutError, int32* ResCode, struct FResultSaveRankMatchResultResponse* Response);
	static bool Receive_ResultSaveTimeTrialResult(int32 Handle, bool* OutError, int32* ResCode, struct FResultSaveTimeTrialResultResponse* Response);
	static bool Receive_RomCheckRomVersion(int32 Handle, bool* OutError, int32* ResCode, struct FRomCheckRomVersionResponse* Response);
	static bool Receive_SamplePart1(int32 Handle, bool* OutError, int32* ResCode, struct FSamplePart1Response* Response);
	static bool Receive_SessionKeepalive(int32 Handle, bool* OutError, int32* ResCode, struct FSessionKeepaliveResponse* Response);
	static bool Receive_StartSaveFestaStart(int32 Handle, bool* OutError, int32* ResCode, struct FStartSaveFestaStartResponse* Response);
	static bool Receive_StartSaveLegendCompeStart(int32 Handle, bool* OutError, int32* ResCode, struct FStartSaveLegendCompeStartResponse* Response);
	static bool Receive_StartSaveRankMatchStart(int32 Handle, bool* OutError, int32* ResCode, struct FStartSaveRankMatchStartResponse* Response);
	static bool Receive_UserGetData(int32 Handle, bool* OutError, int32* ResCode, struct FUserGetDataResponse* Response);
	static bool Receive_UserGetPartsData(int32 Handle, bool* OutError, int32* ResCode, struct FUserGetPartsDataResponse* Response);
	static bool Receive_UserGetUserIdsByPuid(int32 Handle, bool* OutError, int32* ResCode, struct FUserGetUserIdsByPuidResponse* Response);
	static bool Receive_UserGetUserIdsByUid(int32 Handle, bool* OutError, int32* ResCode, struct FUserGetUserIdsByUidResponse* Response);
	static bool Receive_UserGetUserNetworkSettings(int32 Handle, bool* OutError, int32* ResCode, struct FUserGetUserNetworkSettingsResponse* Response);
	static bool Receive_UserGetUserSearch(int32 Handle, bool* OutError, int32* ResCode, struct FUserGetUserSearchResponse* Response);
	static bool Receive_UserNintendoSwitchOnlineCheck(int32 Handle, bool* OutError, int32* ResCode, struct FUserNintendoSwitchOnlineCheckResponse* Response);
	static bool Receive_UserSavePaidDlcOwnerships(int32 Handle, bool* OutError, int32* ResCode, struct FUserSavePaidDlcOwnershipsResponse* Response);
	static bool Receive_UserSaveUserNetworkSettings(int32 Handle, bool* OutError, int32* ResCode, struct FUserSaveUserNetworkSettingsResponse* Response);
	static int32 Send_CntReplayGetSignedUrl(const struct FCntReplayGetSignedUrlRequest& Request);
	static void Send_CntReplayGetSignedUrl_Callbacked(const struct FCntReplayGetSignedUrlRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_CntReplayGetSignedUrl_Callbacked_NoResend(const struct FCntReplayGetSignedUrlRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_CntReplayGetSignedUrl_NoResend(const struct FCntReplayGetSignedUrlRequest& Request);
	static int32 Send_CompensationGetCompensations(const struct FCompensationGetCompensationsRequest& Request);
	static void Send_CompensationGetCompensations_Callbacked(const struct FCompensationGetCompensationsRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_CompensationGetCompensations_Callbacked_NoResend(const struct FCompensationGetCompensationsRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_CompensationGetCompensations_NoResend(const struct FCompensationGetCompensationsRequest& Request);
	static int32 Send_DebugChangeFairPlayPoint(const struct FDebugChangeFairPlayPointRequest& Request);
	static void Send_DebugChangeFairPlayPoint_Callbacked(const struct FDebugChangeFairPlayPointRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_DebugChangeFairPlayPoint_Callbacked_NoResend(const struct FDebugChangeFairPlayPointRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_DebugChangeFairPlayPoint_NoResend(const struct FDebugChangeFairPlayPointRequest& Request);
	static int32 Send_DebugChangeRankMatchRate(const struct FDebugChangeRankMatchRateRequest& Request);
	static void Send_DebugChangeRankMatchRate_Callbacked(const struct FDebugChangeRankMatchRateRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_DebugChangeRankMatchRate_Callbacked_NoResend(const struct FDebugChangeRankMatchRateRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_DebugChangeRankMatchRate_NoResend(const struct FDebugChangeRankMatchRateRequest& Request);
	static int32 Send_DebugConnectTest(const struct FDebugConnectTestRequest& Request);
	static void Send_DebugConnectTest_Callbacked(const struct FDebugConnectTestRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_DebugConnectTest_Callbacked_NoResend(const struct FDebugConnectTestRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_DebugConnectTest_NoResend(const struct FDebugConnectTestRequest& Request);
	static int32 Send_DebugMatchmakingSubscribeFesta(const struct FDebugMatchmakingSubscribeFestaRequest& Request);
	static void Send_DebugMatchmakingSubscribeFesta_Callbacked(const struct FDebugMatchmakingSubscribeFestaRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_DebugMatchmakingSubscribeFesta_Callbacked_NoResend(const struct FDebugMatchmakingSubscribeFestaRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_DebugMatchmakingSubscribeFesta_NoResend(const struct FDebugMatchmakingSubscribeFestaRequest& Request);
	static int32 Send_DebugMatchmakingSubscribeLegendCompe(const struct FDebugMatchmakingSubscribeLegendCompeRequest& Request);
	static void Send_DebugMatchmakingSubscribeLegendCompe_Callbacked(const struct FDebugMatchmakingSubscribeLegendCompeRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_DebugMatchmakingSubscribeLegendCompe_Callbacked_NoResend(const struct FDebugMatchmakingSubscribeLegendCompeRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_DebugMatchmakingSubscribeLegendCompe_NoResend(const struct FDebugMatchmakingSubscribeLegendCompeRequest& Request);
	static int32 Send_DebugMatchmakingSubscribeRankMatch(const struct FDebugMatchmakingSubscribeRankMatchRequest& Request);
	static void Send_DebugMatchmakingSubscribeRankMatch_Callbacked(const struct FDebugMatchmakingSubscribeRankMatchRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_DebugMatchmakingSubscribeRankMatch_Callbacked_NoResend(const struct FDebugMatchmakingSubscribeRankMatchRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_DebugMatchmakingSubscribeRankMatch_NoResend(const struct FDebugMatchmakingSubscribeRankMatchRequest& Request);
	static int32 Send_FairPointAddFairPoint(const struct FFairPointAddFairPointRequest& Request);
	static void Send_FairPointAddFairPoint_Callbacked(const struct FFairPointAddFairPointRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_FairPointAddFairPoint_Callbacked_NoResend(const struct FFairPointAddFairPointRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_FairPointAddFairPoint_NoResend(const struct FFairPointAddFairPointRequest& Request);
	static int32 Send_FairPointCheckFairPoint(const struct FFairPointCheckFairPointRequest& Request);
	static void Send_FairPointCheckFairPoint_Callbacked(const struct FFairPointCheckFairPointRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_FairPointCheckFairPoint_Callbacked_NoResend(const struct FFairPointCheckFairPointRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_FairPointCheckFairPoint_NoResend(const struct FFairPointCheckFairPointRequest& Request);
	static int32 Send_FairPointSubFairPoint(const struct FFairPointSubFairPointRequest& Request);
	static void Send_FairPointSubFairPoint_Callbacked(const struct FFairPointSubFairPointRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_FairPointSubFairPoint_Callbacked_NoResend(const struct FFairPointSubFairPointRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_FairPointSubFairPoint_NoResend(const struct FFairPointSubFairPointRequest& Request);
	static int32 Send_FestaCheckFestaReward(const struct FFestaCheckFestaRewardRequest& Request);
	static void Send_FestaCheckFestaReward_Callbacked(const struct FFestaCheckFestaRewardRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_FestaCheckFestaReward_Callbacked_NoResend(const struct FFestaCheckFestaRewardRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_FestaCheckFestaReward_NoResend(const struct FFestaCheckFestaRewardRequest& Request);
	static int32 Send_FestaFestaTop(const struct FFestaFestaTopRequest& Request);
	static void Send_FestaFestaTop_Callbacked(const struct FFestaFestaTopRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_FestaFestaTop_Callbacked_NoResend(const struct FFestaFestaTopRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_FestaFestaTop_NoResend(const struct FFestaFestaTopRequest& Request);
	static int32 Send_FriendAcceptFriend(const struct FFriendAcceptFriendRequest& Request);
	static void Send_FriendAcceptFriend_Callbacked(const struct FFriendAcceptFriendRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_FriendAcceptFriend_Callbacked_NoResend(const struct FFriendAcceptFriendRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_FriendAcceptFriend_NoResend(const struct FFriendAcceptFriendRequest& Request);
	static int32 Send_FriendApplyFriend(const struct FFriendApplyFriendRequest& Request);
	static void Send_FriendApplyFriend_Callbacked(const struct FFriendApplyFriendRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_FriendApplyFriend_Callbacked_NoResend(const struct FFriendApplyFriendRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_FriendApplyFriend_NoResend(const struct FFriendApplyFriendRequest& Request);
	static int32 Send_FriendCancelFriend(const struct FFriendCancelFriendRequest& Request);
	static void Send_FriendCancelFriend_Callbacked(const struct FFriendCancelFriendRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_FriendCancelFriend_Callbacked_NoResend(const struct FFriendCancelFriendRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_FriendCancelFriend_NoResend(const struct FFriendCancelFriendRequest& Request);
	static int32 Send_FriendGetFriendLastDate(const struct FFriendGetFriendLastDateRequest& Request);
	static void Send_FriendGetFriendLastDate_Callbacked(const struct FFriendGetFriendLastDateRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_FriendGetFriendLastDate_Callbacked_NoResend(const struct FFriendGetFriendLastDateRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_FriendGetFriendLastDate_NoResend(const struct FFriendGetFriendLastDateRequest& Request);
	static int32 Send_FriendGetFriendList(const struct FFriendGetFriendListRequest& Request);
	static void Send_FriendGetFriendList_Callbacked(const struct FFriendGetFriendListRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_FriendGetFriendList_Callbacked_NoResend(const struct FFriendGetFriendListRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_FriendGetFriendList_NoResend(const struct FFriendGetFriendListRequest& Request);
	static int32 Send_FriendNotifyFriend(const struct FFriendNotifyFriendRequest& Request);
	static void Send_FriendNotifyFriend_Callbacked(const struct FFriendNotifyFriendRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_FriendNotifyFriend_Callbacked_NoResend(const struct FFriendNotifyFriendRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_FriendNotifyFriend_NoResend(const struct FFriendNotifyFriendRequest& Request);
	static int32 Send_FriendRejectFriend(const struct FFriendRejectFriendRequest& Request);
	static void Send_FriendRejectFriend_Callbacked(const struct FFriendRejectFriendRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_FriendRejectFriend_Callbacked_NoResend(const struct FFriendRejectFriendRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_FriendRejectFriend_NoResend(const struct FFriendRejectFriendRequest& Request);
	static int32 Send_FriendRequestFriend(const struct FFriendRequestFriendRequest& Request);
	static void Send_FriendRequestFriend_Callbacked(const struct FFriendRequestFriendRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_FriendRequestFriend_Callbacked_NoResend(const struct FFriendRequestFriendRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_FriendRequestFriend_NoResend(const struct FFriendRequestFriendRequest& Request);
	static int32 Send_FriendUnfriend(const struct FFriendUnfriendRequest& Request);
	static void Send_FriendUnfriend_Callbacked(const struct FFriendUnfriendRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_FriendUnfriend_Callbacked_NoResend(const struct FFriendUnfriendRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_FriendUnfriend_NoResend(const struct FFriendUnfriendRequest& Request);
	static int32 Send_GhostGetFriendGhostData(const struct FGhostGetFriendGhostDataRequest& Request);
	static void Send_GhostGetFriendGhostData_Callbacked(const struct FGhostGetFriendGhostDataRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_GhostGetFriendGhostData_Callbacked_NoResend(const struct FGhostGetFriendGhostDataRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_GhostGetFriendGhostData_NoResend(const struct FGhostGetFriendGhostDataRequest& Request);
	static int32 Send_GhostGetRankingGhostData(const struct FGhostGetRankingGhostDataRequest& Request);
	static void Send_GhostGetRankingGhostData_Callbacked(const struct FGhostGetRankingGhostDataRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_GhostGetRankingGhostData_Callbacked_NoResend(const struct FGhostGetRankingGhostDataRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_GhostGetRankingGhostData_NoResend(const struct FGhostGetRankingGhostDataRequest& Request);
	static int32 Send_HealthCheck(const struct FHealthCheckRequest& Request);
	static void Send_HealthCheck_Callbacked(const struct FHealthCheckRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_HealthCheck_Callbacked_NoResend(const struct FHealthCheckRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_HealthCheck_NoResend(const struct FHealthCheckRequest& Request);
	static int32 Send_LegendCompeCheckLegendCompeReward(const struct FLegendCompeCheckLegendCompeRewardRequest& Request);
	static void Send_LegendCompeCheckLegendCompeReward_Callbacked(const struct FLegendCompeCheckLegendCompeRewardRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_LegendCompeCheckLegendCompeReward_Callbacked_NoResend(const struct FLegendCompeCheckLegendCompeRewardRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_LegendCompeCheckLegendCompeReward_NoResend(const struct FLegendCompeCheckLegendCompeRewardRequest& Request);
	static int32 Send_LobbyGenerateLobby(const struct FLobbyGenerateLobbyRequest& Request);
	static void Send_LobbyGenerateLobby_Callbacked(const struct FLobbyGenerateLobbyRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_LobbyGenerateLobby_Callbacked_NoResend(const struct FLobbyGenerateLobbyRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_LobbyGenerateLobby_NoResend(const struct FLobbyGenerateLobbyRequest& Request);
	static int32 Send_LobbyGetEosLobbyId(const struct FLobbyGetEosLobbyIdRequest& Request);
	static void Send_LobbyGetEosLobbyId_Callbacked(const struct FLobbyGetEosLobbyIdRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_LobbyGetEosLobbyId_Callbacked_NoResend(const struct FLobbyGetEosLobbyIdRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_LobbyGetEosLobbyId_NoResend(const struct FLobbyGetEosLobbyIdRequest& Request);
	static int32 Send_LobbyKeepAlive(const struct FLobbyKeepAliveRequest& Request);
	static void Send_LobbyKeepAlive_Callbacked(const struct FLobbyKeepAliveRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_LobbyKeepAlive_Callbacked_NoResend(const struct FLobbyKeepAliveRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_LobbyKeepAlive_NoResend(const struct FLobbyKeepAliveRequest& Request);
	static int32 Send_LobbyRemoveLobby(const struct FLobbyRemoveLobbyRequest& Request);
	static void Send_LobbyRemoveLobby_Callbacked(const struct FLobbyRemoveLobbyRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_LobbyRemoveLobby_Callbacked_NoResend(const struct FLobbyRemoveLobbyRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_LobbyRemoveLobby_NoResend(const struct FLobbyRemoveLobbyRequest& Request);
	static int32 Send_LoginCheck(const struct FLoginCheckRequest& Request);
	static void Send_LoginCheck_Callbacked(const struct FLoginCheckRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_LoginCheck_Callbacked_NoResend(const struct FLoginCheckRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_LoginCheck_NoResend(const struct FLoginCheckRequest& Request);
	static int32 Send_MasterDataGetMaintenanceSchedule(const struct FMasterDataGetMaintenanceScheduleRequest& Request);
	static void Send_MasterDataGetMaintenanceSchedule_Callbacked(const struct FMasterDataGetMaintenanceScheduleRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_MasterDataGetMaintenanceSchedule_Callbacked_NoResend(const struct FMasterDataGetMaintenanceScheduleRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_MasterDataGetMaintenanceSchedule_NoResend(const struct FMasterDataGetMaintenanceScheduleRequest& Request);
	static int32 Send_MasterDataGetMasterData(const struct FMasterDataGetMasterDataRequest& Request);
	static void Send_MasterDataGetMasterData_Callbacked(const struct FMasterDataGetMasterDataRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_MasterDataGetMasterData_Callbacked_NoResend(const struct FMasterDataGetMasterDataRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_MasterDataGetMasterData_NoResend(const struct FMasterDataGetMasterDataRequest& Request);
	static int32 Send_MasterDataGetVersion(const struct FMasterDataGetVersionRequest& Request);
	static void Send_MasterDataGetVersion_Callbacked(const struct FMasterDataGetVersionRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_MasterDataGetVersion_Callbacked_NoResend(const struct FMasterDataGetVersionRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_MasterDataGetVersion_NoResend(const struct FMasterDataGetVersionRequest& Request);
	static int32 Send_MatchmakingDescribe(const struct FMatchmakingDescribeRequest& Request);
	static void Send_MatchmakingDescribe_Callbacked(const struct FMatchmakingDescribeRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_MatchmakingDescribe_Callbacked_NoResend(const struct FMatchmakingDescribeRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_MatchmakingDescribe_NoResend(const struct FMatchmakingDescribeRequest& Request);
	static int32 Send_MatchmakingStop(const struct FMatchmakingStopRequest& Request);
	static void Send_MatchmakingStop_Callbacked(const struct FMatchmakingStopRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_MatchmakingStop_Callbacked_NoResend(const struct FMatchmakingStopRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_MatchmakingStop_NoResend(const struct FMatchmakingStopRequest& Request);
	static int32 Send_MatchmakingSubscribeFesta(const struct FMatchmakingSubscribeFestaRequest& Request);
	static void Send_MatchmakingSubscribeFesta_Callbacked(const struct FMatchmakingSubscribeFestaRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_MatchmakingSubscribeFesta_Callbacked_NoResend(const struct FMatchmakingSubscribeFestaRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_MatchmakingSubscribeFesta_NoResend(const struct FMatchmakingSubscribeFestaRequest& Request);
	static int32 Send_MatchmakingSubscribeLegendCompe(const struct FMatchmakingSubscribeLegendCompeRequest& Request);
	static void Send_MatchmakingSubscribeLegendCompe_Callbacked(const struct FMatchmakingSubscribeLegendCompeRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_MatchmakingSubscribeLegendCompe_Callbacked_NoResend(const struct FMatchmakingSubscribeLegendCompeRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_MatchmakingSubscribeLegendCompe_NoResend(const struct FMatchmakingSubscribeLegendCompeRequest& Request);
	static int32 Send_MatchmakingSubscribeRankMatch(const struct FMatchmakingSubscribeRankMatchRequest& Request);
	static void Send_MatchmakingSubscribeRankMatch_Callbacked(const struct FMatchmakingSubscribeRankMatchRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_MatchmakingSubscribeRankMatch_Callbacked_NoResend(const struct FMatchmakingSubscribeRankMatchRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_MatchmakingSubscribeRankMatch_NoResend(const struct FMatchmakingSubscribeRankMatchRequest& Request);
	static int32 Send_MatchmakingUnsubscribe(const struct FMatchmakingUnsubscribeRequest& Request);
	static void Send_MatchmakingUnsubscribe_Callbacked(const struct FMatchmakingUnsubscribeRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_MatchmakingUnsubscribe_Callbacked_NoResend(const struct FMatchmakingUnsubscribeRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_MatchmakingUnsubscribe_NoResend(const struct FMatchmakingUnsubscribeRequest& Request);
	static int32 Send_OntSaveOntParticipantUser(const struct FOntSaveOntParticipantUserRequest& Request);
	static void Send_OntSaveOntParticipantUser_Callbacked(const struct FOntSaveOntParticipantUserRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_OntSaveOntParticipantUser_Callbacked_NoResend(const struct FOntSaveOntParticipantUserRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_OntSaveOntParticipantUser_NoResend(const struct FOntSaveOntParticipantUserRequest& Request);
	static int32 Send_OperationSaveAutoReport(const struct FOperationSaveAutoReportRequest& Request);
	static void Send_OperationSaveAutoReport_Callbacked(const struct FOperationSaveAutoReportRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_OperationSaveAutoReport_Callbacked_NoResend(const struct FOperationSaveAutoReportRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_OperationSaveAutoReport_NoResend(const struct FOperationSaveAutoReportRequest& Request);
	static int32 Send_OperationSaveOperatorReport(const struct FOperationSaveOperatorReportRequest& Request);
	static void Send_OperationSaveOperatorReport_Callbacked(const struct FOperationSaveOperatorReportRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_OperationSaveOperatorReport_Callbacked_NoResend(const struct FOperationSaveOperatorReportRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_OperationSaveOperatorReport_NoResend(const struct FOperationSaveOperatorReportRequest& Request);
	static int32 Send_RankingGetFriendRankingFestaPoint(const struct FRankingGetFriendRankingFestaPointRequest& Request);
	static void Send_RankingGetFriendRankingFestaPoint_Callbacked(const struct FRankingGetFriendRankingFestaPointRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_RankingGetFriendRankingFestaPoint_Callbacked_NoResend(const struct FRankingGetFriendRankingFestaPointRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_RankingGetFriendRankingFestaPoint_NoResend(const struct FRankingGetFriendRankingFestaPointRequest& Request);
	static int32 Send_RankingGetFriendRankingLegendCompe(const struct FRankingGetFriendRankingLegendCompeRequest& Request);
	static void Send_RankingGetFriendRankingLegendCompe_Callbacked(const struct FRankingGetFriendRankingLegendCompeRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_RankingGetFriendRankingLegendCompe_Callbacked_NoResend(const struct FRankingGetFriendRankingLegendCompeRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_RankingGetFriendRankingLegendCompe_NoResend(const struct FRankingGetFriendRankingLegendCompeRequest& Request);
	static int32 Send_RankingGetFriendRankingRankMatch(const struct FRankingGetFriendRankingRankMatchRequest& Request);
	static void Send_RankingGetFriendRankingRankMatch_Callbacked(const struct FRankingGetFriendRankingRankMatchRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_RankingGetFriendRankingRankMatch_Callbacked_NoResend(const struct FRankingGetFriendRankingRankMatchRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_RankingGetFriendRankingRankMatch_NoResend(const struct FRankingGetFriendRankingRankMatchRequest& Request);
	static int32 Send_RankingGetMyRankingFestaPoint(const struct FRankingGetMyRankingFestaPointRequest& Request);
	static void Send_RankingGetMyRankingFestaPoint_Callbacked(const struct FRankingGetMyRankingFestaPointRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_RankingGetMyRankingFestaPoint_Callbacked_NoResend(const struct FRankingGetMyRankingFestaPointRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_RankingGetMyRankingFestaPoint_NoResend(const struct FRankingGetMyRankingFestaPointRequest& Request);
	static int32 Send_RankingGetMyRankingLegendCompe(const struct FRankingGetMyRankingLegendCompeRequest& Request);
	static void Send_RankingGetMyRankingLegendCompe_Callbacked(const struct FRankingGetMyRankingLegendCompeRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_RankingGetMyRankingLegendCompe_Callbacked_NoResend(const struct FRankingGetMyRankingLegendCompeRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_RankingGetMyRankingLegendCompe_NoResend(const struct FRankingGetMyRankingLegendCompeRequest& Request);
	static int32 Send_RankingGetMyRankingRankMatch(const struct FRankingGetMyRankingRankMatchRequest& Request);
	static void Send_RankingGetMyRankingRankMatch_Callbacked(const struct FRankingGetMyRankingRankMatchRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_RankingGetMyRankingRankMatch_Callbacked_NoResend(const struct FRankingGetMyRankingRankMatchRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_RankingGetMyRankingRankMatch_NoResend(const struct FRankingGetMyRankingRankMatchRequest& Request);
	static int32 Send_RankingGetMyRankingTimeTrial(const struct FRankingGetMyRankingTimeTrialRequest& Request);
	static void Send_RankingGetMyRankingTimeTrial_Callbacked(const struct FRankingGetMyRankingTimeTrialRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_RankingGetMyRankingTimeTrial_Callbacked_NoResend(const struct FRankingGetMyRankingTimeTrialRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_RankingGetMyRankingTimeTrial_NoResend(const struct FRankingGetMyRankingTimeTrialRequest& Request);
	static int32 Send_RankingGetRankingFestaPoint(const struct FRankingGetRankingFestaPointRequest& Request);
	static void Send_RankingGetRankingFestaPoint_Callbacked(const struct FRankingGetRankingFestaPointRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_RankingGetRankingFestaPoint_Callbacked_NoResend(const struct FRankingGetRankingFestaPointRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_RankingGetRankingFestaPoint_NoResend(const struct FRankingGetRankingFestaPointRequest& Request);
	static int32 Send_RankingGetRankingLegendCompe(const struct FRankingGetRankingLegendCompeRequest& Request);
	static void Send_RankingGetRankingLegendCompe_Callbacked(const struct FRankingGetRankingLegendCompeRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_RankingGetRankingLegendCompe_Callbacked_NoResend(const struct FRankingGetRankingLegendCompeRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_RankingGetRankingLegendCompe_NoResend(const struct FRankingGetRankingLegendCompeRequest& Request);
	static int32 Send_RankingGetRankingRankMatch(const struct FRankingGetRankingRankMatchRequest& Request);
	static void Send_RankingGetRankingRankMatch_Callbacked(const struct FRankingGetRankingRankMatchRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_RankingGetRankingRankMatch_Callbacked_NoResend(const struct FRankingGetRankingRankMatchRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_RankingGetRankingRankMatch_NoResend(const struct FRankingGetRankingRankMatchRequest& Request);
	static int32 Send_RankingGetRankingTimeTrial(const struct FRankingGetRankingTimeTrialRequest& Request);
	static void Send_RankingGetRankingTimeTrial_Callbacked(const struct FRankingGetRankingTimeTrialRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_RankingGetRankingTimeTrial_Callbacked_NoResend(const struct FRankingGetRankingTimeTrialRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_RankingGetRankingTimeTrial_NoResend(const struct FRankingGetRankingTimeTrialRequest& Request);
	static int32 Send_ResultSaveFestaResult(const struct FResultSaveFestaResultRequest& Request);
	static void Send_ResultSaveFestaResult_Callbacked(const struct FResultSaveFestaResultRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_ResultSaveFestaResult_Callbacked_NoResend(const struct FResultSaveFestaResultRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_ResultSaveFestaResult_NoResend(const struct FResultSaveFestaResultRequest& Request);
	static int32 Send_ResultSaveLegendCompeResult(const struct FResultSaveLegendCompeResultRequest& Request);
	static void Send_ResultSaveLegendCompeResult_Callbacked(const struct FResultSaveLegendCompeResultRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_ResultSaveLegendCompeResult_Callbacked_NoResend(const struct FResultSaveLegendCompeResultRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_ResultSaveLegendCompeResult_NoResend(const struct FResultSaveLegendCompeResultRequest& Request);
	static int32 Send_ResultSaveRankMatchResult(const struct FResultSaveRankMatchResultRequest& Request);
	static void Send_ResultSaveRankMatchResult_Callbacked(const struct FResultSaveRankMatchResultRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_ResultSaveRankMatchResult_Callbacked_NoResend(const struct FResultSaveRankMatchResultRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_ResultSaveRankMatchResult_NoResend(const struct FResultSaveRankMatchResultRequest& Request);
	static int32 Send_ResultSaveTimeTrialResult(const struct FResultSaveTimeTrialResultRequest& Request);
	static void Send_ResultSaveTimeTrialResult_Callbacked(const struct FResultSaveTimeTrialResultRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_ResultSaveTimeTrialResult_Callbacked_NoResend(const struct FResultSaveTimeTrialResultRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_ResultSaveTimeTrialResult_NoResend(const struct FResultSaveTimeTrialResultRequest& Request);
	static int32 Send_RomCheckRomVersion(const struct FRomCheckRomVersionRequest& Request);
	static void Send_RomCheckRomVersion_Callbacked(const struct FRomCheckRomVersionRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_RomCheckRomVersion_Callbacked_NoResend(const struct FRomCheckRomVersionRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_RomCheckRomVersion_NoResend(const struct FRomCheckRomVersionRequest& Request);
	static int32 Send_SamplePart1(const struct FSamplePart1Request& Request);
	static void Send_SamplePart1_Callbacked(const struct FSamplePart1Request& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_SamplePart1_Callbacked_NoResend(const struct FSamplePart1Request& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_SamplePart1_NoResend(const struct FSamplePart1Request& Request);
	static int32 Send_SessionKeepalive(const struct FSessionKeepaliveRequest& Request);
	static void Send_SessionKeepalive_Callbacked(const struct FSessionKeepaliveRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_SessionKeepalive_Callbacked_NoResend(const struct FSessionKeepaliveRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_SessionKeepalive_NoResend(const struct FSessionKeepaliveRequest& Request);
	static int32 Send_StartSaveFestaStart(const struct FStartSaveFestaStartRequest& Request);
	static void Send_StartSaveFestaStart_Callbacked(const struct FStartSaveFestaStartRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_StartSaveFestaStart_Callbacked_NoResend(const struct FStartSaveFestaStartRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_StartSaveFestaStart_NoResend(const struct FStartSaveFestaStartRequest& Request);
	static int32 Send_StartSaveLegendCompeStart(const struct FStartSaveLegendCompeStartRequest& Request);
	static void Send_StartSaveLegendCompeStart_Callbacked(const struct FStartSaveLegendCompeStartRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_StartSaveLegendCompeStart_Callbacked_NoResend(const struct FStartSaveLegendCompeStartRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_StartSaveLegendCompeStart_NoResend(const struct FStartSaveLegendCompeStartRequest& Request);
	static int32 Send_StartSaveRankMatchStart(const struct FStartSaveRankMatchStartRequest& Request);
	static void Send_StartSaveRankMatchStart_Callbacked(const struct FStartSaveRankMatchStartRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_StartSaveRankMatchStart_Callbacked_NoResend(const struct FStartSaveRankMatchStartRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_StartSaveRankMatchStart_NoResend(const struct FStartSaveRankMatchStartRequest& Request);
	static int32 Send_UserGetData(const struct FUserGetDataRequest& Request);
	static void Send_UserGetData_Callbacked(const struct FUserGetDataRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_UserGetData_Callbacked_NoResend(const struct FUserGetDataRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_UserGetData_NoResend(const struct FUserGetDataRequest& Request);
	static int32 Send_UserGetPartsData(const struct FUserGetPartsDataRequest& Request);
	static void Send_UserGetPartsData_Callbacked(const struct FUserGetPartsDataRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_UserGetPartsData_Callbacked_NoResend(const struct FUserGetPartsDataRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_UserGetPartsData_NoResend(const struct FUserGetPartsDataRequest& Request);
	static int32 Send_UserGetUserIdsByPuid(const struct FUserGetUserIdsByPuidRequest& Request);
	static void Send_UserGetUserIdsByPuid_Callbacked(const struct FUserGetUserIdsByPuidRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_UserGetUserIdsByPuid_Callbacked_NoResend(const struct FUserGetUserIdsByPuidRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_UserGetUserIdsByPuid_NoResend(const struct FUserGetUserIdsByPuidRequest& Request);
	static int32 Send_UserGetUserIdsByUid(const struct FUserGetUserIdsByUidRequest& Request);
	static void Send_UserGetUserIdsByUid_Callbacked(const struct FUserGetUserIdsByUidRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_UserGetUserIdsByUid_Callbacked_NoResend(const struct FUserGetUserIdsByUidRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_UserGetUserIdsByUid_NoResend(const struct FUserGetUserIdsByUidRequest& Request);
	static int32 Send_UserGetUserNetworkSettings(const struct FUserGetUserNetworkSettingsRequest& Request);
	static void Send_UserGetUserNetworkSettings_Callbacked(const struct FUserGetUserNetworkSettingsRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_UserGetUserNetworkSettings_Callbacked_NoResend(const struct FUserGetUserNetworkSettingsRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_UserGetUserNetworkSettings_NoResend(const struct FUserGetUserNetworkSettingsRequest& Request);
	static int32 Send_UserGetUserSearch(const struct FUserGetUserSearchRequest& Request);
	static void Send_UserGetUserSearch_Callbacked(const struct FUserGetUserSearchRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_UserGetUserSearch_Callbacked_NoResend(const struct FUserGetUserSearchRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_UserGetUserSearch_NoResend(const struct FUserGetUserSearchRequest& Request);
	static int32 Send_UserNintendoSwitchOnlineCheck(const struct FUserNintendoSwitchOnlineCheckRequest& Request);
	static void Send_UserNintendoSwitchOnlineCheck_Callbacked(const struct FUserNintendoSwitchOnlineCheckRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_UserNintendoSwitchOnlineCheck_Callbacked_NoResend(const struct FUserNintendoSwitchOnlineCheckRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_UserNintendoSwitchOnlineCheck_NoResend(const struct FUserNintendoSwitchOnlineCheckRequest& Request);
	static int32 Send_UserSavePaidDlcOwnerships(const struct FUserSavePaidDlcOwnershipsRequest& Request);
	static void Send_UserSavePaidDlcOwnerships_Callbacked(const struct FUserSavePaidDlcOwnershipsRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_UserSavePaidDlcOwnerships_Callbacked_NoResend(const struct FUserSavePaidDlcOwnershipsRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_UserSavePaidDlcOwnerships_NoResend(const struct FUserSavePaidDlcOwnershipsRequest& Request);
	static int32 Send_UserSaveUserNetworkSettings(const struct FUserSaveUserNetworkSettingsRequest& Request);
	static void Send_UserSaveUserNetworkSettings_Callbacked(const struct FUserSaveUserNetworkSettingsRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static void Send_UserSaveUserNetworkSettings_Callbacked_NoResend(const struct FUserSaveUserNetworkSettingsRequest& Request, TDelegate<void(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error)> Callback);
	static int32 Send_UserSaveUserNetworkSettings_NoResend(const struct FUserSaveUserNetworkSettingsRequest& Request);
	static int32 TransferDataForDownload(const class FString& Uri, TArray<uint8>* Bytes, TDelegate<void(int32 ResCode, bool Error)> OnComplete, TDelegate<void(int32 Length, float Rate)> OnProgress);
	static int32 TransferDataForDownloadDetail(const class FString& Uri, TArray<uint8>* Bytes, TDelegate<void(int32 ResCode, int32 ContentLength, float ElapsedTime, bool Error)> OnComplete, TDelegate<void(int32 Length, float Rate)> OnProgress);
	static const int32 TransferDataGetInvalidHandle();
	static void TransferDataTryCancel(int32 Handle);
	static int32 TransferGhostDataForUpload(const class FString& Uri, const TArray<uint8>& Bytes, TDelegate<void(int32 ResCode, bool Error)> OnComplete, TDelegate<void(int32 Length, float Rate)> OnProgress, int32 courseId, int32 speedType, const class FString& Date);
	static int32 TransferGhostDataForUploadDetail(const class FString& Uri, const TArray<uint8>& Bytes, TDelegate<void(int32 ResCode, int32 ContentLength, float ElapsedTime, bool Error)> OnComplete, TDelegate<void(int32 Length, float Rate)> OnProgress, int32 courseId, int32 speedType, const class FString& Date);
	static class FString TransferGhostDataGetUriForUpload();
	static TArray<uint8> TransferMakeRandomBytes(int32 Size);
	static int32 TransferReplayDataForUpload(const class FString& Uri, const TArray<uint8>& Bytes, TDelegate<void(int32 ResCode, bool Error)> OnComplete, TDelegate<void(int32 Length, float Rate)> OnProgress, const class FString& Name_0);
	static int32 TransferReplayDataForUploadDetail(const class FString& Uri, const TArray<uint8>& Bytes, TDelegate<void(int32 ResCode, int32 ContentLength, float ElapsedTime, bool Error)> OnComplete, TDelegate<void(int32 Length, float Rate)> OnProgress, const class FString& Name_0);
	static bool TransferSaveBytesToFile(const TArray<uint8>& Bytes, const class FString& Path);
	static bool ValidateResCode(bool OutError, int32 ResCode, EResponseCodeAbstract* ResCodeAbstract);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HttpHelper">();
	}
	static class UHttpHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHttpHelper>();
	}
};
static_assert(alignof(UHttpHelper) == 0x000008, "Wrong alignment on UHttpHelper");
static_assert(sizeof(UHttpHelper) == 0x000028, "Wrong size on UHttpHelper");

// Class UnionSystem.HttpHelperContext
// 0x0170 (0x01A0 - 0x0030)
class UHttpHelperContext final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x170];                                     // 0x0030(0x0170)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HttpHelperContext">();
	}
	static class UHttpHelperContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHttpHelperContext>();
	}
};
static_assert(alignof(UHttpHelperContext) == 0x000008, "Wrong alignment on UHttpHelperContext");
static_assert(sizeof(UHttpHelperContext) == 0x0001A0, "Wrong size on UHttpHelperContext");

// Class UnionSystem.InformManager
// 0x0090 (0x00C0 - 0x0030)
class UInformManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x90];                                      // 0x0030(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InformAboutAbuse(const class FString& TargetUserId, int32 reasonId, int32 Location, const class FString& reasonMemo, int32 GameMode, const class FString& entryRaceId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InformManager">();
	}
	static class UInformManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInformManager>();
	}
};
static_assert(alignof(UInformManager) == 0x000008, "Wrong alignment on UInformManager");
static_assert(sizeof(UInformManager) == 0x0000C0, "Wrong size on UInformManager");

// Class UnionSystem.InputDataAsset
// 0x0050 (0x0080 - 0x0030)
class UInputDataAsset final : public UDataAsset
{
public:
	TMap<class FName, struct FInputConfig>        InputConfigs;                                      // 0x0030(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputDataAsset">();
	}
	static class UInputDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputDataAsset>();
	}
};
static_assert(alignof(UInputDataAsset) == 0x000008, "Wrong alignment on UInputDataAsset");
static_assert(sizeof(UInputDataAsset) == 0x000080, "Wrong size on UInputDataAsset");
static_assert(offsetof(UInputDataAsset, InputConfigs) == 0x000030, "Member 'UInputDataAsset::InputConfigs' has a wrong offset!");

// Class UnionSystem.InputProcessInterface
// 0x0000 (0x0000 - 0x0000)
class IInputProcessInterface final
{
public:
	void SilentFocus();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputProcessInterface">();
	}
	static class IInputProcessInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInputProcessInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IInputProcessInterface) == 0x000001, "Wrong alignment on IInputProcessInterface");
static_assert(sizeof(IInputProcessInterface) == 0x000001, "Wrong size on IInputProcessInterface");

// Class UnionSystem.JukeboxDataAsset
// 0x00B0 (0x00E0 - 0x0030)
class UJukeboxDataAsset final : public UDataAsset
{
public:
	class UDataTable*                             JukeboxAlbumCompositeDataTable;                    // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             JukeboxTrackCompositeDataTable;                    // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, struct FAlbumData>                AlbumDataMap;                                      // 0x0040(0x0050)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	TMap<int32, struct FTrackData>                TrackDataMap;                                      // 0x0090(0x0050)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)

public:
	void ClearData();
	struct FAlbumData GetAlbumData(int32 AlbumID);
	struct FTrackData GetTrackData(int32 TrackID);
	void Update();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JukeboxDataAsset">();
	}
	static class UJukeboxDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJukeboxDataAsset>();
	}
};
static_assert(alignof(UJukeboxDataAsset) == 0x000008, "Wrong alignment on UJukeboxDataAsset");
static_assert(sizeof(UJukeboxDataAsset) == 0x0000E0, "Wrong size on UJukeboxDataAsset");
static_assert(offsetof(UJukeboxDataAsset, JukeboxAlbumCompositeDataTable) == 0x000030, "Member 'UJukeboxDataAsset::JukeboxAlbumCompositeDataTable' has a wrong offset!");
static_assert(offsetof(UJukeboxDataAsset, JukeboxTrackCompositeDataTable) == 0x000038, "Member 'UJukeboxDataAsset::JukeboxTrackCompositeDataTable' has a wrong offset!");
static_assert(offsetof(UJukeboxDataAsset, AlbumDataMap) == 0x000040, "Member 'UJukeboxDataAsset::AlbumDataMap' has a wrong offset!");
static_assert(offsetof(UJukeboxDataAsset, TrackDataMap) == 0x000090, "Member 'UJukeboxDataAsset::TrackDataMap' has a wrong offset!");

// Class UnionSystem.KeyConfigItem
// 0x00E8 (0x0110 - 0x0028)
class UKeyConfigItem final : public UObject
{
public:
	uint8                                         Pad_28[0xE8];                                      // 0x0028(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetToDefault();
	void SetPrimaryKey(const struct FKey& Key);
	void SetSecondaryKey(const struct FKey& Key);

	const class FText GetDisplayName() const;
	struct FKey GetPrimaryDefaultKey() const;
	struct FKey GetPrimaryKey() const;
	const class FName GetPrimaryMappingName() const;
	struct FKey GetSecondaryDefaultKey() const;
	struct FKey GetSecondaryKey() const;
	const class FName GetSecondaryMappingName() const;
	bool IsCustomized() const;
	bool IsCustomizedPrimaryKey() const;
	bool IsCustomizedSecondaryKey() const;
	bool IsValidPrimaryKey() const;
	bool IsValidSecondaryKey() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KeyConfigItem">();
	}
	static class UKeyConfigItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKeyConfigItem>();
	}
};
static_assert(alignof(UKeyConfigItem) == 0x000008, "Wrong alignment on UKeyConfigItem");
static_assert(sizeof(UKeyConfigItem) == 0x000110, "Wrong size on UKeyConfigItem");

// Class UnionSystem.KeyConfigHelpers
// 0x0000 (0x0028 - 0x0028)
class UKeyConfigHelpers final : public UBlueprintFunctionLibrary
{
public:
	static EControllerButtonType CalcButtonViewTypeByKey(const struct FKey& InKey);
	static void ClearAssignedKey(int32 InPlayerControllerIndex, const class FName& MappingName);
	static void ClearCustomKeyConfigs(int32 InPlayerControllerIndex);
	static bool CompareCustomKeyConfigs(const TMap<class FName, struct FKey>& CustomKeyConfigs1, const TMap<class FName, struct FKey>& CustomKeyConfigs2);
	static bool FindInputConfig(class UInputDataAsset* InputDataAsset, EKeyConfigOperationType OperationType, struct FInputConfig* OutInputConfig);
	static struct FKey GetAssignedKey(int32 InPlayerControllerIndex, const class FName& MappingName, bool* IsFound);
	static bool GetCustomKeyConfigs(int32 InPlayerControllerIndex, TMap<class FName, struct FKey>* OutCustomKeyConfigs);
	static const class FName GetInputConfigNameFromOperationType(EKeyConfigOperationType OperationType);
	static void GetKeyConfigItems(int32 InPlayerControllerIndex, const struct FInputConfig& InputConfig, EKeyConfigDeviceType Type, TMap<class FName, class UKeyConfigItem*>* OutKeyConfigItems);
	static void SetAssignedKey(int32 InPlayerControllerIndex, const class FName& MappingName, const struct FKey& NewKey);
	static void SetCustomKeyConfigs(int32 InPlayerControllerIndex, const TMap<class FName, struct FKey>& InCustomKeyConfigs);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KeyConfigHelpers">();
	}
	static class UKeyConfigHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKeyConfigHelpers>();
	}
};
static_assert(alignof(UKeyConfigHelpers) == 0x000008, "Wrong alignment on UKeyConfigHelpers");
static_assert(sizeof(UKeyConfigHelpers) == 0x000028, "Wrong size on UKeyConfigHelpers");

// Class UnionSystem.KeyConfigPressAnyKey
// 0x0050 (0x0330 - 0x02E0)
class UKeyConfigPressAnyKey final : public UUserWidget
{
public:
	TMulticastInlineDelegate<void(const struct FKey& NewKey)> OnNewKeyAssigned;                      // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnKeyAssignCancel;                                 // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_300[0x30];                                     // 0x0300(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AssignKey(const struct FKey& NewKey);
	void Cancel();
	void SetCurrentKey(const struct FKey& Key);
	void SetIsGamepadKey(const bool bInIsGamepadKey);

	struct FKey GetCurrentKey() const;
	bool IsGamepadKey() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KeyConfigPressAnyKey">();
	}
	static class UKeyConfigPressAnyKey* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKeyConfigPressAnyKey>();
	}
};
static_assert(alignof(UKeyConfigPressAnyKey) == 0x000008, "Wrong alignment on UKeyConfigPressAnyKey");
static_assert(sizeof(UKeyConfigPressAnyKey) == 0x000330, "Wrong size on UKeyConfigPressAnyKey");
static_assert(offsetof(UKeyConfigPressAnyKey, OnNewKeyAssigned) == 0x0002E0, "Member 'UKeyConfigPressAnyKey::OnNewKeyAssigned' has a wrong offset!");
static_assert(offsetof(UKeyConfigPressAnyKey, OnKeyAssignCancel) == 0x0002F0, "Member 'UKeyConfigPressAnyKey::OnKeyAssignCancel' has a wrong offset!");

// Class UnionSystem.LobbyContextBase
// 0x0208 (0x0230 - 0x0028)
class ULobbyContextBase : public UObject
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxLobbyMember;                                    // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TDelegate<void(class ULobbyContextBase* LobbyContext)> LobbyContextOnLobbyUpdateDelegate;        // 0x0064(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TDelegate<void(class ULobbyContextBase* LobbyContext)> LobbyContextOnLobbyDeleteDelegate;        // 0x0074(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TDelegate<void(class ULobbyContextBase* LobbyContext, class ULobbyMemberContextBase* MemberContext)> LobbyContextOnMemberConnectDelegate; // 0x0084(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TDelegate<void(class ULobbyContextBase* LobbyContext, class ULobbyMemberContextBase* MemberContext)> LobbyContextOnMemberUpdateDelegate; // 0x0094(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TDelegate<void(class ULobbyContextBase* LobbyContext, class ULobbyMemberContextBase* MemberContext, bool bWasKicked)> LobbyContextOnMemberDisconnectDelegate; // 0x00A4(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TDelegate<void(class ULobbyContextBase* LobbyContext, class ULobbyMemberContextBase* MemberContext)> LobbyContextOnMemberPromoteDelegate; // 0x00B4(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C4[0x24];                                      // 0x00C4(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ULobbyMemberContextBase>    LobbyMemberContextClass;                           // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULobbyTransactionParam*                 TransactionParam;                                  // 0x00F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x58];                                      // 0x00F8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class ULobbyMemberContextBase*>   Members;                                           // 0x0150(0x0050)(Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A0[0x90];                                     // 0x01A0(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BeginTransaction();
	void ClearAllLobbyContextDelegates();
	void Create(class ULobbyTransactionParam* Param);
	bool CreateSession(const TDelegate<void(bool bSuccess)>& OnComplete);
	void CreateShortLobbyId(TDelegate<void(const class FString& ShortLobbyId)> OnComplete);
	void CreateSimple(bool bLocked, bool bPublic, bool bHostMigration, const class FString& Password);
	void Destroy();
	bool DestroySession(const TDelegate<void(bool bSuccess)>& OnComplete);
	bool EndTransaction(TDelegate<void(bool bSuccessful, const struct FLobbyOperationResult& Result)> OnComplete);
	bool EndTransaction_NoCallback();
	void Exit();
	void Finalize();
	bool GetHostUserIdStringByLobbyId(int32 InLocalUserNum, const struct FLobbyId& InLobbyId, class FString* OutHostUserId);
	class ULobbyMemberContextBase* GetLocalMemberDefaultDummy();
	void Initialize(int32 LocalUserNum, const struct FUniqueNetIdRepl& UserId, const struct FUniqueNetIdRepl& OwnerUserId, const struct FLobbyId& LobbyId);
	void InitializeNoLobbyInfo(int32 LocalUserNum);
	void Join(const struct FLobbyId& LobbyId, const class FString& Password);
	void KeepAliveShortLobbyId();
	void KickMember(class ULobbyMemberContextBase* MemberContext, TDelegate<void(bool bSuccessful, const struct FLobbyOperationResult& Result)> OnComplete);
	void OnConnectLobbyCompletedInternal(bool bSuccessful, const struct FOnlineErrorBP& Error);
	void OnCreateLobbyCompletedInternal(bool bSuccessful, const struct FOnlineErrorBP& Error);
	void OnCreateShortLobbyIdComplete(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error);
	void OnDeleteLobbyComplete(bool bSuccessful, const struct FLobbyOperationResult& Result);
	void OnDeleteLobbyCompletedInternal(bool bSuccessful, const struct FOnlineErrorBP& Error);
	void OnDestroiedSession(bool bSuccessful);
	void OnDisconnectLobbyCompletedInternal(bool bSuccessful, const struct FOnlineErrorBP& Error);
	void OnGetLobbyHostCallbackInternal(bool bWasSuccessful, const TArray<struct FCommon_UserSearchData>& SearchDatas, EResponseCodeAbstract ResCodeAbstract);
	void OnKeepAliveShortLobbyIdComplete(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error);
	void OnKickMemberComplete(bool bSuccessful, const struct FLobbyOperationResult& Result);
	void OnLobbyDelete(const struct FUniqueNetIdRepl& UserId, const struct FLobbyId& LobbyId);
	void OnLobbyDeleteInternal();
	void OnLobbyUpdate(const struct FUniqueNetIdRepl& UserId, const struct FLobbyId& LobbyId);
	void OnLobbyUpdateInternal();
	void OnMemberConnect(const struct FUniqueNetIdRepl& UserId, const struct FLobbyId& LobbyId, const struct FUniqueNetIdRepl& MemberId);
	void OnMemberConnectInternal(class ULobbyMemberContextBase* MemberContext);
	void OnMemberDisconnect(const struct FUniqueNetIdRepl& UserId, const struct FLobbyId& LobbyId, const struct FUniqueNetIdRepl& MemberId, bool bWasKicked);
	void OnMemberDisconnectInternal(class ULobbyMemberContextBase* MemberContext, bool bWasKicked);
	void OnMemberPromote(const struct FUniqueNetIdRepl& UserId, const struct FLobbyId& LobbyId, const struct FUniqueNetIdRepl& NewLeaderId);
	void OnMemberPromoteInternal(class ULobbyMemberContextBase* MemberContext);
	void OnMemberUpdate(const struct FUniqueNetIdRepl& UserId, const struct FLobbyId& LobbyId, const struct FUniqueNetIdRepl& MemberId);
	void OnMemberUpdateInternal(class ULobbyMemberContextBase* MemberContext);
	void OnPlatformEvent(const struct FUnionPlatformEventInfo& EventInfo);
	void OnSearchLobbyCompletedInternal(bool bSuccessful, const struct FSearchLobbyResult& Result);
	void OnUpdateLobbyComplete(bool bSuccessful, const struct FLobbyOperationResult& Result, TDelegate<void(bool bSuccessful, const struct FLobbyOperationResult& Result)> OnComplete);
	void RemoveComMemberContext();
	void RemoveShortLobbyId();
	void ResetShortLobbyId();
	void SearchByShortLobbyId(const class FString& ShortLobbyId);
	void SearchByShortLobbyIdNoLobbyType(const class FString& ShortLobbyId);
	bool SendSessionInvite(const struct FUniqueNetIdRepl& FriendId);
	void SetLocked(bool bInLock);
	void SetPublic(bool bInPublic);
	void WaitAddMemberInitComplete(TDelegate<void()> OnComplete);

	void GetAllMemberInternalUserIds(TArray<class FString>* OutResult) const;
	void GetAllMembers(TArray<class ULobbyMemberContextBase*>* OutResult) const;
	void GetAllMemberUserIds(TArray<class FString>* OutResult) const;
	int32 GetHasValidInitDataMemerContextCount() const;
	class ULobbyMemberContextBase* GetHostMember() const;
	const struct FLobbyId GetLobbyId() const;
	bool GetLobbyTypeByLobbyId(int32 InLocalUserNum, const struct FLobbyId& InLobbyId, int64* OutLobbyType) const;
	class ULobbyMemberContextBase* GetLocalMember() const;
	void GetLocalUserId(struct FUniqueNetIdRepl* OutUserId) const;
	int32 GetMaxLobbyMember() const;
	class ULobbyMemberContextBase* GetMember(const struct FUniqueNetIdRepl& MemberId) const;
	int32 GetMemberCount() const;
	class ULobbyMemberContextBase* GetMemberFromLobbyMemberIndex(int32 LobbyMemberIndex) const;
	void GetOwnerUserId(struct FUniqueNetIdRepl* OutUserId) const;
	class FString GetShortLobbyId() const;
	float GetShortLobbyIdExpirationTimeSec() const;
	void GetSortedAllMembersByLobbyMemberIndex(TArray<class ULobbyMemberContextBase*>* OutResult) const;
	bool HasSession() const;
	bool IsJoining() const;
	bool IsLobbyHostLocalMember() const;
	bool IsSameLobby(const class ULobbyContextBase* OtherContext) const;
	class FString ToString() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyContextBase">();
	}
	static class ULobbyContextBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyContextBase>();
	}
};
static_assert(alignof(ULobbyContextBase) == 0x000008, "Wrong alignment on ULobbyContextBase");
static_assert(sizeof(ULobbyContextBase) == 0x000230, "Wrong size on ULobbyContextBase");
static_assert(offsetof(ULobbyContextBase, MaxLobbyMember) == 0x000060, "Member 'ULobbyContextBase::MaxLobbyMember' has a wrong offset!");
static_assert(offsetof(ULobbyContextBase, LobbyContextOnLobbyUpdateDelegate) == 0x000064, "Member 'ULobbyContextBase::LobbyContextOnLobbyUpdateDelegate' has a wrong offset!");
static_assert(offsetof(ULobbyContextBase, LobbyContextOnLobbyDeleteDelegate) == 0x000074, "Member 'ULobbyContextBase::LobbyContextOnLobbyDeleteDelegate' has a wrong offset!");
static_assert(offsetof(ULobbyContextBase, LobbyContextOnMemberConnectDelegate) == 0x000084, "Member 'ULobbyContextBase::LobbyContextOnMemberConnectDelegate' has a wrong offset!");
static_assert(offsetof(ULobbyContextBase, LobbyContextOnMemberUpdateDelegate) == 0x000094, "Member 'ULobbyContextBase::LobbyContextOnMemberUpdateDelegate' has a wrong offset!");
static_assert(offsetof(ULobbyContextBase, LobbyContextOnMemberDisconnectDelegate) == 0x0000A4, "Member 'ULobbyContextBase::LobbyContextOnMemberDisconnectDelegate' has a wrong offset!");
static_assert(offsetof(ULobbyContextBase, LobbyContextOnMemberPromoteDelegate) == 0x0000B4, "Member 'ULobbyContextBase::LobbyContextOnMemberPromoteDelegate' has a wrong offset!");
static_assert(offsetof(ULobbyContextBase, LobbyMemberContextClass) == 0x0000E8, "Member 'ULobbyContextBase::LobbyMemberContextClass' has a wrong offset!");
static_assert(offsetof(ULobbyContextBase, TransactionParam) == 0x0000F0, "Member 'ULobbyContextBase::TransactionParam' has a wrong offset!");
static_assert(offsetof(ULobbyContextBase, Members) == 0x000150, "Member 'ULobbyContextBase::Members' has a wrong offset!");

// Class UnionSystem.LobbySubsystem
// 0x19D0 (0x1A00 - 0x0030)
class ULobbySubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FUniqueNetIdRepl& UserId, const struct FLobbyId& LobbyId)> LobbyUpdateMulticastDelegate; // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(const struct FUniqueNetIdRepl& UserId, const struct FLobbyId& LobbyId)> LobbyDeleteMulticastDelegate; // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(const struct FUniqueNetIdRepl& UserId, const struct FLobbyId& LobbyId, const struct FUniqueNetIdRepl& MemberId)> MemberConnectMulticastDelegate; // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(const struct FUniqueNetIdRepl& UserId, const struct FLobbyId& LobbyId, const struct FUniqueNetIdRepl& MemberId)> MemberUpdateMulticastDelegate; // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(const struct FUniqueNetIdRepl& UserId, const struct FLobbyId& LobbyId, const struct FUniqueNetIdRepl& MemberId, bool bWasKicked)> MemberDisconnectMulticastDelegate; // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(const struct FUniqueNetIdRepl& UserId, const struct FLobbyId& LobbyId, const struct FUniqueNetIdRepl& MemberId)> MemberPromotedMulticastDelegate; // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(const struct FUniqueNetIdRepl& UserId, class ULobbyJoinInfo* Invite)> InvitationReceivedMulticastDelegate; // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void()>              PlatformInviteReceivedMulticastDelegate;           // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x1948];                                    // 0x00B8(0x1948)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallInvitationReceivedDelegates(int32 LocalUserNum, const struct FLobbyId& LobbyId);
	void ClearAllDelegates();
	void ConfirmMatchingUsers(int32 LocalUserNum, const struct FLobbyId& LobbyId);
	void ConnectLobby(int32 LocalUserNum, const struct FLobbyId& LobbyId, const class FString& Password, TDelegate<void(bool bSuccessful, const struct FCreateOrConnectLobbyResult& Result)> OnComplete);
	void ConnectP2PAsync(int32 LocalUserNum, const struct FLobbyId& LobbyId);
	int32 ConnectP2PLobbyUsers(int32 LocalUserNum, const struct FLobbyId& LobbyId, bool IsHost, bool EnableAllClientConnect);
	void CreateLobby(int32 LocalUserNum, const class ULobbyTransactionParam* TransactionParam, TDelegate<void(bool bSuccessful, const struct FCreateOrConnectLobbyResult& Result)> OnComplete);
	void DeleteLobby(int32 LocalUserNum, const struct FLobbyId& LobbyId, TDelegate<void(bool bSuccessful, const struct FLobbyOperationResult& Result)> OnComplete);
	bool GetLobbyAttributeValueBool(int32 LocalUserNum, const struct FLobbyId& LobbyId, const class FString& AttrKey, bool* OutAttrValue, bool bUseLobbyAttribute);
	bool GetLobbyAttributeValueFloat(int32 LocalUserNum, const struct FLobbyId& LobbyId, const class FString& AttrKey, float* OutAttrValue, bool bUseLobbyAttribute);
	bool GetLobbyAttributeValueInt64(int32 LocalUserNum, const struct FLobbyId& LobbyId, const class FString& AttrKey, int64* OutAttrValue, bool bUseLobbyAttribute);
	bool GetLobbyAttributeValueString(int32 LocalUserNum, const struct FLobbyId& LobbyId, const class FString& AttrKey, class FString* OutAttrValue, bool bUseLobbyAttribute);
	bool GetMemberAttributeValueBool(int32 LocalUserNum, const struct FLobbyId& LobbyId, const struct FUniqueNetIdRepl& MemberId, const class FString& AttrKey, bool* OutAttrValue, bool bUseLobbyAttribute);
	bool GetMemberAttributeValueFloat(int32 LocalUserNum, const struct FLobbyId& LobbyId, const struct FUniqueNetIdRepl& MemberId, const class FString& AttrKey, float* OutAttrValue, bool bUseLobbyAttribute);
	bool GetMemberAttributeValueInt64(int32 LocalUserNum, const struct FLobbyId& LobbyId, const struct FUniqueNetIdRepl& MemberId, const class FString& AttrKey, int64* OutAttrValue, bool bUseLobbyAttribute);
	bool GetMemberAttributeValueString(int32 LocalUserNum, const struct FLobbyId& LobbyId, const struct FUniqueNetIdRepl& MemberId, const class FString& AttrKey, class FString* OutAttrValue, bool bUseLobbyAttribute);
	bool GetPendingInviteInfo(int32 LocalUserNum, TArray<class ULobbyJoinInfo*>* OutPendingInvites);
	bool GetSessionInviteInfo(int32 LocalUserNum, TArray<class ULobbyJoinInfo*>* OutPendingInvites);
	bool IsRequiredPassword(int32 LocalUserNum, const struct FLobbyId& LobbyId);
	void KickMember(int32 LocalUserNum, const struct FLobbyId& LobbyId, const struct FUniqueNetIdRepl& MemberId, TDelegate<void(bool bSuccessful, const struct FLobbyOperationResult& Result)> OnComplete);
	void PromoteMember(int32 LocalUserNum, const struct FLobbyId& LobbyId, const struct FUniqueNetIdRepl& MemberId, TDelegate<void(bool bSuccessful, const struct FLobbyOperationResult& Result)> OnComplete);
	void RejectInvitation(int32 LocalUserNum, const class ULobbyJoinInfo* InviteInfo, TDelegate<void(bool bSuccessful, const struct FLobbyOperationResult& Result)> OnComplete);
	void SearchLobby(int32 LocalUserNum, int64 LobbyType, TDelegate<void(bool bSuccessful, const struct FSearchLobbyResult& Result)> OnComplete);
	void SetPFBusyFlag(bool BusyFlag);
	bool SetupConnectP2PLobbyUsers(int32 LocalUserNum, const struct FLobbyId& LobbyId, bool IsHost);

	bool GetJoinedLobbies(int32 LocalUserNum, TArray<struct FLobbyId>* OutLobbyIds) const;
	int32 GetMaxMemberCount() const;
	int32 GetMemberCount(int32 LocalUserNum, const struct FLobbyId& LobbyId) const;
	struct FUniqueNetIdRepl GetMemberUserId(int32 LocalUserNum, const struct FLobbyId& LobbyId, int32 MemberIndex) const;
	TArray<struct FUniqueNetIdRepl> GetMemberUserIds(int32 LocalUserNum, const struct FLobbyId& LobbyId) const;
	int32 GetOnlineIndex() const;
	bool HasSessionInvite() const;
	bool IsLockedLobby(int32 LocalUserNum, const struct FLobbyId& LobbyId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbySubsystem">();
	}
	static class ULobbySubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbySubsystem>();
	}
};
static_assert(alignof(ULobbySubsystem) == 0x000008, "Wrong alignment on ULobbySubsystem");
static_assert(sizeof(ULobbySubsystem) == 0x001A00, "Wrong size on ULobbySubsystem");
static_assert(offsetof(ULobbySubsystem, LobbyUpdateMulticastDelegate) == 0x000038, "Member 'ULobbySubsystem::LobbyUpdateMulticastDelegate' has a wrong offset!");
static_assert(offsetof(ULobbySubsystem, LobbyDeleteMulticastDelegate) == 0x000048, "Member 'ULobbySubsystem::LobbyDeleteMulticastDelegate' has a wrong offset!");
static_assert(offsetof(ULobbySubsystem, MemberConnectMulticastDelegate) == 0x000058, "Member 'ULobbySubsystem::MemberConnectMulticastDelegate' has a wrong offset!");
static_assert(offsetof(ULobbySubsystem, MemberUpdateMulticastDelegate) == 0x000068, "Member 'ULobbySubsystem::MemberUpdateMulticastDelegate' has a wrong offset!");
static_assert(offsetof(ULobbySubsystem, MemberDisconnectMulticastDelegate) == 0x000078, "Member 'ULobbySubsystem::MemberDisconnectMulticastDelegate' has a wrong offset!");
static_assert(offsetof(ULobbySubsystem, MemberPromotedMulticastDelegate) == 0x000088, "Member 'ULobbySubsystem::MemberPromotedMulticastDelegate' has a wrong offset!");
static_assert(offsetof(ULobbySubsystem, InvitationReceivedMulticastDelegate) == 0x000098, "Member 'ULobbySubsystem::InvitationReceivedMulticastDelegate' has a wrong offset!");
static_assert(offsetof(ULobbySubsystem, PlatformInviteReceivedMulticastDelegate) == 0x0000A8, "Member 'ULobbySubsystem::PlatformInviteReceivedMulticastDelegate' has a wrong offset!");

// Class UnionSystem.LobbyTransactionParam
// 0x0070 (0x0098 - 0x0028)
class ULobbyTransactionParam final : public UObject
{
public:
	uint8                                         Pad_28[0x70];                                      // 0x0028(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAttributeBool(const class FString& Key, bool Value);
	void AddAttributeFloat(const class FString& Key, float Value);
	void AddAttributeInt64(const class FString& Key, int64 Value);
	void AddAttributeString(const class FString& Key, const class FString& Value);
	void AddDeleteAttribute(const class FString& Key);
	void SetCapacity(int64 InCapacity);
	void SetCreateDefault();
	void SetEnableHostMigration(bool bInEnableHostMigration);
	void SetLocked(bool bInLocked);
	void SetPassword(const class FString& InPassword);
	void SetPublic(bool bInPublic);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyTransactionParam">();
	}
	static class ULobbyTransactionParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyTransactionParam>();
	}
};
static_assert(alignof(ULobbyTransactionParam) == 0x000008, "Wrong alignment on ULobbyTransactionParam");
static_assert(sizeof(ULobbyTransactionParam) == 0x000098, "Wrong size on ULobbyTransactionParam");

// Class UnionSystem.LobbyMemberTransactionParam
// 0x0060 (0x0088 - 0x0028)
class ULobbyMemberTransactionParam final : public UObject
{
public:
	uint8                                         Pad_28[0x60];                                      // 0x0028(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAttributeBool(const class FString& Key, bool Value);
	void AddAttributeFloat(const class FString& Key, float Value);
	void AddAttributeInt64(const class FString& Key, int64 Value);
	void AddAttributeString(const class FString& Key, const class FString& Value);
	void AddDeleteAttribute(const class FString& Key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyMemberTransactionParam">();
	}
	static class ULobbyMemberTransactionParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyMemberTransactionParam>();
	}
};
static_assert(alignof(ULobbyMemberTransactionParam) == 0x000008, "Wrong alignment on ULobbyMemberTransactionParam");
static_assert(sizeof(ULobbyMemberTransactionParam) == 0x000088, "Wrong size on ULobbyMemberTransactionParam");

// Class UnionSystem.LobbySubsystemLobbySearchQueryUtility
// 0x0000 (0x0028 - 0x0028)
class ULobbySubsystemLobbySearchQueryUtility final : public UBlueprintFunctionLibrary
{
public:
	static void AddLobbySearchQueryFilter_Bool(struct FLobbySubsystemLobbySearchQuery& Query, const class FString& Key, bool bValue, ELobbySubsystemLobbySearchQueryFilterComparator Comparator);
	static void AddLobbySearchQueryFilter_Float(struct FLobbySubsystemLobbySearchQuery& Query, const class FString& Key, float Value, ELobbySubsystemLobbySearchQueryFilterComparator Comparator);
	static void AddLobbySearchQueryFilter_Int64(struct FLobbySubsystemLobbySearchQuery& Query, const class FString& Key, int64 Value, ELobbySubsystemLobbySearchQueryFilterComparator Comparator);
	static void AddLobbySearchQueryFilter_String(struct FLobbySubsystemLobbySearchQuery& Query, const class FString& Key, const class FString& Value, ELobbySubsystemLobbySearchQueryFilterComparator Comparator);
	static void SetLimit(struct FLobbySubsystemLobbySearchQuery& Query, int32 NewLimit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbySubsystemLobbySearchQueryUtility">();
	}
	static class ULobbySubsystemLobbySearchQueryUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbySubsystemLobbySearchQueryUtility>();
	}
};
static_assert(alignof(ULobbySubsystemLobbySearchQueryUtility) == 0x000008, "Wrong alignment on ULobbySubsystemLobbySearchQueryUtility");
static_assert(sizeof(ULobbySubsystemLobbySearchQueryUtility) == 0x000028, "Wrong size on ULobbySubsystemLobbySearchQueryUtility");

// Class UnionSystem.LobbyJoinInfo
// 0x0038 (0x0060 - 0x0028)
class ULobbyJoinInfo final : public UObject
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FLobbyId GetLobbyId() const;
	class FString GetPasswrod() const;
	class FString GetSourceDisplayName() const;
	struct FUniqueNetIdRepl GetSourceUserId() const;
	bool HasSessionInvite() const;
	bool IsAccepted() const;
	class FString ToString() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyJoinInfo">();
	}
	static class ULobbyJoinInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyJoinInfo>();
	}
};
static_assert(alignof(ULobbyJoinInfo) == 0x000008, "Wrong alignment on ULobbyJoinInfo");
static_assert(sizeof(ULobbyJoinInfo) == 0x000060, "Wrong size on ULobbyJoinInfo");

// Class UnionSystem.LocalizationFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class ULocalizationFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static ELanguage ConvLangToEnumFromString(const class FString& LangString);
	static class FString ConvLangToStringFromEnum(ELanguage LangEnum);
	static ELanguage GetDefaultTextLang();
	static float GetFontSizeRate();
	static class FText GetKeytopButtonTextByFKey(const struct FKey& InKey, uint8 KeytopPattern);
	static ELanguage GetPCPlatformLanguage();
	static ELanguage GetPCPlatformVoiceLangFromTable();
	static ELanguage GetTextLang();
	static ELanguage GetVoiceLang();
	static ELanguage GetVoiceLangFromTable();
	static ELanguage GetVoiceLangFromTableByEnum(ELanguage Lang);
	static void SetTextLang(ELanguage Lang);
	static void SetTextLangByString(const class FString& Lang);
	static void SetVoiceLang(ELanguage Lang);
	static void SetVoiceLangByString(const class FString& Lang);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalizationFunctionLibrary">();
	}
	static class ULocalizationFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalizationFunctionLibrary>();
	}
};
static_assert(alignof(ULocalizationFunctionLibrary) == 0x000008, "Wrong alignment on ULocalizationFunctionLibrary");
static_assert(sizeof(ULocalizationFunctionLibrary) == 0x000028, "Wrong size on ULocalizationFunctionLibrary");

// Class UnionSystem.LocalStorageSubsystem
// 0x0030 (0x0060 - 0x0030)
class ULocalStorageSubsystem final : public UGameInstanceSubsystem
{
public:
	TDelegate<void(ELocalStorageStatus Status)>   OnSaveComplete;                                    // 0x0030(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(ELocalStorageStatus Status)>   OnLoadComplete;                                    // 0x0040(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Delete(const class FString& Filename, ELocalStorageStatus* OutStatus);
	bool Exists(const class FString& Filename, ELocalStorageStatus* OutStatus);
	bool IsBusy();
	void LoadAsync(const class FString& Filename, TArray<uint8>* OutBuffer);
	void SaveAsync(const class FString& Filename, TArray<uint8>* InBuffer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalStorageSubsystem">();
	}
	static class ULocalStorageSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalStorageSubsystem>();
	}
};
static_assert(alignof(ULocalStorageSubsystem) == 0x000008, "Wrong alignment on ULocalStorageSubsystem");
static_assert(sizeof(ULocalStorageSubsystem) == 0x000060, "Wrong size on ULocalStorageSubsystem");
static_assert(offsetof(ULocalStorageSubsystem, OnSaveComplete) == 0x000030, "Member 'ULocalStorageSubsystem::OnSaveComplete' has a wrong offset!");
static_assert(offsetof(ULocalStorageSubsystem, OnLoadComplete) == 0x000040, "Member 'ULocalStorageSubsystem::OnLoadComplete' has a wrong offset!");

// Class UnionSystem.LogTrackSubsystem
// 0x0020 (0x0050 - 0x0030)
class ULogTrackSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogTrackSubsystem">();
	}
	static class ULogTrackSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogTrackSubsystem>();
	}
};
static_assert(alignof(ULogTrackSubsystem) == 0x000008, "Wrong alignment on ULogTrackSubsystem");
static_assert(sizeof(ULogTrackSubsystem) == 0x000050, "Wrong size on ULogTrackSubsystem");

// Class UnionSystem.MachineIdUtilityLibrary
// 0x0000 (0x0028 - 0x0028)
class UMachineIdUtilityLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString BuildHoverboardCenterPartsPath(EMachineId FrontPartsId, EMachineId RearPartsId);
	static class FString BuildMachineSidePartsPath(EMachineId FrontPartsId, EMachineId RearPartsId);
	static EMachineId GetConvertMachineIdToMachineCustomId(EMachineId InMachineID);
	static int32 GetPlayerIndexFromSimpleCustomMachineId(EMachineId InMachineID);
	static bool IsBasicCustomMachineId(EMachineId InMachineID);
	static bool IsBasicMachineId(EMachineId InMachineID);
	static bool IsCustomMachineId(EMachineId InMachineID);
	static bool IsExtendMachineId(EMachineId InMachineID);
	static bool IsHoverboardMachineId(EMachineId InMachineID);
	static bool IsSimpleCustomMachineId(EMachineId InMachineID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MachineIdUtilityLibrary">();
	}
	static class UMachineIdUtilityLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMachineIdUtilityLibrary>();
	}
};
static_assert(alignof(UMachineIdUtilityLibrary) == 0x000008, "Wrong alignment on UMachineIdUtilityLibrary");
static_assert(sizeof(UMachineIdUtilityLibrary) == 0x000028, "Wrong size on UMachineIdUtilityLibrary");

// Class UnionSystem.MasterDataHelper
// 0x01B8 (0x01E0 - 0x0028)
class UMasterDataHelper : public UObject
{
public:
	class UDataTable*                             DriverData;                                        // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DriverCustomParamData;                             // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             MachineCockpitDataTable;                           // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             MachinePartsDataTable;                             // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             MachineTypeDataTable;                              // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DefaultMachineCustomizeDataTable;                  // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             MonsterTruckCockpitDataTable;                      // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             MachineColorDataTable;                             // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             MachineSurfaceDataTable;                           // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             MachineGlowDataTable;                              // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             MachineColorPresetDataTable;                       // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             GroupColorIdToMachineColorPresetIdDataTable;       // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             MachineOffsetDataTable;                            // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             MachineOtherNameDataTable;                         // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             MachineBakeAsset;                                  // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             MachineHornDataTable;                              // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             MachineAuraDataTable;                              // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             StageDataTable;                                    // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             GadgetDataTable;                                   // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             GadgetPlateDataTable;                              // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DefaultGadgetPresetDataTable;                      // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             GadgetLayoutDataTable;                             // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             GadgetCustomCategoryColorDataTable;                // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             StickerDataTable;                                  // 0x00E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             RaceItemDataTable;                                 // 0x00E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             FooterTextDataTable;                               // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             RivalTeamDataTable;                                // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             PartyRaceMissionDataTable;                         // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             PartyRacePresetSettingDataTable;                   // 0x0108(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             RewardRivalLevelDataTable;                         // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             RateRankUpExpDataTable;                            // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             UIResultParamTable;                                // 0x0120(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             RewardTimeTrialDataTable;                          // 0x0128(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             OnlineErrorTextLabelTable;                         // 0x0130(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ServerErrorTextLabelTable;                         // 0x0138(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             CompensationTitleTextLabelTable;                   // 0x0140(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             CompensationBodyTextLabelTable;                    // 0x0148(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             SaveDataTextTable;                                 // 0x0150(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGrandPrixCommonData*                   GrandPrixCommonData;                               // 0x0158(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             GrandPrixStages;                                   // 0x0160(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             UIColorInfoDataAsset;                              // 0x0168(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             FestaUIDataAsset;                                  // 0x0170(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             HonorTitleDataAsset;                               // 0x0178(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             JukeboxDataAsset;                                  // 0x0180(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             ContentDataAsset;                                  // 0x0188(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ChallengeDataTable;                                // 0x0190(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ChallengeProgressRewardTable;                      // 0x0198(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             RewardAchievementDataTable;                        // 0x01A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             RewardGrandPrixRivalWinHonorDataTable;             // 0x01A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             IgnoreWidgetDataAsset;                             // 0x01B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             PlatformPresence;                                  // 0x01B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             PlatformStoreMessageDataAsset;                     // 0x01C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             PlayerInteractionData;                             // 0x01C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             RivalInteractionData;                              // 0x01D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             CueSheetIdTable;                                   // 0x01D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MasterDataHelper">();
	}
	static class UMasterDataHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMasterDataHelper>();
	}
};
static_assert(alignof(UMasterDataHelper) == 0x000008, "Wrong alignment on UMasterDataHelper");
static_assert(sizeof(UMasterDataHelper) == 0x0001E0, "Wrong size on UMasterDataHelper");
static_assert(offsetof(UMasterDataHelper, DriverData) == 0x000028, "Member 'UMasterDataHelper::DriverData' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, DriverCustomParamData) == 0x000030, "Member 'UMasterDataHelper::DriverCustomParamData' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, MachineCockpitDataTable) == 0x000038, "Member 'UMasterDataHelper::MachineCockpitDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, MachinePartsDataTable) == 0x000040, "Member 'UMasterDataHelper::MachinePartsDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, MachineTypeDataTable) == 0x000048, "Member 'UMasterDataHelper::MachineTypeDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, DefaultMachineCustomizeDataTable) == 0x000050, "Member 'UMasterDataHelper::DefaultMachineCustomizeDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, MonsterTruckCockpitDataTable) == 0x000058, "Member 'UMasterDataHelper::MonsterTruckCockpitDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, MachineColorDataTable) == 0x000060, "Member 'UMasterDataHelper::MachineColorDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, MachineSurfaceDataTable) == 0x000068, "Member 'UMasterDataHelper::MachineSurfaceDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, MachineGlowDataTable) == 0x000070, "Member 'UMasterDataHelper::MachineGlowDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, MachineColorPresetDataTable) == 0x000078, "Member 'UMasterDataHelper::MachineColorPresetDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, GroupColorIdToMachineColorPresetIdDataTable) == 0x000080, "Member 'UMasterDataHelper::GroupColorIdToMachineColorPresetIdDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, MachineOffsetDataTable) == 0x000088, "Member 'UMasterDataHelper::MachineOffsetDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, MachineOtherNameDataTable) == 0x000090, "Member 'UMasterDataHelper::MachineOtherNameDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, MachineBakeAsset) == 0x000098, "Member 'UMasterDataHelper::MachineBakeAsset' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, MachineHornDataTable) == 0x0000A0, "Member 'UMasterDataHelper::MachineHornDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, MachineAuraDataTable) == 0x0000A8, "Member 'UMasterDataHelper::MachineAuraDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, StageDataTable) == 0x0000B0, "Member 'UMasterDataHelper::StageDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, GadgetDataTable) == 0x0000B8, "Member 'UMasterDataHelper::GadgetDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, GadgetPlateDataTable) == 0x0000C0, "Member 'UMasterDataHelper::GadgetPlateDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, DefaultGadgetPresetDataTable) == 0x0000C8, "Member 'UMasterDataHelper::DefaultGadgetPresetDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, GadgetLayoutDataTable) == 0x0000D0, "Member 'UMasterDataHelper::GadgetLayoutDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, GadgetCustomCategoryColorDataTable) == 0x0000D8, "Member 'UMasterDataHelper::GadgetCustomCategoryColorDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, StickerDataTable) == 0x0000E0, "Member 'UMasterDataHelper::StickerDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, RaceItemDataTable) == 0x0000E8, "Member 'UMasterDataHelper::RaceItemDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, FooterTextDataTable) == 0x0000F0, "Member 'UMasterDataHelper::FooterTextDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, RivalTeamDataTable) == 0x0000F8, "Member 'UMasterDataHelper::RivalTeamDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, PartyRaceMissionDataTable) == 0x000100, "Member 'UMasterDataHelper::PartyRaceMissionDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, PartyRacePresetSettingDataTable) == 0x000108, "Member 'UMasterDataHelper::PartyRacePresetSettingDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, RewardRivalLevelDataTable) == 0x000110, "Member 'UMasterDataHelper::RewardRivalLevelDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, RateRankUpExpDataTable) == 0x000118, "Member 'UMasterDataHelper::RateRankUpExpDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, UIResultParamTable) == 0x000120, "Member 'UMasterDataHelper::UIResultParamTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, RewardTimeTrialDataTable) == 0x000128, "Member 'UMasterDataHelper::RewardTimeTrialDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, OnlineErrorTextLabelTable) == 0x000130, "Member 'UMasterDataHelper::OnlineErrorTextLabelTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, ServerErrorTextLabelTable) == 0x000138, "Member 'UMasterDataHelper::ServerErrorTextLabelTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, CompensationTitleTextLabelTable) == 0x000140, "Member 'UMasterDataHelper::CompensationTitleTextLabelTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, CompensationBodyTextLabelTable) == 0x000148, "Member 'UMasterDataHelper::CompensationBodyTextLabelTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, SaveDataTextTable) == 0x000150, "Member 'UMasterDataHelper::SaveDataTextTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, GrandPrixCommonData) == 0x000158, "Member 'UMasterDataHelper::GrandPrixCommonData' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, GrandPrixStages) == 0x000160, "Member 'UMasterDataHelper::GrandPrixStages' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, UIColorInfoDataAsset) == 0x000168, "Member 'UMasterDataHelper::UIColorInfoDataAsset' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, FestaUIDataAsset) == 0x000170, "Member 'UMasterDataHelper::FestaUIDataAsset' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, HonorTitleDataAsset) == 0x000178, "Member 'UMasterDataHelper::HonorTitleDataAsset' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, JukeboxDataAsset) == 0x000180, "Member 'UMasterDataHelper::JukeboxDataAsset' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, ContentDataAsset) == 0x000188, "Member 'UMasterDataHelper::ContentDataAsset' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, ChallengeDataTable) == 0x000190, "Member 'UMasterDataHelper::ChallengeDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, ChallengeProgressRewardTable) == 0x000198, "Member 'UMasterDataHelper::ChallengeProgressRewardTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, RewardAchievementDataTable) == 0x0001A0, "Member 'UMasterDataHelper::RewardAchievementDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, RewardGrandPrixRivalWinHonorDataTable) == 0x0001A8, "Member 'UMasterDataHelper::RewardGrandPrixRivalWinHonorDataTable' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, IgnoreWidgetDataAsset) == 0x0001B0, "Member 'UMasterDataHelper::IgnoreWidgetDataAsset' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, PlatformPresence) == 0x0001B8, "Member 'UMasterDataHelper::PlatformPresence' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, PlatformStoreMessageDataAsset) == 0x0001C0, "Member 'UMasterDataHelper::PlatformStoreMessageDataAsset' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, PlayerInteractionData) == 0x0001C8, "Member 'UMasterDataHelper::PlayerInteractionData' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, RivalInteractionData) == 0x0001D0, "Member 'UMasterDataHelper::RivalInteractionData' has a wrong offset!");
static_assert(offsetof(UMasterDataHelper, CueSheetIdTable) == 0x0001D8, "Member 'UMasterDataHelper::CueSheetIdTable' has a wrong offset!");

// Class UnionSystem.MasterDataManageSubsystem
// 0x0020 (0x0050 - 0x0030)
class UMasterDataManageSubsystem final : public UGameInstanceSubsystem
{
public:
	class UMasterDataHelper*                      MasterDataHelper;                                  // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URaceMasterDataAccessor*                RaceMasterDataAccessor;                            // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MasterDataManageSubsystem">();
	}
	static class UMasterDataManageSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMasterDataManageSubsystem>();
	}
};
static_assert(alignof(UMasterDataManageSubsystem) == 0x000008, "Wrong alignment on UMasterDataManageSubsystem");
static_assert(sizeof(UMasterDataManageSubsystem) == 0x000050, "Wrong size on UMasterDataManageSubsystem");
static_assert(offsetof(UMasterDataManageSubsystem, MasterDataHelper) == 0x000030, "Member 'UMasterDataManageSubsystem::MasterDataHelper' has a wrong offset!");
static_assert(offsetof(UMasterDataManageSubsystem, RaceMasterDataAccessor) == 0x000038, "Member 'UMasterDataManageSubsystem::RaceMasterDataAccessor' has a wrong offset!");

// Class UnionSystem.MatchmakingRequestContext
// 0x0028 (0x0258 - 0x0230)
class UMatchmakingRequestContext : public ULobbyContextBase
{
public:
	uint8                                         Pad_230[0x28];                                     // 0x0230(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetNoTriggerMatchmakingComplete(bool bNewValue);

	bool IsSeries() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchmakingRequestContext">();
	}
	static class UMatchmakingRequestContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchmakingRequestContext>();
	}
};
static_assert(alignof(UMatchmakingRequestContext) == 0x000008, "Wrong alignment on UMatchmakingRequestContext");
static_assert(sizeof(UMatchmakingRequestContext) == 0x000258, "Wrong size on UMatchmakingRequestContext");

// Class UnionSystem.MatchmakingContext_WithFlexMatch
// 0x0018 (0x0270 - 0x0258)
class UMatchmakingContext_WithFlexMatch : public UMatchmakingRequestContext
{
public:
	float                                         DefaultMatchmakingDescribeTimeSpan;                // 0x0258(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25C[0x14];                                     // 0x025C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeFlexMatch(int32 LocalUserNum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchmakingContext_WithFlexMatch">();
	}
	static class UMatchmakingContext_WithFlexMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchmakingContext_WithFlexMatch>();
	}
};
static_assert(alignof(UMatchmakingContext_WithFlexMatch) == 0x000008, "Wrong alignment on UMatchmakingContext_WithFlexMatch");
static_assert(sizeof(UMatchmakingContext_WithFlexMatch) == 0x000270, "Wrong size on UMatchmakingContext_WithFlexMatch");
static_assert(offsetof(UMatchmakingContext_WithFlexMatch, DefaultMatchmakingDescribeTimeSpan) == 0x000258, "Member 'UMatchmakingContext_WithFlexMatch::DefaultMatchmakingDescribeTimeSpan' has a wrong offset!");

// Class UnionSystem.MatchmakingSubsystem
// 0x0020 (0x0050 - 0x0030)
class UMatchmakingSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMatchmakingRequestContext*             MatchmakingRequestContext;                         // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TDelegate<void(EGameMatchmakingCompleteStatus Status, const struct FCreateOrConnectLobbyResult& Result)> OnMatchmakingComplete; // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CancelMatchmaking(int32 LocalUserNum);
	void ClearAllDelegates();
	class UMatchmakingRequestContext* CreateMatchmakingContext(TSubclassOf<class UMatchmakingRequestContext> MatchmakingContextClass);
	void EndMatchmaking(int32 LocalUserNum);
	class UMatchmakingRequestContext* GetCurrentMatchmakingContext(bool* bIsExists);
	void SetMatchmakingCompleteDelegate(TDelegate<void(EGameMatchmakingCompleteStatus Status, const struct FCreateOrConnectLobbyResult& Result)> Delegate);
	void StartMatchmaking(int32 LocalUserNum, class UMatchmakingRequestContext* NewContext, TDelegate<void(EGameMatchmakingCompleteStatus Status, const struct FCreateOrConnectLobbyResult& Result)> OnComplete);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchmakingSubsystem">();
	}
	static class UMatchmakingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchmakingSubsystem>();
	}
};
static_assert(alignof(UMatchmakingSubsystem) == 0x000008, "Wrong alignment on UMatchmakingSubsystem");
static_assert(sizeof(UMatchmakingSubsystem) == 0x000050, "Wrong size on UMatchmakingSubsystem");
static_assert(offsetof(UMatchmakingSubsystem, MatchmakingRequestContext) == 0x000038, "Member 'UMatchmakingSubsystem::MatchmakingRequestContext' has a wrong offset!");
static_assert(offsetof(UMatchmakingSubsystem, OnMatchmakingComplete) == 0x000040, "Member 'UMatchmakingSubsystem::OnMatchmakingComplete' has a wrong offset!");

// Class UnionSystem.MaterialPlayer
// 0x0050 (0x0078 - 0x0028)
class UMaterialPlayer final : public UObject
{
public:
	TArray<TWeakObjectPtr<class UMaterialInstanceDynamic>> MaterialInstances;                        // 0x0028(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveTable>             AnimationCurves;                                   // 0x0038(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlaySpeed;                                         // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetMaterialWhenDestroyed;                       // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0xF];                                       // 0x0069(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetCurrentTime();
	float GetCurrentTimeRatio();
	void OverrideMaterialColorParameter(class FName ParameterName, const struct FLinearColor& Color);
	void OverrideMaterialParameter(class FName ParameterName, float Value);
	void OverrideMaterialVectorParameter(class FName ParameterName, const struct FVector& Value);
	void Play();
	void PlayWithStartTime(float StartTime);
	void SetCurrentTime(float CurrentTime);
	void SetPause(bool bPause);
	void Stop();
	void StopAndReset();
	void Update(float DeltaTime);

	bool IsActive() const;
	bool IsPlaying() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialPlayer">();
	}
	static class UMaterialPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialPlayer>();
	}
};
static_assert(alignof(UMaterialPlayer) == 0x000008, "Wrong alignment on UMaterialPlayer");
static_assert(sizeof(UMaterialPlayer) == 0x000078, "Wrong size on UMaterialPlayer");
static_assert(offsetof(UMaterialPlayer, MaterialInstances) == 0x000028, "Member 'UMaterialPlayer::MaterialInstances' has a wrong offset!");
static_assert(offsetof(UMaterialPlayer, AnimationCurves) == 0x000038, "Member 'UMaterialPlayer::AnimationCurves' has a wrong offset!");
static_assert(offsetof(UMaterialPlayer, Priority) == 0x000060, "Member 'UMaterialPlayer::Priority' has a wrong offset!");
static_assert(offsetof(UMaterialPlayer, PlaySpeed) == 0x000064, "Member 'UMaterialPlayer::PlaySpeed' has a wrong offset!");
static_assert(offsetof(UMaterialPlayer, bResetMaterialWhenDestroyed) == 0x000068, "Member 'UMaterialPlayer::bResetMaterialWhenDestroyed' has a wrong offset!");

// Class UnionSystem.MaterialPlayerComponent
// 0x0018 (0x00B8 - 0x00A0)
class UMaterialPlayerComponent final : public UActorComponent
{
public:
	bool                                          bManualUpdate;                                     // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialPlayer*>                MaterialPlayers;                                   // 0x00A8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	int32 BindCurves(class UCurveTable* CurveTable, class FName TargetTag);
	int32 BindCurvesByInfo(struct FMatereialPlayerBindInfo* BindInfo);
	float GetCurrentTime(int32 Index_0);
	float GetCurrentTimeRatio(int32 Index_0);
	void OverrideMaterialColorParameter(int32 Index_0, class FName ParameterName, const struct FLinearColor& Color);
	void OverrideMaterialParameter(int32 Index_0, class FName ParameterName, float Value);
	void OverrideMaterialVectorParameter(int32 Index_0, class FName ParameterName, const struct FVector& Value);
	void Play(int32 Index_0);
	void PlayWithStartTime(int32 Index_0, float StartTime);
	void SetCurrentTime(int32 Index_0, float CurrentTime);
	void Stop(int32 Index_0);
	void StopAll(bool bReset);
	void StopAndReset(int32 Index_0);

	bool IsPlaying(int32 Index_0) const;
	bool IsValidPlayIndex(int32 Index_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialPlayerComponent">();
	}
	static class UMaterialPlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialPlayerComponent>();
	}
};
static_assert(alignof(UMaterialPlayerComponent) == 0x000008, "Wrong alignment on UMaterialPlayerComponent");
static_assert(sizeof(UMaterialPlayerComponent) == 0x0000B8, "Wrong size on UMaterialPlayerComponent");
static_assert(offsetof(UMaterialPlayerComponent, bManualUpdate) == 0x0000A0, "Member 'UMaterialPlayerComponent::bManualUpdate' has a wrong offset!");
static_assert(offsetof(UMaterialPlayerComponent, MaterialPlayers) == 0x0000A8, "Member 'UMaterialPlayerComponent::MaterialPlayers' has a wrong offset!");

// Class UnionSystem.MCEventDataAsset
// 0x0010 (0x0040 - 0x0030)
class UMCEventDataAsset final : public UDataAsset
{
public:
	TArray<struct FMCEventData>                   list;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MCEventDataAsset">();
	}
	static class UMCEventDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMCEventDataAsset>();
	}
};
static_assert(alignof(UMCEventDataAsset) == 0x000008, "Wrong alignment on UMCEventDataAsset");
static_assert(sizeof(UMCEventDataAsset) == 0x000040, "Wrong size on UMCEventDataAsset");
static_assert(offsetof(UMCEventDataAsset, list) == 0x000030, "Member 'UMCEventDataAsset::list' has a wrong offset!");

// Class UnionSystem.MCEvent
// 0x0000 (0x0028 - 0x0028)
class UMCEvent final : public UBlueprintFunctionLibrary
{
public:
	static struct FMCEventData GetMCEventData_SpecifyId(int32 PointUpChanceId);
	static int32 LotteryMCEventId();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MCEvent">();
	}
	static class UMCEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMCEvent>();
	}
};
static_assert(alignof(UMCEvent) == 0x000008, "Wrong alignment on UMCEvent");
static_assert(sizeof(UMCEvent) == 0x000028, "Wrong size on UMCEvent");

// Class UnionSystem.MenuInputRecieveInterface
// 0x0000 (0x0000 - 0x0000)
class IMenuInputRecieveInterface final
{
public:
	void OnAcceptKeyPressed();
	void OnAcceptKeyPressedWithPlayerId(const int32& PlayerControllerIndex);
	void OnAcceptKeyReleased();
	void OnAcceptKeyReleasedWithPlayerId(const int32& PlayerControllerIndex);
	void OnBackKeyPressed();
	void OnBackKeyPressedWithPlayerId(const int32& PlayerControllerIndex);
	void OnBackKeyReleased();
	void OnBackKeyReleasedWithPlayerId(const int32& PlayerControllerIndex);
	void OnDownKeyPressed();
	void OnDownKeyPressedWithPlayerId(const int32& PlayerControllerIndex);
	void OnDownKeyReleased();
	void OnDownKeyReleasedWithPlayerId(const int32& PlayerControllerIndex);
	void OnFaceButtonLeftPressed();
	void OnFaceButtonLeftPressedWithPlayerId(const int32& PlayerControllerIndex);
	void OnFaceButtonLeftReleased();
	void OnFaceButtonLeftReleasedWithPlayerId(const int32& PlayerControllerIndex);
	void OnFaceButtonTopPressed();
	void OnFaceButtonTopPressedWithPlayerId(const int32& PlayerControllerIndex);
	void OnFaceButtonTopReleased();
	void OnFaceButtonTopReleasedWithPlayerId(const int32& PlayerControllerIndex);
	void OnLeftKeyPressed();
	void OnLeftKeyPressedWithPlayerId(const int32& PlayerControllerIndex);
	void OnLeftKeyReleased();
	void OnLeftKeyReleasedWithPlayerId(const int32& PlayerControllerIndex);
	void OnLeftShoulderPressed();
	void OnLeftShoulderPressedWithPlayerId(const int32& PlayerControllerIndex);
	void OnLeftShoulderReleased();
	void OnLeftShoulderReleasedWithPlayerId(const int32& PlayerControllerIndex);
	void OnLeftStickAxis(const struct FVector2D& Value);
	void OnLeftStickAxisWithPlayerId(const struct FVector2D& Value, const int32& PlayerControllerIndex);
	void OnLeftStickButtonPressed();
	void OnLeftStickButtonPressedWithPlayerId(const int32& PlayerControllerIndex);
	void OnLeftStickButtonReleased();
	void OnLeftStickButtonReleasedWithPlayerId(const int32& PlayerControllerIndex);
	void OnRightKeyPressed();
	void OnRightKeyPressedWithPlayerId(const int32& PlayerControllerIndex);
	void OnRightKeyReleased();
	void OnRightKeyReleasedWithPlayerId(const int32& PlayerControllerIndex);
	void OnRightShoulderPressed();
	void OnRightShoulderPressedWithPlayerId(const int32& PlayerControllerIndex);
	void OnRightShoulderReleased();
	void OnRightShoulderReleasedWithPlayerId(const int32& PlayerControllerIndex);
	void OnRightStickAxis(const struct FVector2D& Value);
	void OnRightStickAxisWithPlayerId(const struct FVector2D& Value, const int32& PlayerControllerIndex);
	void OnRightStickButtonPressed();
	void OnRightStickButtonPressedWithPlayerId(const int32& PlayerControllerIndex);
	void OnRightStickButtonReleased();
	void OnRightStickButtonReleasedWithPlayerId(const int32& PlayerControllerIndex);
	void OnSpecialPressed();
	void OnSpecialPressedWithPlayerId(const int32& PlayerControllerIndex);
	void OnSpecialReleased();
	void OnSpecialReleasedWithPlayerId(const int32& PlayerControllerIndex);
	void OnUpKeyPressed();
	void OnUpKeyPressedWithPlayerId(const int32& PlayerControllerIndex);
	void OnUpKeyReleased();
	void OnUpKeyReleasedWithPlayerId(const int32& PlayerControllerIndex);
	void SilentFocusReady(bool bOnce);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuInputRecieveInterface">();
	}
	static class IMenuInputRecieveInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMenuInputRecieveInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IMenuInputRecieveInterface) == 0x000001, "Wrong alignment on IMenuInputRecieveInterface");
static_assert(sizeof(IMenuInputRecieveInterface) == 0x000001, "Wrong size on IMenuInputRecieveInterface");

// Class UnionSystem.MenuPlayerController
// 0x0000 (0x0A38 - 0x0A38)
class AMenuPlayerController : public AAppPlayerController
{
public:
	void SetMenuDirectionKeyEnable(bool bEnableDirection);

	bool GetMenuDirectionKeyEnable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuPlayerController">();
	}
	static class AMenuPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMenuPlayerController>();
	}
};
static_assert(alignof(AMenuPlayerController) == 0x000008, "Wrong alignment on AMenuPlayerController");
static_assert(sizeof(AMenuPlayerController) == 0x000A38, "Wrong size on AMenuPlayerController");

// Class UnionSystem.MenuPopupWindowInterface
// 0x0000 (0x0000 - 0x0000)
class IMenuPopupWindowInterface final
{
public:
	class UWidgetAnimation* GetAnimationIn();
	class UWidgetAnimation* GetAnimationLoop();
	class UWidgetAnimation* GetAnimationOut();
	EPopupWindowButtonType GetPopupWindowButtonType();
	EPopupWindowType GetPopupWindowType();
	void InitParam(EPopupWindowButtonType ButtonType);
	void PlayAnimationIn();
	void SetButtonControlDelayTime(float InTime);
	void SetButtonText(const TArray<class FText>& BtnTextArray);
	void SetDisplayFooterButton(const bool InDisplay);
	void SetDonpaTicketCount(int32 CurrentCount, int32 AfterCount);
	void SetEnableInput(bool InEnable);
	void SetFooterMenuBtn(int32 BtnIconIndex, int32 BtnIconType, const class FText& BtnText);
	void SetImageButtonSelectText(const class FText& InText);
	void SetImageTexture(const class UTexture2D* Texture2D);
	void SetInitialFocusButtonIndex(const int32 InButtonIndex);
	void SetPopupInfoDisplayIndex(int32 Index_0);
	void SetPopupInfoMainMenuButtonIconIndex(int32 Btn01IconIndex, int32 Btn02IconIndex);
	void SetTextMessege(const class FText& Text);
	void SetTextTitle(const class FText& Text, bool Attension);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuPopupWindowInterface">();
	}
	static class IMenuPopupWindowInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMenuPopupWindowInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IMenuPopupWindowInterface) == 0x000001, "Wrong alignment on IMenuPopupWindowInterface");
static_assert(sizeof(IMenuPopupWindowInterface) == 0x000001, "Wrong size on IMenuPopupWindowInterface");

// Class UnionSystem.MovieFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UMovieFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UDataTable* GetMovieList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieFunctionLibrary">();
	}
	static class UMovieFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieFunctionLibrary>();
	}
};
static_assert(alignof(UMovieFunctionLibrary) == 0x000008, "Wrong alignment on UMovieFunctionLibrary");
static_assert(sizeof(UMovieFunctionLibrary) == 0x000028, "Wrong size on UMovieFunctionLibrary");

// Class UnionSystem.NetMasterDataManageSubsystem
// 0x0370 (0x03A0 - 0x0030)
class UNetMasterDataManageSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x370];                                     // 0x0030(0x0370)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const struct FMasterDataGetMasterDataResponse_MstFestaData GetCurrentFestaData(bool* bResult);
	bool GetCurrentFestaRuleData(struct FDateTime* FestaStartUTCTime, struct FDateTime* FestaEndUTCTime, int32* raceRuleId, int32* LoopCount, TArray<struct FMasterDataGetMasterDataResponse_MstFestaTimeSceduleData>* TimeScheduleDataArray);
	bool GetGeneralizedParamData(const class FString& KeyName, struct FMasterDataGetMasterDataResponse_MstGeneralizedParameterData* Out);
	struct FMasterDataGetMasterDataResponse GetMasterData();
	bool HasDifferentialData();
	bool IsBusy();
	void OnGetHttpCommandComplete(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error);
	void SaveLocalMasterData();
	void SetupLocalMasterData();
	void UpdateMasterDataRequest(TDelegate<void(bool bWasSuccessful, int32 ErrorCode)> OnCompleteDelegate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetMasterDataManageSubsystem">();
	}
	static class UNetMasterDataManageSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNetMasterDataManageSubsystem>();
	}
};
static_assert(alignof(UNetMasterDataManageSubsystem) == 0x000008, "Wrong alignment on UNetMasterDataManageSubsystem");
static_assert(sizeof(UNetMasterDataManageSubsystem) == 0x0003A0, "Wrong size on UNetMasterDataManageSubsystem");

// Class UnionSystem.NetPingSubsystem
// 0x0018 (0x0048 - 0x0030)
class UNetPingSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetICMPAddr(const class FString& InAddr);
	void SetTickEnabled(bool bNewValue);
	void SetUDPQoSAddr(const class FString& InAddr);

	int32 GetCurrentPingMs() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetPingSubsystem">();
	}
	static class UNetPingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNetPingSubsystem>();
	}
};
static_assert(alignof(UNetPingSubsystem) == 0x000008, "Wrong alignment on UNetPingSubsystem");
static_assert(sizeof(UNetPingSubsystem) == 0x000048, "Wrong size on UNetPingSubsystem");

// Class UnionSystem.NetSaveGame
// 0x02E0 (0x0308 - 0x0028)
class UNetSaveGame final : public USaveGame
{
public:
	struct FSaveDataHeader                        _Header;                                           // 0x0028(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNetMasterDataVersionData              _LocalNetMasterDataVersion;                        // 0x0038(0x0010)(NativeAccessSpecifierPublic)
	struct FAppLocalNetMasterData                 _LocalNetMasterData;                               // 0x0048(0x02C0)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetSaveGame">();
	}
	static class UNetSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNetSaveGame>();
	}
};
static_assert(alignof(UNetSaveGame) == 0x000008, "Wrong alignment on UNetSaveGame");
static_assert(sizeof(UNetSaveGame) == 0x000308, "Wrong size on UNetSaveGame");
static_assert(offsetof(UNetSaveGame, _Header) == 0x000028, "Member 'UNetSaveGame::_Header' has a wrong offset!");
static_assert(offsetof(UNetSaveGame, _LocalNetMasterDataVersion) == 0x000038, "Member 'UNetSaveGame::_LocalNetMasterDataVersion' has a wrong offset!");
static_assert(offsetof(UNetSaveGame, _LocalNetMasterData) == 0x000048, "Member 'UNetSaveGame::_LocalNetMasterData' has a wrong offset!");

// Class UnionSystem.NetworkClientDevelopmentSettings
// 0x0030 (0x0068 - 0x0038)
class UNetworkClientDevelopmentSettings final : public UDeveloperSettings
{
public:
	class FString                                 CollectKeyMachine;                                 // 0x0038(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LongRespWarnMessage;                               // 0x0048(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LongRespThresholdPc;                               // 0x0058(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LongRespThresholdPs;                               // 0x005C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LongRespThresholdNx;                               // 0x0060(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LongRespThresholdXb;                               // 0x0064(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetworkClientDevelopmentSettings">();
	}
	static class UNetworkClientDevelopmentSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNetworkClientDevelopmentSettings>();
	}
};
static_assert(alignof(UNetworkClientDevelopmentSettings) == 0x000008, "Wrong alignment on UNetworkClientDevelopmentSettings");
static_assert(sizeof(UNetworkClientDevelopmentSettings) == 0x000068, "Wrong size on UNetworkClientDevelopmentSettings");
static_assert(offsetof(UNetworkClientDevelopmentSettings, CollectKeyMachine) == 0x000038, "Member 'UNetworkClientDevelopmentSettings::CollectKeyMachine' has a wrong offset!");
static_assert(offsetof(UNetworkClientDevelopmentSettings, LongRespWarnMessage) == 0x000048, "Member 'UNetworkClientDevelopmentSettings::LongRespWarnMessage' has a wrong offset!");
static_assert(offsetof(UNetworkClientDevelopmentSettings, LongRespThresholdPc) == 0x000058, "Member 'UNetworkClientDevelopmentSettings::LongRespThresholdPc' has a wrong offset!");
static_assert(offsetof(UNetworkClientDevelopmentSettings, LongRespThresholdPs) == 0x00005C, "Member 'UNetworkClientDevelopmentSettings::LongRespThresholdPs' has a wrong offset!");
static_assert(offsetof(UNetworkClientDevelopmentSettings, LongRespThresholdNx) == 0x000060, "Member 'UNetworkClientDevelopmentSettings::LongRespThresholdNx' has a wrong offset!");
static_assert(offsetof(UNetworkClientDevelopmentSettings, LongRespThresholdXb) == 0x000064, "Member 'UNetworkClientDevelopmentSettings::LongRespThresholdXb' has a wrong offset!");

// Class UnionSystem.NetworkClientSettings
// 0x0020 (0x0058 - 0x0038)
class UNetworkClientSettings final : public UDeveloperSettings
{
public:
	class FString                                 ServerStagingName;                                 // 0x0038(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CrmApplicationId;                                  // 0x0048(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetworkClientSettings">();
	}
	static class UNetworkClientSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNetworkClientSettings>();
	}
};
static_assert(alignof(UNetworkClientSettings) == 0x000008, "Wrong alignment on UNetworkClientSettings");
static_assert(sizeof(UNetworkClientSettings) == 0x000058, "Wrong size on UNetworkClientSettings");
static_assert(offsetof(UNetworkClientSettings, ServerStagingName) == 0x000038, "Member 'UNetworkClientSettings::ServerStagingName' has a wrong offset!");
static_assert(offsetof(UNetworkClientSettings, CrmApplicationId) == 0x000048, "Member 'UNetworkClientSettings::CrmApplicationId' has a wrong offset!");

// Class UnionSystem.NetworkMeasurementSubsystem
// 0x01B8 (0x01E8 - 0x0030)
class UNetworkMeasurementSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x1B8];                                     // 0x0030(0x01B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetworkMeasurementSubsystem">();
	}
	static class UNetworkMeasurementSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNetworkMeasurementSubsystem>();
	}
};
static_assert(alignof(UNetworkMeasurementSubsystem) == 0x000008, "Wrong alignment on UNetworkMeasurementSubsystem");
static_assert(sizeof(UNetworkMeasurementSubsystem) == 0x0001E8, "Wrong size on UNetworkMeasurementSubsystem");

// Class UnionSystem.OnlineActivitySubsystem
// 0x0058 (0x0088 - 0x0030)
class UOnlineActivitySubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x58];                                      // 0x0030(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddRecentPlayers(int32 LocalUserNum, TArray<class FString>& PlatformIdList);
	void CancelInviteLobby();
	void CheckEndInviteRequest();
	void DebugDeleteActivity();
	void DebugSetActivity(const class FString& LobbyIdString);
	void DeleteActivity();
	void DestroyInviteLobby(int32 LocalUserNum);
	void FinishInviteLobby();
	const struct FLobbyId GetJoinLobby();
	bool HasInviteOnly();
	bool HasInviteRequest();
	bool IsJoinLobbyReady();
	bool JoinInviteLobby(int32 LocalUserNum, TDelegate<void(bool bSuccessful, const struct FCreateOrConnectLobbyResult& Result)> OnComplete);
	void OnConnectLobbyComplete(bool bSuccessful, const struct FCreateOrConnectLobbyResult& Result);
	void SendInviteNoCallback(int32 LocalUserNum, const struct FUniqueNetIdRepl& UserId, const class FString& InLobbyIdString);
	void SetActivity(const class FString& LobbyIdString, int32 InLocalUserNum, int32 MaxPlayerNum, int32 CurrentPlayerNum);
	void SetupJoinRequest(TDelegate<void(bool bSuccess)> OnComplete);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineActivitySubsystem">();
	}
	static class UOnlineActivitySubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineActivitySubsystem>();
	}
};
static_assert(alignof(UOnlineActivitySubsystem) == 0x000008, "Wrong alignment on UOnlineActivitySubsystem");
static_assert(sizeof(UOnlineActivitySubsystem) == 0x000088, "Wrong size on UOnlineActivitySubsystem");

// Class UnionSystem.OnlineMatchSubsystem
// 0x0230 (0x0260 - 0x0030)
class UOnlineMatchSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x218];                                     // 0x0030(0x0218)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FUniqueNetIdRepl& UserId, bool bIsConnecting)> PeerChangeStatusClosedDelegate; // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UFont*                                  FontObject;                                        // 0x0258(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static bool IsEnableOnlineSinglePlay();

	void ClearLocalUser();
	void OnCheckNetworkOnlineComplete(const class FString& ApiName, const class FString& RequestData, const class FString& ResponseData, bool Error);
	void SetHostLocalUser();
	void SetHostRemoteUser(const struct FUniqueNetIdRepl& UserId);
	void SetupLocalUser(const struct FUniqueNetIdRepl& LocalUserId);
	bool ShutdownMatch();

	int32 GetOnlineConnectPeerCount() const;
	int32 GetOnlineIndex(const struct FUniqueNetIdRepl& UserId) const;
	struct FUniqueNetIdRepl GetOnlineIndexToPeerUserId(int32 OnlineIndex) const;
	bool IsSetupLocalUser() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineMatchSubsystem">();
	}
	static class UOnlineMatchSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineMatchSubsystem>();
	}
};
static_assert(alignof(UOnlineMatchSubsystem) == 0x000008, "Wrong alignment on UOnlineMatchSubsystem");
static_assert(sizeof(UOnlineMatchSubsystem) == 0x000260, "Wrong size on UOnlineMatchSubsystem");
static_assert(offsetof(UOnlineMatchSubsystem, PeerChangeStatusClosedDelegate) == 0x000248, "Member 'UOnlineMatchSubsystem::PeerChangeStatusClosedDelegate' has a wrong offset!");
static_assert(offsetof(UOnlineMatchSubsystem, FontObject) == 0x000258, "Member 'UOnlineMatchSubsystem::FontObject' has a wrong offset!");

// Class UnionSystem.OnlineMessageFactorySubsystem
// 0x0000 (0x0030 - 0x0030)
class UOnlineMessageFactorySubsystem final : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineMessageFactorySubsystem">();
	}
	static class UOnlineMessageFactorySubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineMessageFactorySubsystem>();
	}
};
static_assert(alignof(UOnlineMessageFactorySubsystem) == 0x000008, "Wrong alignment on UOnlineMessageFactorySubsystem");
static_assert(sizeof(UOnlineMessageFactorySubsystem) == 0x000030, "Wrong size on UOnlineMessageFactorySubsystem");

// Class UnionSystem.OnlineMessageSubsystem
// 0x0050 (0x0080 - 0x0030)
class UOnlineMessageSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineMessageSubsystem">();
	}
	static class UOnlineMessageSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineMessageSubsystem>();
	}
};
static_assert(alignof(UOnlineMessageSubsystem) == 0x000008, "Wrong alignment on UOnlineMessageSubsystem");
static_assert(sizeof(UOnlineMessageSubsystem) == 0x000080, "Wrong size on UOnlineMessageSubsystem");

// Class UnionSystem.OptionConfigSaveGame
// 0x0060 (0x0088 - 0x0028)
class UOptionConfigSaveGame final : public USaveGame
{
public:
	struct FSaveDataHeader                        _Header;                                           // 0x0028(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	struct FOnlineSettings                        _OnlineSettings;                                   // 0x0034(0x0006)(NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionRaceSettings                    _RaceSettings;                                     // 0x003A(0x000A)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FControllerSettings>            _ControllerSettings;                               // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FOptionInternationalization            _OptionInternationalizationData;                   // 0x0058(0x0003)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B[0x1];                                       // 0x005B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGraphicsSettings                      _GraphicsSettings;                                 // 0x005C(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	struct FOptionAudioSettings                   _AudioSettings;                                    // 0x0074(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptionConfigSaveGame">();
	}
	static class UOptionConfigSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptionConfigSaveGame>();
	}
};
static_assert(alignof(UOptionConfigSaveGame) == 0x000008, "Wrong alignment on UOptionConfigSaveGame");
static_assert(sizeof(UOptionConfigSaveGame) == 0x000088, "Wrong size on UOptionConfigSaveGame");
static_assert(offsetof(UOptionConfigSaveGame, _Header) == 0x000028, "Member 'UOptionConfigSaveGame::_Header' has a wrong offset!");
static_assert(offsetof(UOptionConfigSaveGame, _OnlineSettings) == 0x000034, "Member 'UOptionConfigSaveGame::_OnlineSettings' has a wrong offset!");
static_assert(offsetof(UOptionConfigSaveGame, _RaceSettings) == 0x00003A, "Member 'UOptionConfigSaveGame::_RaceSettings' has a wrong offset!");
static_assert(offsetof(UOptionConfigSaveGame, _ControllerSettings) == 0x000048, "Member 'UOptionConfigSaveGame::_ControllerSettings' has a wrong offset!");
static_assert(offsetof(UOptionConfigSaveGame, _OptionInternationalizationData) == 0x000058, "Member 'UOptionConfigSaveGame::_OptionInternationalizationData' has a wrong offset!");
static_assert(offsetof(UOptionConfigSaveGame, _GraphicsSettings) == 0x00005C, "Member 'UOptionConfigSaveGame::_GraphicsSettings' has a wrong offset!");
static_assert(offsetof(UOptionConfigSaveGame, _AudioSettings) == 0x000074, "Member 'UOptionConfigSaveGame::_AudioSettings' has a wrong offset!");

// Class UnionSystem.OutOfContentButton
// 0x0000 (0x02E0 - 0x02E0)
class UOutOfContentButton final : public UImage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutOfContentButton">();
	}
	static class UOutOfContentButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOutOfContentButton>();
	}
};
static_assert(alignof(UOutOfContentButton) == 0x000010, "Wrong alignment on UOutOfContentButton");
static_assert(sizeof(UOutOfContentButton) == 0x0002E0, "Wrong size on UOutOfContentButton");

// Class UnionSystem.P2PConnectionSubsystem
// 0x0270 (0x02A0 - 0x0030)
class UP2PConnectionSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x1D8];                                     // 0x0030(0x01D8)(Fixing Size After Last Property [ Dumper-7 ])
	class ULobbyContextBase*                      SquadLobby;                                        // 0x0208(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_210[0x90];                                     // 0x0210(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientTimeoutCheckStart();
	void EndConnect();
	void OnUpdateLobbyComplete(bool bSuccessful, const struct FLobbyOperationResult& Result, TDelegate<void(bool bSuccessful, const struct FLobbyOperationResult& Result)> OnComplete);
	int32 StartConnect(bool bIsHost, bool bIsResend);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"P2PConnectionSubsystem">();
	}
	static class UP2PConnectionSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UP2PConnectionSubsystem>();
	}
};
static_assert(alignof(UP2PConnectionSubsystem) == 0x000008, "Wrong alignment on UP2PConnectionSubsystem");
static_assert(sizeof(UP2PConnectionSubsystem) == 0x0002A0, "Wrong size on UP2PConnectionSubsystem");
static_assert(offsetof(UP2PConnectionSubsystem, SquadLobby) == 0x000208, "Member 'UP2PConnectionSubsystem::SquadLobby' has a wrong offset!");

// Class UnionSystem.PlatformPrivilegeObject
// 0x0068 (0x02F8 - 0x0290)
class APlatformPrivilegeObject : public AActor
{
public:
	uint8                                         Pad_290[0x68];                                     // 0x0290(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RequestStart();

	bool IsEnd() const;
	bool IsSuccess() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformPrivilegeObject">();
	}
	static class APlatformPrivilegeObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlatformPrivilegeObject>();
	}
};
static_assert(alignof(APlatformPrivilegeObject) == 0x000008, "Wrong alignment on APlatformPrivilegeObject");
static_assert(sizeof(APlatformPrivilegeObject) == 0x0002F8, "Wrong size on APlatformPrivilegeObject");

// Class UnionSystem.PlatformStoreMessageDataAsset
// 0x00D0 (0x0100 - 0x0030)
class UPlatformStoreMessageDataAsset final : public UDataAsset
{
public:
	class FText                                   PlayStationPlatformStoreMessage;                   // 0x0030(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   XboxPlatformStoreMessage;                          // 0x0040(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   SwitchPlatformStoreMessage;                        // 0x0050(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   SteamPlatformStoreMessage;                         // 0x0060(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   EpicPlatformStoreMessage;                          // 0x0070(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   AcceptButtonText;                                  // 0x0080(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   CancelButtonText;                                  // 0x0090(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   PlatformStoreButtonMessage;                        // 0x00A0(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   PlayStationPlatformStoreButtonMessage;             // 0x00B0(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   XboxPlatformStoreButtonMessage;                    // 0x00C0(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   SwitchPlatformStoreButtonMessage;                  // 0x00D0(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   SteamPlatformStoreButtonMessage;                   // 0x00E0(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   EpicPlatformStoreButtonMessage;                    // 0x00F0(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void GetPlatformStoreButtonText(class FText* AcceptText, class FText* CancelText);

	EPlatformStoreType GetCurrentPlatform() const;
	class FText GetPlatformStoreButtonMessage() const;
	class FText GetPlatformStoreMessage(EPlatformStoreType PlatformType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformStoreMessageDataAsset">();
	}
	static class UPlatformStoreMessageDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformStoreMessageDataAsset>();
	}
};
static_assert(alignof(UPlatformStoreMessageDataAsset) == 0x000008, "Wrong alignment on UPlatformStoreMessageDataAsset");
static_assert(sizeof(UPlatformStoreMessageDataAsset) == 0x000100, "Wrong size on UPlatformStoreMessageDataAsset");
static_assert(offsetof(UPlatformStoreMessageDataAsset, PlayStationPlatformStoreMessage) == 0x000030, "Member 'UPlatformStoreMessageDataAsset::PlayStationPlatformStoreMessage' has a wrong offset!");
static_assert(offsetof(UPlatformStoreMessageDataAsset, XboxPlatformStoreMessage) == 0x000040, "Member 'UPlatformStoreMessageDataAsset::XboxPlatformStoreMessage' has a wrong offset!");
static_assert(offsetof(UPlatformStoreMessageDataAsset, SwitchPlatformStoreMessage) == 0x000050, "Member 'UPlatformStoreMessageDataAsset::SwitchPlatformStoreMessage' has a wrong offset!");
static_assert(offsetof(UPlatformStoreMessageDataAsset, SteamPlatformStoreMessage) == 0x000060, "Member 'UPlatformStoreMessageDataAsset::SteamPlatformStoreMessage' has a wrong offset!");
static_assert(offsetof(UPlatformStoreMessageDataAsset, EpicPlatformStoreMessage) == 0x000070, "Member 'UPlatformStoreMessageDataAsset::EpicPlatformStoreMessage' has a wrong offset!");
static_assert(offsetof(UPlatformStoreMessageDataAsset, AcceptButtonText) == 0x000080, "Member 'UPlatformStoreMessageDataAsset::AcceptButtonText' has a wrong offset!");
static_assert(offsetof(UPlatformStoreMessageDataAsset, CancelButtonText) == 0x000090, "Member 'UPlatformStoreMessageDataAsset::CancelButtonText' has a wrong offset!");
static_assert(offsetof(UPlatformStoreMessageDataAsset, PlatformStoreButtonMessage) == 0x0000A0, "Member 'UPlatformStoreMessageDataAsset::PlatformStoreButtonMessage' has a wrong offset!");
static_assert(offsetof(UPlatformStoreMessageDataAsset, PlayStationPlatformStoreButtonMessage) == 0x0000B0, "Member 'UPlatformStoreMessageDataAsset::PlayStationPlatformStoreButtonMessage' has a wrong offset!");
static_assert(offsetof(UPlatformStoreMessageDataAsset, XboxPlatformStoreButtonMessage) == 0x0000C0, "Member 'UPlatformStoreMessageDataAsset::XboxPlatformStoreButtonMessage' has a wrong offset!");
static_assert(offsetof(UPlatformStoreMessageDataAsset, SwitchPlatformStoreButtonMessage) == 0x0000D0, "Member 'UPlatformStoreMessageDataAsset::SwitchPlatformStoreButtonMessage' has a wrong offset!");
static_assert(offsetof(UPlatformStoreMessageDataAsset, SteamPlatformStoreButtonMessage) == 0x0000E0, "Member 'UPlatformStoreMessageDataAsset::SteamPlatformStoreButtonMessage' has a wrong offset!");
static_assert(offsetof(UPlatformStoreMessageDataAsset, EpicPlatformStoreButtonMessage) == 0x0000F0, "Member 'UPlatformStoreMessageDataAsset::EpicPlatformStoreButtonMessage' has a wrong offset!");

// Class UnionSystem.PlatformUIUtilityLibrary
// 0x0000 (0x0028 - 0x0028)
class UPlatformUIUtilityLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void GetPlatformControllerWidgetClass(EUnionControllerType Type, EUnionPlatform Platform, TSubclassOf<class UUserWidget>* OutClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformUIUtilityLibrary">();
	}
	static class UPlatformUIUtilityLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformUIUtilityLibrary>();
	}
};
static_assert(alignof(UPlatformUIUtilityLibrary) == 0x000008, "Wrong alignment on UPlatformUIUtilityLibrary");
static_assert(sizeof(UPlatformUIUtilityLibrary) == 0x000028, "Wrong size on UPlatformUIUtilityLibrary");

// Class UnionSystem.PlayerNameInterface
// 0x0000 (0x0000 - 0x0000)
class IPlayerNameInterface final
{
public:
	void SetCOMIF(bool IsCom);
	void SetCrossPlayIconIF(ECrossplayPlatform CrossplayType);
	void SetGroupIndexIF(bool IsGroup, int32 GroupIndex, bool IsForce);
	void SetNameIF(const class FText& InName);
	void SetOnlineIF(bool IsRival);
	void SetPlayerIndexIF(bool IsLocalPlayer, int32 PlayerIndex);
	void SetRankIF(int32 Rank);
	void SetReaderIF(bool IsReader);
	void SetRivalIF(bool IsRival, bool IsPowerRival);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerNameInterface">();
	}
	static class IPlayerNameInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPlayerNameInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPlayerNameInterface) == 0x000001, "Wrong alignment on IPlayerNameInterface");
static_assert(sizeof(IPlayerNameInterface) == 0x000001, "Wrong size on IPlayerNameInterface");

// Class UnionSystem.PlaylogHelper
// 0x0000 (0x0028 - 0x0028)
class UPlaylogHelper final : public UBlueprintFunctionLibrary
{
public:
	static class FString CRM_GetUserInfoString();
	static void CRM_KickStart(TDelegate<void(bool Result)> Callback);
	static TArray<float> CRM_MakeRandomFloatArray(int32 Size);
	static TArray<int32> CRM_MakeRandomIntegerArray(int32 Size);
	static bool CRM_PutBaseMachine(const struct FCRM_BaseMachine& Data);
	static bool CRM_PutChallenge(const struct FCRM_Challenge& Data);
	static bool CRM_PutCharacter(const struct FCRM_Character& Data);
	static bool CRM_PutCondition(const struct FCRM_Condition& Data);
	static bool CRM_PutConnection(const struct FCRM_Connection& Data);
	static bool CRM_PutConnectionError(const struct FCRM_ConnectionError& Data);
	static bool CRM_PutCustomMachineParts(const struct FCRM_CustomMachineParts& Data);
	static bool CRM_PutCustomMachinePartsSpot(const struct FCRM_CustomMachinePartsSpot& Data);
	static bool CRM_PutDlc(const struct FCRM_Dlc& Data);
	static bool CRM_PutEventFesta(const struct FCRM_EventFesta& Data);
	static bool CRM_PutEventLegend(const struct FCRM_EventLegend& Data);
	static bool CRM_PutFriendMatch(const struct FCRM_FriendMatch& Data);
	static bool CRM_PutGadgetPossession(const struct FCRM_GadgetPossession& Data);
	static bool CRM_PutGadgetUsage(const struct FCRM_GadgetUsage& Data);
	static bool CRM_PutGameLogin(const struct FCRM_GameLogin& Data);
	static bool CRM_PutGhost(const struct FCRM_Ghost& Data);
	static bool CRM_PutGrandprix(const struct FCRM_Grandprix& Data);
	static bool CRM_PutLobbyBasic(const struct FCRM_LobbyBasic& Data);
	static bool CRM_PutLobbyInvite(const struct FCRM_LobbyInvite& Data);
	static bool CRM_PutLobbyStage(const struct FCRM_LobbyStage& Data);
	static bool CRM_PutLobbyStamp(const struct FCRM_LobbyStamp& Data);
	static bool CRM_PutMatchingRaceStart(const struct FCRM_MatchingRaceStart& Data);
	static bool CRM_PutMatchingRegistration(const struct FCRM_MatchingRegistration& Data);
	static bool CRM_PutMatchingResult(const struct FCRM_MatchingResult& Data);
	static bool CRM_PutParty(const struct FCRM_Party& Data);
	static bool CRM_PutProgressGrandprix(const struct FCRM_ProgressGrandprix& Data);
	static bool CRM_PutProgressParty(const struct FCRM_ProgressParty& Data);
	static bool CRM_PutProgressRival(const struct FCRM_ProgressRival& Data);
	static bool CRM_PutProgressRivalTeam(const struct FCRM_ProgressRivalTeam& Data);
	static bool CRM_PutRaceLog(const struct FCRM_RaceLog& Data);
	static bool CRM_PutRadjCom(const struct FCRM_RadjCom& Data);
	static bool CRM_PutRadjDataAccelOff(const struct FCRM_RadjDataAccelOff& Data);
	static bool CRM_PutRadjDataAccelOn(const struct FCRM_RadjDataAccelOn& Data);
	static bool CRM_PutRadjDataAirtrickEnd(const struct FCRM_RadjDataAirtrickEnd& Data);
	static bool CRM_PutRadjDataAirtrickStart(const struct FCRM_RadjDataAirtrickStart& Data);
	static bool CRM_PutRadjDataBackEnd(const struct FCRM_RadjDataBackEnd& Data);
	static bool CRM_PutRadjDataBackStart(const struct FCRM_RadjDataBackStart& Data);
	static bool CRM_PutRadjDataBodyHitAssistWall(const struct FCRM_RadjDataBodyHitAssistWall& Data);
	static bool CRM_PutRadjDataBodyHitIrregular(const struct FCRM_RadjDataBodyHitIrregular& Data);
	static bool CRM_PutRadjDataBodyHitMachine(const struct FCRM_RadjDataBodyHitMachine& Data);
	static bool CRM_PutRadjDataBodyHitObject(const struct FCRM_RadjDataBodyHitObject& Data);
	static bool CRM_PutRadjDataBodyHitWall(const struct FCRM_RadjDataBodyHitWall& Data);
	static bool CRM_PutRadjDataBoostAbsorbEnd(const struct FCRM_RadjDataBoostAbsorbEnd& Data);
	static bool CRM_PutRadjDataBoostAbsorbEntry(const struct FCRM_RadjDataBoostAbsorbEntry& Data);
	static bool CRM_PutRadjDataBoostRingMinus(const struct FCRM_RadjDataBoostRingMinus& Data);
	static bool CRM_PutRadjDataBoostRingPlus(const struct FCRM_RadjDataBoostRingPlus& Data);
	static bool CRM_PutRadjDataBoostSlipstreamEnd(const struct FCRM_RadjDataBoostSlipstreamEnd& Data);
	static bool CRM_PutRadjDataBoostSlipstreamStart(const struct FCRM_RadjDataBoostSlipstreamStart& Data);
	static bool CRM_PutRadjDataBrakeOff(const struct FCRM_RadjDataBrakeOff& Data);
	static bool CRM_PutRadjDataBrakeOn(const struct FCRM_RadjDataBrakeOn& Data);
	static bool CRM_PutRadjDataCheckPoint(const struct FCRM_RadjDataCheckPoint& Data);
	static bool CRM_PutRadjDataDriftOff(const struct FCRM_RadjDataDriftOff& Data);
	static bool CRM_PutRadjDataDriftOn(const struct FCRM_RadjDataDriftOn& Data);
	static bool CRM_PutRadjDataEventsOnline(const struct FCRM_RadjDataEventsOnline& Data);
	static bool CRM_PutRadjDataFinish(const struct FCRM_RadjDataFinish& Data);
	static bool CRM_PutRadjDataFrameRateBoostingEnd(const struct FCRM_RadjDataFrameRateBoostingEnd& Data);
	static bool CRM_PutRadjDataFrameRateBoostingStart(const struct FCRM_RadjDataFrameRateBoostingStart& Data);
	static bool CRM_PutRadjDataGameHighLoadingEnd(const struct FCRM_RadjDataGameHighLoadingEnd& Data);
	static bool CRM_PutRadjDataGameHighLoadingStart(const struct FCRM_RadjDataGameHighLoadingStart& Data);
	static bool CRM_PutRadjDataGuideJumpEnd(const struct FCRM_RadjDataGuideJumpEnd& Data);
	static bool CRM_PutRadjDataGuideJumpStart(const struct FCRM_RadjDataGuideJumpStart& Data);
	static bool CRM_PutRadjDataItemEnd(const struct FCRM_RadjDataItemEnd& Data);
	static bool CRM_PutRadjDataItemGet(const struct FCRM_RadjDataItemGet& Data);
	static bool CRM_PutRadjDataItemHitMachine(const struct FCRM_RadjDataItemHitMachine& Data);
	static bool CRM_PutRadjDataItemStart(const struct FCRM_RadjDataItemStart& Data);
	static bool CRM_PutRadjDataJumpEnd(const struct FCRM_RadjDataJumpEnd& Data);
	static bool CRM_PutRadjDataJumpStart(const struct FCRM_RadjDataJumpStart& Data);
	static bool CRM_PutRadjDataLap(const struct FCRM_RadjDataLap& Data);
	static bool CRM_PutRadjDataMisalignment(const struct FCRM_RadjDataMisalignment& Data);
	static bool CRM_PutRadjDataOvertake(const struct FCRM_RadjDataOvertake& Data);
	static bool CRM_PutRadjDataOvertaken(const struct FCRM_RadjDataOvertaken& Data);
	static bool CRM_PutRadjDataPositionsOnline(const struct FCRM_RadjDataPositionsOnline& Data);
	static bool CRM_PutRadjDataRankdown(const struct FCRM_RadjDataRankdown& Data);
	static bool CRM_PutRadjDataRankup(const struct FCRM_RadjDataRankup& Data);
	static bool CRM_PutRadjDataRearViewOff(const struct FCRM_RadjDataRearViewOff& Data);
	static bool CRM_PutRadjDataRearViewOn(const struct FCRM_RadjDataRearViewOn& Data);
	static bool CRM_PutRadjDataRedStarRing(const struct FCRM_RadjDataRedStarRing& Data);
	static bool CRM_PutRadjDataRespot(const struct FCRM_RadjDataRespot& Data);
	static bool CRM_PutRadjDataShortCutRing(const struct FCRM_RadjDataShortCutRing& Data);
	static bool CRM_PutRadjDataShortWarp(const struct FCRM_RadjDataShortWarp& Data);
	static bool CRM_PutRadjDataStart(const struct FCRM_RadjDataStart& Data);
	static bool CRM_PutRadjDataStartDash(const struct FCRM_RadjDataStartDash& Data);
	static bool CRM_PutRadjDataSteerDownOff(const struct FCRM_RadjDataSteerDownOff& Data);
	static bool CRM_PutRadjDataSteerDownOn(const struct FCRM_RadjDataSteerDownOn& Data);
	static bool CRM_PutRadjDataSteerLeftOff(const struct FCRM_RadjDataSteerLeftOff& Data);
	static bool CRM_PutRadjDataSteerLeftOn(const struct FCRM_RadjDataSteerLeftOn& Data);
	static bool CRM_PutRadjDataSteerRightOff(const struct FCRM_RadjDataSteerRightOff& Data);
	static bool CRM_PutRadjDataSteerRightOn(const struct FCRM_RadjDataSteerRightOn& Data);
	static bool CRM_PutRadjDataSteerUpOff(const struct FCRM_RadjDataSteerUpOff& Data);
	static bool CRM_PutRadjDataSteerUpOn(const struct FCRM_RadjDataSteerUpOn& Data);
	static bool CRM_PutRadjDataWiden(const struct FCRM_RadjDataWiden& Data);
	static bool CRM_PutRadjDataWidened(const struct FCRM_RadjDataWidened& Data);
	static bool CRM_PutRadjLocalPlayer(const struct FCRM_RadjLocalPlayer& Data);
	static bool CRM_PutRadjMachine(const struct FCRM_RadjMachine& Data);
	static bool CRM_PutRadjOnlinePlayer(const struct FCRM_RadjOnlinePlayer& Data);
	static bool CRM_PutRadjRaceSetting(const struct FCRM_RadjRaceSetting& Data);
	static bool CRM_PutSequence(const struct FCRM_Sequence& Data);
	static bool CRM_PutSubMode(const struct FCRM_SubMode& Data);
	static bool CRM_PutTimeTrial(const struct FCRM_TimeTrial& Data);
	static bool CRM_PutWorldMatch(const struct FCRM_WorldMatch& Data);
	static bool CRM_SetInactive();
	static bool CRM_SetMessageSendingSuppress();
	static bool CRM_SetOutfocus();
	static bool CRM_SetPushMessageCallback(TDelegate<void(const class FString& Message)> Callback);
	static void CRM_SetRestrictionInteger(int32 Value);
	static void CRM_SetRestrictionString(class FString* Value);
	static bool CRM_SetSuspended();
	static bool CRM_TestInactive();
	static bool CRM_TestMessageSendingSuppress();
	static bool CRM_TestOutfocus();
	static bool CRM_TestSuspended();
	static bool CRM_UnsetInactive();
	static bool CRM_UnsetMessageSendingSuppress();
	static bool CRM_UnsetOutfocus();
	static bool CRM_UnsetSuspended();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaylogHelper">();
	}
	static class UPlaylogHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlaylogHelper>();
	}
};
static_assert(alignof(UPlaylogHelper) == 0x000008, "Wrong alignment on UPlaylogHelper");
static_assert(sizeof(UPlaylogHelper) == 0x000028, "Wrong size on UPlaylogHelper");

// Class UnionSystem.PlaylogManager
// 0x0168 (0x0198 - 0x0030)
class UPlaylogManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x148];                                     // 0x0030(0x0148)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            CrmWidget;                                         // 0x0178(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TDelegate<void(bool Success)>                 SetupCompleteDelegate;                             // 0x0180(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_190[0x8];                                      // 0x0190(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnId(const class FString& AccountID);
	void OnUrl(const class FString& RegistrationURL);
	void SteamOnSetupComplete(bool Success);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaylogManager">();
	}
	static class UPlaylogManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlaylogManager>();
	}
};
static_assert(alignof(UPlaylogManager) == 0x000008, "Wrong alignment on UPlaylogManager");
static_assert(sizeof(UPlaylogManager) == 0x000198, "Wrong size on UPlaylogManager");
static_assert(offsetof(UPlaylogManager, CrmWidget) == 0x000178, "Member 'UPlaylogManager::CrmWidget' has a wrong offset!");
static_assert(offsetof(UPlaylogManager, SetupCompleteDelegate) == 0x000180, "Member 'UPlaylogManager::SetupCompleteDelegate' has a wrong offset!");

// Class UnionSystem.PlayLogSaveGame
// 0x9740 (0x9768 - 0x0028)
class UPlayLogSaveGame final : public USaveGame
{
public:
	struct FSaveDataHeader                        _Header;                                           // 0x0028(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         Timestamp;                                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPlayLogSystem                         System;                                            // 0x0040(0x0028)(NativeAccessSpecifierPrivate)
	struct FPlayLogSaveGameCondition              Condition;                                         // 0x0068(0x0040)(NativeAccessSpecifierPrivate)
	struct FPlayLogSaveGameProgressGrandprix      ProgressGrandprix;                                 // 0x00A8(0x012C)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FPlayLogSaveGameProgressRival          ProgressRival;                                     // 0x01D4(0x0190)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FPlayLogSaveGameProgressParty          ProgressParty;                                     // 0x0364(0x0154)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FPlayLogSaveGameCharacter              Character;                                         // 0x04B8(0x0DE8)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FPlayLogSaveGameMachine                machine;                                           // 0x12A0(0x6720)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FPlayLogSaveGameGadget                 gadget;                                            // 0x79C0(0x07D0)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FPlayLogSaveGameGrandprix              GrandPrix;                                         // 0x8190(0x0258)(NativeAccessSpecifierPrivate)
	struct FPlayLogSaveGameParty                  Party;                                             // 0x83E8(0x0220)(NativeAccessSpecifierPrivate)
	struct FPlayLogSaveGameTimeTrial              TimeTrial;                                         // 0x8608(0x0EB8)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FPlayLogSaveGameFriendMatch            FriendMatch;                                       // 0x94C0(0x0088)(NoDestructor, NativeAccessSpecifierPrivate)
	struct FPlayLogSaveGameEventFesta             EventFesta;                                        // 0x9548(0x0020)(NativeAccessSpecifierPrivate)
	struct FPlayLogSaveGameMode                   GameMode;                                          // 0x9568(0x0200)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayLogSaveGame">();
	}
	static class UPlayLogSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayLogSaveGame>();
	}
};
static_assert(alignof(UPlayLogSaveGame) == 0x000008, "Wrong alignment on UPlayLogSaveGame");
static_assert(sizeof(UPlayLogSaveGame) == 0x009768, "Wrong size on UPlayLogSaveGame");
static_assert(offsetof(UPlayLogSaveGame, _Header) == 0x000028, "Member 'UPlayLogSaveGame::_Header' has a wrong offset!");
static_assert(offsetof(UPlayLogSaveGame, Timestamp) == 0x000038, "Member 'UPlayLogSaveGame::Timestamp' has a wrong offset!");
static_assert(offsetof(UPlayLogSaveGame, System) == 0x000040, "Member 'UPlayLogSaveGame::System' has a wrong offset!");
static_assert(offsetof(UPlayLogSaveGame, Condition) == 0x000068, "Member 'UPlayLogSaveGame::Condition' has a wrong offset!");
static_assert(offsetof(UPlayLogSaveGame, ProgressGrandprix) == 0x0000A8, "Member 'UPlayLogSaveGame::ProgressGrandprix' has a wrong offset!");
static_assert(offsetof(UPlayLogSaveGame, ProgressRival) == 0x0001D4, "Member 'UPlayLogSaveGame::ProgressRival' has a wrong offset!");
static_assert(offsetof(UPlayLogSaveGame, ProgressParty) == 0x000364, "Member 'UPlayLogSaveGame::ProgressParty' has a wrong offset!");
static_assert(offsetof(UPlayLogSaveGame, Character) == 0x0004B8, "Member 'UPlayLogSaveGame::Character' has a wrong offset!");
static_assert(offsetof(UPlayLogSaveGame, machine) == 0x0012A0, "Member 'UPlayLogSaveGame::machine' has a wrong offset!");
static_assert(offsetof(UPlayLogSaveGame, gadget) == 0x0079C0, "Member 'UPlayLogSaveGame::gadget' has a wrong offset!");
static_assert(offsetof(UPlayLogSaveGame, GrandPrix) == 0x008190, "Member 'UPlayLogSaveGame::GrandPrix' has a wrong offset!");
static_assert(offsetof(UPlayLogSaveGame, Party) == 0x0083E8, "Member 'UPlayLogSaveGame::Party' has a wrong offset!");
static_assert(offsetof(UPlayLogSaveGame, TimeTrial) == 0x008608, "Member 'UPlayLogSaveGame::TimeTrial' has a wrong offset!");
static_assert(offsetof(UPlayLogSaveGame, FriendMatch) == 0x0094C0, "Member 'UPlayLogSaveGame::FriendMatch' has a wrong offset!");
static_assert(offsetof(UPlayLogSaveGame, EventFesta) == 0x009548, "Member 'UPlayLogSaveGame::EventFesta' has a wrong offset!");
static_assert(offsetof(UPlayLogSaveGame, GameMode) == 0x009568, "Member 'UPlayLogSaveGame::GameMode' has a wrong offset!");

// Class UnionSystem.ProceduralMeshComponentEx
// 0x0050 (0x05A0 - 0x0550)
class UProceduralMeshComponentEx : public UMeshComponent
{
public:
	uint8                                         Pad_550[0x10];                                     // 0x0550(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoxSphereBounds                       LocalBounds;                                       // 0x0560(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_598[0x8];                                      // 0x0598(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearAllMeshSections();
	void ClearMeshSection(int32 SectionIndex);
	void SetMeshSectionVisible(int32 SectionIndex, bool bNewVisibility);

	int32 GetNumSections() const;
	bool IsMeshSectionVisible(int32 SectionIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralMeshComponentEx">();
	}
	static class UProceduralMeshComponentEx* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralMeshComponentEx>();
	}
};
static_assert(alignof(UProceduralMeshComponentEx) == 0x000010, "Wrong alignment on UProceduralMeshComponentEx");
static_assert(sizeof(UProceduralMeshComponentEx) == 0x0005A0, "Wrong size on UProceduralMeshComponentEx");
static_assert(offsetof(UProceduralMeshComponentEx, LocalBounds) == 0x000560, "Member 'UProceduralMeshComponentEx::LocalBounds' has a wrong offset!");

// Class UnionSystem.ProjectDecal
// 0x0028 (0x0050 - 0x0028)
class UProjectDecal final : public UObject
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Clear();
	void Initialize(int32 Width, int32 Height, int32 MaterialIndex, const class UStaticMeshComponent* Projected);
	class UTexture2D* Project(int32 Width, int32 Height, int32 MaterialIndex, const class UStaticMeshComponent* Projected, const class UStaticMeshComponent* Projector, const class UTexture2D* Texture, bool Overwrite);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectDecal">();
	}
	static class UProjectDecal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectDecal>();
	}
};
static_assert(alignof(UProjectDecal) == 0x000008, "Wrong alignment on UProjectDecal");
static_assert(sizeof(UProjectDecal) == 0x000050, "Wrong size on UProjectDecal");

// Class UnionSystem.QueryFunction
// 0x0000 (0x0028 - 0x0028)
class UQueryFunction final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QueryFunction">();
	}
	static class UQueryFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQueryFunction>();
	}
};
static_assert(alignof(UQueryFunction) == 0x000008, "Wrong alignment on UQueryFunction");
static_assert(sizeof(UQueryFunction) == 0x000028, "Wrong size on UQueryFunction");

// Class UnionSystem.RaceInputRecieveInterface
// 0x0000 (0x0000 - 0x0000)
class IRaceInputRecieveInterface final
{
public:
	void OnAccelInput(float InValue);
	void OnBrakeInput(float InValue);
	void OnDriftPressed();
	void OnDriftReleased();
	void OnEmotePressed();
	void OnEmoteReleased();
	void OnHornPressed();
	void OnHornReleased();
	void OnPausePressed();
	void OnPauseReleased();
	void OnPitchInput(float InValue);
	void OnRearViewPressed();
	void OnRearViewReleased();
	void OnSlimeCancelXInput(float InValue);
	void OnSlimeCancelYInput(float InValue);
	void OnSteerInput(float InValue);
	void OnTradeItemPressed();
	void OnTradeItemReleased();
	void OnTrickX2Input(float InValue);
	void OnTrickXInput(float InValue);
	void OnTrickY2Input(float InValue);
	void OnTrickYInput(float InValue);
	void OnUseItemPressed();
	void OnUseItemReleased();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceInputRecieveInterface">();
	}
	static class IRaceInputRecieveInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRaceInputRecieveInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IRaceInputRecieveInterface) == 0x000001, "Wrong alignment on IRaceInputRecieveInterface");
static_assert(sizeof(IRaceInputRecieveInterface) == 0x000001, "Wrong size on IRaceInputRecieveInterface");

// Class UnionSystem.RaceMasterDataAccessor
// 0x0120 (0x0148 - 0x0028)
class URaceMasterDataAccessor : public UObject
{
public:
	class UObject*                                RunData[0x24];                                     // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Initialize();

	class UObject* GetRunData(ERaceRunDataType Type) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceMasterDataAccessor">();
	}
	static class URaceMasterDataAccessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<URaceMasterDataAccessor>();
	}
};
static_assert(alignof(URaceMasterDataAccessor) == 0x000008, "Wrong alignment on URaceMasterDataAccessor");
static_assert(sizeof(URaceMasterDataAccessor) == 0x000148, "Wrong size on URaceMasterDataAccessor");
static_assert(offsetof(URaceMasterDataAccessor, RunData) == 0x000028, "Member 'URaceMasterDataAccessor::RunData' has a wrong offset!");

// Class UnionSystem.RacePlayerController
// 0x0160 (0x0B98 - 0x0A38)
class ARacePlayerController : public AAppPlayerController
{
public:
	uint8                                         Pad_A38[0x8];                                      // 0x0A38(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  RaceInputReciever;                                 // 0x0A40(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A48[0x150];                                    // 0x0A48(0x0150)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoInputRacePressed(ERaceInputKey InKey, float Amount);
	void DoInputRaceReleased(ERaceInputKey InKey);
	void SetSubMode(ERacePlayerControllerSubMode InSubMode);

	ERacePlayerControllerSubMode GetSubMode() const;
	bool IsRaceInputEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RacePlayerController">();
	}
	static class ARacePlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARacePlayerController>();
	}
};
static_assert(alignof(ARacePlayerController) == 0x000008, "Wrong alignment on ARacePlayerController");
static_assert(sizeof(ARacePlayerController) == 0x000B98, "Wrong size on ARacePlayerController");
static_assert(offsetof(ARacePlayerController, RaceInputReciever) == 0x000A40, "Member 'ARacePlayerController::RaceInputReciever' has a wrong offset!");

// Class UnionSystem.RankingSubsystem
// 0x0080 (0x00B0 - 0x0030)
class URankingSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x80];                                      // 0x0030(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetRankingFestaPoint(const class FString& FilePathFull, TDelegate<void(bool bWasSuccessful, const struct FRankingDataFestaPointList& RankDataList)> OnComplete);
	bool GetRankingLegendCompe(const class FString& FilePathFull, TDelegate<void(bool bWasSuccessful, const struct FRankingDataLegendCompeList& RankDataList)> OnComplete);
	bool GetRankingRankMatch(const class FString& FilePathFull, TDelegate<void(bool bWasSuccessful, const struct FRankingDataRankMatchList& RankDataList)> OnComplete);
	bool GetRankingTimeTrial(const class FString& FilePathFull, TDelegate<void(bool bWasSuccessful, const struct FRankingDataTimeTrialList& RankDataList)> OnComplete);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RankingSubsystem">();
	}
	static class URankingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URankingSubsystem>();
	}
};
static_assert(alignof(URankingSubsystem) == 0x000008, "Wrong alignment on URankingSubsystem");
static_assert(sizeof(URankingSubsystem) == 0x0000B0, "Wrong size on URankingSubsystem");

// Class UnionSystem.ReplaySaveGame
// 0x0020 (0x0048 - 0x0028)
class UReplaySaveGame final : public USaveGame
{
public:
	struct FSaveDataHeader                        _Header;                                           // 0x0028(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FReplaySaveSlot>                ReplaySlot;                                        // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplaySaveGame">();
	}
	static class UReplaySaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReplaySaveGame>();
	}
};
static_assert(alignof(UReplaySaveGame) == 0x000008, "Wrong alignment on UReplaySaveGame");
static_assert(sizeof(UReplaySaveGame) == 0x000048, "Wrong size on UReplaySaveGame");
static_assert(offsetof(UReplaySaveGame, _Header) == 0x000028, "Member 'UReplaySaveGame::_Header' has a wrong offset!");
static_assert(offsetof(UReplaySaveGame, ReplaySlot) == 0x000038, "Member 'UReplaySaveGame::ReplaySlot' has a wrong offset!");

// Class UnionSystem.ResponseCodeHttp
// 0x0000 (0x0028 - 0x0028)
class UResponseCodeHttp final : public UBlueprintFunctionLibrary
{
public:
	static bool IsOkProper(int32 ResponseCode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResponseCodeHttp">();
	}
	static class UResponseCodeHttp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResponseCodeHttp>();
	}
};
static_assert(alignof(UResponseCodeHttp) == 0x000008, "Wrong alignment on UResponseCodeHttp");
static_assert(sizeof(UResponseCodeHttp) == 0x000028, "Wrong size on UResponseCodeHttp");

// Class UnionSystem.SaveDataManageSubsystem
// 0x0240 (0x0270 - 0x0030)
class USaveDataManageSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(ESaveDataStatus Status)> OnLoadComplete;                           // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(ESaveDataStatus Status)> OnSaveComplete;                           // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x20];                                      // 0x0058(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USavingIcon*                            AutoSaveIconWidget;                                // 0x0078(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, bool>                     LoadedMap;                                         // 0x0088(0x0050)(NativeAccessSpecifierPrivate)
	class UAppSaveGame*                           _AppSaveGame;                                      // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayLogSaveGame*                       _PlayLogSaveGame;                                  // 0x00E0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOptionConfigSaveGame*                  _OptionConfigSaveGame;                             // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UReplaySaveGame*                        _ReplaySaveGame;                                   // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNetSaveGame*                           _NetSaveGame;                                      // 0x00F8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x170];                                    // 0x0100(0x0170)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndAutoSavingAnimation();
	bool ExistsAutoApp(ESaveDataStatus* OutStatus);
	bool ExistsAutoAppDemo(ESaveDataStatus* OutStatus);
	bool ExistsAutoAppPS4(ESaveDataStatus* OutStatus);
	bool ExistsAutoNet(ESaveDataStatus* OutStatus);
	bool ExistsAutoOptionConfig(ESaveDataStatus* OutStatus);
	bool ExistsAutoPlayLog(ESaveDataStatus* OutStatus);
	bool ExistsAutoReplayPS4SaveGameByIndex(int32 ReplaySlotIndex, ESaveDataStatus* OutStatus);
	bool ExistsAutoReplaySaveGameByIndex(int32 ReplaySlotIndex, ESaveDataStatus* OutStatus);
	bool ExistsAutoReplaySaveGameByStage(EStageId StageId, ESaveDataStatus* OutStatus);
	int32 GetAppSaveCount(ESaveDataStatus* OutStatus);
	class UAppSaveGame* GetAppSaveGamePtr();
	int32 GetNetSaveCount(ESaveDataStatus* OutStatus);
	class UNetSaveGame* GetNetSaveGamePtr();
	int32 GetOptionConfigSaveCount(ESaveDataStatus* OutStatus);
	class UOptionConfigSaveGame* GetOptionConfigSaveGamePtr();
	int32 GetPlayLogSaveCount(ESaveDataStatus* OutStatus);
	class UPlayLogSaveGame* GetPlayLogSaveGamePtr();
	int32 GetReplaySaveCount(ESaveDataStatus* OutStatus);
	class UReplaySaveGame* GetReplaySaveGamePtr();
	void GetUserNetworkSettingsFromLocalData(struct FUserSaveUserNetworkSettingsRequest* OutRequest);
	void InitSaveAutoReplayAsyncBySlot(int32 ReplaySlotIndex);
	void InitSaveAutoReplayAsyncByStage(EStageId StageId);
	bool IsBusy();
	bool IsLoadedAppSaveData(ESaveDataStatus* OutStatus);
	bool IsLoadedNetSaveData(ESaveDataStatus* OutStatus);
	bool IsLoadedOptionConfigSaveData(ESaveDataStatus* OutStatus);
	bool IsLoadedPlayLogSaveData(ESaveDataStatus* OutStatus);
	bool IsLoadedReplaySaveData(EStageId StageId, ESaveDataStatus* OutStatus);
	bool IsValidAppDataVersion(int32* OutCurVersion, int32* OutSavedVersion, ESaveDataStatus* OutStatus);
	bool IsValidAppRomVersion(int32* OutRomVersion, int32* OutSavedVersion, ESaveDataStatus* OutStatus);
	bool IsValidNetDataVersion(int32* OutCurVersion, int32* OutSavedVersion, ESaveDataStatus* OutStatus);
	bool IsValidNetRomVersion(int32* OutRomVersion, int32* OutSavedVersion, ESaveDataStatus* OutStatus);
	bool IsValidOptionConfigDataVersion(int32* OutCurVersion, int32* OutSavedVersion, ESaveDataStatus* OutStatus);
	bool IsValidOptionConfigRomVersion(int32* OutRomVersion, int32* OutSavedVersion, ESaveDataStatus* OutStatus);
	bool IsValidPlayLogDataVersion(int32* OutCurVersion, int32* OutSavedVersion, ESaveDataStatus* OutStatus);
	bool IsValidPlayLogRomVersion(int32* OutRomVersion, int32* OutSavedVersion, ESaveDataStatus* OutStatus);
	bool IsValidReplayDataVersion(int32* OutCurVersion, int32* OutSavedVersion, ESaveDataStatus* OutStatus);
	bool IsValidReplayRomVersion(int32* OutRomVersion, int32* OutSavedVersion, ESaveDataStatus* OutStatus);
	void LoadAutoAppAsync();
	ESaveDataStatus LoadAutoAppSync();
	void LoadAutoDemoAppAsync();
	void LoadAutoNetAsync();
	ESaveDataStatus LoadAutoNetSync();
	void LoadAutoOptionConfigAsync();
	ESaveDataStatus LoadAutoOptionConfigSync();
	void LoadAutoPlayLogAsync();
	ESaveDataStatus LoadAutoPlayLogSync();
	void LoadReplayConfigAsync(EStageId StageId);
	ESaveDataStatus LoadReplayConfigSyncByIndex(int32 ReplaySlotIndex);
	void OnInitReplaySaveCompleteFunc(const class FString& SlotName, const int32 UserIndex, bool bSuccess);
	void OnLoadCompleteFunc(const class FString& SlotName, const int32 UserIndex, class USaveGame* SaveGame);
	void OnSaveCompleteFunc(const class FString& SlotName, const int32 UserIndex, bool bSuccess);
	void OnSaveErrorPopupClosedFunc();
	void SaveAutoAppAsync();
	ESaveDataStatus SaveAutoAppSync();
	void SaveAutoNetAsync();
	ESaveDataStatus SaveAutoNetSync();
	void SaveAutoOptionConfigAsync();
	ESaveDataStatus SaveAutoOptionConfigSync();
	void SaveAutoPlayLogAsync();
	ESaveDataStatus SaveAutoPlayLogSync();
	void SaveAutoReplayAsync(EStageId StageId);
	void StartAutoSavingAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveDataManageSubsystem">();
	}
	static class USaveDataManageSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveDataManageSubsystem>();
	}
};
static_assert(alignof(USaveDataManageSubsystem) == 0x000008, "Wrong alignment on USaveDataManageSubsystem");
static_assert(sizeof(USaveDataManageSubsystem) == 0x000270, "Wrong size on USaveDataManageSubsystem");
static_assert(offsetof(USaveDataManageSubsystem, OnLoadComplete) == 0x000038, "Member 'USaveDataManageSubsystem::OnLoadComplete' has a wrong offset!");
static_assert(offsetof(USaveDataManageSubsystem, OnSaveComplete) == 0x000048, "Member 'USaveDataManageSubsystem::OnSaveComplete' has a wrong offset!");
static_assert(offsetof(USaveDataManageSubsystem, AutoSaveIconWidget) == 0x000078, "Member 'USaveDataManageSubsystem::AutoSaveIconWidget' has a wrong offset!");
static_assert(offsetof(USaveDataManageSubsystem, LoadedMap) == 0x000088, "Member 'USaveDataManageSubsystem::LoadedMap' has a wrong offset!");
static_assert(offsetof(USaveDataManageSubsystem, _AppSaveGame) == 0x0000D8, "Member 'USaveDataManageSubsystem::_AppSaveGame' has a wrong offset!");
static_assert(offsetof(USaveDataManageSubsystem, _PlayLogSaveGame) == 0x0000E0, "Member 'USaveDataManageSubsystem::_PlayLogSaveGame' has a wrong offset!");
static_assert(offsetof(USaveDataManageSubsystem, _OptionConfigSaveGame) == 0x0000E8, "Member 'USaveDataManageSubsystem::_OptionConfigSaveGame' has a wrong offset!");
static_assert(offsetof(USaveDataManageSubsystem, _ReplaySaveGame) == 0x0000F0, "Member 'USaveDataManageSubsystem::_ReplaySaveGame' has a wrong offset!");
static_assert(offsetof(USaveDataManageSubsystem, _NetSaveGame) == 0x0000F8, "Member 'USaveDataManageSubsystem::_NetSaveGame' has a wrong offset!");

// Class UnionSystem.SavingIcon
// 0x0000 (0x02E0 - 0x02E0)
class USavingIcon : public UUserWidget
{
public:
	void StartAnimIn();
	void StartAnimOut();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SavingIcon">();
	}
	static class USavingIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<USavingIcon>();
	}
};
static_assert(alignof(USavingIcon) == 0x000008, "Wrong alignment on USavingIcon");
static_assert(sizeof(USavingIcon) == 0x0002E0, "Wrong size on USavingIcon");

// Class UnionSystem.SequenceParameterActor
// 0x0120 (0x03B0 - 0x0290)
class ASequenceParameterActor final : public AActor
{
public:
	struct FTransform                             SequenceTransform_;                                // 0x0290(0x0060)(Edit, BlueprintVisible, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSequenceVisibility_;                              // 0x02F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSequenceEvent_;                                   // 0x02F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSequenceMainFloorVisibility_;                     // 0x02F2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSequenceFloorFrontVisibility_;                    // 0x02F3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSequenceFloorBackVisibility_;                     // 0x02F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSequenceAccelFloorVisibility_;                    // 0x02F5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F6[0x2];                                      // 0x02F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SequenceLabel;                                     // 0x02F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_300[0xB0];                                     // 0x0300(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSequenceAccelFloorVisibility_(bool bVisibility);
	void SetSequenceEvent_(bool bEvent);
	void SetSequenceFloorBackVisibility_(bool bVisibility);
	void SetSequenceFloorFrontVisibility_(bool bVisibility);
	void SetSequenceMainFloorVisibility_(bool bVisibility);
	void SetSequenceTransform_(const struct FTransform& Transform);
	void SetSequenceVisibility_(bool bVisibility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequenceParameterActor">();
	}
	static class ASequenceParameterActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASequenceParameterActor>();
	}
};
static_assert(alignof(ASequenceParameterActor) == 0x000010, "Wrong alignment on ASequenceParameterActor");
static_assert(sizeof(ASequenceParameterActor) == 0x0003B0, "Wrong size on ASequenceParameterActor");
static_assert(offsetof(ASequenceParameterActor, SequenceTransform_) == 0x000290, "Member 'ASequenceParameterActor::SequenceTransform_' has a wrong offset!");
static_assert(offsetof(ASequenceParameterActor, bSequenceVisibility_) == 0x0002F0, "Member 'ASequenceParameterActor::bSequenceVisibility_' has a wrong offset!");
static_assert(offsetof(ASequenceParameterActor, bSequenceEvent_) == 0x0002F1, "Member 'ASequenceParameterActor::bSequenceEvent_' has a wrong offset!");
static_assert(offsetof(ASequenceParameterActor, bSequenceMainFloorVisibility_) == 0x0002F2, "Member 'ASequenceParameterActor::bSequenceMainFloorVisibility_' has a wrong offset!");
static_assert(offsetof(ASequenceParameterActor, bSequenceFloorFrontVisibility_) == 0x0002F3, "Member 'ASequenceParameterActor::bSequenceFloorFrontVisibility_' has a wrong offset!");
static_assert(offsetof(ASequenceParameterActor, bSequenceFloorBackVisibility_) == 0x0002F4, "Member 'ASequenceParameterActor::bSequenceFloorBackVisibility_' has a wrong offset!");
static_assert(offsetof(ASequenceParameterActor, bSequenceAccelFloorVisibility_) == 0x0002F5, "Member 'ASequenceParameterActor::bSequenceAccelFloorVisibility_' has a wrong offset!");
static_assert(offsetof(ASequenceParameterActor, SequenceLabel) == 0x0002F8, "Member 'ASequenceParameterActor::SequenceLabel' has a wrong offset!");

// Class UnionSystem.SequenceTriggerComponent
// 0x0080 (0x0120 - 0x00A0)
class USequenceTriggerComponent final : public UActorComponent
{
public:
	class FName                                   SequenceParameterLabel;                            // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAtomCue*                          soundAsset_;                                       // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0x70];                                      // 0x00B0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SequenceTriggerComponent">();
	}
	static class USequenceTriggerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USequenceTriggerComponent>();
	}
};
static_assert(alignof(USequenceTriggerComponent) == 0x000008, "Wrong alignment on USequenceTriggerComponent");
static_assert(sizeof(USequenceTriggerComponent) == 0x000120, "Wrong size on USequenceTriggerComponent");
static_assert(offsetof(USequenceTriggerComponent, SequenceParameterLabel) == 0x0000A0, "Member 'USequenceTriggerComponent::SequenceParameterLabel' has a wrong offset!");
static_assert(offsetof(USequenceTriggerComponent, soundAsset_) == 0x0000A8, "Member 'USequenceTriggerComponent::soundAsset_' has a wrong offset!");

// Class UnionSystem.SessionManager
// 0x0118 (0x0148 - 0x0030)
class USessionManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x118];                                     // 0x0030(0x0118)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetDisplayCode(class FString* displayCode);
	bool GetExternalAddressRegionName(class FString* AddressRegionName);
	bool GetFairPlayPoint(int32* OutFairPlayPoint);
	bool GetIsBan(bool* bOutIsBan);
	bool GetLoginComplete();
	bool GetPenaltyEndTime(class FString* endTime);
	bool GetRegionCode(class FString* regionCode);
	EResponseCodeAbstract GetResponseCodeAbstract();
	bool GetSwitchOnlineCode(int32* switchOnlineCode);
	bool GetUserID(class FString* UserId);
	void StartLogin(TDelegate<void(bool Error, bool SavedataDeleted)> Callback);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SessionManager">();
	}
	static class USessionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USessionManager>();
	}
};
static_assert(alignof(USessionManager) == 0x000008, "Wrong alignment on USessionManager");
static_assert(sizeof(USessionManager) == 0x000148, "Wrong size on USessionManager");

// Class UnionSystem.ShareConfig
// 0x0040 (0x0078 - 0x0038)
class UShareConfig final : public UDeveloperSettings
{
public:
	class FString                                 UrlOfficial;                                       // 0x0038(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UrlTwitter;                                        // 0x0048(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UrlYouTube;                                        // 0x0058(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Tags;                                              // 0x0068(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShareConfig">();
	}
	static class UShareConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShareConfig>();
	}
};
static_assert(alignof(UShareConfig) == 0x000008, "Wrong alignment on UShareConfig");
static_assert(sizeof(UShareConfig) == 0x000078, "Wrong size on UShareConfig");
static_assert(offsetof(UShareConfig, UrlOfficial) == 0x000038, "Member 'UShareConfig::UrlOfficial' has a wrong offset!");
static_assert(offsetof(UShareConfig, UrlTwitter) == 0x000048, "Member 'UShareConfig::UrlTwitter' has a wrong offset!");
static_assert(offsetof(UShareConfig, UrlYouTube) == 0x000058, "Member 'UShareConfig::UrlYouTube' has a wrong offset!");
static_assert(offsetof(UShareConfig, Tags) == 0x000068, "Member 'UShareConfig::Tags' has a wrong offset!");

// Class UnionSystem.UnionSpeedClassLibrary
// 0x0000 (0x0028 - 0x0028)
class UUnionSpeedClassLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float GetMaxSpeedByClass(const ESpeedClassId ClassId);
	static float GetMinSpeedByClass(const ESpeedClassId ClassId);
	static uint8 GetTimeTrialIndex(const ESpeedClassId InId);
	static bool IsTimeTrialActive(const ESpeedClassId InId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionSpeedClassLibrary">();
	}
	static class UUnionSpeedClassLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionSpeedClassLibrary>();
	}
};
static_assert(alignof(UUnionSpeedClassLibrary) == 0x000008, "Wrong alignment on UUnionSpeedClassLibrary");
static_assert(sizeof(UUnionSpeedClassLibrary) == 0x000028, "Wrong size on UUnionSpeedClassLibrary");

// Class UnionSystem.StageIdUtilityLibrary
// 0x0000 (0x0028 - 0x0028)
class UStageIdUtilityLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString BuildStageDirectory(EStageId InId);
	static class FString BuildStageName(EStageId InId, const class FString& InPrefix);
	static class FString BuildStageString(EStageId InId, const class FString& InPrefix);
	static EStageId GetEditorLevelStageId();
	static class FString GetLevelName_BG(EStageId InId);
	static class FString GetLevelName_Editor(EStageId InId);
	static class FString GetLevelName_FX(EStageId InId);
	static class FString GetLevelName_ItemBox(EStageId InId);
	static class FString GetLevelName_ItemBoxFinalLap(EStageId InId);
	static class FString GetLevelName_ItemBoxIrregular(EStageId InId);
	static class FString GetLevelName_ObjectGame(EStageId InId);
	static class FString GetLevelName_ObjectGameFinalLap(EStageId InId);
	static class FString GetLevelName_ObjectGameIrregular(EStageId InId);
	static class FString GetLevelName_Sound(EStageId InId);
	static int32 GetStageEndNumber(EStageId InId);
	static EStageId GetStageId(int32 InNumber);
	static EStageId GetStageIdByActor(const class AActor* Actor);
	static class FString GetStageName(EStageId InId);
	static int32 GetStageNumber(EStageId InId);
	static class FString GetStageString(EStageId InId);
	static bool IsAnotherStage(EStageId InId);
	static bool IsCommonStage(EStageId InId);
	static bool IsDebugAnotherStage(EStageId InId);
	static bool IsDebugMainStage(EStageId InId);
	static bool IsDebugStage(EStageId InId);
	static bool IsExtndMainStage(EStageId InId);
	static bool IsMainStage(EStageId InId);
	static bool IsStageIdValid(EStageId InId);
	static EStageId StringToStageId(const class FString& String);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StageIdUtilityLibrary">();
	}
	static class UStageIdUtilityLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStageIdUtilityLibrary>();
	}
};
static_assert(alignof(UStageIdUtilityLibrary) == 0x000008, "Wrong alignment on UStageIdUtilityLibrary");
static_assert(sizeof(UStageIdUtilityLibrary) == 0x000028, "Wrong size on UStageIdUtilityLibrary");

// Class UnionSystem.SwitchPlatformUtility
// 0x0000 (0x0028 - 0x0028)
class USwitchPlatformUtility final : public UBlueprintFunctionLibrary
{
public:
	static void SetCPUBoostModeEnabled(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwitchPlatformUtility">();
	}
	static class USwitchPlatformUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwitchPlatformUtility>();
	}
};
static_assert(alignof(USwitchPlatformUtility) == 0x000008, "Wrong alignment on USwitchPlatformUtility");
static_assert(sizeof(USwitchPlatformUtility) == 0x000028, "Wrong size on USwitchPlatformUtility");

// Class UnionSystem.TimeTrialVariousLibrary
// 0x0000 (0x0028 - 0x0028)
class UTimeTrialVariousLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool CheckForNewRecord(const int32 InClockCount, const EStageId InStageId, const ESpeedClassId InSpeedClassId, bool* OutMedalAcquistion);
	static void CheckHashGhostResultMatch(const ESpeedClassId InSpeedClass, const EStageId InStageId, bool* OutResult);
	static bool CheckIsTargetTimeClear(const int32 InClockCount, const EStageId InStageId, const ESpeedClassId InSpeedClassId, ETimeTrialClearRankId* OutClearRank);
	static void ConvertUserTimeTrialRaceData(const struct FTimeTrialLapTimes& InLapTimes, const EDriverId InDriverId, const struct FUserMachineCustomizeData& InMachineCustomizeData, const struct FUserGadgetPresetData& InGadgetPresetData, ETimeTrialClearRankId InClearRank, struct FUserTimeTrialRaceData* OutRaceData);
	static struct FTimeTrialResultRewardTableData GetCurrentRewardData();
	static struct FTimeTrialResultRewardTableData GetNextRewardData(int32 MedalCount, int32* OutRewardCount, int32* OutRewardMax, bool* OutIsValid);
	static bool GetRewardData(int32 MedalCount, struct FTimeTrialResultRewardTableData* OutRewardData);
	static struct FTimeTrialLapTimes GetTimeTrialBestTimeData(const EStageId InStageId, const ESpeedClassId InSpeedClassId);
	static struct FTimeTrialRankData GetTimeTrialRankData(const int32 InClockCount, const EStageId InStageId, const ESpeedClassId InSpeedClassId);
	static int32 GetTimeTrialTargetTime(ESpeedClassId InSpeedClass, EStageId InStageId);
	static bool IsGhostResultReleased(const struct FUserTimeTrialRaceData& InResultData);
	static bool IsGhostVersionCheck(const int32& InStageVersion, const ESpeedClassId InSpeedClass);
	static bool IsGhostVersionHeaderCheck(const int32& InStageVersion, const struct FReplayHeader& InGhostHeader);
	static bool IsReplayGhostReleased(const struct FReplaySaveInfo& InGhostData);
	static bool IsTimeTrialRankCleared(const ETimeTrialClearRankId InId);
	static bool isTimeTrialResultReward(int32 MedalCount, class UDataTable* ResultRewardDataTable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimeTrialVariousLibrary">();
	}
	static class UTimeTrialVariousLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimeTrialVariousLibrary>();
	}
};
static_assert(alignof(UTimeTrialVariousLibrary) == 0x000008, "Wrong alignment on UTimeTrialVariousLibrary");
static_assert(sizeof(UTimeTrialVariousLibrary) == 0x000028, "Wrong size on UTimeTrialVariousLibrary");

// Class UnionSystem.TransferFunction
// 0x0000 (0x0028 - 0x0028)
class UTransferFunction final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TransferFunction">();
	}
	static class UTransferFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTransferFunction>();
	}
};
static_assert(alignof(UTransferFunction) == 0x000008, "Wrong alignment on UTransferFunction");
static_assert(sizeof(UTransferFunction) == 0x000028, "Wrong size on UTransferFunction");

// Class UnionSystem.UISubsystem
// 0x0050 (0x0080 - 0x0030)
class UUISubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            PopupWindow;                                       // 0x0038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            RewardDisplayWidget;                               // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            FriendListWidget;                                  // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            AdvertiseWidget;                                   // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            AutoSaveInfoWidget;                                // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            ProfileErrorWidget;                                // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x18];                                      // 0x0068(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UUserWidget* CreateAdvertiseWidget();
	class UUserWidget* CreateAutoSaveInfoWidget();
	class UUserWidget* CreateFriendListWidget();
	class UUserWidget* CreateProfileErrorPopupWindow();
	class UUserWidget* CreateRewardDisplayWidget();
	void DestroyAdvertiseWidget();
	void DestroyAutoSaveInfoWidget();
	void DestroyFriendListWidget();
	void DestroyProfileErrorPopupWindow();
	void DestroyRewardDisplayWidget();
	class UUserWidget* GetAdvertiseWidget();
	class UUserWidget* GetAutoSaveInfoWidget();
	class UUserWidget* GetFriendListWidget();
	EPopupWindowType GetPopupWindowType();
	class UUserWidget* GetRewardDisplayWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISubsystem">();
	}
	static class UUISubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISubsystem>();
	}
};
static_assert(alignof(UUISubsystem) == 0x000008, "Wrong alignment on UUISubsystem");
static_assert(sizeof(UUISubsystem) == 0x000080, "Wrong size on UUISubsystem");
static_assert(offsetof(UUISubsystem, PopupWindow) == 0x000038, "Member 'UUISubsystem::PopupWindow' has a wrong offset!");
static_assert(offsetof(UUISubsystem, RewardDisplayWidget) == 0x000040, "Member 'UUISubsystem::RewardDisplayWidget' has a wrong offset!");
static_assert(offsetof(UUISubsystem, FriendListWidget) == 0x000048, "Member 'UUISubsystem::FriendListWidget' has a wrong offset!");
static_assert(offsetof(UUISubsystem, AdvertiseWidget) == 0x000050, "Member 'UUISubsystem::AdvertiseWidget' has a wrong offset!");
static_assert(offsetof(UUISubsystem, AutoSaveInfoWidget) == 0x000058, "Member 'UUISubsystem::AutoSaveInfoWidget' has a wrong offset!");
static_assert(offsetof(UUISubsystem, ProfileErrorWidget) == 0x000060, "Member 'UUISubsystem::ProfileErrorWidget' has a wrong offset!");

// Class UnionSystem.UnionAddOnBase
// 0x0000 (0x0028 - 0x0028)
class UUnionAddOnBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionAddOnBase">();
	}
	static class UUnionAddOnBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionAddOnBase>();
	}
};
static_assert(alignof(UUnionAddOnBase) == 0x000008, "Wrong alignment on UUnionAddOnBase");
static_assert(sizeof(UUnionAddOnBase) == 0x000028, "Wrong size on UUnionAddOnBase");

// Class UnionSystem.UnionAddOnEpic
// 0x0070 (0x0098 - 0x0028)
class UUnionAddOnEpic final : public UUnionAddOnBase
{
public:
	uint8                                         Pad_28[0x70];                                      // 0x0028(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionAddOnEpic">();
	}
	static class UUnionAddOnEpic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionAddOnEpic>();
	}
};
static_assert(alignof(UUnionAddOnEpic) == 0x000008, "Wrong alignment on UUnionAddOnEpic");
static_assert(sizeof(UUnionAddOnEpic) == 0x000098, "Wrong size on UUnionAddOnEpic");

// Class UnionSystem.UnionAddOnNX
// 0x0050 (0x0078 - 0x0028)
class UUnionAddOnNX final : public UUnionAddOnBase
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionAddOnNX">();
	}
	static class UUnionAddOnNX* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionAddOnNX>();
	}
};
static_assert(alignof(UUnionAddOnNX) == 0x000008, "Wrong alignment on UUnionAddOnNX");
static_assert(sizeof(UUnionAddOnNX) == 0x000078, "Wrong size on UUnionAddOnNX");

// Class UnionSystem.UnionAddOnPS
// 0x0098 (0x00C0 - 0x0028)
class UUnionAddOnPS final : public UUnionAddOnBase
{
public:
	uint8                                         Pad_28[0x98];                                      // 0x0028(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionAddOnPS">();
	}
	static class UUnionAddOnPS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionAddOnPS>();
	}
};
static_assert(alignof(UUnionAddOnPS) == 0x000008, "Wrong alignment on UUnionAddOnPS");
static_assert(sizeof(UUnionAddOnPS) == 0x0000C0, "Wrong size on UUnionAddOnPS");

// Class UnionSystem.UnionAddOnSteam
// 0x0050 (0x0078 - 0x0028)
class UUnionAddOnSteam final : public UUnionAddOnBase
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionAddOnSteam">();
	}
	static class UUnionAddOnSteam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionAddOnSteam>();
	}
};
static_assert(alignof(UUnionAddOnSteam) == 0x000008, "Wrong alignment on UUnionAddOnSteam");
static_assert(sizeof(UUnionAddOnSteam) == 0x000078, "Wrong size on UUnionAddOnSteam");

// Class UnionSystem.UnionAOStaticMeshComponent
// 0x0050 (0x0630 - 0x05E0)
class UUnionAOStaticMeshComponent final : public UUnionStaticMeshComponent
{
public:
	bool                                          IsMesh;                                            // 0x05D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAO;                                              // 0x05D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5DA[0x2];                                      // 0x05DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ShadowColor;                                       // 0x05DC(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Intensity;                                         // 0x05EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceShadow;                                    // 0x05F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RayLength;                                         // 0x05F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      MaterialInstance;                                  // 0x05F8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               DynamicMaterialInstance;                           // 0x0600(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Texture2D;                                         // 0x0608(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            StaticShadowMesh;                                  // 0x0610(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSetUp;                                           // 0x0618(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_619[0xF];                                      // 0x0619(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionStaticMeshComponent*              ShadowMesh;                                        // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionAOStaticMeshComponent">();
	}
	static class UUnionAOStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionAOStaticMeshComponent>();
	}
};
static_assert(alignof(UUnionAOStaticMeshComponent) == 0x000010, "Wrong alignment on UUnionAOStaticMeshComponent");
static_assert(sizeof(UUnionAOStaticMeshComponent) == 0x000630, "Wrong size on UUnionAOStaticMeshComponent");
static_assert(offsetof(UUnionAOStaticMeshComponent, IsMesh) == 0x0005D8, "Member 'UUnionAOStaticMeshComponent::IsMesh' has a wrong offset!");
static_assert(offsetof(UUnionAOStaticMeshComponent, IsAO) == 0x0005D9, "Member 'UUnionAOStaticMeshComponent::IsAO' has a wrong offset!");
static_assert(offsetof(UUnionAOStaticMeshComponent, ShadowColor) == 0x0005DC, "Member 'UUnionAOStaticMeshComponent::ShadowColor' has a wrong offset!");
static_assert(offsetof(UUnionAOStaticMeshComponent, Intensity) == 0x0005EC, "Member 'UUnionAOStaticMeshComponent::Intensity' has a wrong offset!");
static_assert(offsetof(UUnionAOStaticMeshComponent, DistanceShadow) == 0x0005F0, "Member 'UUnionAOStaticMeshComponent::DistanceShadow' has a wrong offset!");
static_assert(offsetof(UUnionAOStaticMeshComponent, RayLength) == 0x0005F4, "Member 'UUnionAOStaticMeshComponent::RayLength' has a wrong offset!");
static_assert(offsetof(UUnionAOStaticMeshComponent, MaterialInstance) == 0x0005F8, "Member 'UUnionAOStaticMeshComponent::MaterialInstance' has a wrong offset!");
static_assert(offsetof(UUnionAOStaticMeshComponent, DynamicMaterialInstance) == 0x000600, "Member 'UUnionAOStaticMeshComponent::DynamicMaterialInstance' has a wrong offset!");
static_assert(offsetof(UUnionAOStaticMeshComponent, Texture2D) == 0x000608, "Member 'UUnionAOStaticMeshComponent::Texture2D' has a wrong offset!");
static_assert(offsetof(UUnionAOStaticMeshComponent, StaticShadowMesh) == 0x000610, "Member 'UUnionAOStaticMeshComponent::StaticShadowMesh' has a wrong offset!");
static_assert(offsetof(UUnionAOStaticMeshComponent, IsSetUp) == 0x000618, "Member 'UUnionAOStaticMeshComponent::IsSetUp' has a wrong offset!");
static_assert(offsetof(UUnionAOStaticMeshComponent, ShadowMesh) == 0x000628, "Member 'UUnionAOStaticMeshComponent::ShadowMesh' has a wrong offset!");

// Class UnionSystem.UnionAtomComponent
// 0x0080 (0x1370 - 0x12F0)
class UUnionAtomComponent : public UAtomComponent
{
public:
	bool                                          bUseRate;                                          // 0x12F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12F1[0x3];                                     // 0x12F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartTime;                                         // 0x12F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTimeRate;                                     // 0x12F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12FC[0x4];                                     // 0x12FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAutoManageAttachment : 1;                         // 0x1300(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1301[0x3];                                     // 0x1301(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class USceneComponent>         AutoAttachParent;                                  // 0x1304(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AutoAttachSocketName;                              // 0x130C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               AutoAttachLocationRule;                            // 0x1314(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               AutoAttachRotationRule;                            // 0x1315(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               AutoAttachScaleRule;                               // 0x1316(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1317[0x49];                                    // 0x1317(0x0049)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bForceDisableLoopSoundDistanceCulling : 1;         // 0x1360(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1361[0xF];                                     // 0x1361(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAudioFinishedFunc();
	void OnStatusChangedFunc(EAtomComponentStatus Status, class UAtomComponent* AtomComponent);
	void PlayWithAutoAttach(float InStartTime);
	bool SetPanSplit(ESoundPan Pan);
	void StopAndResetDistanceCulling();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionAtomComponent">();
	}
	static class UUnionAtomComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionAtomComponent>();
	}
};
static_assert(alignof(UUnionAtomComponent) == 0x000010, "Wrong alignment on UUnionAtomComponent");
static_assert(sizeof(UUnionAtomComponent) == 0x001370, "Wrong size on UUnionAtomComponent");
static_assert(offsetof(UUnionAtomComponent, bUseRate) == 0x0012F0, "Member 'UUnionAtomComponent::bUseRate' has a wrong offset!");
static_assert(offsetof(UUnionAtomComponent, StartTime) == 0x0012F4, "Member 'UUnionAtomComponent::StartTime' has a wrong offset!");
static_assert(offsetof(UUnionAtomComponent, StartTimeRate) == 0x0012F8, "Member 'UUnionAtomComponent::StartTimeRate' has a wrong offset!");
static_assert(offsetof(UUnionAtomComponent, AutoAttachParent) == 0x001304, "Member 'UUnionAtomComponent::AutoAttachParent' has a wrong offset!");
static_assert(offsetof(UUnionAtomComponent, AutoAttachSocketName) == 0x00130C, "Member 'UUnionAtomComponent::AutoAttachSocketName' has a wrong offset!");
static_assert(offsetof(UUnionAtomComponent, AutoAttachLocationRule) == 0x001314, "Member 'UUnionAtomComponent::AutoAttachLocationRule' has a wrong offset!");
static_assert(offsetof(UUnionAtomComponent, AutoAttachRotationRule) == 0x001315, "Member 'UUnionAtomComponent::AutoAttachRotationRule' has a wrong offset!");
static_assert(offsetof(UUnionAtomComponent, AutoAttachScaleRule) == 0x001316, "Member 'UUnionAtomComponent::AutoAttachScaleRule' has a wrong offset!");

// Class UnionSystem.UnionBoxComponent
// 0x0000 (0x0560 - 0x0560)
class UUnionBoxComponent final : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionBoxComponent">();
	}
	static class UUnionBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionBoxComponent>();
	}
};
static_assert(alignof(UUnionBoxComponent) == 0x000010, "Wrong alignment on UUnionBoxComponent");
static_assert(sizeof(UUnionBoxComponent) == 0x000560, "Wrong size on UUnionBoxComponent");

// Class UnionSystem.UnionCapsuleComponent
// 0x0000 (0x0550 - 0x0550)
class UUnionCapsuleComponent final : public UCapsuleComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionCapsuleComponent">();
	}
	static class UUnionCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionCapsuleComponent>();
	}
};
static_assert(alignof(UUnionCapsuleComponent) == 0x000010, "Wrong alignment on UUnionCapsuleComponent");
static_assert(sizeof(UUnionCapsuleComponent) == 0x000550, "Wrong size on UUnionCapsuleComponent");

// Class UnionSystem.UnionChallengeManager
// 0x0038 (0x0068 - 0x0030)
class UUnionChallengeManager final : public UGameInstanceSubsystem
{
public:
	TDelegate<void(int32 InChallengeId, float InTime)> ShowChallengeClearNoticeEvent;                // 0x0030(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x28];                                      // 0x0040(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetIsRaceSequence(bool IsRace);

	bool GetIsRaceSequence() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionChallengeManager">();
	}
	static class UUnionChallengeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionChallengeManager>();
	}
};
static_assert(alignof(UUnionChallengeManager) == 0x000008, "Wrong alignment on UUnionChallengeManager");
static_assert(sizeof(UUnionChallengeManager) == 0x000068, "Wrong size on UUnionChallengeManager");
static_assert(offsetof(UUnionChallengeManager, ShowChallengeClearNoticeEvent) == 0x000030, "Member 'UUnionChallengeManager::ShowChallengeClearNoticeEvent' has a wrong offset!");

// Class UnionSystem.UnionCombineDescendantBoundsComponent
// 0x0040 (0x0270 - 0x0230)
class UUnionCombineDescendantBoundsComponent final : public USceneComponent
{
public:
	uint8                                         Pad_230[0x40];                                     // 0x0230(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionCombineDescendantBoundsComponent">();
	}
	static class UUnionCombineDescendantBoundsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionCombineDescendantBoundsComponent>();
	}
};
static_assert(alignof(UUnionCombineDescendantBoundsComponent) == 0x000010, "Wrong alignment on UUnionCombineDescendantBoundsComponent");
static_assert(sizeof(UUnionCombineDescendantBoundsComponent) == 0x000270, "Wrong size on UUnionCombineDescendantBoundsComponent");

// Class UnionSystem.ContentDebugMenu
// 0x0008 (0x0030 - 0x0028)
class UContentDebugMenu final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContentDebugMenu">();
	}
	static class UContentDebugMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContentDebugMenu>();
	}
};
static_assert(alignof(UContentDebugMenu) == 0x000008, "Wrong alignment on UContentDebugMenu");
static_assert(sizeof(UContentDebugMenu) == 0x000030, "Wrong size on UContentDebugMenu");

// Class UnionSystem.UnionContentManager
// 0x00B0 (0x00D8 - 0x0028)
class UUnionContentManager final : public UObject
{
public:
	class UUnionAddOnBase*                        m_addOn;                                           // 0x0028(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UContentDebugMenu*                      m_DebugMenu;                                       // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<int32>                                 m_packageIds;                                      // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<EDriverId>                             m_serverReleaseDriverList;                         // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<EMachineId>                            m_serverReleaseMachineList;                        // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int32>                                 m_serverReleaseAlbumIdList;                        // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x60];                                      // 0x0078(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionContentManager">();
	}
	static class UUnionContentManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionContentManager>();
	}
};
static_assert(alignof(UUnionContentManager) == 0x000008, "Wrong alignment on UUnionContentManager");
static_assert(sizeof(UUnionContentManager) == 0x0000D8, "Wrong size on UUnionContentManager");
static_assert(offsetof(UUnionContentManager, m_addOn) == 0x000028, "Member 'UUnionContentManager::m_addOn' has a wrong offset!");
static_assert(offsetof(UUnionContentManager, m_DebugMenu) == 0x000030, "Member 'UUnionContentManager::m_DebugMenu' has a wrong offset!");
static_assert(offsetof(UUnionContentManager, m_packageIds) == 0x000038, "Member 'UUnionContentManager::m_packageIds' has a wrong offset!");
static_assert(offsetof(UUnionContentManager, m_serverReleaseDriverList) == 0x000048, "Member 'UUnionContentManager::m_serverReleaseDriverList' has a wrong offset!");
static_assert(offsetof(UUnionContentManager, m_serverReleaseMachineList) == 0x000058, "Member 'UUnionContentManager::m_serverReleaseMachineList' has a wrong offset!");
static_assert(offsetof(UUnionContentManager, m_serverReleaseAlbumIdList) == 0x000068, "Member 'UUnionContentManager::m_serverReleaseAlbumIdList' has a wrong offset!");

// Class UnionSystem.ContentDataAsset
// 0x02F0 (0x0320 - 0x0030)
class UContentDataAsset final : public UDataAsset
{
public:
	TMap<int32, struct FContentCharaData>         CharaDLCMap;                                       // 0x0030(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<EContentId, struct FContentCharaData>    CharaContentSeverTimeMap;                          // 0x0080(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<int32, struct FContentMachineData>       MachineDLCMap;                                     // 0x00D0(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<EContentId, struct FContentMachineData>  MachineContentSeverTimeMap;                        // 0x0120(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<int32, struct FContentStageData>         StageDLCMap;                                       // 0x0170(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<int32, struct FContentStickerData>       StickerDLCMap;                                     // 0x01C0(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<int32, struct FContentHonorTitleData>    HonorOtherTitleDLCMap;                             // 0x0210(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<int32, struct FContentAlbumData>         AlbumDLCMap;                                       // 0x0260(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<EContentId, struct FContentAlbumData>    AlbumSeverTimeMap;                                 // 0x02B0(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TArray<struct FPackageData>                   PackageDataList;                                   // 0x0300(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<EContentId>                            ServerTimeContent;                                 // 0x0310(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)

public:
	void Build();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContentDataAsset">();
	}
	static class UContentDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContentDataAsset>();
	}
};
static_assert(alignof(UContentDataAsset) == 0x000008, "Wrong alignment on UContentDataAsset");
static_assert(sizeof(UContentDataAsset) == 0x000320, "Wrong size on UContentDataAsset");
static_assert(offsetof(UContentDataAsset, CharaDLCMap) == 0x000030, "Member 'UContentDataAsset::CharaDLCMap' has a wrong offset!");
static_assert(offsetof(UContentDataAsset, CharaContentSeverTimeMap) == 0x000080, "Member 'UContentDataAsset::CharaContentSeverTimeMap' has a wrong offset!");
static_assert(offsetof(UContentDataAsset, MachineDLCMap) == 0x0000D0, "Member 'UContentDataAsset::MachineDLCMap' has a wrong offset!");
static_assert(offsetof(UContentDataAsset, MachineContentSeverTimeMap) == 0x000120, "Member 'UContentDataAsset::MachineContentSeverTimeMap' has a wrong offset!");
static_assert(offsetof(UContentDataAsset, StageDLCMap) == 0x000170, "Member 'UContentDataAsset::StageDLCMap' has a wrong offset!");
static_assert(offsetof(UContentDataAsset, StickerDLCMap) == 0x0001C0, "Member 'UContentDataAsset::StickerDLCMap' has a wrong offset!");
static_assert(offsetof(UContentDataAsset, HonorOtherTitleDLCMap) == 0x000210, "Member 'UContentDataAsset::HonorOtherTitleDLCMap' has a wrong offset!");
static_assert(offsetof(UContentDataAsset, AlbumDLCMap) == 0x000260, "Member 'UContentDataAsset::AlbumDLCMap' has a wrong offset!");
static_assert(offsetof(UContentDataAsset, AlbumSeverTimeMap) == 0x0002B0, "Member 'UContentDataAsset::AlbumSeverTimeMap' has a wrong offset!");
static_assert(offsetof(UContentDataAsset, PackageDataList) == 0x000300, "Member 'UContentDataAsset::PackageDataList' has a wrong offset!");
static_assert(offsetof(UContentDataAsset, ServerTimeContent) == 0x000310, "Member 'UContentDataAsset::ServerTimeContent' has a wrong offset!");

// Class UnionSystem.UnionContentUtils
// 0x0000 (0x0028 - 0x0028)
class UUnionContentUtils final : public UBlueprintFunctionLibrary
{
public:
	static bool CanUseAlbum(int32 AlbumID);
	static bool CanUseCharacter(EDriverId DriverId);
	static bool CanUseHonorTitle(int32 HonorTitleId);
	static bool CanUseMachine(EMachineId MachineId);
	static bool CanUseStageByGameMode(EGameModeId GameModeID, EStageId StageId);
	static bool CanUseStageByGameModeForCourseSelect(EGameModeId GameModeID, EStageId StageId);
	static bool CanUseSticker(int32 stickerId);
	static void GetIsItemReleased(const struct FContentItem& CheckItem, bool* IsReleased);
	static void GetUseItemList(EGameModeId GameModeID, const TArray<struct FContentItem>& CheckItemList, TArray<struct FContentItem>* UnlockItemList);
	static bool IsAuraReleased(EMachineAuraId AuraId);
	static bool IsBusyCheckContent();
	static bool IsCharacterReleased(EDriverId DriverId);
	static bool IsGadgetReleased(EGadgetId gadgetId);
	static bool IsHonorTitleReleased(int32 HonorTitleId);
	static bool IsHornReleased(EMachineHornType hornId);
	static bool IsMachineFrontPartsReleased(EMachineId MachineId);
	static bool IsMachineRearPartsReleased(EMachineId MachineId);
	static bool IsMachineTirePartsReleased(EMachineId MachineId);
	static bool IsStickerReleased(int32 stickerId);
	static void RequestCheckContent(bool bEnableMasterData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionContentUtils">();
	}
	static class UUnionContentUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionContentUtils>();
	}
};
static_assert(alignof(UUnionContentUtils) == 0x000008, "Wrong alignment on UUnionContentUtils");
static_assert(sizeof(UUnionContentUtils) == 0x000028, "Wrong size on UUnionContentUtils");

// Class UnionSystem.UnionCueSheetIdDataAsset
// 0x0000 (0x0030 - 0x0030)
class UUnionCueSheetIdDataAsset : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionCueSheetIdDataAsset">();
	}
	static class UUnionCueSheetIdDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionCueSheetIdDataAsset>();
	}
};
static_assert(alignof(UUnionCueSheetIdDataAsset) == 0x000008, "Wrong alignment on UUnionCueSheetIdDataAsset");
static_assert(sizeof(UUnionCueSheetIdDataAsset) == 0x000030, "Wrong size on UUnionCueSheetIdDataAsset");

// Class UnionSystem.UnionCueSheetIdDataAsset_01_Union
// 0x0000 (0x0030 - 0x0030)
class UUnionCueSheetIdDataAsset_01_Union final : public UUnionCueSheetIdDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionCueSheetIdDataAsset_01_Union">();
	}
	static class UUnionCueSheetIdDataAsset_01_Union* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionCueSheetIdDataAsset_01_Union>();
	}
};
static_assert(alignof(UUnionCueSheetIdDataAsset_01_Union) == 0x000008, "Wrong alignment on UUnionCueSheetIdDataAsset_01_Union");
static_assert(sizeof(UUnionCueSheetIdDataAsset_01_Union) == 0x000030, "Wrong size on UUnionCueSheetIdDataAsset_01_Union");

// Class UnionSystem.UnionCueSheetIdDataAsset_02_Union
// 0x0000 (0x0030 - 0x0030)
class UUnionCueSheetIdDataAsset_02_Union final : public UUnionCueSheetIdDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionCueSheetIdDataAsset_02_Union">();
	}
	static class UUnionCueSheetIdDataAsset_02_Union* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionCueSheetIdDataAsset_02_Union>();
	}
};
static_assert(alignof(UUnionCueSheetIdDataAsset_02_Union) == 0x000008, "Wrong alignment on UUnionCueSheetIdDataAsset_02_Union");
static_assert(sizeof(UUnionCueSheetIdDataAsset_02_Union) == 0x000030, "Wrong size on UUnionCueSheetIdDataAsset_02_Union");

// Class UnionSystem.UnionCueSheetIdDataAsset_03_Union
// 0x0000 (0x0030 - 0x0030)
class UUnionCueSheetIdDataAsset_03_Union final : public UUnionCueSheetIdDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionCueSheetIdDataAsset_03_Union">();
	}
	static class UUnionCueSheetIdDataAsset_03_Union* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionCueSheetIdDataAsset_03_Union>();
	}
};
static_assert(alignof(UUnionCueSheetIdDataAsset_03_Union) == 0x000008, "Wrong alignment on UUnionCueSheetIdDataAsset_03_Union");
static_assert(sizeof(UUnionCueSheetIdDataAsset_03_Union) == 0x000030, "Wrong size on UUnionCueSheetIdDataAsset_03_Union");

// Class UnionSystem.UnionCueSheetIdDataAsset_04_Union
// 0x0000 (0x0030 - 0x0030)
class UUnionCueSheetIdDataAsset_04_Union final : public UUnionCueSheetIdDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionCueSheetIdDataAsset_04_Union">();
	}
	static class UUnionCueSheetIdDataAsset_04_Union* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionCueSheetIdDataAsset_04_Union>();
	}
};
static_assert(alignof(UUnionCueSheetIdDataAsset_04_Union) == 0x000008, "Wrong alignment on UUnionCueSheetIdDataAsset_04_Union");
static_assert(sizeof(UUnionCueSheetIdDataAsset_04_Union) == 0x000030, "Wrong size on UUnionCueSheetIdDataAsset_04_Union");

// Class UnionSystem.UnionCueSheetIdDataAsset_05_Union
// 0x0000 (0x0030 - 0x0030)
class UUnionCueSheetIdDataAsset_05_Union final : public UUnionCueSheetIdDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionCueSheetIdDataAsset_05_Union">();
	}
	static class UUnionCueSheetIdDataAsset_05_Union* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionCueSheetIdDataAsset_05_Union>();
	}
};
static_assert(alignof(UUnionCueSheetIdDataAsset_05_Union) == 0x000008, "Wrong alignment on UUnionCueSheetIdDataAsset_05_Union");
static_assert(sizeof(UUnionCueSheetIdDataAsset_05_Union) == 0x000030, "Wrong size on UUnionCueSheetIdDataAsset_05_Union");

// Class UnionSystem.UnionDateTime
// 0x0000 (0x0028 - 0x0028)
class UUnionDateTime final : public UBlueprintFunctionLibrary
{
public:
	static struct FDateTime FromUnixTimestamp(int64 UnixTime);
	static struct FDateTime GetServerTime();
	static int32 GetUnionDay();
	static int32 GetUnionHour();
	static int32 GetUnionMillisecond();
	static int32 GetUnionMinute();
	static int32 GetUnionMonth();
	static struct FDateTime GetUnionNow();
	static int32 GetUnionSecond();
	static struct FDateTime GetUnionUtcNow();
	static int32 GetUnionYear();
	static void SetServerTime(const struct FDateTime& InServerTime);
	static int64 ToUnixTimestamp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionDateTime">();
	}
	static class UUnionDateTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionDateTime>();
	}
};
static_assert(alignof(UUnionDateTime) == 0x000008, "Wrong alignment on UUnionDateTime");
static_assert(sizeof(UUnionDateTime) == 0x000028, "Wrong size on UUnionDateTime");

// Class UnionSystem.NiagaraWatcher
// 0x0018 (0x0040 - 0x0028)
class UNiagaraWatcher final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NiagaraWatcher">();
	}
	static class UNiagaraWatcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNiagaraWatcher>();
	}
};
static_assert(alignof(UNiagaraWatcher) == 0x000008, "Wrong alignment on UNiagaraWatcher");
static_assert(sizeof(UNiagaraWatcher) == 0x000040, "Wrong size on UNiagaraWatcher");

// Class UnionSystem.DebugViewBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UDebugViewBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ToggleDisplayNiagaraBounds(const bool bEnable);
	static void ToggleEffects(const bool bEnable);
	static void ToggleEffectsCacheEmpty();
	static void ToggleEffectsCacheReset();
	static void ToggleEffectsDisable();
	static void ToggleEffectsEnable();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugViewBlueprintFunctionLibrary">();
	}
	static class UDebugViewBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugViewBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UDebugViewBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UDebugViewBlueprintFunctionLibrary");
static_assert(sizeof(UDebugViewBlueprintFunctionLibrary) == 0x000028, "Wrong size on UDebugViewBlueprintFunctionLibrary");

// Class UnionSystem.DebugViewGameplayStatics
// 0x0000 (0x0028 - 0x0028)
class UDebugViewGameplayStatics final : public UGameplayStatics
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugViewGameplayStatics">();
	}
	static class UDebugViewGameplayStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugViewGameplayStatics>();
	}
};
static_assert(alignof(UDebugViewGameplayStatics) == 0x000008, "Wrong alignment on UDebugViewGameplayStatics");
static_assert(sizeof(UDebugViewGameplayStatics) == 0x000028, "Wrong size on UDebugViewGameplayStatics");

// Class UnionSystem.UnionDebugMayaCameraController
// 0x0078 (0x08D0 - 0x0858)
class AUnionDebugMayaCameraController final : public APlayerController
{
public:
	uint8                                         Pad_858[0x78];                                     // 0x0858(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionDebugMayaCameraController">();
	}
	static class AUnionDebugMayaCameraController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnionDebugMayaCameraController>();
	}
};
static_assert(alignof(AUnionDebugMayaCameraController) == 0x000008, "Wrong alignment on AUnionDebugMayaCameraController");
static_assert(sizeof(AUnionDebugMayaCameraController) == 0x0008D0, "Wrong size on AUnionDebugMayaCameraController");

// Class UnionSystem.UnionDeviceSelector
// 0x0068 (0x0090 - 0x0028)
class UUnionDeviceSelector final : public UObject
{
public:
	uint8                                         Pad_28[0x68];                                      // 0x0028(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionDeviceSelector">();
	}
	static class UUnionDeviceSelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionDeviceSelector>();
	}
};
static_assert(alignof(UUnionDeviceSelector) == 0x000008, "Wrong alignment on UUnionDeviceSelector");
static_assert(sizeof(UUnionDeviceSelector) == 0x000090, "Wrong size on UUnionDeviceSelector");

// Class UnionSystem.UnionErrorDebugMenu
// 0x0010 (0x0038 - 0x0028)
class UUnionErrorDebugMenu final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionErrorDebugMenu">();
	}
	static class UUnionErrorDebugMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionErrorDebugMenu>();
	}
};
static_assert(alignof(UUnionErrorDebugMenu) == 0x000008, "Wrong alignment on UUnionErrorDebugMenu");
static_assert(sizeof(UUnionErrorDebugMenu) == 0x000038, "Wrong size on UUnionErrorDebugMenu");

// Class UnionSystem.UnionErrorManager
// 0x00A0 (0x00D0 - 0x0030)
class UUnionErrorManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNetworkLastError*                      m_NetworkLastError;                                // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionErrorDebugMenu*                   m_ErrorDebugMenu;                                  // 0x0040(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionErrorViewer*                      m_ErrorViewer;                                     // 0x0048(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x80];                                      // 0x0050(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetShowTargetErrorWindowParam();

	bool IsShowAppRestartErrorWindow() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionErrorManager">();
	}
	static class UUnionErrorManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionErrorManager>();
	}
};
static_assert(alignof(UUnionErrorManager) == 0x000008, "Wrong alignment on UUnionErrorManager");
static_assert(sizeof(UUnionErrorManager) == 0x0000D0, "Wrong size on UUnionErrorManager");
static_assert(offsetof(UUnionErrorManager, m_NetworkLastError) == 0x000038, "Member 'UUnionErrorManager::m_NetworkLastError' has a wrong offset!");
static_assert(offsetof(UUnionErrorManager, m_ErrorDebugMenu) == 0x000040, "Member 'UUnionErrorManager::m_ErrorDebugMenu' has a wrong offset!");
static_assert(offsetof(UUnionErrorManager, m_ErrorViewer) == 0x000048, "Member 'UUnionErrorManager::m_ErrorViewer' has a wrong offset!");

// Class UnionSystem.UnionErrorUtils
// 0x0000 (0x0028 - 0x0028)
class UUnionErrorUtils final : public UBlueprintFunctionLibrary
{
public:
	static bool CheckReturnTitleError(EResponseCodeAbstract ResponseCodeAbstract);
	static void DbgSetNetworkErrorWithString(EOnlineErrorId ErrorID, const class FString& BodyStr);
	static void DbgSetNetworkErrorWithText(EOnlineErrorId ErrorID, const class FText& BodyText);
	static EErrorLevel GetErrorLevel();
	static class FText GetOnlineErrorBodyText(EOnlineErrorId ErrorID, int32 AppendId, int32 NetworkDelayLevel);
	static class FText GetOnlineErrorReturnMenuText(EOnlineErrorId ErrorID, int32 AppendId);
	static const class FText GetOnlineErrorTitleText(EOnlineErrorId ErrorID);
	static class FText GetServerErrorBodyText(EResponseCodeAbstract ResponseCode, int32 AppendId, int32 NetworkDelayLevel);
	static class FText GetServerErrorReturnMenuText(EResponseCodeAbstract ResponseCode, int32 AppendId);
	static const class FText GetServerErrorTitleText(EResponseCodeAbstract ResponseCode);
	static bool HasRaceFatalError();
	static bool IsAddFairPlayPoints();
	static bool IsDisplayedErrorViewer();
	static bool IsNeedReLogin();
	static void ResetReLoginFlag();
	static void SetNetworkError(EOnlineErrorId ErrorID, const int32& AppendId);
	static void SetNetworkErrorWithTopMenuText(EOnlineErrorId ErrorID);
	static void SetSeverError(EResponseCodeAbstract ResponseCode, int32 Code);
	static void SetSeverErrorWithTopMenuText(EResponseCodeAbstract ResponseCode, int32 Code);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionErrorUtils">();
	}
	static class UUnionErrorUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionErrorUtils>();
	}
};
static_assert(alignof(UUnionErrorUtils) == 0x000008, "Wrong alignment on UUnionErrorUtils");
static_assert(sizeof(UUnionErrorUtils) == 0x000028, "Wrong size on UUnionErrorUtils");

// Class UnionSystem.UnionErrorViewer
// 0x0000 (0x0028 - 0x0028)
class UUnionErrorViewer : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionErrorViewer">();
	}
	static class UUnionErrorViewer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionErrorViewer>();
	}
};
static_assert(alignof(UUnionErrorViewer) == 0x000008, "Wrong alignment on UUnionErrorViewer");
static_assert(sizeof(UUnionErrorViewer) == 0x000028, "Wrong size on UUnionErrorViewer");

// Class UnionSystem.UnionExecuteConsoleCommandBP
// 0x0000 (0x0028 - 0x0028)
class UUnionExecuteConsoleCommandBP final : public UBlueprintFunctionLibrary
{
public:
	static void AnimationBudgetEnabled(const class UObject* WorldContextObject, const class FString& Value);
	static void DebugExecuteConsoleCommand(const class UObject* WorldContextObject, const class FString& Command);
	static bool IsEnableGlobalInvalidation();
	static void RestartLevel(const class UObject* WorldContextObject);
	static void SlateEnableGlobalInvalidation(const class UObject* WorldContextObject, const class FString& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionExecuteConsoleCommandBP">();
	}
	static class UUnionExecuteConsoleCommandBP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionExecuteConsoleCommandBP>();
	}
};
static_assert(alignof(UUnionExecuteConsoleCommandBP) == 0x000008, "Wrong alignment on UUnionExecuteConsoleCommandBP");
static_assert(sizeof(UUnionExecuteConsoleCommandBP) == 0x000028, "Wrong size on UUnionExecuteConsoleCommandBP");

// Class UnionSystem.UnionForceFeedbackManager
// 0x01A8 (0x01D0 - 0x0028)
class UUnionForceFeedbackManager final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UForceFeedbackEffect*                   PresetForceFeedbackEffects[0x2C];                  // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_198[0x38];                                     // 0x0198(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionForceFeedbackManager">();
	}
	static class UUnionForceFeedbackManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionForceFeedbackManager>();
	}
};
static_assert(alignof(UUnionForceFeedbackManager) == 0x000008, "Wrong alignment on UUnionForceFeedbackManager");
static_assert(sizeof(UUnionForceFeedbackManager) == 0x0001D0, "Wrong size on UUnionForceFeedbackManager");
static_assert(offsetof(UUnionForceFeedbackManager, PresetForceFeedbackEffects) == 0x000038, "Member 'UUnionForceFeedbackManager::PresetForceFeedbackEffects' has a wrong offset!");

// Class UnionSystem.UnionForceFeedbackLibrary
// 0x0000 (0x0028 - 0x0028)
class UUnionForceFeedbackLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool IsPlayingPresetForceFeedback(int32 PlayerIndex, EPresetForceFeedbackType ForceFeedbackType);
	static void PlayForceFeedback(int32 PlayerIndex, class UForceFeedbackEffect* ForceFeedbackEffect, bool bLooping, const class FName& Tag);
	static void PlayPresetForceFeedback(int32 PlayerIndex, EPresetForceFeedbackType ForceFeedbackType);
	static void PlayPresetForceFeedbackWithParam(int32 PlayerIndex, EPresetForceFeedbackType ForceFeedbackType, int32 GroupId, float PlayIgnoreTime);
	static void SetLevel(int32 PlayerIndex, EForceFeedbackLevel Level);
	static void StopAllForceFeedback(int32 PlayerIndex);
	static void StopForceFeedback(int32 PlayerIndex, class UForceFeedbackEffect* ForceFeedbackEffect);
	static void StopForceFeedbackByTag(int32 PlayerIndex, const class FName& Tag);
	static void StopPresetForceFeedback(int32 PlayerIndex, EPresetForceFeedbackType ForceFeedbackType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionForceFeedbackLibrary">();
	}
	static class UUnionForceFeedbackLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionForceFeedbackLibrary>();
	}
};
static_assert(alignof(UUnionForceFeedbackLibrary) == 0x000008, "Wrong alignment on UUnionForceFeedbackLibrary");
static_assert(sizeof(UUnionForceFeedbackLibrary) == 0x000028, "Wrong size on UUnionForceFeedbackLibrary");

// Class UnionSystem.UnionGameInstanceSubsystem
// 0x0220 (0x0250 - 0x0030)
class UUnionGameInstanceSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x220];                                     // 0x0030(0x0220)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsCastShadowDashPanel();
	bool IsCastShadowItemBox();
	bool IsCastShadowRing();
	void LoadBootCuesheet();
	void LoadCommonVoice();
	void SetUseCustomCulling(bool IsUse);
	void UnloadCommonVoice();

	bool IsUseCustomCulling() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionGameInstanceSubsystem">();
	}
	static class UUnionGameInstanceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionGameInstanceSubsystem>();
	}
};
static_assert(alignof(UUnionGameInstanceSubsystem) == 0x000008, "Wrong alignment on UUnionGameInstanceSubsystem");
static_assert(sizeof(UUnionGameInstanceSubsystem) == 0x000250, "Wrong size on UUnionGameInstanceSubsystem");

// Class UnionSystem.UnionGraph
// 0x0010 (0x0038 - 0x0028)
class UUnionGraph final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool Deserialize(const TArray<uint8>& Bytes);
	bool Dump(const class FString& Name_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionGraph">();
	}
	static class UUnionGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionGraph>();
	}
};
static_assert(alignof(UUnionGraph) == 0x000008, "Wrong alignment on UUnionGraph");
static_assert(sizeof(UUnionGraph) == 0x000038, "Wrong size on UUnionGraph");

// Class UnionSystem.InputModifierAbsHighPass
// 0x0008 (0x0030 - 0x0028)
class UInputModifierAbsHighPass final : public UInputModifier
{
public:
	float                                         Threshold;                                         // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputModifierAbsHighPass">();
	}
	static class UInputModifierAbsHighPass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputModifierAbsHighPass>();
	}
};
static_assert(alignof(UInputModifierAbsHighPass) == 0x000008, "Wrong alignment on UInputModifierAbsHighPass");
static_assert(sizeof(UInputModifierAbsHighPass) == 0x000030, "Wrong size on UInputModifierAbsHighPass");
static_assert(offsetof(UInputModifierAbsHighPass, Threshold) == 0x000028, "Member 'UInputModifierAbsHighPass::Threshold' has a wrong offset!");

// Class UnionSystem.InputModifierAxisToBool
// 0x0008 (0x0030 - 0x0028)
class UInputModifierAxisToBool final : public UInputModifier
{
public:
	float                                         Min;                                               // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputModifierAxisToBool">();
	}
	static class UInputModifierAxisToBool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputModifierAxisToBool>();
	}
};
static_assert(alignof(UInputModifierAxisToBool) == 0x000008, "Wrong alignment on UInputModifierAxisToBool");
static_assert(sizeof(UInputModifierAxisToBool) == 0x000030, "Wrong size on UInputModifierAxisToBool");
static_assert(offsetof(UInputModifierAxisToBool, Min) == 0x000028, "Member 'UInputModifierAxisToBool::Min' has a wrong offset!");
static_assert(offsetof(UInputModifierAxisToBool, Max) == 0x00002C, "Member 'UInputModifierAxisToBool::Max' has a wrong offset!");

// Class UnionSystem.UnionManaPlayer
// 0x00F0 (0x0118 - 0x0028)
class UUnionManaPlayer final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnEndReached;                                      // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMovieClosed;                                     // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& OpenedUrl)> OnMovieOpened;                    // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& FailedUrl)> OnMovieOpenFailed;                // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPlaybackResumed;                                 // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPlaybackSuspended;                               // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSeekCompleted;                                   // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTracksChanged;                                   // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FText Subtitle)> OnSubtitleChanged;                          // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FManaEventPointInfo& EventPointInfo)> OnEventPoint;   // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UManaPlayer*                            _ManaPlayer;                                       // 0x00D0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UManaMovie*                             _ManaMovie;                                        // 0x00D8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UManaTexture*                           _ManaTexture;                                      // 0x00E0(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     _Material;                                         // 0x00E8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAtomCue*                          _Cue;                                              // 0x00F8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x18];                                     // 0x0100(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Close();
	bool Create(class UMaterialInterface* MaterialForPrime, class UMaterialInterface* MaterialForVp9, class UManaTexture* ManaTexture);
	bool DisableTrack(EManaPlayerTrack TrackType);
	class UAtomComponent* GetAtomComponent();
	class UMaterialInterface* GetMaterial();
	EManaSubtitlesEncoding GetSubtitleTrackEncoding(int32 TrackIndex);
	class UManaTexture* GetTexture();
	class UAtomComponent* GetTimeSyncedSource();
	float GetVolume(EManaPlayerTrack TrackType);
	void HandleManaPlayerEventPoint(const struct FManaEventPointInfo& EventPointInfo);
	void HandleManaPlayerMovieClosed();
	void HandleManaPlayerMovieOpened(const class FString& OpenedUrl);
	void HandleManaPlayerMovieOpenFailed(const class FString& FailedUrl);
	void HandleManaPlayerPlaybackResumed();
	void HandleManaPlayerPlaybackSuspended();
	void HandleManaPlayerSeekCompleted();
	void HandleManaPlayerSubtitleChanged(const class FText& Subtitle);
	void HandleManaPlayerTracksChanged();
	bool Pause();
	bool Play();
	void PlayAndSeek();
	bool Reopen();
	bool Rewind();
	bool Seek(const struct FTimespan& Time);
	bool SelectTrack(EManaPlayerTrack TrackType, int32 TrackIndex);
	bool SetLooping(bool Looping);
	bool SetMovie(class FName Name_0);
	bool SetRate(float Rate);
	void SetTexture(class UManaTexture* InManaTexture);
	void SetTimeSyncedSource(class UAtomComponent* SyncedSource);
	bool SetTrackFormat(EManaPlayerTrack TrackType, int32 TrackIndex, int32 FormatIndex);
	bool SetVolume(float Volume, EManaPlayerTrack TrackType);

	struct FTimespan GetDuration() const;
	int32 GetFrames() const;
	int32 GetMovieFrames() const;
	class UManaMovie* GetMovieSource() const;
	struct FTimespan GetMovieTime() const;
	int32 GetNumTrackFormats(EManaPlayerTrack TrackType, int32 TrackIndex) const;
	int32 GetNumTracks(EManaPlayerTrack TrackType) const;
	float GetRate() const;
	int32 GetSelectedTrack(EManaPlayerTrack TrackType) const;
	EManaComponentStatus GetStatus() const;
	struct FTimespan GetTime() const;
	class FText GetTrackDisplayName(EManaPlayerTrack TrackType, int32 TrackIndex) const;
	int32 GetTrackFormat(EManaPlayerTrack TrackType, int32 TrackIndex) const;
	class FString GetTrackLanguage(EManaPlayerTrack TrackType, int32 TrackIndex) const;
	bool HasError() const;
	bool IsClosed() const;
	bool IsLooping() const;
	bool IsPaused() const;
	bool IsPlaying() const;
	bool IsPreparing() const;
	bool IsReady() const;
	bool IsSeeking() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionManaPlayer">();
	}
	static class UUnionManaPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionManaPlayer>();
	}
};
static_assert(alignof(UUnionManaPlayer) == 0x000008, "Wrong alignment on UUnionManaPlayer");
static_assert(sizeof(UUnionManaPlayer) == 0x000118, "Wrong size on UUnionManaPlayer");
static_assert(offsetof(UUnionManaPlayer, OnEndReached) == 0x000030, "Member 'UUnionManaPlayer::OnEndReached' has a wrong offset!");
static_assert(offsetof(UUnionManaPlayer, OnMovieClosed) == 0x000040, "Member 'UUnionManaPlayer::OnMovieClosed' has a wrong offset!");
static_assert(offsetof(UUnionManaPlayer, OnMovieOpened) == 0x000050, "Member 'UUnionManaPlayer::OnMovieOpened' has a wrong offset!");
static_assert(offsetof(UUnionManaPlayer, OnMovieOpenFailed) == 0x000060, "Member 'UUnionManaPlayer::OnMovieOpenFailed' has a wrong offset!");
static_assert(offsetof(UUnionManaPlayer, OnPlaybackResumed) == 0x000070, "Member 'UUnionManaPlayer::OnPlaybackResumed' has a wrong offset!");
static_assert(offsetof(UUnionManaPlayer, OnPlaybackSuspended) == 0x000080, "Member 'UUnionManaPlayer::OnPlaybackSuspended' has a wrong offset!");
static_assert(offsetof(UUnionManaPlayer, OnSeekCompleted) == 0x000090, "Member 'UUnionManaPlayer::OnSeekCompleted' has a wrong offset!");
static_assert(offsetof(UUnionManaPlayer, OnTracksChanged) == 0x0000A0, "Member 'UUnionManaPlayer::OnTracksChanged' has a wrong offset!");
static_assert(offsetof(UUnionManaPlayer, OnSubtitleChanged) == 0x0000B0, "Member 'UUnionManaPlayer::OnSubtitleChanged' has a wrong offset!");
static_assert(offsetof(UUnionManaPlayer, OnEventPoint) == 0x0000C0, "Member 'UUnionManaPlayer::OnEventPoint' has a wrong offset!");
static_assert(offsetof(UUnionManaPlayer, _ManaPlayer) == 0x0000D0, "Member 'UUnionManaPlayer::_ManaPlayer' has a wrong offset!");
static_assert(offsetof(UUnionManaPlayer, _ManaMovie) == 0x0000D8, "Member 'UUnionManaPlayer::_ManaMovie' has a wrong offset!");
static_assert(offsetof(UUnionManaPlayer, _ManaTexture) == 0x0000E0, "Member 'UUnionManaPlayer::_ManaTexture' has a wrong offset!");
static_assert(offsetof(UUnionManaPlayer, _Material) == 0x0000E8, "Member 'UUnionManaPlayer::_Material' has a wrong offset!");
static_assert(offsetof(UUnionManaPlayer, _Cue) == 0x0000F8, "Member 'UUnionManaPlayer::_Cue' has a wrong offset!");

// Class UnionSystem.UnionNetRequestTimeManager
// 0x0060 (0x0090 - 0x0030)
class UUnionNetRequestTimeManager final : public UGameInstanceSubsystem
{
public:
	TMap<class FString, struct FDateTime>         LastRequestTime;                                   // 0x0030(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearAll();
	void ClearCompensationRequestTime();
	bool IsCommunicationTime(const class FString& ApiName);
	bool IsCommunicationTimeCompensation();
	bool IsCommunicationTimeForError(const class FString& ApiName);
	void SetResponseTime(const class FString& ApiName, bool bSuccess);
	void SetResponseTimeCompensation(bool bSuccess);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionNetRequestTimeManager">();
	}
	static class UUnionNetRequestTimeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionNetRequestTimeManager>();
	}
};
static_assert(alignof(UUnionNetRequestTimeManager) == 0x000008, "Wrong alignment on UUnionNetRequestTimeManager");
static_assert(sizeof(UUnionNetRequestTimeManager) == 0x000090, "Wrong size on UUnionNetRequestTimeManager");
static_assert(offsetof(UUnionNetRequestTimeManager, LastRequestTime) == 0x000030, "Member 'UUnionNetRequestTimeManager::LastRequestTime' has a wrong offset!");

// Class UnionSystem.UnionNetUtils
// 0x0000 (0x0028 - 0x0028)
class UUnionNetUtils final : public UBlueprintFunctionLibrary
{
public:
	static bool CheckOnlineSettingsForLobby(const class UObject* WorldContextObject, int32 LocalUserNum, const struct FLobbyId& LobbyId, struct FLobbyDoesMatchOnlineSettings* OutDoesMatch);
	static bool CompareLobbyId(const struct FLobbyId& LobbyId, const struct FLobbyId& OtherLobbyId);
	static bool CompareUserId(const struct FUniqueNetIdRepl& UserId1, const struct FUniqueNetIdRepl& UserId2);
	static void ConvertLobbyIdToString(const struct FLobbyId& LobbyId, class FString* OutUserIdString);
	static void ConvertUserIdToString(const struct FUniqueNetIdRepl& UserId, class FString* OutUserIdString);
	static void CRM_PutConnectionError_Api(const class UObject* WorldContextObject, int32 ErrorNumber, int32 ErrorCode, const class FString& ErrorMessage, const class FString& ApiName, int32 Elapsed);
	static void CRM_PutConnectionError_Full(const class UObject* WorldContextObject, int32 ErrorNumber, int32 ErrorCode, const class FString& ErrorMessage, const class FString& OpponentUserId, const class FString& entryRaceId, int32 UserSlotId, int32 DisconnectionReason, const class FString& DisconnectionReasonInfo, const class FString& ApiName, int32 Elapsed);
	static void CRM_PutConnectionError_Minimum(const class UObject* WorldContextObject, int32 ErrorNumber, int32 ErrorCode, const class FString& ErrorMessage);
	static void Debug_Lobby_Create(const class UObject* WorldContextObject, class ULobbyContextBase* LobbyContext, bool bLocked, bool bPublic, bool bHostMigration, const class FString& Password, const TDelegate<void(bool bSuccessful, const struct FLobbyOperationResult& Result)>& OnComplete);
	static void Debug_Lobby_Exit(const class UObject* WorldContextObject, class ULobbyContextBase* LobbyContext, const TDelegate<void(bool bSuccessful, const struct FLobbyOperationResult& Result)>& OnComplete);
	static void Debug_Lobby_Join(const class UObject* WorldContextObject, class ULobbyContextBase* LobbyContext, class ULobbyJoinInfo* JoinInfo, const TDelegate<void(bool bSuccessful, const struct FLobbyOperationResult& Result)>& OnComplete);
	static void Debug_Lobby_JoinByLobbyId(const class UObject* WorldContextObject, class ULobbyContextBase* LobbyContext, const struct FLobbyId& LobbyId, const TDelegate<void(bool bSuccessful, const struct FLobbyOperationResult& Result)>& OnComplete);
	static void Debug_Lobby_Seach(const class UObject* WorldContextObject, class ULobbyContextBase* LobbyContext, const TDelegate<void(bool bSuccessful, const struct FSearchLobbyResult& Result)>& OnComplete);
	static void Debug_Lobby_SyncInitMemberAttributes(const class UObject* WorldContextObject, class ULobbyContextBase* LobbyContext, const TDelegate<void(bool bSuccessful, const struct FLobbyOperationResult& Result)>& OnComplete);
	static void Debug_P2P_DelConnectMemberSquad(const class UObject* WorldContextObject, const class ULobbyMemberContextBase* MemberContext);
	static void Debug_P2P_EndConnectSquadRequest(const class UObject* WorldContextObject, const class ULobbyContextBase* LobbyContext);
	static void Debug_P2P_StartConnect(const class UObject* WorldContextObject, bool bIsHost);
	static void Debug_P2P_StartConnectionP2P(const class UObject* WorldContextObject, const struct FLobbyId& LobbyId);
	static void Debug_P2P_StartConnectSquad(const class UObject* WorldContextObject);
	static void Debug_P2P_UpdateConnectMemberSquad(const class UObject* WorldContextObject, const class ULobbyContextBase* LobbyContext);
	static class FString GetComputerNameString();
	static class FString GetEOSRelayControlString(const class UObject* WorldContextObject);
	static class FString GetMatchSettingString(const class UObject* WorldContextObject);
	static const class FString GetNetworkSettingName();
	static class FString GetServerStagingName();
	static int64 GetTickMilliseconds();
	static bool IsValidLobbyId(const struct FLobbyId& LobbyId);
	static void MakeLobbyOperationResultByLobbyErrorType(ELobbyErrorType LobbyErrorType, struct FLobbyOperationResult* OutResult);
	static void SearchLobbyByHostUserId(const class UObject* WorldContextObject, int32 LocalUserNum, const struct FUniqueNetIdRepl& HostProductUserId, TDelegate<void(bool bSuccessful, const struct FSearchLobbyResult& Result)> OnComplete);
	static ELobbyErrorType ToLobbyErrorType(const struct FOnlineErrorBP& Error);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionNetUtils">();
	}
	static class UUnionNetUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionNetUtils>();
	}
};
static_assert(alignof(UUnionNetUtils) == 0x000008, "Wrong alignment on UUnionNetUtils");
static_assert(sizeof(UUnionNetUtils) == 0x000028, "Wrong size on UUnionNetUtils");

// Class UnionSystem.NetworkLastError
// 0x0188 (0x01B0 - 0x0028)
class UNetworkLastError final : public UObject
{
public:
	uint8                                         Pad_28[0x188];                                     // 0x0028(0x0188)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetworkLastError">();
	}
	static class UNetworkLastError* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNetworkLastError>();
	}
};
static_assert(alignof(UNetworkLastError) == 0x000008, "Wrong alignment on UNetworkLastError");
static_assert(sizeof(UNetworkLastError) == 0x0001B0, "Wrong size on UNetworkLastError");

// Class UnionSystem.UnionNiagaraComponents
// 0x0000 (0x0780 - 0x0780)
class UUnionNiagaraComponents final : public UNiagaraComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionNiagaraComponents">();
	}
	static class UUnionNiagaraComponents* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionNiagaraComponents>();
	}
};
static_assert(alignof(UUnionNiagaraComponents) == 0x000010, "Wrong alignment on UUnionNiagaraComponents");
static_assert(sizeof(UUnionNiagaraComponents) == 0x000780, "Wrong size on UUnionNiagaraComponents");

// Class UnionSystem.UnionPlatformDebugMenu
// 0x0080 (0x00A8 - 0x0028)
class UUnionPlatformDebugMenu final : public UObject
{
public:
	uint8                                         Pad_28[0x80];                                      // 0x0028(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGetAChievementEnd(float InValue);
	void OnPlatformStoreClose(EUnionOpenStoreResultType InType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionPlatformDebugMenu">();
	}
	static class UUnionPlatformDebugMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionPlatformDebugMenu>();
	}
};
static_assert(alignof(UUnionPlatformDebugMenu) == 0x000008, "Wrong alignment on UUnionPlatformDebugMenu");
static_assert(sizeof(UUnionPlatformDebugMenu) == 0x0000A8, "Wrong size on UUnionPlatformDebugMenu");

// Class UnionSystem.UnionPlatformManager
// 0x0180 (0x01B0 - 0x0030)
class UUnionPlatformManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionPlatformDebugMenu*                m_DebugMenu;                                       // 0x0058(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionDeviceSelector*                   m_XboxDeviceSelector;                              // 0x0060(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUnionPlatformSoftwareKeyboardBase*     m_SoftwareKeyboard;                                // 0x0068(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x118];                                     // 0x0070(0x0118)(Fixing Size After Last Property [ Dumper-7 ])
	class UUnionContentManager*                   m_ContentManager;                                  // 0x0188(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_190[0x20];                                     // 0x0190(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlatformEvent(const struct FUnionPlatformEventInfo& EventInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionPlatformManager">();
	}
	static class UUnionPlatformManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionPlatformManager>();
	}
};
static_assert(alignof(UUnionPlatformManager) == 0x000008, "Wrong alignment on UUnionPlatformManager");
static_assert(sizeof(UUnionPlatformManager) == 0x0001B0, "Wrong size on UUnionPlatformManager");
static_assert(offsetof(UUnionPlatformManager, m_DebugMenu) == 0x000058, "Member 'UUnionPlatformManager::m_DebugMenu' has a wrong offset!");
static_assert(offsetof(UUnionPlatformManager, m_XboxDeviceSelector) == 0x000060, "Member 'UUnionPlatformManager::m_XboxDeviceSelector' has a wrong offset!");
static_assert(offsetof(UUnionPlatformManager, m_SoftwareKeyboard) == 0x000068, "Member 'UUnionPlatformManager::m_SoftwareKeyboard' has a wrong offset!");
static_assert(offsetof(UUnionPlatformManager, m_ContentManager) == 0x000188, "Member 'UUnionPlatformManager::m_ContentManager' has a wrong offset!");

// Class UnionSystem.UnionPlatformSignInBase
// 0x0008 (0x0030 - 0x0028)
class UUnionPlatformSignInBase : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionPlatformSignInBase">();
	}
	static class UUnionPlatformSignInBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionPlatformSignInBase>();
	}
};
static_assert(alignof(UUnionPlatformSignInBase) == 0x000008, "Wrong alignment on UUnionPlatformSignInBase");
static_assert(sizeof(UUnionPlatformSignInBase) == 0x000030, "Wrong size on UUnionPlatformSignInBase");

// Class UnionSystem.UnionPlatformSignInEpic
// 0x0080 (0x00B0 - 0x0030)
class UUnionPlatformSignInEpic final : public UUnionPlatformSignInBase
{
public:
	uint8                                         Pad_30[0x80];                                      // 0x0030(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionPlatformSignInEpic">();
	}
	static class UUnionPlatformSignInEpic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionPlatformSignInEpic>();
	}
};
static_assert(alignof(UUnionPlatformSignInEpic) == 0x000008, "Wrong alignment on UUnionPlatformSignInEpic");
static_assert(sizeof(UUnionPlatformSignInEpic) == 0x0000B0, "Wrong size on UUnionPlatformSignInEpic");

// Class UnionSystem.UnionPlatformSignInSteam
// 0x0080 (0x00B0 - 0x0030)
class UUnionPlatformSignInSteam final : public UUnionPlatformSignInBase
{
public:
	uint8                                         Pad_30[0x80];                                      // 0x0030(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionPlatformSignInSteam">();
	}
	static class UUnionPlatformSignInSteam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionPlatformSignInSteam>();
	}
};
static_assert(alignof(UUnionPlatformSignInSteam) == 0x000008, "Wrong alignment on UUnionPlatformSignInSteam");
static_assert(sizeof(UUnionPlatformSignInSteam) == 0x0000B0, "Wrong size on UUnionPlatformSignInSteam");

// Class UnionSystem.UnionPlatformSoftwareKeyboardBase
// 0x0008 (0x0030 - 0x0028)
class UUnionPlatformSoftwareKeyboardBase : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionPlatformSoftwareKeyboardBase">();
	}
	static class UUnionPlatformSoftwareKeyboardBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionPlatformSoftwareKeyboardBase>();
	}
};
static_assert(alignof(UUnionPlatformSoftwareKeyboardBase) == 0x000008, "Wrong alignment on UUnionPlatformSoftwareKeyboardBase");
static_assert(sizeof(UUnionPlatformSoftwareKeyboardBase) == 0x000030, "Wrong size on UUnionPlatformSoftwareKeyboardBase");

// Class UnionSystem.UnionPlatformSoftwareKeyboardSteam
// 0x00E0 (0x0110 - 0x0030)
class UUnionPlatformSoftwareKeyboardSteam final : public UUnionPlatformSoftwareKeyboardBase
{
public:
	uint8                                         Pad_30[0xE0];                                      // 0x0030(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionPlatformSoftwareKeyboardSteam">();
	}
	static class UUnionPlatformSoftwareKeyboardSteam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionPlatformSoftwareKeyboardSteam>();
	}
};
static_assert(alignof(UUnionPlatformSoftwareKeyboardSteam) == 0x000008, "Wrong alignment on UUnionPlatformSoftwareKeyboardSteam");
static_assert(sizeof(UUnionPlatformSoftwareKeyboardSteam) == 0x000110, "Wrong size on UUnionPlatformSoftwareKeyboardSteam");

// Class UnionSystem.UnionPlatformUtils
// 0x0000 (0x0028 - 0x0028)
class UUnionPlatformUtils final : public UBlueprintFunctionLibrary
{
public:
	static struct FKey GetGamepadAcceptKey();
	static struct FKey GetGamepadBackKey();
	static class FString GetGamerTag();
	static ENXPrivilegeType GetNXOnlinePrivilege();
	static EUnionPlatformOnlineRestrictionType GetOnlinePlayRestrictionType();
	static class FString GetPresenceId(EUnionPresenceType PresenceType);
	static const class FText GetPresenceText(EUnionPresenceType PresenceType);
	static bool GetPresenceTexts(EUnionPresenceType PresenceType, TArray<class FString>* OutList);
	static bool IsHighEndPlatform();
	static bool IsInvertGamepadAcceptAndBackKey();
	static bool IsNXOnlinePrivilege();
	static bool IsOnlinePrivilegeOn();
	static bool IsPremiumResolveUiCanceledByUser();
	static bool IsProhibitedOnlinPlayByParentalControls();
	static bool IsStartedStreamingInstall();
	static bool IsUserHasNetworkRankingPrivilege();
	static bool IsUserHasPrivilege(EUnionPlatformPrivilegeType UnionPlatformPrivilegeType);
	static void RequestSoftwareKeyboard(const struct FSoftwareKeyBoardBootParam& PootParam);
	static void SetNXOnlinePrivilege(ENXPrivilegeType NXPrivilegeType);
	static void SetShareAllOff();
	static void SetShareAllOn();
	static void StartPresence(const EUnionPresenceType& PresenceType);
	static void StartRemotePlayExclusionZone();
	static void StopRemotePlayExclusionZone();
	static void WriteAchievement(const class FString& AchievementName, const float& NowValue, const float& MaxValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionPlatformUtils">();
	}
	static class UUnionPlatformUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionPlatformUtils>();
	}
};
static_assert(alignof(UUnionPlatformUtils) == 0x000008, "Wrong alignment on UUnionPlatformUtils");
static_assert(sizeof(UUnionPlatformUtils) == 0x000028, "Wrong size on UUnionPlatformUtils");

// Class UnionSystem.UnionPrimitiveComponent
// 0x0000 (0x0520 - 0x0520)
class UUnionPrimitiveComponent final : public UPrimitiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionPrimitiveComponent">();
	}
	static class UUnionPrimitiveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionPrimitiveComponent>();
	}
};
static_assert(alignof(UUnionPrimitiveComponent) == 0x000010, "Wrong alignment on UUnionPrimitiveComponent");
static_assert(sizeof(UUnionPrimitiveComponent) == 0x000520, "Wrong size on UUnionPrimitiveComponent");

// Class UnionSystem.UnionProceduralMeshComponent
// 0x0000 (0x05D0 - 0x05D0)
class UUnionProceduralMeshComponent : public UProceduralMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionProceduralMeshComponent">();
	}
	static class UUnionProceduralMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionProceduralMeshComponent>();
	}
};
static_assert(alignof(UUnionProceduralMeshComponent) == 0x000010, "Wrong alignment on UUnionProceduralMeshComponent");
static_assert(sizeof(UUnionProceduralMeshComponent) == 0x0005D0, "Wrong size on UUnionProceduralMeshComponent");

// Class UnionSystem.UnionRaceBGMManager
// 0x0060 (0x0088 - 0x0028)
class UUnionRaceBGMManager final : public UObject
{
public:
	uint8                                         Pad_28[0x60];                                      // 0x0028(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRaceBGMManager">();
	}
	static class UUnionRaceBGMManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRaceBGMManager>();
	}
};
static_assert(alignof(UUnionRaceBGMManager) == 0x000008, "Wrong alignment on UUnionRaceBGMManager");
static_assert(sizeof(UUnionRaceBGMManager) == 0x000088, "Wrong size on UUnionRaceBGMManager");

// Class UnionSystem.UnionRaceBGMLibrary
// 0x0000 (0x0028 - 0x0028)
class UUnionRaceBGMLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool ChangeFinalLap(const class FString& Label);
	static bool ChangeFinalLapForce(const class FString& Label, const class FString& Label2);
	static bool ChangeFinalLapLast();
	static bool ChangeFinalLapWhenTimeTrial(const class FString& Label);
	static bool ChangeFirstLapWhenAnotherTimeTrial();
	static bool ChangeGateDecide(const class FString& Label, bool bRandomCourse);
	static bool ChangeGateSelect();
	static bool ChangeReturnFromDomainSubInFinalLap();
	static bool ChangeReturnFromDomainSubInFirstLap();
	static bool ChangeReturnFromDomainSubInSecondLap();
	static bool ChangeSecondLap(bool bRandomCourse);
	static bool ChangeSecondLapForce(const class FString& Label, const class FString& Label2);
	static bool ChangeTransitionToDomainSubInFinalLap();
	static bool ChangeTransitionToDomainSubInFirstLap();
	static bool ChangeTransitionToDomainSubInSecondLap();
	static bool PlayFirstLap(const class FString& Label, const class FString& Label2);
	static bool PlayGoalWithParam(const struct FAppRaceEventGoalData& InGoalParam);
	static bool PlayIntro(const class FString& Label);
	static bool PlayOnCourseEditor(const class FString& Label, bool bFinalLap);
	static bool PlayPreFirstLapWhenAnotherTimeTrial(const class FString& Label);
	static bool RaceBGMFinished();
	static bool SetAisacGateDistanceFirstLapToSecondLap(float Value);
	static bool SetAisacGateDistanceSecondLapToFinalLap(float Value);
	static void SetGoalStageSelectorLabel(const class FString& InGoalStageSelectorLabel);
	static bool SetVolume(float Value);
	static bool Stop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRaceBGMLibrary">();
	}
	static class UUnionRaceBGMLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRaceBGMLibrary>();
	}
};
static_assert(alignof(UUnionRaceBGMLibrary) == 0x000008, "Wrong alignment on UUnionRaceBGMLibrary");
static_assert(sizeof(UUnionRaceBGMLibrary) == 0x000028, "Wrong size on UUnionRaceBGMLibrary");

// Class UnionSystem.UnionRenderTargetUtility
// 0x0000 (0x0028 - 0x0028)
class UUnionRenderTargetUtility final : public UBlueprintFunctionLibrary
{
public:
	static class UTexture2D* CompressTexture2D(class UTexture2D* Texture, const EUnionTextureCompressType Mode);
	static class UTexture2D* ConvertAndCompressRenderTargetToTexture(class UTextureRenderTarget2D* RenderTarget, EUnionTextureCompressType CompressType, int32 Partitions, int32 Uber);
	static class UObject* LoadVfxAsset(const class FString& Path);
	static void ReflectionFocus(class UCineCameraComponent* Cine, class USceneCaptureComponent2D* Scene, float FOVScale);
	static bool SetPostProcessToActiveCamera(class UWorld* World, class FName MaterialName);
	static void UpdateRenderTargetSizeForRuntime(class UTextureRenderTarget2D* RenderTarget, const class APlayerController* PlayerController, const float ReductionScaleX, const float ReductionScaleY);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRenderTargetUtility">();
	}
	static class UUnionRenderTargetUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionRenderTargetUtility>();
	}
};
static_assert(alignof(UUnionRenderTargetUtility) == 0x000008, "Wrong alignment on UUnionRenderTargetUtility");
static_assert(sizeof(UUnionRenderTargetUtility) == 0x000028, "Wrong size on UUnionRenderTargetUtility");

// Class UnionSystem.UnionRingGateCameraInterface
// 0x0000 (0x0000 - 0x0000)
class IUnionRingGateCameraInterface final
{
public:
	void AddRingGateHiddenActor(class AActor* Actor);
	void AddRingGateShowActor(class AActor* Actor);
	void RemoveRingGateHiddenActor(class AActor* Actor);
	void RemoveRingGateShowActor(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionRingGateCameraInterface">();
	}
	static class IUnionRingGateCameraInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUnionRingGateCameraInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IUnionRingGateCameraInterface) == 0x000001, "Wrong alignment on IUnionRingGateCameraInterface");
static_assert(sizeof(IUnionRingGateCameraInterface) == 0x000001, "Wrong size on IUnionRingGateCameraInterface");

// Class UnionSystem.UnionSaveDataTransferBase
// 0x0050 (0x02E0 - 0x0290)
class AUnionSaveDataTransferBase final : public AActor
{
public:
	EResultSearchTrialSaveData                    m_ResultSearch;                                    // 0x0290(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EResultTransferTrialSaveData                  m_ResultTransfer;                                  // 0x0291(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_292[0x4E];                                     // 0x0292(0x004E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EResultSearchTrialSaveData GetResultSearchTrialVersionSaveData();
	EResultTransferTrialSaveData GetResultTransferTrialVersionSaveData();
	void SearchTrialVersionSaveData();
	void TransferTrialVersionSaveData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionSaveDataTransferBase">();
	}
	static class AUnionSaveDataTransferBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnionSaveDataTransferBase>();
	}
};
static_assert(alignof(AUnionSaveDataTransferBase) == 0x000008, "Wrong alignment on AUnionSaveDataTransferBase");
static_assert(sizeof(AUnionSaveDataTransferBase) == 0x0002E0, "Wrong size on AUnionSaveDataTransferBase");
static_assert(offsetof(AUnionSaveDataTransferBase, m_ResultSearch) == 0x000290, "Member 'AUnionSaveDataTransferBase::m_ResultSearch' has a wrong offset!");
static_assert(offsetof(AUnionSaveDataTransferBase, m_ResultTransfer) == 0x000291, "Member 'AUnionSaveDataTransferBase::m_ResultTransfer' has a wrong offset!");

// Class UnionSystem.UnionSceneComponent
// 0x0060 (0x0290 - 0x0230)
class UUnionSceneComponent : public USceneComponent
{
public:
	uint8                                         bAutoManageAttachment : 1;                         // 0x0230(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_231[0x3];                                      // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class USceneComponent>         AutoAttachParent;                                  // 0x0234(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AutoAttachSocketName;                              // 0x023C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               AutoAttachLocationRule;                            // 0x0244(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               AutoAttachRotationRule;                            // 0x0245(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               AutoAttachScaleRule;                               // 0x0246(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_247[0x49];                                     // 0x0247(0x0049)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionSceneComponent">();
	}
	static class UUnionSceneComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionSceneComponent>();
	}
};
static_assert(alignof(UUnionSceneComponent) == 0x000010, "Wrong alignment on UUnionSceneComponent");
static_assert(sizeof(UUnionSceneComponent) == 0x000290, "Wrong size on UUnionSceneComponent");
static_assert(offsetof(UUnionSceneComponent, AutoAttachParent) == 0x000234, "Member 'UUnionSceneComponent::AutoAttachParent' has a wrong offset!");
static_assert(offsetof(UUnionSceneComponent, AutoAttachSocketName) == 0x00023C, "Member 'UUnionSceneComponent::AutoAttachSocketName' has a wrong offset!");
static_assert(offsetof(UUnionSceneComponent, AutoAttachLocationRule) == 0x000244, "Member 'UUnionSceneComponent::AutoAttachLocationRule' has a wrong offset!");
static_assert(offsetof(UUnionSceneComponent, AutoAttachRotationRule) == 0x000245, "Member 'UUnionSceneComponent::AutoAttachRotationRule' has a wrong offset!");
static_assert(offsetof(UUnionSceneComponent, AutoAttachScaleRule) == 0x000246, "Member 'UUnionSceneComponent::AutoAttachScaleRule' has a wrong offset!");

// Class UnionSystem.UnionSettings
// 0x0248 (0x0280 - 0x0038)
class UUnionSettings final : public UDeveloperSettings
{
public:
	struct FUnionQualitySettings                  QualitySettings;                                   // 0x0038(0x0068)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	EViewResolution                               TravelRingResolution;                              // 0x00A0(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUnionTravelRingSettings               TravelRingSettings[0x3];                           // 0x00A4(0x0020)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	EShortcutViewScale                            ShortcutRingViewScale;                             // 0x0104(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_105[0x3];                                      // 0x0105(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMachineSettings                       MachineSettings;                                   // 0x0108(0x00B4)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FUnionCastShadowSettings               CastShadowSettings[0x3];                           // 0x01BC(0x0003)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C5[0x3];                                      // 0x01C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUnionRaceCarSettings                  RaceCarSettings;                                   // 0x01C8(0x000C)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D4[0x4];                                      // 0x01D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHoldItemSettings                      HoldItemSettings;                                  // 0x01D8(0x0060)(Edit, Config, NativeAccessSpecifierPublic)
	struct FMenuSettings                          MenuSettings;                                      // 0x0238(0x0008)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FMatchingLobbySettings                 MatchingLobbySettings;                             // 0x0240(0x000C)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FIntPoint                              ScreenResolutionsEditor;                           // 0x024C(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_254[0x2C];                                     // 0x0254(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEnableBlur(bool Enable);
	void SetMinLoDBias(int32 Bias);
	void SetRenderingScale(float Scale);

	float CalcScreenPercentage() const;
	const struct FMachinePostProcessSettings GetCurrentMachinePostProcessSettings() const;
	const struct FUnionCastShadowSettings GetCurrentUnionCastShadowSettings() const;
	bool GetDynamicShadowEnable() const;
	bool GetGFurEnable() const;
	const struct FHoldItemQualitySettings GetHoldItemSettingsNonPC() const;
	const struct FHoldItemQualitySettings GetHoldItemSettingsPC() const;
	int32 GetLobbyMeshLOD() const;
	const struct FMachineQualitySettings GetMachineQualitySettingsNonPC() const;
	const struct FMachineQualitySettings GetMachineQualitySettingsPC() const;
	int32 GetMenuMinLoD() const;
	int32 GetMinLoDNonPC() const;
	int32 GetMinLoDPC() const;
	int32 GetQualityIndex() const;
	bool IsCastShadowDashPanel() const;
	bool IsCastShadowItemBox() const;
	bool IsCastShadowRing() const;
	bool IsEnableFlowingWaterPP() const;
	bool IsEnableHiSpeedPP() const;
	bool IsEnableRadialBlurPP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionSettings">();
	}
	static class UUnionSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionSettings>();
	}
};
static_assert(alignof(UUnionSettings) == 0x000008, "Wrong alignment on UUnionSettings");
static_assert(sizeof(UUnionSettings) == 0x000280, "Wrong size on UUnionSettings");
static_assert(offsetof(UUnionSettings, QualitySettings) == 0x000038, "Member 'UUnionSettings::QualitySettings' has a wrong offset!");
static_assert(offsetof(UUnionSettings, TravelRingResolution) == 0x0000A0, "Member 'UUnionSettings::TravelRingResolution' has a wrong offset!");
static_assert(offsetof(UUnionSettings, TravelRingSettings) == 0x0000A4, "Member 'UUnionSettings::TravelRingSettings' has a wrong offset!");
static_assert(offsetof(UUnionSettings, ShortcutRingViewScale) == 0x000104, "Member 'UUnionSettings::ShortcutRingViewScale' has a wrong offset!");
static_assert(offsetof(UUnionSettings, MachineSettings) == 0x000108, "Member 'UUnionSettings::MachineSettings' has a wrong offset!");
static_assert(offsetof(UUnionSettings, CastShadowSettings) == 0x0001BC, "Member 'UUnionSettings::CastShadowSettings' has a wrong offset!");
static_assert(offsetof(UUnionSettings, RaceCarSettings) == 0x0001C8, "Member 'UUnionSettings::RaceCarSettings' has a wrong offset!");
static_assert(offsetof(UUnionSettings, HoldItemSettings) == 0x0001D8, "Member 'UUnionSettings::HoldItemSettings' has a wrong offset!");
static_assert(offsetof(UUnionSettings, MenuSettings) == 0x000238, "Member 'UUnionSettings::MenuSettings' has a wrong offset!");
static_assert(offsetof(UUnionSettings, MatchingLobbySettings) == 0x000240, "Member 'UUnionSettings::MatchingLobbySettings' has a wrong offset!");
static_assert(offsetof(UUnionSettings, ScreenResolutionsEditor) == 0x00024C, "Member 'UUnionSettings::ScreenResolutionsEditor' has a wrong offset!");

// Class UnionSystem.UnionSkeletalMeshActor
// 0x0000 (0x0310 - 0x0310)
class AUnionSkeletalMeshActor final : public ASkeletalMeshActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionSkeletalMeshActor">();
	}
	static class AUnionSkeletalMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnionSkeletalMeshActor>();
	}
};
static_assert(alignof(AUnionSkeletalMeshActor) == 0x000008, "Wrong alignment on AUnionSkeletalMeshActor");
static_assert(sizeof(AUnionSkeletalMeshActor) == 0x000310, "Wrong size on AUnionSkeletalMeshActor");

// Class UnionSystem.UnionSkeletalMeshComponent
// 0x0000 (0x0F70 - 0x0F70)
class UUnionSkeletalMeshComponent final : public USkeletalMeshComponent
{
public:
	void SetVisibilityWithTickControl(bool bNewVisibility, bool bPropagateToChildren);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionSkeletalMeshComponent">();
	}
	static class UUnionSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionSkeletalMeshComponent>();
	}
};
static_assert(alignof(UUnionSkeletalMeshComponent) == 0x000010, "Wrong alignment on UUnionSkeletalMeshComponent");
static_assert(sizeof(UUnionSkeletalMeshComponent) == 0x000F70, "Wrong size on UUnionSkeletalMeshComponent");

// Class UnionSystem.UnionSkeletalMeshComponentBudgeted
// 0x0000 (0x0F90 - 0x0F90)
class UUnionSkeletalMeshComponentBudgeted final : public USkeletalMeshComponentBudgeted
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionSkeletalMeshComponentBudgeted">();
	}
	static class UUnionSkeletalMeshComponentBudgeted* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionSkeletalMeshComponentBudgeted>();
	}
};
static_assert(alignof(UUnionSkeletalMeshComponentBudgeted) == 0x000010, "Wrong alignment on UUnionSkeletalMeshComponentBudgeted");
static_assert(sizeof(UUnionSkeletalMeshComponentBudgeted) == 0x000F90, "Wrong size on UUnionSkeletalMeshComponentBudgeted");

// Class UnionSystem.UnionSphereComponent
// 0x0000 (0x0550 - 0x0550)
class UUnionSphereComponent final : public USphereComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionSphereComponent">();
	}
	static class UUnionSphereComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionSphereComponent>();
	}
};
static_assert(alignof(UUnionSphereComponent) == 0x000010, "Wrong alignment on UUnionSphereComponent");
static_assert(sizeof(UUnionSphereComponent) == 0x000550, "Wrong size on UUnionSphereComponent");

// Class UnionSystem.UnionStaticMeshActor
// 0x0000 (0x02A0 - 0x02A0)
class AUnionStaticMeshActor final : public AStaticMeshActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionStaticMeshActor">();
	}
	static class AUnionStaticMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnionStaticMeshActor>();
	}
};
static_assert(alignof(AUnionStaticMeshActor) == 0x000008, "Wrong alignment on AUnionStaticMeshActor");
static_assert(sizeof(AUnionStaticMeshActor) == 0x0002A0, "Wrong size on AUnionStaticMeshActor");

// Class UnionSystem.UnionStatsManager
// 0x08B8 (0x08E8 - 0x0030)
class UUnionStatsManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnStatsLoadedSaveData;                             // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const EStatsEventId StatsEventId, int64 StatsValue)> OnStatsEventUpdate; // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const EStatsEventId StatsEventId, const EMachineId MachineId, int32 StatsValue)> OnMachineStatsEventUpdate; // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const EStatsEventId StatsEventId, const EDriverId DriverId, int32 StatsValue)> OnCharacterStatsEventUpdate; // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FHonorCommendationDataSetList& DataSetList)> OnHonorResultEvent; // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FHonorCommendationDataSetList          HonorList;                                         // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x850];                                     // 0x0098(0x0850)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetCharacterStatsEventValue(const EStatsEventId StatsEventId, const EDriverId DriverId);
	void GetCharacterStatsEventValueTopThree(TArray<EDriverId>* TopThreeIds, TArray<int32>* TopThreeCounts);
	int32 GetMachineStatsEventValue(const EStatsEventId StatsEventId, const EMachineId MachineId);
	void GetResultHonorList(int32 RacerIndex, TArray<struct FHonorCommendationData>* OutDataList);
	TArray<bool> GetSaveRedStarRings();
	int32 GetStatsEventValue(const EStatsEventId StatsEventId);
	TArray<struct FCommon_HistoryData_CharacterUsage> GetTopThreeCharactersUsageAddOne(EDriverId AddOneDriverId);
	bool IsRaceRedStarRingDisplay();
	void OnSetHonorList(const struct FHonorCommendationDataSetList& list);
	void ReinitializeStatsForDemo();
	void RequestAddDriversParameter(const EStatsEventId StatsEventId, const EDriverId DriverId, const int32 AddValue);
	void RequestAddMachinesParameter(const EStatsEventId StatsEventId, const EMachineId MachineId, const int32 AddValue);
	void RequestAddRaceDetailsParameter(const EStatsEventId StatsEventId, const int32 AddValue);
	void SetSaveRedStarRings(const TArray<bool>& InRSRs);

	bool GetMultiPlayBonus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionStatsManager">();
	}
	static class UUnionStatsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionStatsManager>();
	}
};
static_assert(alignof(UUnionStatsManager) == 0x000008, "Wrong alignment on UUnionStatsManager");
static_assert(sizeof(UUnionStatsManager) == 0x0008E8, "Wrong size on UUnionStatsManager");
static_assert(offsetof(UUnionStatsManager, OnStatsLoadedSaveData) == 0x000038, "Member 'UUnionStatsManager::OnStatsLoadedSaveData' has a wrong offset!");
static_assert(offsetof(UUnionStatsManager, OnStatsEventUpdate) == 0x000048, "Member 'UUnionStatsManager::OnStatsEventUpdate' has a wrong offset!");
static_assert(offsetof(UUnionStatsManager, OnMachineStatsEventUpdate) == 0x000058, "Member 'UUnionStatsManager::OnMachineStatsEventUpdate' has a wrong offset!");
static_assert(offsetof(UUnionStatsManager, OnCharacterStatsEventUpdate) == 0x000068, "Member 'UUnionStatsManager::OnCharacterStatsEventUpdate' has a wrong offset!");
static_assert(offsetof(UUnionStatsManager, OnHonorResultEvent) == 0x000078, "Member 'UUnionStatsManager::OnHonorResultEvent' has a wrong offset!");
static_assert(offsetof(UUnionStatsManager, HonorList) == 0x000088, "Member 'UUnionStatsManager::HonorList' has a wrong offset!");

// Class UnionSystem.UnionSystemBP
// 0x0000 (0x0028 - 0x0028)
class UUnionSystemBP final : public UBlueprintFunctionLibrary
{
public:
	static void AddCustomPresent();
	static bool AddLevel(const class UObject* WorldContextObject, class FName LevelName, bool Load, bool Visible, int32 LightChannel, const struct FVector& Location, class FName Dependant);
	static bool AddLevelByReference(const class UObject* WorldContextObject, TSoftObjectPtr<class UWorld> Level, bool Load, bool Visible, int32 LightChannel, const struct FVector& Location, TSoftObjectPtr<class UWorld> Dependant);
	static bool AllLevelLoaded();
	static struct FSoundHandle AttachTo(const struct FSoundHandle& Handle, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, EAttachLocation LocationType);
	static void ClearLevels(const class UObject* WorldContextObject);
	static void DeleteInvalidSaveData(bool* bOutQuitGame);
	static bool DoesPackageExist(const class FString& LongPackageName);
	static bool FindDirectionalLight(int32 LightChannel, class UDirectionalLightComponent** DirectionalLight);
	static class AActor* GetActorOfLevelByClass(const class AActor* Target, TSubclassOf<class AActor> ActorClass);
	static void GetAllActorsOfLevel(const class UObject* WorldContextObject, TArray<class AActor*>* OutActors);
	static class UAtomComponent* GetAtomComponent(const struct FSoundHandle& Handle);
	static float GetBGMVolume();
	static float GetFFBVolume(int32 PlayerIndex);
	static const class UUnionSettings* GetGameSettings();
	static class FString GetLevelName(const class UWorld* World);
	static class FString GetLevelNameByReference(const TSoftObjectPtr<class UWorld> SoftWorld);
	static float GetMasterVolume();
	static bool GetMasterVolumeMute();
	static class UObject* GetMenuKeyboardButtonImage();
	static class UObject* GetMenuMouseButtonImage();
	static class UObject* GetPlatformControllerButtonImage(EControllerButtonTextureType Type, EUnionPlatform Platform);
	static class UObject* GetPlatformIcon(EUnionPlatform Platform);
	static class UObject* GetPlatformResource(EUnionControllerType Type, EUnionPlatform Platform);
	static float GetSEVolume();
	static struct FSoundHandle GetSoundHandle();
	static float GetVoiceVolume();
	static bool IsPlaying(const struct FSoundHandle& Handle);
	static bool IsUseCustomCulling();
	static class USaveGame* LoadDemoGameSlot(const class FString& SlotName, const int32 UserIndex);
	static class USaveGame* LoadGameFromSlot(const class FString& SlotName, const int32 UserIndex);
	static class USaveGame* LoadPS4GameSlot(const class FString& SlotName, const int32 UserIndex);
	static void OpenLevel(const class UObject* WorldContextObject, class FName LevelName, bool bAbsolute, const class FString& Options);
	static void OpenLevelByReference(const class UObject* WorldContextObject, const TSoftObjectPtr<class UWorld> Level, bool bAbsolute, const class FString& Options);
	static struct FSoundHandle Play(const struct FSoundHandle& Handle, class USoundAtomCue* Sound);
	static struct FSoundHandle PlayFFB(const struct FSoundHandle& Handle, class USoundAtomCue* Sound, ESoundPan Pan, bool Aduio, int32 FFBPlayerBit);
	static bool RemoveLevel(class ULevelStreamingDynamic* StreamingLevel);
	static void ResetGameSettings();
	static void ResetLevelFlagsForPSDCache();
	static bool SaveGameToSlot(class USaveGame* SaveGameObject, const class FString& SlotName, const int32 UserIndex);
	static void SendEvent(const class UObject* WorldContextObject, class ULevel* Level, class FName EventName);
	static void SetActiveHorizontalFlip(bool Active);
	static struct FSoundHandle SetAisacByName(const struct FSoundHandle& Handle, const class FString& ControlName, float ControlValue);
	static void SetBGMVolume(float Volume);
	static void SetBootSettings();
	static void SetFFBVolume(int32 PlayerIndex, float Volume);
	static void SetGameSettings(int32 NumPlayers);
	static void SetLevelFlagsForPSDCache(EStageId StageId0, EStageId StageId1, EStageId StageId2);
	static struct FSoundHandle SetLocation(const struct FSoundHandle& Handle, const struct FVector& Location);
	static void SetMasterVolume(float Volume);
	static void SetMasterVolumeMute(bool OnOffFlag);
	static struct FSoundHandle SetPanSplit(const struct FSoundHandle& Handle, ESoundPan Pan);
	static void SetSEVolume(float Volume);
	static void SetSoundHandle(const struct FSoundHandle& Handle);
	static void SetUseCustomCulling(bool IsUse);
	static void SetVoiceVolume(float Volume);
	static struct FSoundHandle SetVolume(const struct FSoundHandle& Handle, float Volume);
	static bool SetZOrder(class UWidget* Widget, int32 ZOrder);
	static struct FSoundHandle SoundBuildPlayer();
	static void SoundCuesheetLoadAsync(const TArray<TSoftObjectPtr<class USoundAtomCueSheet>>& CuesheetArray);
	static void SoundCuesheetLoadSync(const TArray<TSoftObjectPtr<class USoundAtomCueSheet>>& CuesheetArray);
	static void SoundCuesheetUnloadSync(const TArray<TSoftObjectPtr<class USoundAtomCueSheet>>& CuesheetArray);
	static struct FSoundHandle SoundPlay(class USoundAtomCue* Sound);
	static struct FSoundHandle SoundPlayFFB(class USoundAtomCue* Sound, ESoundPan Pan, bool Audio, int32 FFBPlayerBit);
	static void SoundSetPanSplit(ESoundPan Pan);
	static bool StartLevels(const class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	static bool StartLevelsAsync(const class UObject* WorldContextObject);
	static struct FSoundHandle Stop(const struct FSoundHandle& Handle);
	static void UnloadLevel(const class UObject* WorldContextObject, class FName LevelName, const struct FLatentActionInfo& LatentInfo, bool bShouldBlockOnUnload);
	static void UnloadLevelByReference(const class UObject* WorldContextObject, const TSoftObjectPtr<class UWorld> Level, const struct FLatentActionInfo& LatentInfo, bool bShouldBlockOnUnload);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionSystemBP">();
	}
	static class UUnionSystemBP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionSystemBP>();
	}
};
static_assert(alignof(UUnionSystemBP) == 0x000008, "Wrong alignment on UUnionSystemBP");
static_assert(sizeof(UUnionSystemBP) == 0x000028, "Wrong size on UUnionSystemBP");

// Class UnionSystem.UnionTestUserWidget
// 0x0000 (0x02E0 - 0x02E0)
class UUnionTestUserWidget : public UUserWidget
{
public:
	void BeginPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionTestUserWidget">();
	}
	static class UUnionTestUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionTestUserWidget>();
	}
};
static_assert(alignof(UUnionTestUserWidget) == 0x000008, "Wrong alignment on UUnionTestUserWidget");
static_assert(sizeof(UUnionTestUserWidget) == 0x0002E0, "Wrong size on UUnionTestUserWidget");

// Class UnionSystem.UnionTestForceFeedbackViewerUI
// 0x0010 (0x02F0 - 0x02E0)
class UUnionTestForceFeedbackViewerUI final : public UUnionTestUserWidget
{
public:
	TArray<struct FHDVibCueListForViewer>         CueList;                                           // 0x02E0(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	bool Finalize();
	void Quit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionTestForceFeedbackViewerUI">();
	}
	static class UUnionTestForceFeedbackViewerUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionTestForceFeedbackViewerUI>();
	}
};
static_assert(alignof(UUnionTestForceFeedbackViewerUI) == 0x000008, "Wrong alignment on UUnionTestForceFeedbackViewerUI");
static_assert(sizeof(UUnionTestForceFeedbackViewerUI) == 0x0002F0, "Wrong size on UUnionTestForceFeedbackViewerUI");
static_assert(offsetof(UUnionTestForceFeedbackViewerUI, CueList) == 0x0002E0, "Member 'UUnionTestForceFeedbackViewerUI::CueList' has a wrong offset!");

// Class UnionSystem.UnionTestGameMode
// 0x0000 (0x0328 - 0x0328)
class AUnionTestGameMode final : public AGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionTestGameMode">();
	}
	static class AUnionTestGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnionTestGameMode>();
	}
};
static_assert(alignof(AUnionTestGameMode) == 0x000008, "Wrong alignment on AUnionTestGameMode");
static_assert(sizeof(AUnionTestGameMode) == 0x000328, "Wrong size on AUnionTestGameMode");

// Class UnionSystem.UnionTestInputActor
// 0x0000 (0x0290 - 0x0290)
class AUnionTestInputActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionTestInputActor">();
	}
	static class AUnionTestInputActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnionTestInputActor>();
	}
};
static_assert(alignof(AUnionTestInputActor) == 0x000008, "Wrong alignment on AUnionTestInputActor");
static_assert(sizeof(AUnionTestInputActor) == 0x000290, "Wrong size on AUnionTestInputActor");

// Class UnionSystem.UnionTestMapViewerUI
// 0x0000 (0x02E0 - 0x02E0)
class UUnionTestMapViewerUI final : public UUnionTestUserWidget
{
public:
	void EnumerateMaps(TArray<class FText>* Maps);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionTestMapViewerUI">();
	}
	static class UUnionTestMapViewerUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionTestMapViewerUI>();
	}
};
static_assert(alignof(UUnionTestMapViewerUI) == 0x000008, "Wrong alignment on UUnionTestMapViewerUI");
static_assert(sizeof(UUnionTestMapViewerUI) == 0x0002E0, "Wrong size on UUnionTestMapViewerUI");

// Class UnionSystem.UnionTestMovieViewerUI
// 0x0000 (0x02E0 - 0x02E0)
class UUnionTestMovieViewerUI final : public UUnionTestUserWidget
{
public:
	bool Finalize();
	void Quit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionTestMovieViewerUI">();
	}
	static class UUnionTestMovieViewerUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionTestMovieViewerUI>();
	}
};
static_assert(alignof(UUnionTestMovieViewerUI) == 0x000008, "Wrong alignment on UUnionTestMovieViewerUI");
static_assert(sizeof(UUnionTestMovieViewerUI) == 0x0002E0, "Wrong size on UUnionTestMovieViewerUI");

// Class UnionSystem.UnionTestPawn
// 0x0000 (0x0340 - 0x0340)
class AUnionTestPawn final : public ADefaultPawn
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionTestPawn">();
	}
	static class AUnionTestPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnionTestPawn>();
	}
};
static_assert(alignof(AUnionTestPawn) == 0x000008, "Wrong alignment on AUnionTestPawn");
static_assert(sizeof(AUnionTestPawn) == 0x000340, "Wrong size on AUnionTestPawn");

// Class UnionSystem.UnionTestPlayerController
// 0x0000 (0x0858 - 0x0858)
class AUnionTestPlayerController final : public APlayerController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionTestPlayerController">();
	}
	static class AUnionTestPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnionTestPlayerController>();
	}
};
static_assert(alignof(AUnionTestPlayerController) == 0x000008, "Wrong alignment on AUnionTestPlayerController");
static_assert(sizeof(AUnionTestPlayerController) == 0x000858, "Wrong size on AUnionTestPlayerController");

// Class UnionSystem.UnionVATMeshComponent
// 0x0050 (0x0640 - 0x05F0)
class UUnionVATMeshComponent : public UVATMeshComponent
{
public:
	TMulticastInlineDelegate<void(class UUnionVATMeshComponent* VATMeshComponent, const struct FUnionVATSequenceInfo& SequenceInfo)> OnVATSequenceCallback; // 0x05F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EVisibilityBasedVatUpdateOption               VisibilityBasedVatUpdateOption;                    // 0x0600(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUnionVATPlayMode                             PlayMode;                                          // 0x0601(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_602[0x2];                                      // 0x0602(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaterialIndice0;                                   // 0x0604(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndice1;                                   // 0x0608(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndice2;                                   // 0x060C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndice3;                                   // 0x0610(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_614[0x2C];                                     // 0x0614(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Rebuild(bool ResetState);
	void ResetPlaybackState();
	void SetFrame(int32 Frame);
	void SetPlayMode(EUnionVATPlayMode PlayMode_0, bool ResetState);
	void UpdateDeltaTime(float DeltaTime);
	void UpdateFrame();

	int32 GetFrame() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionVATMeshComponent">();
	}
	static class UUnionVATMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionVATMeshComponent>();
	}
};
static_assert(alignof(UUnionVATMeshComponent) == 0x000010, "Wrong alignment on UUnionVATMeshComponent");
static_assert(sizeof(UUnionVATMeshComponent) == 0x000640, "Wrong size on UUnionVATMeshComponent");
static_assert(offsetof(UUnionVATMeshComponent, OnVATSequenceCallback) == 0x0005F0, "Member 'UUnionVATMeshComponent::OnVATSequenceCallback' has a wrong offset!");
static_assert(offsetof(UUnionVATMeshComponent, VisibilityBasedVatUpdateOption) == 0x000600, "Member 'UUnionVATMeshComponent::VisibilityBasedVatUpdateOption' has a wrong offset!");
static_assert(offsetof(UUnionVATMeshComponent, PlayMode) == 0x000601, "Member 'UUnionVATMeshComponent::PlayMode' has a wrong offset!");
static_assert(offsetof(UUnionVATMeshComponent, MaterialIndice0) == 0x000604, "Member 'UUnionVATMeshComponent::MaterialIndice0' has a wrong offset!");
static_assert(offsetof(UUnionVATMeshComponent, MaterialIndice1) == 0x000608, "Member 'UUnionVATMeshComponent::MaterialIndice1' has a wrong offset!");
static_assert(offsetof(UUnionVATMeshComponent, MaterialIndice2) == 0x00060C, "Member 'UUnionVATMeshComponent::MaterialIndice2' has a wrong offset!");
static_assert(offsetof(UUnionVATMeshComponent, MaterialIndice3) == 0x000610, "Member 'UUnionVATMeshComponent::MaterialIndice3' has a wrong offset!");

// Class UnionSystem.UnionVATAnimEventComponent
// 0x0020 (0x0660 - 0x0640)
class UUnionVATAnimEventComponent final : public UUnionVATMeshComponent
{
public:
	TArray<struct FUnionVATAnimEventSequence>     AnimEventSequences;                                // 0x0640(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_650[0x10];                                     // 0x0650(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnVATSequence(class UUnionVATMeshComponent* VATMeshComponent, const struct FUnionVATSequenceInfo& SequenceInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionVATAnimEventComponent">();
	}
	static class UUnionVATAnimEventComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionVATAnimEventComponent>();
	}
};
static_assert(alignof(UUnionVATAnimEventComponent) == 0x000010, "Wrong alignment on UUnionVATAnimEventComponent");
static_assert(sizeof(UUnionVATAnimEventComponent) == 0x000660, "Wrong size on UUnionVATAnimEventComponent");
static_assert(offsetof(UUnionVATAnimEventComponent, AnimEventSequences) == 0x000640, "Member 'UUnionVATAnimEventComponent::AnimEventSequences' has a wrong offset!");

// Class UnionSystem.UnionVATMeshActor
// 0x0000 (0x02A0 - 0x02A0)
class AUnionVATMeshActor final : public AStaticMeshActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionVATMeshActor">();
	}
	static class AUnionVATMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUnionVATMeshActor>();
	}
};
static_assert(alignof(AUnionVATMeshActor) == 0x000008, "Wrong alignment on AUnionVATMeshActor");
static_assert(sizeof(AUnionVATMeshActor) == 0x0002A0, "Wrong size on AUnionVATMeshActor");

// Class UnionSystem.UnionVersionUtility
// 0x0000 (0x0028 - 0x0028)
class UUnionVersionUtility final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionVersionUtility">();
	}
	static class UUnionVersionUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionVersionUtility>();
	}
};
static_assert(alignof(UUnionVersionUtility) == 0x000008, "Wrong alignment on UUnionVersionUtility");
static_assert(sizeof(UUnionVersionUtility) == 0x000028, "Wrong size on UUnionVersionUtility");

// Class UnionSystem.UnionWidgetComponent
// 0x0000 (0x0690 - 0x0690)
class UUnionWidgetComponent : public UWidgetComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionWidgetComponent">();
	}
	static class UUnionWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionWidgetComponent>();
	}
};
static_assert(alignof(UUnionWidgetComponent) == 0x000010, "Wrong alignment on UUnionWidgetComponent");
static_assert(sizeof(UUnionWidgetComponent) == 0x000690, "Wrong size on UUnionWidgetComponent");

// Class UnionSystem.UnionWidgetImageComponent
// 0x00F0 (0x06C0 - 0x05D0)
class UUnionWidgetImageComponent final : public UUnionProceduralMeshComponent
{
public:
	uint8                                         Pad_5D0[0x8];                                      // 0x05D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUnionWidgetTransform                  _WidgetTransform;                                  // 0x05D8(0x00B8)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	TArray<class USceneComponent*>                _ParentComponents;                                 // 0x0690(0x0010)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _TintColorAndOpacity;                              // 0x06A0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             _BrushImageTexture;                                // 0x06B0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6B8[0x8];                                      // 0x06B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateOrUpdateMesh(bool ForceCreate);
	void SetBrushImageTexture(class UTexture2D* Texture, bool Applying);
	void SetColor(const struct FLinearColor& TintColorAndOpacity, bool Applying);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionWidgetImageComponent">();
	}
	static class UUnionWidgetImageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionWidgetImageComponent>();
	}
};
static_assert(alignof(UUnionWidgetImageComponent) == 0x000010, "Wrong alignment on UUnionWidgetImageComponent");
static_assert(sizeof(UUnionWidgetImageComponent) == 0x0006C0, "Wrong size on UUnionWidgetImageComponent");
static_assert(offsetof(UUnionWidgetImageComponent, _WidgetTransform) == 0x0005D8, "Member 'UUnionWidgetImageComponent::_WidgetTransform' has a wrong offset!");
static_assert(offsetof(UUnionWidgetImageComponent, _ParentComponents) == 0x000690, "Member 'UUnionWidgetImageComponent::_ParentComponents' has a wrong offset!");
static_assert(offsetof(UUnionWidgetImageComponent, _TintColorAndOpacity) == 0x0006A0, "Member 'UUnionWidgetImageComponent::_TintColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UUnionWidgetImageComponent, _BrushImageTexture) == 0x0006B0, "Member 'UUnionWidgetImageComponent::_BrushImageTexture' has a wrong offset!");

// Class UnionSystem.UnionWidgetInterface
// 0x0000 (0x0000 - 0x0000)
class IUnionWidgetInterface final
{
public:
	void SetWidgetTransform(const struct FUnionWidgetTransform& WidgetTransform);

	struct FUnionWidgetTransform GetWidgetTransformCopy() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionWidgetInterface">();
	}
	static class IUnionWidgetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUnionWidgetInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IUnionWidgetInterface) == 0x000001, "Wrong alignment on IUnionWidgetInterface");
static_assert(sizeof(IUnionWidgetInterface) == 0x000001, "Wrong size on IUnionWidgetInterface");

// Class UnionSystem.UnionWidgetPanelComponent
// 0x00C0 (0x02F0 - 0x0230)
class UUnionWidgetPanelComponent final : public USceneComponent
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUnionWidgetTransform                  _WidgetTransform;                                  // 0x0238(0x00B8)(Edit, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionWidgetPanelComponent">();
	}
	static class UUnionWidgetPanelComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionWidgetPanelComponent>();
	}
};
static_assert(alignof(UUnionWidgetPanelComponent) == 0x000010, "Wrong alignment on UUnionWidgetPanelComponent");
static_assert(sizeof(UUnionWidgetPanelComponent) == 0x0002F0, "Wrong size on UUnionWidgetPanelComponent");
static_assert(offsetof(UUnionWidgetPanelComponent, _WidgetTransform) == 0x000238, "Member 'UUnionWidgetPanelComponent::_WidgetTransform' has a wrong offset!");

// Class UnionSystem.UnionWidgetTextComponent
// 0x03D0 (0x0A60 - 0x0690)
class UUnionWidgetTextComponent final : public UWidgetComponent
{
public:
	uint8                                         Pad_690[0x8];                                      // 0x0690(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUnionWidgetTransform                  _WidgetTransform;                                  // 0x0698(0x00B8)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	class FText                                   _Text;                                             // 0x0750(0x0010)(Edit, NativeAccessSpecifierPrivate)
	struct FEditableTextStyle                     _Style;                                            // 0x0760(0x02F0)(Edit, NativeAccessSpecifierPrivate)
	bool                                          _IsReadOnly;                                       // 0x0A50(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _IsPassword;                                       // 0x0A51(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A52[0x2];                                      // 0x0A52(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _MinDesiredWidth;                                  // 0x0A54(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETextJustify                                  _Justification;                                    // 0x0A58(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A59[0x7];                                      // 0x0A59(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAppearance(const struct FEditableTextStyle& Style, bool IsReadOnly, bool IsPassword, float MinDesiredWidth, ETextJustify Justification);
	void SetText(const class FText& Text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionWidgetTextComponent">();
	}
	static class UUnionWidgetTextComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionWidgetTextComponent>();
	}
};
static_assert(alignof(UUnionWidgetTextComponent) == 0x000010, "Wrong alignment on UUnionWidgetTextComponent");
static_assert(sizeof(UUnionWidgetTextComponent) == 0x000A60, "Wrong size on UUnionWidgetTextComponent");
static_assert(offsetof(UUnionWidgetTextComponent, _WidgetTransform) == 0x000698, "Member 'UUnionWidgetTextComponent::_WidgetTransform' has a wrong offset!");
static_assert(offsetof(UUnionWidgetTextComponent, _Text) == 0x000750, "Member 'UUnionWidgetTextComponent::_Text' has a wrong offset!");
static_assert(offsetof(UUnionWidgetTextComponent, _Style) == 0x000760, "Member 'UUnionWidgetTextComponent::_Style' has a wrong offset!");
static_assert(offsetof(UUnionWidgetTextComponent, _IsReadOnly) == 0x000A50, "Member 'UUnionWidgetTextComponent::_IsReadOnly' has a wrong offset!");
static_assert(offsetof(UUnionWidgetTextComponent, _IsPassword) == 0x000A51, "Member 'UUnionWidgetTextComponent::_IsPassword' has a wrong offset!");
static_assert(offsetof(UUnionWidgetTextComponent, _MinDesiredWidth) == 0x000A54, "Member 'UUnionWidgetTextComponent::_MinDesiredWidth' has a wrong offset!");
static_assert(offsetof(UUnionWidgetTextComponent, _Justification) == 0x000A58, "Member 'UUnionWidgetTextComponent::_Justification' has a wrong offset!");

// Class UnionSystem.UnionWidgetTextInterface
// 0x0000 (0x0000 - 0x0000)
class IUnionWidgetTextInterface final
{
public:
	class UWidget* GetTextWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionWidgetTextInterface">();
	}
	static class IUnionWidgetTextInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUnionWidgetTextInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IUnionWidgetTextInterface) == 0x000001, "Wrong alignment on IUnionWidgetTextInterface");
static_assert(sizeof(IUnionWidgetTextInterface) == 0x000001, "Wrong size on IUnionWidgetTextInterface");

// Class UnionSystem.UnionWidgetUtility
// 0x0000 (0x0028 - 0x0028)
class UUnionWidgetUtility final : public UBlueprintFunctionLibrary
{
public:
	static void TransformVertex(TArray<struct FVector2D>* Vertex2Ds, const struct FUnionWidgetTransform& WidgetTransform, const struct FVector2D& ParentSize);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionWidgetUtility">();
	}
	static class UUnionWidgetUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionWidgetUtility>();
	}
};
static_assert(alignof(UUnionWidgetUtility) == 0x000008, "Wrong alignment on UUnionWidgetUtility");
static_assert(sizeof(UUnionWidgetUtility) == 0x000028, "Wrong size on UUnionWidgetUtility");

// Class UnionSystem.CommonNetworkSettings
// 0x0008 (0x0040 - 0x0038)
class UCommonNetworkSettings final : public UDeveloperSettings
{
public:
	EOnlineEnvironmentSpec                        OnlineEnvironmentSpec;                             // 0x0038(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonNetworkSettings">();
	}
	static class UCommonNetworkSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonNetworkSettings>();
	}
};
static_assert(alignof(UCommonNetworkSettings) == 0x000008, "Wrong alignment on UCommonNetworkSettings");
static_assert(sizeof(UCommonNetworkSettings) == 0x000040, "Wrong size on UCommonNetworkSettings");
static_assert(offsetof(UCommonNetworkSettings, OnlineEnvironmentSpec) == 0x000038, "Member 'UCommonNetworkSettings::OnlineEnvironmentSpec' has a wrong offset!");

// Class UnionSystem.UnionMatchmakingSettings
// 0x0060 (0x0098 - 0x0038)
class UUnionMatchmakingSettings final : public UDeveloperSettings
{
public:
	bool                                          bUseFlexMatch;                                     // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 matchVersion;                                      // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 MinLobbyPlayerNumArray;                            // 0x0050(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<float>                                 MinMatchmakingTimeArray;                           // 0x0060(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	int32                                         DefaultFilterLobbyRank;                            // 0x0070(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultExtraProgressTime;                          // 0x0074(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExtendFilterLobbyRank;                             // 0x0078(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtendExtraProgressTime;                           // 0x007C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultFilterLobbyRankForUser;                     // 0x0080(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultExtraProgressTimeForUser;                   // 0x0084(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExtendFilterLobbyRankForUser;                      // 0x0088(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtendExtraProgressTimeForUser;                    // 0x008C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnteringRemainLobbyTimeCount;                      // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void SetUseFlexMatch(bool bNewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnionMatchmakingSettings">();
	}
	static class UUnionMatchmakingSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnionMatchmakingSettings>();
	}
};
static_assert(alignof(UUnionMatchmakingSettings) == 0x000008, "Wrong alignment on UUnionMatchmakingSettings");
static_assert(sizeof(UUnionMatchmakingSettings) == 0x000098, "Wrong size on UUnionMatchmakingSettings");
static_assert(offsetof(UUnionMatchmakingSettings, bUseFlexMatch) == 0x000038, "Member 'UUnionMatchmakingSettings::bUseFlexMatch' has a wrong offset!");
static_assert(offsetof(UUnionMatchmakingSettings, matchVersion) == 0x000040, "Member 'UUnionMatchmakingSettings::matchVersion' has a wrong offset!");
static_assert(offsetof(UUnionMatchmakingSettings, MinLobbyPlayerNumArray) == 0x000050, "Member 'UUnionMatchmakingSettings::MinLobbyPlayerNumArray' has a wrong offset!");
static_assert(offsetof(UUnionMatchmakingSettings, MinMatchmakingTimeArray) == 0x000060, "Member 'UUnionMatchmakingSettings::MinMatchmakingTimeArray' has a wrong offset!");
static_assert(offsetof(UUnionMatchmakingSettings, DefaultFilterLobbyRank) == 0x000070, "Member 'UUnionMatchmakingSettings::DefaultFilterLobbyRank' has a wrong offset!");
static_assert(offsetof(UUnionMatchmakingSettings, DefaultExtraProgressTime) == 0x000074, "Member 'UUnionMatchmakingSettings::DefaultExtraProgressTime' has a wrong offset!");
static_assert(offsetof(UUnionMatchmakingSettings, ExtendFilterLobbyRank) == 0x000078, "Member 'UUnionMatchmakingSettings::ExtendFilterLobbyRank' has a wrong offset!");
static_assert(offsetof(UUnionMatchmakingSettings, ExtendExtraProgressTime) == 0x00007C, "Member 'UUnionMatchmakingSettings::ExtendExtraProgressTime' has a wrong offset!");
static_assert(offsetof(UUnionMatchmakingSettings, DefaultFilterLobbyRankForUser) == 0x000080, "Member 'UUnionMatchmakingSettings::DefaultFilterLobbyRankForUser' has a wrong offset!");
static_assert(offsetof(UUnionMatchmakingSettings, DefaultExtraProgressTimeForUser) == 0x000084, "Member 'UUnionMatchmakingSettings::DefaultExtraProgressTimeForUser' has a wrong offset!");
static_assert(offsetof(UUnionMatchmakingSettings, ExtendFilterLobbyRankForUser) == 0x000088, "Member 'UUnionMatchmakingSettings::ExtendFilterLobbyRankForUser' has a wrong offset!");
static_assert(offsetof(UUnionMatchmakingSettings, ExtendExtraProgressTimeForUser) == 0x00008C, "Member 'UUnionMatchmakingSettings::ExtendExtraProgressTimeForUser' has a wrong offset!");
static_assert(offsetof(UUnionMatchmakingSettings, EnteringRemainLobbyTimeCount) == 0x000090, "Member 'UUnionMatchmakingSettings::EnteringRemainLobbyTimeCount' has a wrong offset!");

}

